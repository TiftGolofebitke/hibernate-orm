<?xml version='1.0' encoding="iso-8859-1"?>
<chapter id="mapping">
    <title>Mapping O/R basique</title>
    <sect1 id="mapping-declaration" revision="1">
        <title>Déclaration de Mapping</title>
        <para>
            Les mappings Objet/relationnel sont généralement définis dans un document XML. 
            Le document de mapping est conçu pour être lisible et éditable à la main. 
            Le langage de mapping est Java-centrique, c'est à dire que les mappings sont construits 
            à partir des déclarations des classes persistantes et non des déclarations des tables.
        </para>
        <para>
            Remarquez que même si beaucoup d'utilisateurs de Hibernate préfèrent écrire les 
            fichiers de mappings à la main, plusieurs outils existent pour générer ce document, 
            notamment XDoclet, Middlegen et AndroMDA.
        </para>
        <para>Démarrons avec un exemple de mapping :</para>
        <programlisting id="mapping-declaration-ex1" revision="1"><![CDATA[<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC
      "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
          "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">

<hibernate-mapping package="eg">

        <class name="Cat" 
            table="cats"
            discriminator-value="C">
                
                <id name="id">
                        <generator class="native"/>
                </id>

                <discriminator column="subclass" 
                     type="character"/>

                <property name="weight"/>

                <property name="birthdate"
                    type="date" 
                    not-null="true" 
                    update="false"/>

                <property name="color"
                    type="eg.types.ColorUserType"
                    not-null="true"
                    update="false"/>

                <property name="sex"
                    not-null="true" 
                    update="false"/>

                <property name="litterId"
                    column="litterId"
                    update="false"/>

                <many-to-one name="mother"
                    column="mother_id"
                    update="false"/>

                <set name="kittens"
                    inverse="true"
                    order-by="litter_id">
                        <key column="mother_id"/>
                        <one-to-many class="Cat"/>
                </set>

                <subclass name="DomesticCat"
                    discriminator-value="D">

                        <property name="name" 
                            type="string"/>

                </subclass>

        </class>

        <class name="Dog">
                <!-- mapping for Dog could go here -->
        </class>

</hibernate-mapping>]]></programlisting>
        <para>
             Etudions le contenu du document de mapping. Nous décrirons uniquement 
             les éléments et attributs du document utilisés par Hibernate à l'exécution. 
             Le document de mapping contient aussi des attributs et éléments optionnels 
             qui agissent sur le schéma de base de données exporté par l'outil de 
             génération de schéma. (Par exemple l'attribut <literal>not-null</literal>.)
        </para>
        <sect2 id="mapping-declaration-doctype" revision="2">
            <title>Doctype</title>
            <para>
                Tous les mappings XML devraient utiliser le doctype indiqué. 
                Ce fichier est présent à l'URL ci-dessus, dans le répertoire 
                <literal>hibernate-x.x.x/src/org/hibernate</literal> ou dans <literal>hibernate3.jar</literal>. 
                Hibernate va toujours chercher la DTD dans son classpath en premier lieu. Si vous constatez 
                des recherches de la DTD sur Internet, vérifiez votre déclaration de DTD par rapport 
                au contenu de votre classpath.
            </para>
        </sect2>
        <sect2 id="mapping-declaration-mapping" revision="3">
            <title>hibernate-mapping</title>
            <para>
                Cet élément a plusieurs attributs optionnels. Les attributs <literal>schema</literal> et <literal>catalog</literal> 
                indiquent que les tables référencées par ce mapping appartiennent au schéma nommé et/ou au catalogue. 
                S'ils sont spécifiés, les noms de tables seront qualifiés par les noms de schéma et catalogue. 
                L'attribut <literal>default-cascade</literal> indique quel type de cascade sera utlisé par défaut 
                pour les propriétés et collections qui ne précisent pas l'attribut <literal>cascade</literal>. 
                L'attribut <literal>auto-import</literal> nous permet d'utiliser par défaut des noms de classes 
                non qualifiés dans le langage de requête.
            </para>
            <programlistingco>
                <areaspec>
                    <area id="hm1" coords="2 55"/>
                    <area id="hm2" coords="3 55"/>
                    <area id="hm3" coords="4 55"/>
                    <area id="hm4" coords="5 55"/>
                    <area id="hm5" coords="6 55"/>
                    <area id="hm6" coords="7 55"/>
                    <area id="hm7" coords="8 55"/>
                </areaspec>
                <programlisting><![CDATA[<hibernate-mapping
         schema="schemaName"
         catalog="catalogName"
         default-cascade="cascade_style"
         default-access="field|property|ClassName"
         default-lazy="true|false"
         auto-import="true|false"
         package="package.name"
 />]]></programlisting>
                <calloutlist>
                    <callout arearefs="hm1">
                        <para>
                            <literal>schema</literal> (optionnel) : Le nom d'un schéma de base de données.
                         </para>
                    </callout>
                    <callout arearefs="hm2">
                        <para>
                            <literal>catalog</literal> (optionnel) : Le nom d'un catalogue de base de données.
                         </para>
                    </callout>
                    <callout arearefs="hm3">
                        <para>
                            <literal>default-cascade</literal> (optionnel - par défaut vaut :  <literal>none</literal>) : 
                             Un type de cascade par défaut.
                         </para>
                    </callout>
                    <callout arearefs="hm4">
                        <para>
                            <literal>default-access</literal> (optionnel - par défaut vaut : <literal>property</literal>) :
                            Comment hibernate accèdera aux propriétés. On peut aussi 
                            redéfinir sa propre implémentation de <literal>PropertyAccessor</literal>.
                         </para>
                    </callout>
                    <callout arearefs="hm5">
                        <para>
                            <literal>default-lazy</literal> (optionnel - par défaut vaut : <literal>true</literal>) :
                             Valeur par défaut pour un attribut <literal>lazy</literal> 
                             non spécifié : celui des mappings de classes et de collection.
                         </para>
                    </callout>
                    <callout arearefs="hm6">
                        <para>
                            <literal>auto-import</literal> (optionnel - par défaut vaut : <literal>true</literal>) :
                             Spécifie si l'on peut utiliser des noms de classes 
                             non qualifiés (des classes de ce mapping) dans le langage de requête.
                         </para>
                    </callout>
                    <callout arearefs="hm7">
                        <para>
                            <literal>package</literal> (optionnel) : Préfixe de package par défaut pour 
                            les noms de classe non qualifiés du document de mapping.
                             
                         </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            <para>
                 Si deux classes possèdent le même nom de classe (non qualifié), vous devez indiquer 
                 <literal>auto-import="false"</literal>. Hibernate lancera une exception 
                 si vous essayez d'assigner à deux classes le même nom importé.
             </para>
            <para>
                 Notez que l'élément <literal>hibernate-mapping</literal> vous permet d'imbriquer plusieurs mappings de
                 <literal>&lt;class&gt;</literal> persistantes, comme dans l'exemple ci-dessus.
                 Cependant la bonne pratique (ce qui est attendu par certains outils) est 
                 de mapper une seule classe (ou une seule hiérarchie de classes)
                 par fichier de mapping et de nommer ce fichier d'après le nom de la superclasse, par exemple
                 <literal>Cat.hbm.xml</literal>, <literal>Dog.hbm.xml</literal>, ou en cas d'héritage,
                 <literal>Animal.hbm.xml</literal>.
             </para>
        </sect2>
        <sect2 id="mapping-declaration-class" revision="3">
            <title>class</title>
            <para>
                Déclarez une classe persistante avec l'élément <literal>class</literal> :
            </para>
            <programlistingco>
                <areaspec>
                    <area id="class1" coords="2 55"/>
                    <area id="class2" coords="3 55"/>
                    <area id="class3" coords="4 55"/>
                    <area id="class4" coords="5 55"/>
                    <area id="class5" coords="6 55"/>
                    <area id="class6" coords="7 55"/>
                    <area id="class7" coords="8 55"/>
                    <area id="class8" coords="9 55"/>
                    <area id="class9" coords="10 55"/>
                    <area id="class10" coords="11 55"/>
                    <area id="class11" coords="12 55"/>
                    <area id="class12" coords="13 55"/>
                    <area id="class13" coords="14 55"/>
                    <area id="class14" coords="15 55"/>
                    <area id="class15" coords="16 55"/>
                    <area id="class16" coords="17 55"/>
                    <area id="class17" coords="18 55"/>
                    <area id="class18" coords="19 55"/>
                    <area id="class19" coords="20 55"/>
                    <area id="class20" coords="21 55"/>
                    <area id="class21" coords="22 55"/>
                </areaspec>
                <programlisting><![CDATA[<class
        name="ClassName"
        table="tableName"
        discriminator-value="discriminator_value"
        mutable="true|false"
        schema="owner"
        catalog="catalog"
        proxy="ProxyInterface"
        dynamic-update="true|false"
        dynamic-insert="true|false"
        select-before-update="true|false"
        polymorphism="implicit|explicit"
        where="arbitrary sql where condition"
        persister="PersisterClass"
        batch-size="N"
        optimistic-lock="none|version|dirty|all"
        lazy="true|false"
        entity-name="EntityName"
        catalog="catalog"
        check="arbitrary sql check condition"
        rowid="rowid"
        subselect="SQL expression"
        abstract="true|false"
        entity-name="EntityName"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="class1">
                        <para>
                            <literal>name</literal> (optionnel) : Le nom Java complet de la classe (ou interface) persistante.
                             Si cet attribut est absent, il est supposé que ce mapping ne se rapporte pas à une entité POJO.
                        </para>
                    </callout>
                    <callout arearefs="class2">
                        <para>
                            <literal>table</literal> (optionnel - par défaut le nom (non-qualifié) de la classe) :  Le 
                            nom de sa table en base de données.
                        </para>
                    </callout>
                    <callout arearefs="class3">
                        <para>
                            <literal>discriminator-value</literal> (optionnel - par défaut le nom de la classe) : 
                            Une valeur permettant de distinguer les sous-classes dans le cas de l'utilisation du polymorphisme. 
                            Les valeurs <literal>null</literal> et <literal>not null</literal> sont autorisées.
                        </para>
                    </callout>
                    <callout arearefs="class4">
                        <para>
                            <literal>mutable</literal> (optionnel, vaut <literal>true</literal> par défaut) : Spécifie 
                            que des instances de la classe sont (ou non) immuables.
                        </para>
                    </callout>
                    <callout arearefs="class5">
                        <para>
                            <literal>schema</literal> (optionnel) : Surcharge le nom de schéma spécifié par 
                            l'élément racine <literal>&lt;hibernate-mapping&gt;</literal>.
                        </para>
                    </callout>
                    <callout arearefs="class6">
                        <para>
                            <literal>catalog</literal> (optionnel) : Surcharge le nom du catalogue spécifié par
                            l'élément racine <literal>&lt;hibernate-mapping&gt;</literal>.
                        </para>
                    </callout>
                    <callout arearefs="class7">
                        <para>
                            <literal>proxy</literal> (optionnel) : Spécifie une interface à utiliser pour l'initialisation différée (lazy loading)
                            des proxies. Vous pouvez indiquer le nom de la classe elle-même.
                        </para>
                    </callout>
                    <callout arearefs="class8">
                        <para>
                            <literal>dynamic-update</literal> (optionnel, par défaut à <literal>false</literal>) : 
                            Spécifie que les  <literal>UPDATE</literal> SQL doivent être générés à l'exécution et contenir 
                            uniquement les colonnes dont les valeurs ont été modifiées.
                        </para>
                    </callout>
                    <callout arearefs="class9">
                        <para>
                            <literal>dynamic-insert</literal> (optionnel, par défaut à <literal>false</literal>): 
                            Spécifie que les <literal>INSERT</literal> SQL doivent être générés à l'exécution et ne contenir 
                            que les colonnes dont les valeurs sont non nulles.
                        </para>
                    </callout>
                    <callout arearefs="class10">
                        <para>
                            <literal>select-before-update</literal> (optionnel, par défaut à <literal>false</literal>): 
                            Spécifie que Hibernate ne doit <emphasis>jamais</emphasis> exécuter un <literal>UPDATE</literal> SQL 
                            sans être certain qu'un objet a été réellement modifié. Dans certains cas, (en réalité, seulement 
                            quand un objet transient a été associé à une nouvelle session par <literal>update()</literal>), 
                            cela signifie que Hibernate exécutera un <literal>SELECT</literal> SQL pour s'assurer qu'un 
                            <literal>UPDATE</literal> SQL est véritablement nécessaire.
                        </para>
                    </callout>
                    <callout arearefs="class11">
                        <para>
                            <literal>polymorphism</literal> (optionnel, vaut <literal>implicit</literal> par défaut) : 
                            Détermine si, pour cette classe, une requête polymorphique implicite ou explicite est utilisée.
                        </para>
                    </callout>
                    <callout arearefs="class12">
                        <para>
                            <literal>where</literal> (optionnel) spécifie une clause SQL <literal>WHERE</literal> 
                            à utiliser lorsque l'on récupère des objets de cette classe.
                        </para>
                    </callout>
                    <callout arearefs="class13">
                        <para>
                            <literal>persister</literal> (optionnel) : Spécifie un <literal>ClassPersister</literal> particulier.
                        </para>
                    </callout>
                    <callout arearefs="class14">
                        <para>
                            <literal>batch-size</literal> (optionnel, par défaut = <literal>1</literal>) : spécifie une taille de batch 
                            pour remplir les instances de cette classe par identifiant en une seule requête.
                        </para>
                    </callout>
                    <callout arearefs="class15">
                        <para>
                            <literal>optimistic-lock</literal> (optionnel, par défaut = <literal>version</literal>) : 
                            Détermine la stratégie de verrou optimiste.
                        </para>
                    </callout>
                    <callout arearefs="class16">
                        <para>
                            <literal>lazy</literal> (optionnel) : Déclarer <literal>lazy="true"</literal> est un raccourci
                            pour spécifier le nom de la classe comme étant l'interface <literal>proxy</literal>.
                        </para>
                    </callout>
                    <callout arearefs="class17">
                        <para>
                            <literal>entity-name</literal> (optionnel) : Hibernate3 permet à une classe d'être
                            mappée plusieurs fois (potentiellement à plusieurs tables), et permet aux mappings d'entité d'être
                            représentés par des Maps ou du XML au niveau Java. Dans ces cas, vous devez indiquer un nom explicite arbitraire pour
                            les entités. Voir <xref linkend="persistent-classes-dynamicmodels"/> et <xref linkend="xml"/>
                            pour plus d'informations.
                        </para>
                    </callout>
                    <callout arearefs="class18">
                        <para>
                            <literal>catalog</literal> (optionnel) : The name of a database catalog used for this
                            class and its table.
                        </para>
                    </callout>
                    <callout arearefs="class19">
                        <para>
                            <literal>check</literal> (optionnel) : expression SQL utilisée pour générer une contrainte 
                            de vérification multi-lignes pour la génération automatique de schéma.
                        </para>
                    </callout>
                    <callout arearefs="class20">
                        <para>
                            <literal>rowid</literal> (optionnel) : Hibernate peut utiliser des ROWID sur les bases de
                            données qui utilisent ce mécanisme. Par exemple avec Oracle, Hibernate peut utiliser la colonne additionnelle 
                            <literal>rowid</literal> pour des mises à jour rapides si cette option vaut  <literal>rowid</literal>. Un ROWID représente
                            la localisation physique d'un tuple enregistré.
                        </para>
                    </callout>
                    <callout arearefs="class21">
                        <para>
                            <literal>subselect</literal> (optionnel) : Permet de mapper une entité immuable en lecture-seule 
                            sur un sous-select de base de données. Utile pour avoir une vue au lieu d'une table en base, mais à éviter. Voir plus bas 
                            pour plus d'information.
                        </para>
                    </callout>
                    <callout arearefs="class22">
                        <para>
                            <literal>abstract</literal> (optionnel) : Utilisé pour marquer des superclasses abstraites dans 
                            des hiérarchies de <literal>&lt;union-subclass&gt;</literal>.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            <para>
                Il est tout à fait possible d'utiliser une interface comme nom 
                de classe persistante. Vous devez alors déclarer les classes implémentant
                cette interface en utilisant l'élément <literal>&lt;subclass&gt;</literal>. 
                Vous pouvez faire persister toute classe interne <emphasis>static</emphasis>. 
                Vous devez alors spécifier le nom de la classe par la notation habituelle 
                des classes internes c'est à dire <literal>eg.Foo$Bar</literal>.
            </para>
            <para>
                Les classes immuables, <literal>mutable="false"</literal>, ne peuvent 
                pas être modifiées ou supprimées par l'application. Cela permet 
                à Hibernate de faire quelques optimisations mineures sur les performances.
            </para>
            <para>
                L'attribut optionnnel <literal>proxy</literal> permet les intialisations 
                différées des instances persistantes de la classe. Hibernate retournera 
                initialement des proxies CGLIB qui implémentent l'interface nommée. 
                Le véritable objet persistant ne sera chargé que lorsque une méthode du proxy 
                sera appelée. Voir plus bas le paragraphe abordant les proxies et le chargement différé (lazy initialization).
            </para>
            <para>
                Le polymorphisme <emphasis>implicite</emphasis> 
                signifie que les instances de la classe seront retournées par une 
                requête qui utilise les noms de la classe ou de chacune de ses 
                superclasses ou encore des interfaces implémentées par cette classe 
                ou ses superclasses. Les instances des classes filles seront retournées 
                par une requête qui utilise le nom de la classe elle même. Le polymorphisme 
                <emphasis>explicite</emphasis>   signifie que les instances de la classe 
                ne seront retournées que par une requête qui utilise explicitement 
                son nom et que seules les instances des classes filles déclarées dans les éléments 
                <literal>&lt;subclass&gt;</literal> ou <literal>&lt;joined-subclass&gt;</literal> 
                seront retournées. Dans la majorités des cas la valeur par défaut, 
                <literal>polymorphism="implicit"</literal>,
                est appropriée. Le polymorphisme explicite est utile lorsque deux 
                classes différentes sont mappées à la même table (ceci permet d'écrire 
                une classe "légère" qui ne contient qu'une partie des colonnes de 
                la table - voir la partie design pattern du site communautaire). 
            </para>
            <para>
                L'attribut <literal>persister</literal> vous permet de customiser 
                la stratégie utilisée pour la classe. Vous pouvez, par exemple, spécifier 
                votre propre sous-classe de <literal>org.hibernate.persister.EntityPersister</literal> ou 
                vous pourriez aussi créer une nouvelle implémentation de l'interface <literal>org.hibernate.persister.ClassPersister</literal> 
                qui proposerait une persistance via, par exemple, des appels de procédures 
                stockées, de la sérialisation vers des fichiers plats ou un annuaire LDAP. 
                Voir <literal>org.hibernate.test.CustomPersister</literal> pour un exemple simple (d'une "persistance" 
                vers une <literal>Hashtable</literal>).
            </para>
            <para>
                Notez que les paramètres <literal>dynamic-update</literal> et <literal>dynamic-insert</literal> 
                ne sont pas hérités par les sous-classes et peuvent donc être spécifiés 
                pour les éléments <literal>&lt;subclass&gt;</literal> ou <literal>&lt;joined-subclass&gt;</literal>
                Ces paramètres peuvent améliorer les performances dans certains cas, 
                mais peuvent aussi les amoindrir. A utiliser en connaissance de causes.
            </para>
            <para>
                L'utilisation de <literal>select-before-update</literal> va généralement 
                faire baisser les performances. Ce paramètre est pratique  
                pour prévenir l'appel inutile d'un trigger sur modification quand on 
                réattache un graphe d'instances à une <literal>Session</literal>.
            </para>
            <para>
                Si vous utilisez le <literal>dynamic-update</literal>, les différentes 
                stratégies de verrouillage optimiste (optimistic locking) sont les suivantes:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        <literal>version</literal> vérifie les colonnes version/timestamp
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>all</literal> vérifie toutes les colonnes
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>dirty</literal> vérifie les colonnes modifiées, permettant des updates concurrents
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>none</literal> pas de verrouillage optimiste
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                Nous encourageons <emphasis>très</emphasis> fortement l'utilisation 
                de colonnes de version/timestamp pour le verrouillage optimiste 
                avec Hibernate. C'est la meilleure stratégie en regard des performances 
                et la seule qui gère correctement les modifications sur les objets détachés 
                (c'est à dire lorsqu'on utilise <literal>Session.merge()</literal>).
            </para>
            <para>
                Il n'y a pas de différence entre table et vue pour le mapping Hibernate, 
                tant que c'est transparent au niveau base de données (remarquez 
                que certaines BDD ne supportent pas les vues correctement, notamment 
                pour les updates). Vous rencontrerez peut-être des cas où vous 
                souhaitez utiliser une vue mais ne pouvez pas en créer sur votre BDD 
                (par exemple à cause de schémas anciens et figés). Dans ces cas, 
                vous pouvez mapper une entité immuable en lecture seule sur un sous-select SQL donné:
            </para>
            <programlisting><![CDATA[<class name="Summary">
    <subselect>
        select item.name, max(bid.amount), count(*)
        from item
        join bid on bid.item_id = item.id
        group by item.name
    </subselect>
    <synchronize table="item"/>
    <synchronize table="bid"/>
    <id name="name"/>
    ...
</class>]]></programlisting>
            <para>
                Déclarez les tables à synchroniser avec cette entité pour assurer 
                que le flush automatique se produise correctement,
                et pour que les requêtes sur l'entité dérivée ne renvoient pas des données périmées.    
                Le litéral <literal>&lt;subselect&gt;</literal> est disponible 
                comme attribut ou comme élément de mapping.
            </para>
        </sect2>
        <sect2 id="mapping-declaration-id" revision="4">
            <title>id</title>
            <para>
                Les classes mappées <emphasis>doivent</emphasis> déclarer la 
                clef primaire de la table en base de données.
                La plupart des classes auront aussi une propriété de type 
                javabean présentant l'identifiant unique d'une instance.
                L'élément <literal>&lt;id&gt;</literal> sert à définir le 
                mapping entre cette propriété et la clef primaire en base.
            </para>
            <programlistingco>
                <areaspec>
                    <area id="id1" coords="2 65"/>
                    <area id="id2" coords="3 65"/>
                    <area id="id3" coords="4 65"/>
                    <area id="id4" coords="5 65"/>
                    <area id="id5" coords="6 65"/>
                </areaspec>
                <programlisting><![CDATA[<id
        name="propertyName"
        type="typename"
        column="column_name"
        unsaved-value="null|any|none|undefined|id_value"
        access="field|property|ClassName">

        <generator class="generatorClass"/>
</id>]]></programlisting>
                <calloutlist>
                    <callout arearefs="id1">
                        <para>
                            <literal>name</literal> (optionnel) : Nom de la propriété qui sert d'identifiant.
                        </para>
                    </callout>
                    <callout arearefs="id2">
                        <para>
                            <literal>type</literal> (optionnel) : Nom indiquant le type Hibernate.
                        </para>
                    </callout>
                    <callout arearefs="id3">
                        <para>
                            <literal>column</literal> (optionnel - le nom de la propriété est pris par défaut) : Nom de la clef primaire.
                        </para>
                    </callout>
                    <callout arearefs="id4">
                        <para>
                            <literal>unsaved-value</literal> (optionnel - par défaut une valeur "bien choisie") : 
                            Une valeur de la propriété d'identifiant qui indique que l'instance est nouvellement
                            instanciée (non sauvegardée), et qui la distingue des instances <literal>transient</literal>s qui ont
                            été sauvegardées ou chargées dans une session précédente.
                        </para>
                    </callout>
                    <callout arearefs="id5">
                        <para>
                            <literal>access</literal> (optionnel - par défaut <literal>property</literal>) : La stratégie que doit utiliser Hibernate 
                            pour accéder aux valeurs des propriétés.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            <para>
                Si l'attribut <literal>name</literal> est absent, Hibernate considère que la classe ne possède pas de propriété identifiant.
            </para>
            <para>
                L'attribut <literal>unsaved-value</literal> est important ! Si 
                l'identifiant de votre classe n'a pas une valeur par défaut compatible avec 
                le comportement standard de Java (zéro ou null), vous devez alors préciser la valeur par défaut.
            </para>
            <para>
                La déclaration alternative <literal>&lt;composite-id&gt;</literal> 
                permet l'acccès aux données d'anciens systèmes qui utilisent des
                clefs composées. Son utilisation est fortement déconseillée pour d'autres cas.
            </para>
            <sect3 id="mapping-declaration-id-generator" revision="2">
                <title>Generator</title>
                <para>
                        L'élément fils <literal>&lt;generator&gt;</literal> nomme une classe Java utilisée pour générer 
                        les identifiants uniques pour les instances des classes persistantes. Si des paramètres sont requis 
                        pour configurer ou initialiser l'instance du générateur, ils sont passés en utilisant l'élément <literal>&lt;param&gt;</literal>.
                </para>
                <programlisting><![CDATA[<id name="id" type="long" column="cat_id">
        <generator class="org.hibernate.id.TableHiLoGenerator">
                <param name="table">uid_table</param>
                <param name="column">next_hi_value_column</param>
        </generator>
</id>]]></programlisting>
                <para>
                        Tous les générateurs doivent implémenter l'interface <literal>org.hibernate.id.IdentifierGenerator</literal>.
                        C'est une interface très simple ; certaines applications peuvent proposer leur propre implémentations spécialisées. 
                        Cependant, Hibernate propose une série d'implémentations intégrées. Il existe des noms raccourcis pour les générateurs intégrés :
                    <variablelist>
                        <varlistentry>
                            <term>
                                <literal>increment</literal>
                            </term>
                            <listitem>
                                <para>
                                    Génère des identifiants de type <literal>long</literal>, <literal>short</literal> ou
                                    <literal>int</literal> qui ne sont uniques que si aucun autre processus n'insère de données dans la même table.
                                    <emphasis>Ne pas utiliser en environnement clusterisé.</emphasis>
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <literal>identity</literal>
                            </term>
                            <listitem>
                                <para>
                                    Utilisation de la colonne identity de DB2, MySQL, MS SQL Server, Sybase et
                                    HypersonicSQL. L'identifiant renvoyé est de type <literal>long</literal>,
                                    <literal>short</literal> ou <literal>int</literal>.
                            </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <literal>sequence</literal>
                            </term>
                            <listitem>
                                <para>
                                    Utilisation des séquences dans  DB2, PostgreSQL, Oracle, SAP DB, McKoi ou d'un générateur dans Interbase.
                                    L'identifiant renvoyé est de type <literal>long</literal>,
                                    <literal>short</literal> ou <literal>int</literal>
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <literal>hilo</literal>
                            </term>
                            <listitem>
                                <para id="mapping-declaration-id-hilodescription" revision="1">
                                    Utilise un algorithme hi/lo pour générer de façon efficace des identifiants de type
                                    <literal>long</literal>, <literal>short</literal> ou <literal>int</literal>,
                                    en prenant comme source de valeur "hi" une table et une colonne (par défaut 
                                    <literal>hibernate_unique_key</literal> et
                                    <literal>next_hi</literal> respectivement). L'algorithme hi/lo génère des identifiants uniques 
                                    pour une base de données particulière seulement.
                            </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <literal>seqhilo</literal>
                            </term>
                            <listitem>
                                <para>
                                    Utilise un algorithme hi/lo pour générer efficacement des identifiants de type                                      <literal>long</literal>, <literal>short</literal> ou <literal>int</literal>,
                                    étant donné un nom de séquence en base.
                            </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <literal>uuid</literal>
                            </term>
                            <listitem>
                                <para>
                                    Utilise un algorithme de type UUID 128 bits pour générer des identifiants de 
                                    type string, unique au sein d'un réseau (l'adresse IP est utilisée). 
                                    Le UUID en codé en une chaîne de nombre héxadécimaux de longueur 32.
                            </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <literal>guid</literal>
                            </term>
                            <listitem>
                                <para>
                                    Utilise une chaîne GUID générée par la base pour MS SQL Server et MySQL.
                            </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <literal>native</literal>
                            </term>
                            <listitem>
                                <para>
                                    Choisit <literal>identity</literal>, <literal>sequence</literal> ou
                                    <literal>hilo</literal> selon les possibilités offertes par la base de données sous-jacente.
                            </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <literal>assigned</literal>
                            </term>
                            <listitem>
                                <para>
                                    Laisse l'application affecter un identifiant à l'objet avant que la métode 
                                    <literal>save()</literal> soit appelée. Il s'agit de la stratégie par défaut 
                                    si aucun <literal>&lt;generator&gt;</literal> n'est spécifié.
                            </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <literal>select</literal>
                            </term>
                            <listitem>
                                <para>
                                    Récupère une clef primaire assignée par un trigger en sélectionnant 
                                    la ligne par une clef unique quelconque.
                            </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <literal>foreign</literal>
                            </term>
                            <listitem>
                                <para>
                                    Utilise l'identifiant d'un objet associé. Habituellement utilisé en conjonction
                                    avec une association <literal>&lt;one-to-one&gt;</literal> sur la clef primaire.
                            </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </para>
            </sect3>
            <sect3 id="mapping-declaration-id-hilo" revision="1">
                <title>algorithme Hi/lo</title>
                <para>
                    Les générateurs <literal>hilo</literal> et <literal>seqhilo</literal> proposent deux implémentations
                    alternatives de l'algorithme hi/lo, une approche largement utilisée pour générer des identifiants. La 
                    première implémentation nécessite une table "spéciale" en base pour héberger la prochaine valeur "hi" disponible.
                    La seconde utilise une séquence de type Oracle (quand la base sous-jacente le propose).
                </para>
                <programlisting><![CDATA[<id name="id" type="long" column="cat_id">
        <generator class="hilo">
                <param name="table">hi_value</param>
                <param name="column">next_value</param>
                <param name="max_lo">100</param>
        </generator>
</id>]]></programlisting>
                <programlisting><![CDATA[<id name="id" type="long" column="cat_id">
        <generator class="seqhilo">
                <param name="sequence">hi_value</param>
                <param name="max_lo">100</param>
        </generator>
</id>]]></programlisting>
                <para>
                    Malheureusement, vous ne pouvez pas utilisez <literal>hilo</literal> quand vous apportez 
                    votre propre <literal>Connection</literal> à Hibernate. Quand Hibernate utilise une datasource du serveur 
                    d'application pour obtenir des connexions inscrites avec JTA, vous devez correctement configurer 
                    <literal>hibernate.transaction.manager_lookup_class</literal>.
                </para>
            </sect3>
            <sect3 id="mapping-declaration-id-uuid">
                <title>UUID algorithm</title>
                <para>
                    Le contenu du UUID est : adresse IP, date de démarrage de la JVM (précis au quart de seconde), 
                    l'heure système et un compteur (unique au sein de la JVM). Il n'est pas possible d'obtenir l'adresse 
                    MAC ou une adresse mémoire à partir de Java, c'est donc le mieux que l'on puisse faire sans utiliser JNI.
                </para>
            </sect3>
            <sect3 id="mapping-declaration-id-sequences">
                <title>Colonnes identifiantes et séquences</title>
                <para>
                    Pour les bases qui implémentent les colonnes "identité" (DB2, MySQL, Sybase, MS SQL), 
                    vous pouvez utiliser la génération de clef par <literal>identity</literal>. 
                    Pour les bases qui implémentent les séquences (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) 
                    vous pouvez utiliser la génération de clef par <literal>sequence</literal>. Ces deux méthodes nécessitent
                    deux requêtes SQL pour insérer un objet.
                </para>
                <programlisting><![CDATA[<id name="id" type="long" column="person_id">
        <generator class="sequence">
                <param name="sequence">person_id_sequence</param>
        </generator>
</id>]]></programlisting>
                <programlisting><![CDATA[<id name="id" type="long" column="person_id" unsaved-value="0">
        <generator class="identity"/>
</id>]]></programlisting>
                   <para>Pour le développement multi-plateformes, la stratégie <literal>native</literal> choisira
                    entre les méthodes <literal>identity</literal>, <literal>sequence</literal> et
                    <literal>hilo</literal>, selon les possibilités offertes par la base sous-jacente.
                </para>
            </sect3>
            <sect3 id="mapping-declaration-id-assigned">
                <title>Identifiants assignés</title>
                <para>
                    Si vous souhaitez que l'application assigne des identifiants (par opposition 
                    à la génération par Hibernate), vous pouvez utiliser le générateur  <literal>assigned</literal>.
                    Ce générateur spécial utilisera une valeur d'identifiant déjà utilisé par la propriété identifiant l'objet.
                    Ce générateur est utilisé quand la clef primaire est une clef naturelle plutôt qu'une clef secondaire.
                    C'est le comportement par défaut si vous ne précisez pas d'élément <literal>&lt;generator&gt;</literal>.
                </para>
                <para>
                    Choisir le générateur <literal>assigned</literal> fait utiliser
                    <literal>unsaved-value="undefined"</literal> par Hibernate, le forçant à interroger
                    la base pour déterminer si l'instance est transiente ou détachée, à moins d'utiliser 
                    une propriété version ou timestamp, ou alors de définir 
                    <literal>Interceptor.isUnsaved()</literal>.
                </para>
            </sect3>
            <sect3 id="mapping-declaration-id-select">
                <title>Clefs primaires assignées par trigger</title>
                <para>
                    Pour les schémas de base hérités d'anciens systèmes uniquement (Hibernate ne génère pas de DDL avec des triggers)  
                </para>
                <programlisting><![CDATA[<id name="id" type="long" column="person_id">
        <generator class="select">
                <param name="key">socialSecurityNumber</param>
        </generator>
</id>]]></programlisting>
                <para>
                    Dans l'exemple ci-dessus, <literal>socialSecurityNumber</literal> a une 
                    valeur unique définie par la classe en tant que clef naturelle et <literal>person_id</literal> 
                    est une clef secondaire dont la valeur est générée par trigger.
                </para>
            </sect3>
        </sect2>
        <sect2 id="mapping-declaration-compositeid" revision="3">
            <title>composite-id</title>
            <programlisting><![CDATA[<composite-id
        name="propertyName"
        class="ClassName"
        mapped="true|false"
        access="field|property|ClassName">
        node="element-name|."

        <key-property name="propertyName" type="typename" column="column_name"/>
        <key-many-to-one name="propertyName class="ClassName" column="column_name"/>
        ......
</composite-id>]]></programlisting>
            <para>
               Pour une table avec clef composée, vous pouvez mapper plusieurs attributs de la classe 
               comme propriétés identifiantes. L'élement <literal>&lt;composite-id&gt;</literal> accepte 
               les mappings de propriétés <literal>&lt;key-property&gt;</literal> et les mappings 
               <literal>&lt;key-many-to-one&gt;</literal> comme fils.
            </para>
            <programlisting><![CDATA[<composite-id>
        <key-property name="medicareNumber"/>
        <key-property name="dependent"/>
</composite-id>]]></programlisting>
            <para>
                Vos classes persistantes <emphasis>doivent</emphasis> surcharger les méthodes <literal>equals()</literal> 
                et <literal>hashCode()</literal> pour implémenter l'égalité d'identifiant composé. Elles doivent aussi 
                implenter l'interface <literal>Serializable</literal>.
            </para>
            <para>
                Malheureusement cette approche sur les identifiants composés signifie qu'un objet persistant
                est son propre identifiant. Il n'y a pas d'autre moyen pratique de manipuler l'objet que par l'objet lui-même.
                Vous devez instancier une instance de la classe persistante elle-même et peupler ses attributs identifiants 
                avant de pouvoir appeler la méthode <literal>load()</literal> pour charger son état persistant associé 
                à une clef composée. Nous appelons cette approche "identifiant composé <emphasis>embarqué</emphasis>"
                et ne la recommandons pas pour des applications complexes.
            </para>
            
            <para>
                Une seconde approche, appelée identifiant composé <emphasis>mappé</emphasis>,
                consiste à encapsuler les propriétés identifiantes (celles contenues dans <literal>&lt;composite-id&gt;</literal>)
                dans une classe particulière.
            </para>
                
            <programlisting><![CDATA[<composite-id class="MedicareId" mapped="true">
        <key-property name="medicareNumber"/>
        <key-property name="dependent"/>
</composite-id>]]></programlisting>

            <para>
                Dans cet exemple, la classe d'identifiant composée,<literal>MedicareId</literal> et la classe mappée elle-même,
                possèdent les propriétés <literal>medicareNumber</literal>
                et <literal>dependent</literal>. La classe identifiante doit redéfinir
                <literal>equals()</literal> et <literal>hashCode()</literal> et implémenter 
                <literal>Serializable</literal>. Le désavantage de cette approche est la
                duplication du code.
            </para>
            
            <para>
                Les attributs suivants servent à configurer un identifiant composé mappé :
            </para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>
                        <literal>mapped</literal> (optionnel, défaut à <literal>false</literal>) :
                        indique qu'un identifiant composé mappé est utilisé, et que les propriétés
                        contenues font référence aux deux classes (celle mappée et la classe identifiante).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>class</literal> (optionnel, mais requis pour un identifiant composé mappé) : 
                        La classe composant utilisée comme identifiant composé.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                Nous décrirons une troisième approche beaucoup plus efficace ou l'identifiant composé
                est implémenté comme une classe composant dans <xref linkend="components-compositeid"/>. 
                Les attributs décrits ci dessous, ne s'appliquent que pour cette dernière approche :
            </para>

            <itemizedlist spacing="compact">
                <listitem>
                    <para>
                        <literal>name</literal> (optionnel, requis pour cette approche) : une propriété de type
                        composant qui contient l'identifiant composé (voir chapitre 9).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>access</literal> (optionnel - défaut à <literal>property</literal>) :
                        La stratégie qu'Hibernate utilisera pour accéder à la valeur de la propriété.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>class</literal> (optionnel - défaut au type de la propriété déterminé par réflexion) : 
                        La classe composant utilisée comme identifiant (voir prochaine section).
                    </para>
                </listitem>
            </itemizedlist>
            
            <para>
                Cette dernière approche est celle que nous recommandons pour toutes vos applications.
            </para>
        </sect2>
        <sect2 id="mapping-declaration-discriminator" revision="3">
            <title>discriminator</title>
            <para>
                   L'élément <literal>&lt;discriminator&gt;</literal> est nécessaire pour la persistance polymorphique 
                   qui utilise la stratégie de mapping de table par hiérarchie de classe. La colonne discriminante contient 
                   une valeur marqueur qui permet à la couche de persistance de savoir quelle 
                   sous-classe instancier pour une ligne particulière de table en base. Un nombre restreint de types 
                   peuvent être utilisés :
                <literal>string</literal>, <literal>character</literal>, <literal>integer</literal>, 
                <literal>byte</literal>, <literal>short</literal>, <literal>boolean</literal>, 
                <literal>yes_no</literal>, <literal>true_false</literal>.
            </para>
            <programlistingco>
                <areaspec>
                    <area id="discriminator1" coords="2 60"/>
                    <area id="discriminator2" coords="3 60"/>
                    <area id="discriminator3" coords="4 60"/>
                    <area id="discriminator4" coords="5 60"/>
                    <area id="discriminator5" coords="6 60"/>
                </areaspec>
                <programlisting><![CDATA[<discriminator
        column="discriminator_column"
        type="discriminator_type"
        force="true|false"
        insert="true|false"
        formula="arbitrary sql expression"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="discriminator1">
                        <para>
                            <literal>column</literal> (optionnel - par défaut à <literal>class</literal>) le 
                            nom de la colonne discriminante.
                        </para>
                    </callout>
                    <callout arearefs="discriminator2">
                        <para>
                            <literal>type</literal> (optionnel - par défaut à <literal>string</literal>) un nom 
                            indiquant le type Hibernate.
                        </para>
                    </callout>
                    <callout arearefs="discriminator3">
                        <para>
                            <literal>force</literal> (optionnel - par défaut à <literal>false</literal>) 
                                   "oblige" Hibernate à spécifier une valeur discriminante autorisée même quand on récupère 
                                   toutes les instances de la classe de base.
                        </para>
                    </callout>
                    <callout arearefs="discriminator4">
                        <para>
                            <literal>insert</literal> (optionnel - par défaut à <literal>true</literal>)
                                   à passer à  <literal>false</literal> si la colonne discriminante fait aussi partie 
                                   d'un identifiant composé mappé (Indique à Hibernate de ne pas inclure la colonne 
                                   dans les <literal>INSERT</literal> SQL).
                        </para>
                    </callout>
                    <callout arearefs="discriminator5">
                        <para>
                            <literal>formula</literal> (optionnel) une expression SQL arbitraire qui est exécutée 
                            quand un type doit être évalué. Permet la discrimination basée sur le contenu.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            <para>
                   Les véritables valeurs de la colonne discriminante sont spécifiées par l'attribut 
                <literal>discriminator-value</literal> des éléments <literal>&lt;class&gt;</literal> et 
                <literal>&lt;subclass&gt;</literal>.
            </para>
            <para>
                L'attribut <literal>force</literal> n'est utile que si la table contient des lignes avec des 
                valeurs "extra" discriminantes qui ne sont pas mappées à une classe persistante. Ce ne sera généralement pas le cas.
            </para>
            <para>
                En utilisant l'attribut <literal>formula</literal> vous pouvez déclarer une expression SQL arbitraire 
                qui sera utilisée pour évaluer le type d'une ligne :
            </para>
            <programlisting><![CDATA[<discriminator
    formula="case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end"
    type="integer"/>]]></programlisting>
        </sect2>
        <sect2 id="mapping-declaration-version" revision="4">
            <title>version (optionnel)</title>
            <para>
                   L'élément <literal>&lt;version&gt;</literal> est optionnel et indique que la table contient 
                   des données versionnées. C'est particulièrement utile si vous avez l'intention d'utiliser 
                   des <emphasis>transactions longues</emphasis> (voir plus-bas).   
            </para>
            <programlistingco>
                <areaspec>
                    <area id="version1" coords="2 60"/>
                    <area id="version2" coords="3 60"/>
                    <area id="version3" coords="4 60"/>
                    <area id="version4" coords="5 60"/>
                    <area id="version5" coords="6 60"/>
                    <area id="version6" coords="7 70"/>
                    <area id="version7" coords="8 70"/>
                </areaspec>
                <programlisting><![CDATA[<version
        column="version_column"
        name="propertyName"
        type="typename"
        access="field|property|ClassName"
        unsaved-value="null|negative|undefined"
        generated="never|always"
        insert="true|false"
        node="element-name|@attribute-name|element/@attribute|."
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="version1">
                        <para>
                            <literal>column</literal> (optionnel - par défaut égal au nom de la propriété) : Le nom de la colonne 
                            contenant le numéro de version.
                        </para>
                    </callout>
                    <callout arearefs="version2">
                        <para>
                            <literal>name</literal> : Le nom d'un attribut de la classe persistante.
                        </para>
                    </callout>
                    <callout arearefs="version3">
                        <para>
                            <literal>type</literal> (optionnel - par défaut à <literal>integer</literal>) : 
                            Le type du numéro de version.
                        </para>
                    </callout>
                    <callout arearefs="version4">
                        <para>
                            <literal>access</literal> (optionnel - par défaut à <literal>property</literal>) : La stratégie 
                            à utiliser par Hibernate pour accéder à la valeur de la propriété.
                        </para>
                    </callout>
                    <callout arearefs="version5">
                        <para>
                            <literal>unsaved-value</literal> (optionnel - par défaut à <literal>undefined</literal>) : 
                            Une valeur de la propriété d'identifiant qui indique que l'instance est nouvellement 
                            instanciée (non sauvegardée), et qui la distingue des instances détachées qui ont 
                            été sauvegardées ou chargées dans une session précédente (<literal>undefined</literal> indique 
                            que la valeur de l'atribut identifiant devrait être utilisé).
                        </para>
                    </callout>
                    <callout arearefs="version6">
                        <para>
                            <literal>generated</literal> (optional - défaut à <literal>never</literal>) :
                            Indique que la valeur de la propriété version est générée par la base de données
                            cf. <xref linkend="mapping-generated">generated properties</xref>.
                        </para>
                    </callout>
                    <callout arearefs="version7">
                        <para>
                            <literal>insert</literal> (optionnel - défaut à <literal>true</literal>) :
                            Indique si la colonne de version doit être incluse dans les ordres insert.
                            Peut être à <literal>false</literal> si et seulement si la colonne de la
                            base de données est définie avec une valeur par défaut à <literal>0</literal>.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            <para>
                Les numéros de version doivent avoir les types Hibernate <literal>long</literal>, <literal>integer</literal>,
                <literal>short</literal>, <literal>timestamp</literal> ou <literal>calendar</literal>.
            </para>
            <para>
                   Une propriété de version ou un timestamp ne doit jamais être null pour une instance 
                   détachée, ainsi Hibernate pourra détecter toute instance ayant une version ou un timestamp null 
                   comme transient, quelles que soient les stratégies <literal>unsaved-value</literal> spécifiées.
                   <emphasis>Déclarer un numéro de version ou un timestamp "nullable" est un moyen pratique d'éviter 
                   tout problème avec les réattachements transitifs dans Hibernate, particulièrement utile pour ceux qui 
                   utilisent des identifiants assignés ou des clefs composées !</emphasis>
            </para>
        </sect2>
        <sect2 id="mapping-declaration-timestamp"  revision="3" >
            <title>timestamp (optionnel)</title>
            <para>
                   L'élément optionnel <literal>&lt;timestamp&gt;</literal> indique que la table contient des données 
                   horodatées (timestamp). Cela sert d'alternative à l'utilisation de numéros de version. Les timestamps (ou horodatage) 
                   sont par nature une implémentation moins fiable pour l'optimistic locking. Cependant, l'application 
                   peut parfois utiliser l'horodatage à d'autres fins.
            </para>
            <programlistingco>
                <areaspec>
                    <area id="timestamp1" coords="2 45"/>
                    <area id="timestamp2" coords="3 45"/>
                    <area id="timestamp3" coords="4 45"/>
                    <area id="timestamp4" coords="5 45"/>
                    <area id="timestamp5" coords="6 70" />
                    <area id="timestamp6" coords="7 70" />
                </areaspec>
                <programlisting><![CDATA[<timestamp
        column="timestamp_column"
        name="propertyName"
        access="field|property|ClassName"
        unsaved-value="null|undefined"
        source="vm|db"
        generated="never|always"
        node="element-name|@attribute-name|element/@attribute|."
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="timestamp1">
                        <para>
                            <literal>column</literal> (optionnel - par défaut à le nom de la propriété) : Le nom d'une colonne 
                            contenant le timestamp.
                        </para>
                    </callout>
                    <callout arearefs="timestamp2">
                        <para>
                            <literal>name</literal> : Le nom d'une propriété au sens JavaBean de type 
                            <literal>Date</literal> ou <literal>Timestamp</literal> de la classe persistante.
                        </para>
                    </callout>
                    <callout arearefs="timestamp3">
                        <para>
                            <literal>access</literal> (optionnel - par défaut à <literal>property</literal>) : La stratégie 
                            à utiliser par Hibernate pour accéder à la valeur de la propriété.
                        </para>
                    </callout>
                    <callout arearefs="timestamp4">
                        <para>
                            <literal>unsaved-value</literal> (optionnel - par défaut à <literal>null</literal>) : 
                              Propriété dont la valeur est un numéro de version qui indique que l'instance est nouvellement 
                              instanciée (non sauvegardée), et qui la distingue des instances détachées qui ont 
                              été sauvegardées ou chargées dans une session précédente (<literal>undefined</literal> indique 
                              que la valeur de l'attribut identifiant devrait être utilisée).
                        </para>
                    </callout>
                    <callout arearefs="timestamp5">
                        <para>
                            <literal>source</literal> (optionnel - par défaut à <literal>vm</literal>) :
                            D'où Hibernate doit-il récupérer la valeur du timestamp? Depuis la base de données
                            ou depuis la JVM d'exécution? Les valeurs de timestamp de la base de données provoquent
                            une surcharge puisque Hibernate doit interroger la base pour déterminer la prochaine valeur
                            mais cela est plus sûr lorsque vous fonctionnez dans un cluster. Remarquez aussi que
                            certains des dialectes ne supportent pas cette fonction, et que d'autres l'implémentent
                            mal, provoquant des erreurs de précision (Oracle 8 par exemple).
                        </para>
                    </callout>
                    <callout arearefs="timestamp6">
                        <para>
                            <literal>generated</literal> (optional - défaut à <literal>never</literal>) :
                            Indique que la valeur de ce timestamp est générée par la base de données
                            cf. <xref linkend="mapping-generated">generated properties</xref>.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            <para>
                Notez que <literal>&lt;timestamp&gt;</literal> est équivalent à 
                <literal>&lt;version type="timestamp"&gt;</literal>.
            </para>
        </sect2>
        <sect2 id="mapping-declaration-property" revision="4">
            <title>property</title>
            <para>
                L'élément <literal>&lt;property&gt;</literal> déclare une propriété de la classe au sens JavaBean.
            </para>
            <programlistingco>
                <areaspec>
                    <area id="property1" coords="2 45"/>
                    <area id="property2" coords="3 45"/>
                    <area id="property3" coords="4 45"/>
                    <areaset id="property4-5" coords="">
                        <area id="property4" coords="5 45"/>
                        <area id="property5" coords="6 45"/>
                    </areaset>
                    <area id="property6" coords="7 45"/>
                    <area id="property7" coords="8 45"/>
                    <area id="property8" coords="9 45"/>
                    <area id="property9" coords="10 45"/>
                    <area id="property10" coords="11 45"/>
                    <area id="property11" coords="12 45"/>
                    <area id="property12" coords="13 70"/>
                </areaspec>
                <programlisting><![CDATA[<property
        name="propertyName"
        column="column_name"
        type="typename"
        update="true|false"
        insert="true|false"
        formula="arbitrary SQL expression"
        access="field|property|ClassName"
        lazy="true|false"
        unique="true|false"
        not-null="true|false"
        optimistic-lock="true|false"
        generated="never|insert|always"
        node="element-name|@attribute-name|element/@attribute|."
        index="index_name"
        unique_key="unique_key_id"
        length="L"
        precision="P"
        scale="S"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="property1">
                        <para>
                            <literal>name</literal> : nom de la propriété, avec une lettre initiale en minuscule.
                        </para>
                    </callout>
                    <callout arearefs="property2">
                        <para>
                            <literal>column</literal> (optionnel - par défaut au nom de la propriété) : le nom 
                                   de la colonne mappée. Cela peut aussi être indiqué dans le(s) sous-élément(s) 
                            <literal>&lt;column&gt;</literal>.
                        </para>
                    </callout>
                    <callout arearefs="property3">
                        <para>
                            <literal>type</literal> (optionnel) : nom indiquant le type Hibernate.
                        </para>
                    </callout>
                    <callout arearefs="property4-5">
                        <para>
                            <literal>update, insert</literal> (optionnel - par défaut à <literal>true</literal>) :
                           indique que les colonnes mappées devraient être incluses dans des <literal>UPDATE</literal> SQL 
                           et/ou des <literal>INSERT</literal>. Mettre les deux à <literal>false</literal> 
                           empêche la propagation en base de données (utile si vous savez qu'un trigger affectera la valeur à la  colonne). 
                        </para>
                    </callout>
                    <callout arearefs="property6">
                        <para>
                            <literal>formula</literal> (optionnel) : une expression SQL qui définit la valeur pour une propriété 
                            <emphasis>calculée</emphasis>. Les propriétés calculées ne possède pas leur propre mapping.
                        </para>
                    </callout>
                    <callout arearefs="property7">
                        <para>
                            <literal>access</literal> (optionnel - par défaut à <literal>property</literal>): Stratégie que Hibernate
                             doit utiliser pour accéder à cette valeur.
                        </para>
                    </callout>
                    <callout arearefs="property8">
                        <para>
                            <literal>lazy</literal> (optionnel - par défaut à <literal>false</literal>): Indique 
                            que cette propriété devrait être chargée en différé (lazy loading) quand on accède à la variable 
                            d'instance pour la première fois.
                        </para>
                    </callout>
                    <callout arearefs="property9">
                        <para>
                            <literal>unique</literal> (optionnel): Génère le DDL d'une contrainte d'unicité pour les colonnes. 
                            Permet aussi d'en faire la cible d'un <literal>property-ref</literal>.
                        </para>
                    </callout>
                    <callout arearefs="property10">
                        <para>
                            <literal>not-null</literal> (optionnel): Génère le DDL d'une contrainte de non nullité pour les colonnes.
                        </para>
                    </callout>
                    <callout arearefs="property11">
                        <para>
                            <literal>optimistic-lock</literal> (optionnel - par défaut à <literal>true</literal>): 
                            Indique que les mises à jour de cette propriété peuvent ou non nécessiter l'acquisition 
                            d'un verrou optimiste. En d'autres termes, cela détermine s'il est nécessaire d'incrémenter 
                            un numéro de version quand cette propriété est marquée obsolète (dirty).
                        </para>                 
                    </callout>
                    <callout arearefs="property12">
                        <para>
                            <literal>generated</literal> (optional - défaut à<literal>never</literal>):
                            Indique que la valeur de ce timestamp est générée par la base de données
                            cf. <xref linkend="mapping-generated">generated properties</xref>.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            <para>
                <emphasis>typename</emphasis> peut être:
            </para>
            <orderedlist spacing="compact">
                <listitem>
                    <para>
                        Nom d'un type basique Hibernate (ex: <literal>integer, string, character,
                        date, timestamp, float, binary, serializable, object, blob</literal>).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Nom d'une classe Java avec un type basique par défaut (ex: <literal>int, float,
                        char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</literal>).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Nom d'une classe Java sérialisable.
                    </para>
                </listitem>
                <listitem>
                    <para>
                       Nom d'une classe ayant un type spécifique (ex: <literal>com.illflow.type.MyCustomType</literal>).
                    </para>
                </listitem>
            </orderedlist>
            <para>
                   Si vous n'indiquez pas un type, Hibernate utlisera la réflexion sur le nom de la propriété 
                   pour tenter de trouver le type Hibernate correct. Hibernate essayera d'interprêter 
                   le nom de la classe retournée par le getter de la propriété en utilisant les régles 2, 3, 
                   4 dans cet ordre. Cependant, ce n'est pas toujours suffisant. Dans certains cas vous aurez 
                   encore besoin de l'attribut <literal>type</literal> (Par exemple, pour distinguer 
                   <literal>Hibernate.DATE</literal> et <literal>Hibernate.TIMESTAMP</literal>, ou pour préciser 
                   un type spécifique).
            </para>
            <para>
                   L'attribut <literal>access</literal> permet de contrôler comment Hibernate accèdera 
                   à la propriété à l'exécution. Par défaut, Hibernate utilisera les méthodes set/get. 
                   Si vous indiquez <literal>access="field"</literal>, Hibernate ignorera les getter/setter 
                   et accèdera à la propriété directement en utilisant la réflexion. Vous pouvez spécifier 
                   votre propre stratégie d'accès aux propriété en donnant une classe qui implémente l'interface 
                <literal>org.hibernate.property.PropertyAccessor</literal>.
            </para>
            <para>
                   Une fonctionnalité particulièrement intéressante est les propriétés dérivées.
                   Ces propriétés sont par définition en lecture seule, la valeur de la propriété est calculée au chargement. 
                   Le calcul est déclaré comme une expression SQL, qui se traduit par une sous-requête <literal>SELECT</literal> 
                   dans la requête SQL qui charge une instance :
            </para>
            <programlisting><![CDATA[
<property name="totalPrice"
    formula="( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product p
                WHERE li.productId = p.productId
                AND li.customerId = customerId
                AND li.orderNumber = orderNumber )"/>]]></programlisting>
            <para>
                   Remarquez que vous pouvez référencer la propre table des entités en ne déclarant pas un 
                   alias sur une colonne particulière (<literal>customerId</literal> dans l'exemple donné). 
                   Notez aussi que vous pouvez utiliser le sous-élément de mapping <literal>&lt;formula&gt;</literal> 
                   plutôt que d'utiliser l'attribut si vous le souhaitez.
            </para>
        </sect2>
        <sect2 id="mapping-declaration-manytoone" revision="5">
            <title>many-to-one</title>
            <para> Une association ordinaire vers une autre classe persistante est déclarée en utilisant 
                   un élément <literal>many-to-one</literal>. Le modèle relationnel est une association 
                   de type many-to-one : une clef étrangère dans une table référence la ou les clef(s) primaire(s) dans la table cible.
            </para>
            <programlistingco>
                <areaspec>
                    <area id="manytoone1" coords="2 60"/>
                    <area id="manytoone2" coords="3 60"/>
                    <area id="manytoone3" coords="4 60"/>
                    <area id="manytoone4" coords="5 60"/>
                    <area id="manytoone5" coords="6 60"/>
                    <areaset id="manytoone6-7" coords="">
                        <area id="manytoone6" coords="7 60"/>
                        <area id="manytoone7" coords="8 60"/>
                    </areaset>
                    <area id="manytoone8" coords="9 60"/>
                    <area id="manytoone9" coords="10 60"/>
                    <area id="manytoone10" coords="11 60"/>
                    <area id="manytoone11" coords="12 60"/>
                    <area id="manytoone12" coords="13 60"/>
                    <area id="manytoone13" coords="14 60"/>
                    <area id="manytoone14" coords="15 60"/>
                    <area id="manytoone14" coords="15 70"/>
                    <area id="manytoone15" coords="16 70"/>
                    <area id="manytoone16" coords="17 70"/>
                </areaspec>
                <programlisting><![CDATA[<many-to-one
        name="propertyName"
        column="column_name"
        class="ClassName"
        cascade="cascade_style"
        fetch="join|select"
        update="true|false"
        insert="true|false"
        property-ref="propertyNameFromAssociatedClass"
        access="field|property|ClassName"
        unique="true|false"
        not-null="true|false"
        optimistic-lock="true|false"
        lazy="proxy|no-proxy|false"
        not-found="ignore|exception"
        entity-name="EntityName"
        formula="arbitrary SQL expression"
        node="element-name|@attribute-name|element/@attribute|."
        embed-xml="true|false"
        index="index_name"
        unique_key="unique_key_id"
        foreign-key="foreign_key_name"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="manytoone1">
                        <para>
                            <literal>name</literal> : Nom de la propriété.
                        </para>
                    </callout>
                    <callout arearefs="manytoone2">
                        <para>
                            <literal>column</literal> (optionnel) : Le nom de la clef étrangère. Cela peut être 
                            aussi indiqué avec le sous-élément <literal>&lt;column&gt;</literal>.
                        </para>
                    </callout>
                    <callout arearefs="manytoone3">
                        <para>
                            <literal>class</literal> (optionnel - par défaut le type de la propriété déterminé 
                            par réflexion) : Le nom de la classe associée.
                        </para>
                    </callout>
                    <callout arearefs="manytoone4">
                        <para>
                            <literal>cascade</literal> (optionnel) : Indique quelles opérations doivent 
                            être propagées de l'objet père vers les objets associés.
                        </para>
                    </callout>
                    <callout arearefs="manytoone5">
                        <para>
                            <literal>fetch</literal> (optionnel - par défaut à <literal>select</literal>) : 
                            Choisit entre le chargement de type outer-join ou le chargement par select successifs.
                        </para>
                    </callout>
                    <callout arearefs="manytoone6-7">
                        <para>
                            <literal>update, insert</literal> (optionnel - par défaut à <literal>true</literal>) :
                           indique que les colonnes mappées devraient être incluses dans des <literal>UPDATE</literal> SQL 
                           et/ou des <literal>INSERT</literal>. Mettre les deux à <literal>false</literal> 
                           empêche la propagation en base de données (utile si vous savez qu'un trigger affectera la valeur à la  colonne).                         
                         </para>
                    </callout>
                    <callout arearefs="manytoone8">
                        <para>
                            <literal>property-ref</literal> : (optionnel) Le nom d'une propriété de la classe 
                            associée qui est liée à cette clef étrangère. Si ce n'est pas spécifié, la clef primaire de la 
                            classe associée est utilisée.
                        </para>
                    </callout>
                    <callout arearefs="manytoone9">
                        <para>
                            <literal>access</literal> (optionnel - par défaut à <literal>property</literal>) : La 
                            stratégie à utiliser par Hibernate pour accéder à la valeur de cette propriété.
                        </para>
                    </callout>
                    <callout arearefs="manytoone10">
                        <para>
                            <literal>unique</literal> (optionnel) : Génère le DDL d'une contrainte d'unicité pour la clef étrangère. 
                            Permet aussi d'en faire la cible d'un <literal>property-ref</literal>. Cela permet de créer une véritable 
                            association one-to-one.
                        </para>
                    </callout>
                    <callout arearefs="manytoone11">
                        <para>
                            <literal>not-null</literal> (optionnel) : Génère le DDL pour une contrainte de non nullité pour la clef étrangère.
                       </para>
                    </callout>
                    <callout arearefs="manytoone12">
                        <para>
                            <literal>optimistic-lock</literal> (optionnel - par défaut à <literal>true</literal>) : 
                            Indique que les mises à jour de cette propriété requièrent ou non l'acquisition 
                            d'un verrou optimiste. En d'autres termes, détermine si un incrément de version doit 
                            avoir lieu quand la propriété est marquée obsolète (dirty).
                        </para>
                    </callout>
                    <callout arearefs="manytoone13">
                        <para>
                            <literal>lazy</literal> (optionnel - par défaut à <literal>false</literal>) : Indique 
                            que cette propriété doit être chargée en différé (lazy loading) au premier accès 
                            à la variable d'instance (nécessite une instrumentation du bytecode lors de la phase 
                            de construction). Remarquez que cela n'influence pas le comportement du proxy 
                            Hibernate - comme l'attribut <literal>lazy</literal> sur des classes ou des mappings 
                            de collections, mais utilise l'interception pour le chargement différé.
                            <literal>lazy="false"</literal> indique que l'association sera toujours chargée.
                        </para>
                    </callout>
                    <callout arearefs="manytoone14">
                        <para>
                            <literal>not-found</literal> (optionnel - par défaut à <literal>exception</literal>) : 
                            Indique comment les clefs étrangères qui référencent des lignes manquantes doivent être manipulées :
                            <literal>ignore</literal> traitera une ligne manquante comme une association nulle.
                        </para>
                    </callout>
                    <callout arearefs="manytoone15">
                        <para>
                            <literal>entity-name</literal> (optionnel) : Le nom de l'entité de la classe associée.
                        </para>                   
                    </callout>
                    <callout arearefs="manytoone16">
                        <para>
                            <literal>formula</literal> (optionnel) : une expression SQL qui définit la valeur
                            pour une clé étrangère calculée.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            <para>
                Donner une valeur significative à l'attribut <literal>cascade</literal> autre que 
                <literal>none</literal>  propagera certaines opérations à l'objet associé. Les valeurs 
                significatives sont les noms des opérations Hibernate basiques,     
                <literal>persist, merge, delete, save-update, evict, replicate, lock,
                refresh</literal>, ainsi que les valeurs spéciales <literal>delete-orphan</literal> 
                et <literal>all</literal> et des combinaisons de noms d'opérations séparées par des virgules,
                comme par exemple <literal>cascade="persist,merge,evict"</literal> ou
                <literal>cascade="all,delete-orphan"</literal>. Voir <xref linkend="objectstate-transitive"/>
                pour une explication complète.
                Notez que les assocations many-to-one et one-to-one ne supportent pas orphan delete.
            </para>

            <para>
                Une déclaration <literal>many-to-one</literal> typique est aussi simple que :
            </para>
            <programlisting><![CDATA[<many-to-one name="product" class="Product" column="PRODUCT_ID"/>]]></programlisting>
            <para>
                L'attribut <literal>property-ref</literal> devrait être utilisé pour mapper seulement des données 
                provenant d'un ancien système où les clefs étrangères font référence à une clef unique de la table associée 
                et qui n'est pas la clef primaire. C'est un cas de mauvaise conception relationnelle.
                Par exemple, supposez que la classe <literal>Product</literal> a un numéro de série unique qui n'est pas
                la clef primaire. (L'attribut <literal>unique</literal> contrôle la génération DDL par Hibernate avec 
                l'outil SchemaExport.)
            </para>
            <programlisting><![CDATA[<property name="serialNumber" unique="true" type="string" column="SERIAL_NUMBER"/>]]></programlisting>
            <para>
                Ainsi le mapping pour <literal>OrderItem</literal> peut utiliser :
            </para>
            <programlisting><![CDATA[<many-to-one name="product" property-ref="serialNumber" column="PRODUCT_SERIAL_NUMBER"/>]]></programlisting>
            <para>
                bien que ce ne soit certainement pas encouragé.
            </para>
            <para>
                Si la clef unique référencée comprend des propriétés multiples de l'entité associée, vous devez mapper
                ces propriétés à l'intérieur d'un élément <literal>&lt;properties&gt;</literal>.
            </para>
        </sect2>
        <sect2 id="mapping-declaration-onetoone" revision="3">
            <title>one-to-one</title>
            <para>
                Une association one-to-one vers une autre classe persistante est déclarée avec l'élément
                <literal>one-to-one</literal>.
            </para>
            <programlistingco>
                <areaspec>
                    <area id="onetoone1" coords="2 60"/>
                    <area id="onetoone2" coords="3 60"/>
                    <area id="onetoone3" coords="4 60"/>
                    <area id="onetoone4" coords="5 60"/>
                    <area id="onetoone5" coords="6 60"/>
                    <area id="onetoone6" coords="7 60"/>
                    <area id="onetoone7" coords="8 60"/>
                    <area id="onetoone8" coords="9 60"/>
                    <area id="onetoone9" coords="10 70"/>
                    <area id="onetoone10" coords="11 70"/>
                </areaspec>
                <programlisting><![CDATA[<one-to-one
        name="propertyName"
        class="ClassName"
        cascade="cascade_style"
        constrained="true|false"
        fetch="join|select"
        property-ref="propertyNameFromAssociatedClass"
        access="field|property|ClassName"
        formula="any SQL expression"
        entity-name="EntityName"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="onetoone1">
                        <para>
                            <literal>name</literal> : Le nom de la propriété.
                        </para>
                    </callout>
                    <callout arearefs="onetoone2">
                        <para>
                            <literal>class</literal> (optionnel - par défaut du type de la propriété 
                            déterminé par réflexion) : Le nom de la classe associée.
                        </para>
                    </callout>
                    <callout arearefs="onetoone3">
                        <para>
                            <literal>cascade</literal> (optionnel) :  Indique quelles opérations doivent 
                            être cascadées de l'objet père vers l'objet associé.
                        </para>
                    </callout>
                    <callout arearefs="onetoone4">
                        <para>
                            <literal>constrained</literal> (optionnel) : Indique qu'une contrainte de clef étrangère 
                            sur la clef primaire de la table mappée référence la table de la classe associée.
                            Cette option affecte l'ordre dans lequel chaque <literal>save()</literal> et chaque
                            <literal>delete()</literal> sont cascadés et détermine si l'association peut utiliser un proxy 
                            (aussi utilisé par l'outil d'export de schéma).
                        </para>
                    </callout>
                    <callout arearefs="onetoone5">
                        <para>
                            <literal>fetch</literal> (optionnel - par défaut à <literal>select</literal>) : 
                            Choisit entre récupération par jointure externe ou select séquentiel.
                        </para>
                    </callout>
                    <callout arearefs="onetoone6">
                        <para>
                            <literal>property-ref</literal> (optionnel) : Le nom de la propriété de la classe associée qui est jointe à la clef
                            primaire de cette classe. Si ce n'est pas spécifié, la clef primaire de la classe associée est utilisée.
                        </para>
                    </callout>
                    <callout arearefs="onetoone7">
                        <para>
                            <literal>access</literal> (optionnel - par défaut à <literal>property</literal>) : 
                            La stratégie à utiliser par Hibernate pour accéder à la valeur de la propriété.
                        </para>
                    </callout>
                    <callout arearefs="onetoone8">
                        <para>
                            <literal>formula</literal> (optionnel) : Presque toutes les associations one-to-one pointent sur la clef primaire 
                            de l'entité propriétaire. Dans les rares cas différents, vous devez donner une ou plusieurs 
                            autres colonnes ou expression à joindre par une formule SQL (voir <literal>org.hibernate.test.onetooneformula</literal> pour un exemple).
                        </para>                 
                    </callout>
                    <callout arearefs="onetoone9">
                        <para>
                            <literal>lazy</literal> (optionnel - par défaut <literal>proxy</literal>) : 
                            Par défaut, les associations simples sont soumise à proxy. <literal>lazy="no-proxy"</literal>
                            spécifie que la propriété doit être chargée à la demande au premier accès à l'instance.
                            (nécessite l'intrumentation du bytecode à la construction). 
                            <literal>lazy="false"</literal> indique que l'association sera toujours chargée
                            agressivement. <emphasis>Notez que si <literal>constrained="false"</literal>,
                            l'utilisation de proxy est impossible et Hibernate chargera automatiquement l'association !</emphasis>
                        </para>
                    </callout>
                    <callout arearefs="onetoone10">
                        <para>
                            <literal>entity-name</literal> (optional) : The entity name of the associated class.
                        </para>                   
                    </callout>
                </calloutlist>
            </programlistingco>
            <para>
                Il existe deux types d'associations one-to-one :
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                associations par clef primaire
            </para>
                </listitem>
                <listitem>
                    <para>
                association par clef étrangère unique
            </para>
                </listitem>
            </itemizedlist>
            <para>
                Les associations par clef primaire ne nécessitent pas une colonne supplémentaire en table ; si deux lignes sont 
                liés par l'association alors les deux lignes de la table partagent la même valeur de clef primaire. Donc si vous 
                voulez que deux objets soient liés par une association par clef primaire, vous devez faire en sorte qu'on leur 
                assigne la même valeur d'identifiant !
            </para>
            <para>
                Pour une association par clef primaire, ajoutez les mappings suivants à <literal>Employee</literal> et 
                <literal>Person</literal>, respectivement.
            </para>
            <programlisting><![CDATA[<one-to-one name="person" class="Person"/>]]></programlisting>
            <programlisting><![CDATA[<one-to-one name="employee" class="Employee" constrained="true"/>]]></programlisting>
            <para>
                Maintenant, vous devez faire en sorte que les clefs primaires des lignes liées dans les tables PERSON et EMPLOYEE 
                sont égales. On utilise une stratégie Hibernate spéciale de génération d'identifiants appelée 
                <literal>foreign</literal> :
            </para>
            <programlisting><![CDATA[<class name="person" table="PERSON">
    <id name="id" column="PERSON_ID">
        <generator class="foreign">
            <param name="property">employee</param>
        </generator>
    </id>
    ...
    <one-to-one name="employee"
        class="Employee"
        constrained="true"/>
</class>]]></programlisting>
            <para>
                Une instance fraîchement enregistrée de <literal>Person</literal> se voit alors assignée la même valeur 
                de clef primaire que l'instance de <literal>Employee</literal> référencée par la propriété <literal>employee</literal> 
                de cette <literal>Person</literal>.
            </para>
            <para>
                Alternativement, une clef étrangère avec contrainte d'unicité de <literal>Employee</literal> vers 
                <literal>Person</literal> peut être indiquée ainsi :
            </para>
            <programlisting><![CDATA[<many-to-one name="person" class="Person" column="PERSON_ID" unique="true"/>]]></programlisting>
            <para>
                Et cette association peut être rendue bidirectionnelle en ajoutant ceci au mapping de <literal>Person</literal> :
            </para>
            <programlisting><![CDATA[<one-to-one name="employee" class="Employee" property-ref="person"/>]]></programlisting>
        </sect2>
        
        <sect2 id="mapping-declaration-naturalid">
            <title>natural-id</title>

            <programlisting><![CDATA[<natural-id mutable="true|false"/>
        <property ... />
        <many-to-one ... />
        ......
</natural-id>]]></programlisting>

            <para>
                Bien que nous recommandions l'utilisation de clé primaire générée, vous devriez toujours
                essayer d'identifier des clé métier (naturelles) pour toutes vos entités. Une clé naturelle
                est une propriété ou une combinaison de propriétés uniques et non nulles. Si elle est aussi
                immuable, c'est encore mieux. Mappez les propriétés de la clé naturelle dans l'élément
                <literal>&lt;natural-id&gt;</literal>. Hibernate générera la clé unique nécessaire et les contraintes
                de non-nullité, et votre mapping s'auto-documentera.
            </para>
            
            <para>
                Nous vous recommandons fortement d'implémenter <literal>equals()</literal> et 
                <literal>hashCode()</literal> pour comparer les clés naturelles de l'entité.
            </para>

            <para>
                Ce mapping n'est pas destiné à être utilisé avec des entités qui ont des clés naturelles.
            </para>

            <itemizedlist spacing="compact">
                <listitem>
                    <para>
                        <literal>mutable</literal> (optionel, par défaut à <literal>false</literal>) : 
                        Par défaut, les identifiants naturels sont supposés être immuable (constants).
                    </para>
                </listitem>
            </itemizedlist>
            
        </sect2>
        <sect2 id="mapping-declaration-component" revision="2">
            <title>component, dynamic-component</title>
            <para>
                L'élément <literal>&lt;component&gt;</literal> mappe les propriétés d'un objet fils 
                aux colonnes d'une classe parente. Les composants peuvent en retour déclarer leurs propres 
                propriétés, composants ou collections. Voir "Components" plus bas.
            </para>
            <programlistingco>
                <areaspec>
                    <area id="component1" coords="2 45"/>
                    <area id="component2" coords="3 45"/>
                    <area id="component3" coords="4 45"/>
                    <area id="component4" coords="5 45"/>
                    <area id="component5" coords="6 45"/>
                    <area id="component6" coords="7 45"/>
                    <area id="component7" coords="8 45"/>
                    <area id="component8" coords="9 45"/>
                </areaspec>
                <programlisting><![CDATA[<component 
        name="propertyName" 
        class="className"
        insert="true|false"
        update="true|false"
        access="field|property|ClassName"
        lazy="true|false"
        optimistic-lock="true|false"
        unique="true|false"
>
        
        <property ...../>
        <many-to-one .... />
        ........
</component>]]></programlisting>
                <calloutlist>
                    <callout arearefs="component1">
                        <para>
                            <literal>name</literal> : Nom de la propriété
                        </para>
                    </callout>
                    <callout arearefs="component2">
                        <para>
                            <literal>class</literal> (optionnel - par défaut au type de la propriété déterminé par réflexion) : 
                            le nom de la classe (fille) du composant.
                        </para>
                    </callout>
                    <callout arearefs="component3">
                        <para>
                            <literal>insert</literal> : Est ce que les colonnes mappées apparaissent dans les 
                            <literal>INSERT</literal>s ?
                        </para>
                    </callout>
                    <callout arearefs="component4">
                        <para>
                            <literal>update</literal>: Est ce que les colonnes mappées apparaissent dans les 
                            <literal>UPDATE</literal>s ?
                        </para>
                    </callout>
                    <callout arearefs="component5">
                        <para>
                            <literal>access</literal> (optionnel - par défaut à <literal>property</literal>) : 
                            La stratégie que Hibernate doit utiliser pour accéder à la valeur de cette propriété.
                        </para>
                    </callout>
                    <callout arearefs="component6">
                        <para>
                            <literal>lazy</literal> (optionnel - par défaut à <literal>false</literal>) : 
                            Indique que ce composant doit être chargé au premier accès 
                            à la variable d'instance (nécessite une instrumentation du bytecode au moment du build).
                        </para>
                    </callout>
                    <callout arearefs="component7">
                        <para>
                            <literal>optimistic-lock</literal> (optionnel - par défaut à <literal>true</literal>) :
                                Indique que les mises à jour sur ce composant nécessitent ou non l'acquisition d'un 
                                verrou optimiste. En d'autres termes, cela détermine si une incrémentation de version 
                                doit avoir lieu quand la propriété est marquée obsolète (dirty).
                            </para>
                    </callout>
                    <callout arearefs="component8">
                        <para>
                            <literal>unique</literal> (optionnel - par défaut à <literal>false</literal>) :
                                Indique qu'une contrainte d'unicité existe sur toutes les colonnes mappées de ce composant.
                            </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            <para>
                Les tags fils <literal>&lt;property&gt;</literal> mappent les propriétés 
                de la classe fille sur les colonnes de la table.
            </para>
            <para>
                L'élément <literal>&lt;component&gt;</literal> permet de déclarer sous-élément <literal>&lt;parent&gt;</literal> qui associe une propriété
                de la classe composant comme une référence arrière vers l'entité contenante.
            </para>
            <para>
                L'élément <literal>&lt;dynamic-component&gt;</literal> permet à une <literal>Map</literal> d'être mappée 
                comme un composant, quand les noms de la propriété font référence aux clefs de cette Map, voir 
                <xref linkend="components-dynamic"/>.
            </para>
        </sect2>
        <sect2 id="mapping-declaration-properties" revision="2">
            <title>properties</title>
            <para>
                L'élément <literal>&lt;properties&gt;</literal> permet la définition d'un groupement logique nommé 
                des propriétés d'une classe. L'utilisation la plus importante de cette construction est la possibilité 
                pour une combinaison de propriétés d'être la cible d'un <literal>property-ref</literal>. C'est aussi 
                un moyen pratique de définir une contrainte d'unicité multi-colonnes.
            </para>
            <programlistingco>
                <areaspec>
                    <area id="properties1" coords="2 45"/>
                    <area id="properties2" coords="3 45"/>
                    <area id="properties3" coords="4 45"/>
                    <area id="properties4" coords="5 45"/>
                    <area id="properties5" coords="6 45"/>
                </areaspec>
                <programlisting><![CDATA[<properties 
        name="logicalName" 
        insert="true|false"
        update="true|false"
        optimistic-lock="true|false"
        unique="true|false"
>
        
        <property ...../>
        <many-to-one .... />
        ........
</properties>]]></programlisting>
                <calloutlist>
                    <callout arearefs="properties1">
                        <para>
                            <literal>name</literal> : Le nom logique d'un regroupement et 
                            <emphasis>non</emphasis> le véritable nom d'une propriété.
                        </para>
                    </callout>
                    <callout arearefs="properties2">
                        <para>
                            <literal>insert</literal> : Est-ce que les colonnes mappées apparaissent dans les 
                            <literal>INSERT</literal>s ?
                        </para>
                    </callout>
                    <callout arearefs="properties3">
                        <para>
                            <literal>update</literal> : Est-ce que les colonnes mappées apparaissent dans les 
                            <literal>UPDATE</literal>s ?
                        </para>
                    </callout>
                    <callout arearefs="properties4">
                        <para>
                            <literal>optimistic-lock</literal> (optionnel - par défaut à <literal>true</literal>) :
                                Indique que les mises à jour sur ce composant nécessitent ou non l'acquisition d'un 
                                verrou optimiste. En d'autres termes, cela détermine si une incrémentation 
                                de version doit avoir lieu quand la propriété est marquée obsolète (dirty).
                            </para>
                    </callout>
                    <callout arearefs="properties5">
                        <para>
                            <literal>unique</literal> (optionnel - par défaut à <literal>false</literal>) :
                            Indique qu'une contrainte d'unicité existe sur toutes les colonnes mappées de ce composant.
                            </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            <para>
                Par exemple, si nous avons le mapping de <literal>&lt;properties&gt;</literal> suivant :
            </para>
            <programlisting><![CDATA[<class name="Person">
    <id name="personNumber"/>
    ...
    <properties name="name" 
            unique="true" update="false">
        <property name="firstName"/>
        <property name="initial"/>
        <property name="lastName"/>
    </properties>
</class>]]></programlisting>
            <para>
                Alors nous pourrions avoir une association sur des données d'un ancien système (legacy) qui font référence 
                à cette clef unique de la table <literal>Person</literal> au lieu de la clef primaire :
            </para>
            <programlisting><![CDATA[<many-to-one name="person" 
         class="Person" property-ref="name">
    <column name="firstName"/>
    <column name="initial"/>
    <column name="lastName"/>
</many-to-one>]]></programlisting>
            <para>
                Nous ne recommandons pas l'utilisation de ce genre de chose en dehors du contexte de mapping de données héritées 
                d'anciens systèmes.
            </para>
        </sect2>
        <sect2 id="mapping-declaration-subclass" revision="4">
            <title>subclass</title>
            <para>
                Pour finir, la persistance polymorphique nécessite la déclaration de chaque sous-classe de la classe persistante de base. 
                pour la stratégie de mapping de type table-per-class-hierarchy, on utilise la déclaration 
                <literal>&lt;subclass&gt;</literal>.    
            </para>
            <programlistingco>
                <areaspec>
                    <area id="subclass1" coords="2 55"/>
                    <area id="subclass2" coords="3 55"/>
                    <area id="subclass3" coords="4 55"/>
                    <area id="subclass4" coords="5 55"/>
                </areaspec>
                <programlisting><![CDATA[<subclass
        name="ClassName"
        discriminator-value="discriminator_value"
        proxy="ProxyInterface"
        lazy="true|false"
        dynamic-update="true|false"
        dynamic-insert="true|false"
        entity-name="EntityName"
        node="element-name"
        extends="SuperclassName">

        <property .... />
        .....
</subclass>]]></programlisting>
                <calloutlist>
                    <callout arearefs="subclass1">
                        <para>
                            <literal>name</literal> : Le nom complet de la sous-classe.
                        </para>
                    </callout>
                    <callout arearefs="subclass2">
                        <para>
                            <literal>discriminator-value</literal> (optionnel - par défaut le nom de la classe) : 
                            une valeur qui distingue les différentes sous-classes.
                        </para>
                    </callout>
                    <callout arearefs="subclass3">
                        <para>
                            <literal>proxy</literal> (optionnel) : Indique une classe ou interface à utiliser pour les chargements
                            à la demande des proxies (lazy).
                        </para>
                    </callout>
                    <callout arearefs="subclass4">
                        <para>
                            <literal>lazy</literal> (optionnel, par défaut à <literal>true</literal>) : Spécifier 
                            <literal>lazy="false"</literal> désactive l'utilisation du chargement à la demande (lazy).
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            <para>
                Chaque sous-classe devrait déclarer ses propres propriétés persistantes et sous-classes.
                Les propriétés <literal>&lt;version&gt;</literal> et <literal>&lt;id&gt;</literal> 
                sont implicitement hérités de la classe de base. Chaque sous-classe dans une hiérarchie doit 
                définir une unique <literal>discriminator-value</literal>. Si aucune n'est spécifiée, 
                le nom complet de la classe Java est utilisé.
            </para>
            <para>
                Pour plus d'infos sur le mapping d'héritage, voir <xref linkend="inheritance"/>.
        </para>
            <programlisting><![CDATA[
<hibernate-mapping>
    <subclass name="DomesticCat" extends="Cat" discriminator-value="D">
         <property name="name" type="string"/>
    </subclass>
</hibernate-mapping>]]></programlisting>
            <para>
                Pour des informations sur les mappings d'héritage, voir <xref linkend="inheritance"/>.
            </para>
        </sect2>
        <sect2 id="mapping-declaration-joinedsubclass" revision="3">
            <title>joined-subclass</title>
            <para>
                Une autre façon possible de faire est la suivante, chaque sous-classe peut être mappée vers sa propre table (stratégie 
                de mapping de type table-per-subclass). L'état hérité est récupéré en joignant la table de la super-classe.
                L'élément <literal>&lt;joined-subclass&gt;</literal> est utilisé.
            </para>
            <programlistingco>
                <areaspec>
                    <area id="joinedsubclass1" coords="2 45"/>
                    <area id="joinedsubclass2" coords="3 45"/>
                    <area id="joinedsubclass3" coords="4 45"/>
                    <area id="joinedsubclass4" coords="5 45"/>
                </areaspec>
                <programlisting><![CDATA[<joined-subclass
        name="ClassName"
        table="tablename"
        proxy="ProxyInterface"
        lazy="true|false"
        dynamic-update="true|false"
        dynamic-insert="true|false"
        schema="schema"
        catalog="catalog"
        extends="SuperclassName"
        persister="ClassName"
        subselect="SQL expression"
        entity-name="EntityName">

        <key .... >

        <property .... />
        .....
</joined-subclass>]]></programlisting>
                <calloutlist>
                    <callout arearefs="joinedsubclass1">
                        <para>
                            <literal>name</literal> : Le nom Java complet de la sous-classe.
                        </para>
                    </callout>
                    <callout arearefs="joinedsubclass2">
                        <para>
                            <literal>table</literal> : Le nom de la table de la sous-classe.
                        </para>
                    </callout>
                    <callout arearefs="joinedsubclass3">
                        <para>
                            <literal>proxy</literal> (optionnel) : Indique une classe ou interface pour le chargement différé des proxies.
                        </para>
                    </callout>
                    <callout arearefs="joinedsubclass4">
                        <para>
                            <literal>lazy</literal> (optionnel, par défaut à <literal>true</literal>) : Indiquer 
                            <literal>lazy="false"</literal> désactive l'utilisation du chargement à la demande.
                         </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            <para>
                Aucune colonne discriminante n'est nécessaire pour cette stratégie de mapping. Cependant, 
                chaque sous-classe doit déclarer une colonne de table contenant l'objet identifiant qui utilise l'élément 
                <literal>&lt;key&gt;</literal>. Le mapping au début de ce chapitre serait ré-écrit ainsi :
            </para>
            <programlisting><![CDATA[<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">

<hibernate-mapping package="eg">

        <class name="Cat" table="CATS">
                <id name="id" column="uid" type="long">
                        <generator class="hilo"/>
                </id>
                <property name="birthdate" type="date"/>
                <property name="color" not-null="true"/>
                <property name="sex" not-null="true"/>
                <property name="weight"/>
                <many-to-one name="mate"/>
                <set name="kittens">
                        <key column="MOTHER"/>
                        <one-to-many class="Cat"/>
                </set>
                <joined-subclass name="DomesticCat" table="DOMESTIC_CATS">
                    <key column="CAT"/>
                    <property name="name" type="string"/>
                </joined-subclass>
        </class>

        <class name="eg.Dog">
                <!-- mapping for Dog could go here -->
        </class>

</hibernate-mapping>]]></programlisting>
            <para>
                 Pour des informations sur les mappings d'héritage, voir <xref linkend="inheritance"/>.
             </para>
        </sect2>
        <sect2 id="mapping-declaration-unionsubclass" revision="2">
            <title>union-subclass</title>
            <para>
               Une troisième option est de seulement mapper vers des tables les classes concrètes 
               d'une hiérarchie d'héritage, (stratégie de type table-per-concrete-class) où 
               chaque table définit tous les états persistants de la classe, y compris les états hérités. 
               Dans Hibernate il n'est absolument pas nécessaire de mapper explicitement de telles hiérarchies 
               d'héritage. Vous pouvez simplement mapper chaque classe avec une déclaration <literal>&lt;class&gt;</literal> 
               différente. Cependant, si vous souhaitez utiliser des associations polymorphiques (càd une association 
               vers la superclasse de la hiérarchie), vous devez utiliser le mapping <literal>&lt;union-subclass&gt;</literal>.
           </para>
            <programlistingco>
                <areaspec>
                    <area id="unionsubclass1" coords="2 45"/>
                    <area id="unionsubclass2" coords="3 45"/>
                    <area id="unionsubclass3" coords="4 45"/>
                    <area id="unionsubclass4" coords="5 45"/>
                </areaspec>
                <programlisting><![CDATA[<union-subclass
        name="ClassName"
        table="tablename"
        proxy="ProxyInterface"
        lazy="true|false"
        dynamic-update="true|false"
        dynamic-insert="true|false"
        schema="schema"
        catalog="catalog"
        extends="SuperclassName"
        abstract="true|false"
        persister="ClassName"
        subselect="SQL expression"
        entity-name="EntityName">

        <property .... />
        .....
</union-subclass>]]></programlisting>
                <calloutlist>
                    <callout arearefs="unionsubclass1">
                        <para>
                            <literal>name</literal> : Le nom Java complet de la sous-classe.
                        </para>
                    </callout>
                    <callout arearefs="unionsubclass2">
                        <para>
                            <literal>table</literal> : nom de la table de la sous-classe.
                        </para>
                    </callout>
                    <callout arearefs="unionsubclass3">
                        <para>
                            <literal>proxy</literal> (optionnel) : Indique une classe ou interface pour le chargement différé des proxies.
                        </para>
                    </callout>
                    <callout arearefs="unionsubclass4">
                        <para>
                            <literal>lazy</literal> (optionnel, par défaut à <literal>true</literal>) : Indiquer 
                            <literal>lazy="false"</literal> désactive l'utilisation du chargement à la demande.
                         </para>

                    </callout>
                </calloutlist>
            </programlistingco>
            <para>
                Aucune colonne discriminante ou colonne clef n'est requise pour cette stratégie de mapping.
            </para>
            <para>
                Pour des informations sur les mappings d'héritage, voir <xref linkend="inheritance"/>.
            </para>
        </sect2>
        <sect2 id="mapping-declaration-join" revision="3">
            <title>join</title>
            <para>
                En utilisant l'élément <literal>&lt;join&gt;</literal>, il est possible de mapper 
                des propriétés d'une classe sur plusieurs tables.
            </para>
            <programlistingco>
                <areaspec>
                    <area id="join1" coords="2 50"/>
                    <area id="join2" coords="3 50"/>
                    <area id="join3" coords="4 50"/>
                    <area id="join4" coords="5 50"/>
                    <area id="join5" coords="6 50"/>
                    <area id="join6" coords="7 50"/>
                </areaspec>
                <programlisting><![CDATA[<join
        table="tablename"
        schema="owner"
        catalog="catalog"
        fetch="join|select"
        inverse="true|false"
        optionnel="true|false">
        
        <key ... />
        
        <property ... />
        ...
</join>]]></programlisting>
                <calloutlist>
                    <callout arearefs="join1">
                        <para>
                            <literal>table</literal> : Le nom de la table jointe.
                        </para>
                    </callout>
                    <callout arearefs="join2">
                        <para>
                            <literal>schema</literal> (optionnel) : court-circuite le nom de schéma spécifié par l'élément de base 
                            <literal>&lt;hibernate-mapping&gt;</literal>.
                        </para>
                    </callout>
                    <callout arearefs="join3">
                        <para>
                            <literal>catalog</literal> (optionnel) : court-circuite le nom de catalogue spécifié par l'élément de base 
                            <literal>&lt;hibernate-mapping&gt;</literal>.
                        </para>
                    </callout>
                    <callout arearefs="join4">
                        <para>
                            <literal>fetch</literal> (optionnel - par défaut à <literal>join</literal>) :
                            Si positionné à <literal>join</literal>, Hibernate utilisera une jointure interne pour charger
                            une <literal>jointure</literal> définie par une classe ou ses super-classes et une jointure externe
                            pour une <literal>&lt;jointure&gt;</literal> définie par une sous-classe.
                            Si positionné à <literal>select</literal> alors Hibernate utilisera un select séquentiel 
                            pour une <literal>&lt;jointure&gt;</literal> définie sur une sous-classe, qui ne sera délivrée que
                            si une ligne se représente une instance de la sous-classe. Les jointures internes seront quand même 
                            utilisées pour charger une <literal>&lt;jointure&gt;</literal> définie par une classe et ses super-classes.
                        </para>
                    </callout>
                    <callout arearefs="join5">
                        <para>
                            <literal>inverse</literal> (optionnel - par défaut à <literal>false</literal>) :
                            Si positionné à true, Hibernate n'essaiera pas d'insérer ou de mettre à jour les 
                            propriétés définies par cette jointure.
                        </para>
                    </callout>
                    <callout arearefs="join6">
                        <para>
                            <literal>optionnel</literal> (optionnel - par défaut à <literal>false</literal>) :
                            Si positionné à true, Hibernate insèrera une ligne seulement si les propriétés définies 
                            par cette jointure sont non-nulles et utilisera toujours une jointure externe pour charger les propriétés.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            <para>
                Par exemple, les informations d'adresse pour une personne peuvent être mappées vers une table 
                séparée (tout en préservant des sémantiques de type valeur pour toutes ses propriétés) :
            </para>
            <programlisting><![CDATA[<class name="Person"
    table="PERSON">

    <id name="id" column="PERSON_ID">...</id>

    <join table="ADDRESS">
        <key column="ADDRESS_ID"/>
        <property name="address"/>
        <property name="zip"/>
        <property name="country"/>
    </join>
    ...]]></programlisting>
            <para>
                Cette fonctionnalité est souvent seulement utile pour les modèles de données 
                hérités d'anciens systèmes (legacy), nous recommandons d'utiliser moins de tables que de classes 
                et un modèle de domaine à granularité fine. Cependant, c'est utile 
                pour passer d'une stratégie de mapping d'héritage à une autre dans une hiérarchie simple ainsi qu'il est 
                expliqué plus tard.
            </para>
        </sect2>
        <sect2 id="mapping-declaration-key">
            <title>key</title>
            <para>
                Nous avons rencontré l'élément <literal>&lt;key&gt;</literal> à plusieurs reprises maintenant. 
                Il apparaît partout que l'élément de mapping parent définit une jointure sur une nouvele table, et 
                définit la clef étrangère dans la table jointe, ce qui référence la clef primaire de la table d'origine.
            </para>
            <programlistingco>
                <areaspec>
                    <area id="key1" coords="2 50"/>
                    <area id="key2" coords="3 50"/>
                    <area id="key3" coords="4 50"/>
                    <area id="key4" coords="5 50"/>
                    <area id="key5" coords="6 50"/>
                    <area id="key6" coords="7 50"/>
                </areaspec>
                <programlisting><![CDATA[<key
        column="columnname"
        on-delete="noaction|cascade"
        property-ref="propertyName"
        not-null="true|false"
        update="true|false"
        unique="true|false"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="key1">
                        <para>
                            <literal>column</literal> (optionnel) : Le nom de la colonne de la clef étrangère
                            Cela peut aussi être spécifié par l'élément(s) intégré(s) <literal>&lt;column&gt;</literal>.
                        </para>
                    </callout>
                    <callout arearefs="key2">
                        <para>
                            <literal>on-delete</literal> (optionnel, par défaut à <literal>noaction</literal>) :
                            Indique si la contrainte de clef étrangère possède la possibilité au niveau base de données 
                            de suppression en cascade.
                        </para>
                    </callout>
                    <callout arearefs="key3">
                        <para>
                            <literal>property-ref</literal> (optionnel) : Indique que la clef étrangère fait 
                            référence à des colonnes qui ne sont pas la clef primaire de la table d'origine 
                            (Pour les données de systèmes legacy).
                        </para>
                    </callout>
                    <callout arearefs="key4">
                        <para>
                            <literal>not-null</literal> (optionnel) : Indique que les colonnes des clefs étrangères ne 
                            peuvent pas être nulles (c'est implicite si la clef étrangère fait partie de la clef primaire).
                        </para>
                    </callout>
                    <callout arearefs="key5">
                        <para>
                            <literal>update</literal> (optionnel) : Indique que la clef étrangère ne devrait jamais être mise à jour 
                            (implicite si celle-ci fait partie de la clef primaire).
                        </para>
                    </callout>
                    <callout arearefs="key6">
                        <para>
                            <literal>unique</literal> (optionnel) : Indique que la clef étrangère doit posséder une contrainte 
                            d'unicité (implicite si la clef étrangère est aussi la clef primaire).
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            <para>
                Nous recommandons pour les systèmes où les suppressions doivent être performantes de définir toutes 
                les clefs <literal>on-delete="cascade"</literal>, ainsi Hibernate utilisera une contrainte 
                <literal>ON CASCADE DELETE</literal> au niveau base de données, plutôt que de nombreux
                <literal>DELETE</literal> individuels. Attention, cette fonctionnalité court-circuite la stratégie 
                habituelle de verrou optimiste pour les données versionnées.
            </para>
            <para>
                Les attributs <literal>not-null</literal> et <literal>update</literal> sont utiles pour 
                mapper une association one-to-many unidirectionnelle. Si vous mappez un one-to-many unidirectionnel 
                vers une clef étrangère non nulle, vous <emphasis>devez</emphasis> déclarer la colonne de la clef 
                en utilisant <literal>&lt;key not-null="true"&gt;</literal>.
            </para>
        </sect2>
        <sect2 id="mapping-column" revision="4">
            <title>éléments column et formula</title>
            <para>
               Tout élément de mapping qui accepte un attribut <literal>column</literal> acceptera alternativement 
               un sous-élément <literal>&lt;column&gt;</literal>. De façon identique, <literal>&lt;formula&gt;</literal> 
               est une alternative à l'attribut <literal>formula</literal>.
           </para>
            <programlisting><![CDATA[<column
        name="column_name"
        length="N"
        precision="N"
        scale="N"
        not-null="true|false"
        unique="true|false"
        unique-key="multicolumn_unique_key_name"
        index="index_name"
        sql-type="sql_type_name"
        check="SQL expression"/>]]></programlisting>
            <programlisting><![CDATA[<formula>SQL expression</formula>]]></programlisting>
            <para>
                Les attributs <literal>column</literal> et <literal>formula</literal> peuvent même être combinés 
                au sein d'une même propriété ou mapping d'association pour exprimer, par exemple, des conditions 
                de jointure exotiques.
            </para>
            <programlisting><![CDATA[<many-to-one name="homeAddress" class="Address"
        insert="false" update="false">
    <column name="person_id" not-null="true" length="10"/>
    <formula>'MAILING'</formula>
</many-to-one>]]></programlisting>
        </sect2>
        <sect2 id="mapping-declaration-import">
            <title>import</title>
            <para>
                Supposez que votre application possède deux classes persistantes du même nom, et vous ne voulez pas préciser 
                le nom Java complet (packages inclus) dans les queries Hibernate. Les classes peuvent alors être "importées" 
                explicitement plutôt que de compter sur <literal>auto-import="true"</literal>.Vous pouvez même importer 
                des classes et interfaces qui ne sont pas mappées explicitement.
            </para>
            <programlisting><![CDATA[<import class="java.lang.Object" rename="Universe"/>]]></programlisting>
            <programlistingco>
                <areaspec>
                    <area id="import1" coords="2 40"/>
                    <area id="import2" coords="3 40"/>
                </areaspec>
                <programlisting><![CDATA[<import
        class="ClassName"
        rename="ShortName"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="import1">
                        <para>
                            <literal>class</literal> : Nom Java complet de la classe.
                        </para>
                    </callout>
                    <callout arearefs="import2">
                        <para>
                            <literal>rename</literal> (optionnel - par défaut vaut le nom de la classe Java (sans package)) :
                            Nom pouvant être utilisé dans le langage de requête.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
        </sect2>
        <sect2 id="mapping-types-anymapping" revision="2">
            <title>any</title>
            <para>
                Il existe encore un type de mapping de propriété. L'élément de mapping <literal>&lt;any&gt;</literal> 
                définit une association polymorphique vers des classes de tables multiples. Ce type de mapping requiert 
                toujours plus d'une colonne. La première colonne contient le type de l'entité associée. Les colonnes 
                restantes contiennent l'identifiant. il est impossible de spécifier une contrainte de clef étrangère 
                pour ce type d'association, donc ce n'est certainement pas considéré comme le moyen habituel de mapper 
                des associations (polymorphiques). Vous devriez utiliser cela uniquement dans des cas particuliers 
                (par exemple des logs d'audit, des données de session utilisateur, etc...).
            </para>
            <para>
                 L'attribut <literal>meta-type</literal> permet à l'application de spécifier un type personnalisé qui mappe 
                 des valeurs de colonnes de le base de données sur des classes persistantes qui ont un attribut identifiant 
                 du type spécifié par <literal>id-type</literal>. Vous devez spécifier le mapping à partir de valeurs du 
                 méta-type sur les noms des classes.
            </para>
            <programlisting><![CDATA[<any name="being" id-type="long" meta-type="string">
    <meta-value value="TBL_ANIMAL" class="Animal"/>
    <meta-value value="TBL_HUMAN" class="Human"/>
    <meta-value value="TBL_ALIEN" class="Alien"/>
    <column name="table_name"/>
    <column name="id"/>
</any>]]></programlisting>
            <programlistingco>
                <areaspec>
                    <area id="any1" coords="2 50"/>
                    <area id="any2" coords="3 50"/>
                    <area id="any3" coords="4 50"/>
                    <area id="any4" coords="5 50"/>
                    <area id="any5" coords="6 50"/>
                    <area id="any6" coords="7 50"/>
                </areaspec>
                <programlisting><![CDATA[<any
        name="propertyName"
        id-type="idtypename"
        meta-type="metatypename"
        cascade="cascade_style"
        access="field|property|ClassName"
        optimistic-lock="true|false"
>
        <meta-value ... />
        <meta-value ... />
        .....
        <column .... />
        <column .... />
        .....
</any>]]></programlisting>
                <calloutlist>
                    <callout arearefs="any1">
                        <para>
                            <literal>name</literal> : le nom de la propriété.
                        </para>
                    </callout>
                    <callout arearefs="any2">
                        <para>
                            <literal>id-type</literal> : le type identifiant.
                        </para>
                    </callout>
                    <callout arearefs="any3">
                        <para>
                            <literal>meta-type</literal> (optionnel - par défaut à <literal>string</literal>) : 
                            Tout type permis pour un mapping par discriminateur.
                        </para>
                    </callout>
                    <callout arearefs="any4">
                        <para>
                            <literal>cascade</literal> (optionnel - par défaut à <literal>none</literal>) : 
                            le style de cascade.
                        </para>
                    </callout>
                    <callout arearefs="any5">
                        <para>
                            <literal>access</literal> (optionnel - par défaut à <literal>property</literal>) : La stratégie 
                            à utiliser par Hibernate pour accéder à cette propriété.
                        </para>
                    </callout>
                    <callout arearefs="any6">
                        <para>
                            <literal>optimistic-lock</literal> (optionnel - par défaut à <literal>true</literal>) : 
                            Indique que les mises à jour sur cette propriété nécessitent ou non l'acquisition d'un 
                            verrou optimiste. En d'autres termes, définit si un incrément de version doit avoir lieu 
                            quand cette propriété est marquée dirty.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
        </sect2>
    </sect1>
    <sect1 id="mapping-types">
        <title>Hibernate Types</title>
        <sect2 id="mapping-types-entitiesvalues" revision="1">
            <title>Entités et valeurs</title>
            <para>
                Pour comprendre le comportement des différents objets Java par rapport au service 
                de persistance, nous avons besoin de les classer en deux groupes :
            </para>
            <para>
                Une <emphasis>entité</emphasis> existe indépendamment de tout autre objet possédant 
                une référence vers l'entité. Comparez cela avec le modèle Java habituel où un objet 
                est supprimé par le garbage collector dès qu'il n'est plus référencé. Les entités 
                doivent être explicitement enregistrées et supprimées (sauf dans les cas où 
                sauvegardes et suppressions sont <emphasis>cascadées</emphasis> d'une entité mère 
                vers ses enfants). C'est différent du modèle ODMG de persistance par 
                atteignabilité - et correspond mieux à la façon dont les objets sont 
                habituellement utilisés dans des grands systèmes. Les entités permettent les références 
                circulaires et partagées. Elles peuvent aussi être versionnées.
            </para>
            <para>
                L'état persistant d'une entité consiste en des références vers d'autres entités et 
                instances de types <emphasis>valeurs</emphasis>. Ces valeurs sont des types primitifs, 
                des collections (et non le contenu d'une collection), des composants de certains objets 
                immuables. Contrairement aux entités, les valeurs (et en particulier les collections et 
                composants) <emphasis>sont</emphasis> persistés par atteignabiliité. Comme les 
                valeurs (et types primitifs) sont persistés et supprimés avec l'entité qui les contient, 
                ils ne peuvent pas posséder leurs propres versions. Les valeurs n'ont pas d'identité 
                indépendantes, ainsi elles ne peuvent pas être partagées par deux entités ou collections.
            </para>
            <para>
                Jusqu'à présent nous avons utilisé le terme "classe persistante" pour parler d'entités. 
                Nous allons continuer à faire ainsi. Cependant, au sens strict, toutes 
                les classes définies par un utilisateur possédant un état persistant ne sont pas des 
                entités. Un <emphasis>composant</emphasis> est une classe définie par un utilisateur 
                avec les caractéristiques d'une valeur. Une propriété Java de type <literal>java.lang.String</literal>
                a aussi les caractéristiques d'une valeur. 
                
                <!-- FIXME Baptiste MATHUS : J'ai remis le texte anglais pour que si la version est publiée
                comme ça, au moins le lecteur puisse essayer lui aussi de comprendre la version anglaise... -->
                
                Given this definition, we can say that all types (classes) provided
                by the JDK have value type semantics in Java, while user-defined types may
                be mapped with entity or value type semantics. This decision is up to the
                application developer. A good hint for an entity class in a domain model are
                shared references to a single instance of that class, while composition or
                aggregation usually translates to a value type.
            </para>
            <para>
                Nous nous pencherons sur ces deux concepts tout au long de la documentation.
            </para>
            <para>
                Le défi est de mapper les type Javas (et la définition des développeurs des 
                entités et valeurs types) sur les types du SQL ou des bases de données. Le pont 
                entre les deux systèmes est proposé par Hibernate : pour les entités nous utilisons 
                <literal>&lt;class&gt;</literal>, <literal>&lt;subclass&gt;</literal> et ainsi de suite.
                Pour les types valeurs nous utilisons <literal>&lt;property&gt;</literal>,
                <literal>&lt;component&gt;</literal>, etc., habituellement avec un attribut <literal>type</literal>. 
                La valeur de cet attribut est le nom d'un <emphasis>type de mapping</emphasis> Hibernate. 
                Hibernate propose de base de nombreux mappings (pour les types de valeurs standards du JDK). 
                Vous pouvez écrire vos propres types de mappings et implémenter aussi vos propres stratégies 
                de conversion, nous le verrons plus tard.
            </para>
            <para>
                Tous les types proposés de base par Hibernate à part les collections autorisent la valeur null.
            </para>
        </sect2>
        <sect2 id="mapping-types-basictypes" revision="3">
            <title>Basic value types</title>
            <para>
                Les <emphasis>types basiques de mapping</emphasis> proposés de base peuvent grossièrement être 
                rangés dans les catégories suivantes :
                <variablelist>
                    <varlistentry>
                        <term>
                            <literal>integer, long, short, float, double, character, byte,
                            boolean, yes_no, true_false</literal>
                        </term>
                        <listitem>
                            <para>
                                Les mappings de type des primitives Java ou leurs classes wrappers (ex: Integer 
                                pour int) vers les types SQL (propriétaires) appropriés. <literal>boolean, 
                                yes_no</literal>et <literal>true_false</literal> sont tous des alternatives 
                                pour les types Java <literal>boolean</literal> ou <literal>java.lang.Boolean</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <literal>string</literal>
                        </term>
                        <listitem>
                            <para>
                                Mapping de type de <literal>java.lang.String</literal> vers
                                <literal>VARCHAR</literal> (ou le <literal>VARCHAR2</literal> Oracle).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <literal>date, time, timestamp</literal>
                        </term>
                        <listitem>
                            <para>
                                Mappings de type pour <literal>java.util.Date</literal> et ses sous-classes  
                                vers les types SQL <literal>DATE</literal>, <literal>TIME</literal> et
                                <literal>TIMESTAMP</literal> (ou équivalent).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <literal>calendar, calendar_date</literal>
                        </term>
                        <listitem>
                            <para>
                                Mappings de type pour <literal>java.util.Calendar</literal> vers les types SQL 
                                <literal>TIMESTAMP</literal> et <literal>DATE</literal>
                                (ou équivalent).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <literal>big_decimal, big_integer</literal>
                        </term>
                        <listitem>
                            <para>
                                Mappings de type pour <literal>java.math.BigDecimal</literal> et
                                <literal>java.math.BigInteger</literal> vers <literal>NUMERIC</literal> 
                                (ou le <literal>NUMBER</literal> Oracle).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <literal>locale, timezone, currency</literal>
                        </term>
                        <listitem>
                            <para>
                                Mappings de type pour <literal>java.util.Locale</literal>,
                                <literal>java.util.TimeZone</literal> et 
                                <literal>java.util.Currency</literal> 
                                vers <literal>VARCHAR</literal> (ou le <literal>VARCHAR2</literal> Oracle).
                                Les instances de <literal>Locale</literal> et <literal>Currency</literal> sont 
                                mappées sur leurs codes ISO. Les instances de <literal>TimeZone</literal> sont
                                mappées sur leur <literal>ID</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <literal>class</literal>
                        </term>
                        <listitem>
                            <para>
                                Un type de mapping pour <literal>java.lang.Class</literal> vers
                                <literal>VARCHAR</literal> (ou le <literal>VARCHAR2</literal> Oracle).
                                Un objet <literal>Class</literal> est mappé sur son nom Java complet.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <literal>binary</literal>
                        </term>
                        <listitem>
                            <para>
                                Mappe les tableaux de bytes vers le type binaire SQL approprié.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <literal>text</literal>
                        </term>
                        <listitem>
                            <para>
                                Mappe les longues chaînes de caractères Java vers les types SQL 
                                <literal>CLOB</literal> ou <literal>TEXT</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <literal>serializable</literal>
                        </term>
                        <listitem>
                            <para>
                                Mappe les types Java sérialisables vers le type SQL binaire approprié. Vous pouvez 
                                aussi indiquer le type Hibernate <literal>serializable</literal> avec le nom 
                                d'une classe Java sérialisable ou une interface qui ne soit pas par défaut un type de base.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <literal>clob, blob</literal>
                        </term>
                        <listitem>
                            <para>
                                Mappings de type pour les classes JDBC <literal>java.sql.Clob</literal> and
                                <literal>java.sql.Blob</literal>. Ces types peuvent ne pas convenir pour certaines 
                                applications car un objet blob ou clob peut ne pas être réutilisable en dehors 
                                d'une transaction (de plus l'implémentation par les pilotes est moyennement bonne).
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <literal>imm_date, imm_time, imm_timestamp, imm_calendar, imm_calendar_date,
                            imm_serializable, imm_binary</literal>
                        </term>
                        <listitem>
                            <para>
                                Mappings de type pour ceux qui sont habituellement modifiable, pour lesquels
                                Hibernate effectue certains optimisations convenant seulement aux types Java immuables,
                                et l'application les traite comme immuable. 
                                Par exemple, vous ne devriez pas appeler <literal>Date.setTime()</literal> sur une instance
                                mappée sur un <literal>imm_timestamp</literal>. Pour changer la valeur
                                de la propriété, et faire que cette modification soit persistée, l'application
                                doit assigner un nouvel (non identique) objet à la propriété.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
            <para>
                Les identifiants uniques des entités et collections peuvent être de n'importe quel type de base excepté 
                <literal>binary</literal>, <literal>blob</literal> et <literal>clob</literal> (les identifiants 
                composites sont aussi permis, voir plus bas).
            </para>
            <para>
                Les types de base des valeurs ont des <literal>Type</literal> constants correspondants définis 
                dans <literal>org.hibernate.Hibernate</literal>. Par exemple, <literal>Hibernate.STRING</literal>
                représenté le type <literal>string</literal>.
            </para>
        </sect2>
        <sect2 id="mapping-types-custom" revision="2">
            <title>Types de valeur définis par l'utilisateur</title>
            <para>
                Il est assez facile pour les développeurs de créer leurs propres types de valeurs. Par exemple, 
                vous pourriez vouloir persister des propriétés du type <literal>java.lang.BigInteger</literal>
                dans des colonnnes <literal>VARCHAR</literal>. Hibernate ne procure pas par défaut un type pour cela. 
                Mais les types que vous pouvez créer ne se limitent pas à mapper des propriétés (ou élément collection) 
                à une simple colonne d'une table. Donc, par exemple, vous pourriez avoir une propriété Java 
                <literal>getName()</literal>/<literal>setName()</literal> de type 
                <literal>java.lang.String</literal> persistée dans les colonnes  
                <literal>FIRST_NAME</literal>, <literal>INITIAL</literal>, <literal>SURNAME</literal>.
            </para>
            <para>
                Pour implémenter votre propre type, vous pouvez soit implémenter <literal>org.hibernate.UserType</literal> 
                soit <literal>org.hibernate.CompositeUserType</literal> et déclarer des propriétés utilisant des 
                noms de classes complets du type. Regardez <literal>org.hibernate.test.DoubleStringType</literal> 
                pour voir ce qu'il est possible de faire.
            </para>
            <programlisting><![CDATA[<property name="twoStrings" type="org.hibernate.test.DoubleStringType">
    <column name="first_string"/>
    <column name="second_string"/>
</property>]]></programlisting>
            <para>
                Remarquez l'utilisation des tags <literal>&lt;column&gt;</literal> pour mapper une propriété sur des colonnes 
                multiples.
            </para>
            <para>
                Les interfaces <literal>CompositeUserType</literal>, <literal>EnhancedUserType</literal>,
                <literal>UserCollectionType</literal>, et <literal>UserVersionType</literal> permettent des utilisations 
                plus spécialisées.
            </para>
            <para>
                Vous pouvez même donner des paramètres en indiquant <literal>UserType</literal> dans le fichier 
                de mapping ; Pour cela, votre <literal>UserType</literal> doit implémenter l'interface 
                <literal>org.hibernate.usertype.ParameterizedType</literal>. Pour spécifier des paramètres dans 
                votre type propre, vous pouvez utiliser l'élément <literal>&lt;type&gt;</literal> dans vos fichiers de mapping.
            </para>
            <programlisting><![CDATA[<property name="priority">
    <type name="com.mycompany.usertypes.DefaultValueIntegerType">
        <param name="default">0</param>
    </type>
</property>]]></programlisting>
            <para>
                Le <literal>UserType</literal> permet maintenant de récupérer la valeur pour le paramètre nommé 
                <literal>default</literal> à partir de l'objet <literal>Properties</literal> qui lui est passé.
            </para>
            <para>
                Si vous utilisez fréquemment un <literal>UserType</literal>, cela peut être utile de lui définir un 
                nom plus court. Vous pouvez faire cela en utilisant l'élément <literal>&lt;typedef&gt;</literal>. 
                Les typedefs permettent d'assigner un nom à votre type propre et peuvent aussi contenir une liste de 
                valeurs de paramètres par défaut si ce type est paramétré.
            </para>
            <programlisting><![CDATA[<typedef class="com.mycompany.usertypes.DefaultValueIntegerType" name="default_zero">
    <param name="default">0</param>
</typedef>]]></programlisting>
            <programlisting><![CDATA[<property name="priority" type="default_zero"/>]]></programlisting>
            <para>
                Il est aussi possible de redéfinir les paramètres par défaut du typedef au cas par cas en 
                utilisant des paramètres type sur le mapping de la propriété. 
            </para>
            <para>
                Bien que le fait que Hibernate propose de base une riche variété de types, et qu'il supporte les composants 
                signifie que vous aurez très rarement <emphasis>besoin</emphasis> d'utiliser un nouveau type propre, 
                il est néanmoins de bonne pratique d'utiliser des types propres pour les classes (non entités) qui 
                apparaissent fréquemment dans votre application. Par exemple une classe <literal>MonetaryAmount</literal> 
                est un bon candidat pour un <literal>CompositeUserType</literal> même s'il pourrait facilement 
                être mappé comme un composant. Une motivation pour cela est l'abstraction. Avec un type propre 
                vos documents de mapping sont à l'abri des changements futurs dans votre façon de représenter des 
                valeurs monétaires.
            </para>
        </sect2>
    </sect1>
    
        <sect1 id="mapping-entityname">
        <title>Mapper une classe plus d'une fois</title>
        <para>
            Il est possible de proposer plus d'un mapping par classe persistante. Dans ce cas, vous
            devez spécifier un <emphasis>nom d'entité</emphasis> pour lever l'ambiguité entre les instances
            des entités mappées (par défaut, le nom de l'entité est celui de la classe). Hibernate
            vous permet de spécifier le nom de l'entité lorsque vous utilisez des objets persistants, lorsque
            vous écrivez des requêtes ou quand vous mappez des associations vers les entités nommées.
        </para>
        
        <programlisting><![CDATA[<class name="Contract" table="Contracts" 
        entity-name="CurrentContract">
    ...
    <set name="history" inverse="true" 
            order-by="effectiveEndDate desc">
        <key column="currentContractId"/>
        <one-to-many entity-name="HistoricalContract"/>
    </set>
</class>

<class name="Contract" table="ContractHistory" 
        entity-name="HistoricalContract">
    ...
    <many-to-one name="currentContract" 
            column="currentContractId" 
            entity-name="CurrentContract"/>
</class>]]></programlisting>

        <para>
            Remarquez comment les associations sont désormais spécifiées en utilisant
            <literal>entity-name</literal> au lieu de <literal>class</literal>.
        </para>

    </sect1>
    
    <sect1 id="mapping-quotedidentifiers">
        <title>SQL quoted identifiers</title>
        <para>
            Vous pouvez forcer Hibernate à mettre un identifiant entre quotes dans le SQL généré en mettant le nom 
            de la table ou de la colonne entre backticks dans le 
            document de mapping. Hibernate utilisera les bons styles de quotes pour le <literal>Dialect</literal> SQL 
            (habituellement des doubles quotes, mais des parenthèses pour SQL server et des backticks pour MySQL).
        </para>
        <programlisting><![CDATA[<class name="LineItem" table="`Line Item`">
    <id name="id" column="`Item Id`"/><generator class="assigned"/></id>
    <property name="itemNumber" column="`Item #`"/>
    ...
</class>]]></programlisting>
    </sect1>
    <sect1 id="mapping-alternatives">
        <title>alternatives Metadata</title>
        <para>
            XML ne convient pas à tout le monde, il y a donc des moyens alternatifs pour définir des metatda 
            de mappings O/R dans Hibernate.
        </para>
        <sect2 id="mapping-xdoclet">
            <title>utilisation de XDoclet</title>
            <para>
                De nombreux utilisateurs de Hibernate préfèrent embarquer les informations de mappings 
                directement au sein du code source en utilisant les tags XDoclet <literal>@hibernate.tags</literal>. 
                Nous ne couvrons pas cette approche dans ce document cependant, puisque c'est considéré comme faisant partie 
                de XDoclet. Cependant, nous présentons l'exemple suivant de la classe <literal>Cat</literal> avec 
                des mappings XDoclet.
        </para>
            <programlisting><![CDATA[package eg;
import java.util.Set;
import java.util.Date;

/**
 * @hibernate.class
 *  table="CATS"
 */
public class Cat {
    private Long id; // identifier
    private Date birthdate;
    private Cat mother;
    private Set kittens
    private Color color;
    private char sex;
    private float weight;

    /*
     * @hibernate.id
     *  generator-class="native"
     *  column="CAT_ID"
     */
    public Long getId() {
        return id;
    }
    private void setId(Long id) {
        this.id=id;
    }

    /**
     * @hibernate.many-to-one
     *  column="PARENT_ID"
     */
    public Cat getMother() {
        return mother;
    }
    void setMother(Cat mother) {
        this.mother = mother;
    }

    /**
     * @hibernate.property
     *  column="BIRTH_DATE"
     */
    public Date getBirthdate() {
        return birthdate;
    }
    void setBirthdate(Date date) {
        birthdate = date;
    }
    /**
     * @hibernate.property
     *  column="WEIGHT"
     */
    public float getWeight() {
        return weight;
    }
    void setWeight(float weight) {
        this.weight = weight;
    }

    /**
     * @hibernate.property
     *  column="COLOR"
     *  not-null="true"
     */
    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }
    /**
     * @hibernate.set
     *  inverse="true"
     *  order-by="BIRTH_DATE"
     * @hibernate.collection-key
     *  column="PARENT_ID"
     * @hibernate.collection-one-to-many
     */
    public Set getKittens() {
        return kittens;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    // addKitten not needed by Hibernate
    public void addKitten(Cat kitten) {
        kittens.add(kitten);
    }

    /**
     * @hibernate.property
     *  column="SEX"
     *  not-null="true"
     *  update="false"
     */
    public char getSex() {
        return sex;
    }
    void setSex(char sex) {
        this.sex=sex;
    }
}]]></programlisting>
            <para>
            Voyez le site web de Hibernate pour plus d'exemples sur XDoclet et Hibernate.
        </para>
        </sect2>
        <sect2 id="mapping-annotations" revision="2">
            <title>Utilisation des annotations JDK 5.0</title>
            <para>
                Le JDK 5.0 introduit des annotations proches de celles de XDoclet au niveau java, qui sont 
                type-safe et vérifiées à la compilation. Ce mécanisme est plus puissant que XDoclet et mieux 
                supporté par les outils et IDE. IntelliJ IDEA, par exemple, supporte l'auto-complétion et le 
                surlignement syntaxique des annotations JDK 5.0. La nouvelle révision des spécifications des EJB 
                (JSR-220) utilise les annotations JDK 5.0 comme mécanisme primaire pour les meta-données des beans entités. 
                Hibernate3 implémente l'<literal>EntityManager</literal> de la JSR-220 (API de persistance), 
                le support du mapping de meta-données est disponible via le package <emphasis>Hibernate Annotations</emphasis>, 
                en tant que module séparé à télécharger. EJB3 (JSR-220) et les métadata Hibernate3 sont supportés.
             </para>
            <para>
                Ceci est un exemple d'une classe POJO annotée comme un EJB entité :
            </para>
            <programlisting><![CDATA[@Entity(access = AccessType.FIELD)
public class Customer implements Serializable {

    @Id;
    Long id;

    String firstName;
    String lastName;
    Date birthday;

    @Transient
    Integer age;

    @Embedded
    private Address homeAddress;

    @OneToMany(cascade=CascadeType.ALL)
    @JoinColumn(name="CUSTOMER_ID")
    Set<Order> orders;

    // Getter/setter and business methods
}]]></programlisting>
            <para>
                Notez que le support des annotations JDK 5.0 (et de la JSR-220) est encore en cours et n'est pas terminé.
                Référez vous au module Hibernate Annotation pour plus de détails.
            </para>
        </sect2>
    </sect1>
    
    <sect1 id="mapping-generated" revision="1">
        <title>Propriétés générées</title>
        <para>
            Les propriétés générées sont des propriétés dont les valeurs sont générées par
            la base de données. Typiquement, les applications Hibernate avaient besoin d'invoquer
            <literal>refresh</literal> sur les instances qui contenaient des propriétés pour lesquelles
            la base de données générait des valeurs. Marquer les propriétés comme générées permet à
            l'application de déléguer cette responsabilité à Hibernate. Principalement, à chaque fois
            qu'Hibernate réalise une insertion ou une mise à jour en base de données pour une entité
            marquée comme telle, cela provoque immédiatement un select pour récupérer les valeurs générées.
        </para>
        <para>
            Les propriétés marquées comme générées doivent de plus ne pas être insérables et modifiables 
            Seuls <xref linkend="mapping-declaration-version">versions</xref>,
            <xref linkend="mapping-declaration-timestamp">timestamps</xref>, et
            <xref linkend="mapping-declaration-property">simple properties</xref> peuvent être marqués comme
            générées.
        </para>
        <para>
            <literal>never</literal> (par défaut) - indique la valeur de la propriété n'est pas générée
            dans la base de données.
        </para>
        <para>
            <literal>insert</literal> - indique que la valeur de la propriété donnée est
            générée à l'insertion mais pas lors des futures mises à jour de l'enregistrement.
            Les colonnes de type "date de création" sont le cas d'utilisation typique de cette option.
            Notez que même les propriétés <xref linkend="mapping-declaration-version">version</xref> et
            <xref linkend="mapping-declaration-timestamp">timestamp</xref> peuvent être
            déclarées comme générées, cette option n'est pas disponible à cet endroit...
        </para>
        <para>
            <literal>always</literal> - indique que la valeur de la propriété est générée à l'insert 
            comme aux updates.
        </para>
        
    </sect1>

    <sect1 id="mapping-database-object">
        <title>Objets auxiliaires de la base de données</title>
        <para>
            Permettent les ordres CREATE et DROP d'objets arbitraire de la base de donnéées, en conjonction avec
            les outils Hibernate d'évolutions de schéma, pour permettre de définir complètement
            un schéma utilisateur au sein des fichiers de mapping Hibernate. Bien que conçu spécifiquement
            pour créer et supprimer des objets tels que des triggers et des procédures stockées,
            ou toute commande pouvant être exécutée via une méthode de <literal>java.sql.Statement.execute()</literal>
            (ALTERs, INSERTS, etc). Il y a principalement deux modes pour définir les objets auxiliaires de base de données...
        </para>
        <para>
            Le premier mode est de lister explicitement les commandes CREATE et DROP dans le fichier
            de mapping:
        </para>
        <programlisting><![CDATA[<hibernate-mapping>
    ...
    <database-object>
        <create>CREATE TRIGGER my_trigger ...</create>
        <drop>DROP TRIGGER my_trigger</drop>
    </database-object>
</hibernate-mapping>]]></programlisting>
        <para>
            Le second mode est de fournir une classe particulière qui connait comment construire
            les commandes CREATE et DROP. Cette classe particulière doit implémenter l'interface
            <literal>org.hibernate.mapping.AuxiliaryDatabaseObject</literal>.
        </para>
        <programlisting><![CDATA[<hibernate-mapping>
    ...
    <database-object>
        <definition class="MyTriggerDefinition"/>
    </database-object>
</hibernate-mapping>]]></programlisting>
        <para>
            Additionnellement, ces objets de base de données peuvent être optionnellement traités
            selon l'utilisation de dialectes particuliers..
        </para>
        <programlisting><![CDATA[<hibernate-mapping>
    ...
    <database-object>
        <definition class="MyTriggerDefinition"/>
        <dialect-scope name="org.hibernate.dialect.Oracle9Dialect"/>
        <dialect-scope name="org.hibernate.dialect.OracleDialect"/>
    </database-object>
</hibernate-mapping>]]></programlisting>
    </sect1>
</chapter>
