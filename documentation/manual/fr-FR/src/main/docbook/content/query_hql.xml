<?xml version="1.0" encoding="iso-8859-1"?>
<chapter id="queryhql">
    <title>HQL: Langage de requêtage d'Hibernate</title>

    <para>
        Hibernate fourni un langage d'interrogation extrêmement puissant qui
        ressemble (et c'est voulu) au SQL. Mais ne soyez pas distraits par la syntaxe ;
        HQL est totalement orienté objet, comprenant des notions d'héritage, de
        polymorphisme et d'association.
    </para>

    <sect1 id="queryhql-casesensitivity">
        <title>Sensibilité à la casse</title>

        <para>
            Les requêtes sont insensibles à la casse, à l'exception des noms des classes Java
            et des propriétés.
            Ainsi, <literal>SeLeCT</literal> est identique à
            <literal>sELEct</literal> et à
            <literal>SELECT</literal> mais
            <literal>net.sf.hibernate.eg.FOO</literal> n'est pas identique
            <literal>net.sf.hibernate.eg.Foo</literal> et
            <literal>foo.barSet</literal> n'est pas identique à
            <literal>foo.BARSET</literal>.
        </para>

        <para>
            Ce guide utilise les mots clés HQL en minuscule. Certains utilisateurs trouvent les
            requêtes écrites avec les mots clés en majuscule plus lisibles, mais nous trouvons
            cette convention pénible lorsqu'elle est lue dans du code Java.
        </para>

    </sect1>

    <sect1 id="queryhql-from">
        <title>La clause from</title>

        <para>
            La requête Hibernate la plus simple est de la forme :
        </para>

        <programlisting><![CDATA[from eg.Cat]]></programlisting>

        <para>
            qui retourne simplement toutes les instances de la classe <literal>eg.Cat</literal>. 
            Nous n'avons pas besoin d'habitude de qualifier le nom de la classe, 
            puisque <literal>auto-import</literal> est la valeur par défaut. Donc nous écrivons presque toujours :
        </para>

        <programlisting><![CDATA[from Cat]]></programlisting>

        <para>
            La plupart du temps, vous devrez assigner un <emphasis>alias</emphasis> puisque vous
            voudrez faire référence à <literal>Cat</literal> dans d'autres parties de la requête.
        </para>

        <programlisting><![CDATA[from Cat as cat]]></programlisting>

        <para>
            Cette requête assigne l'alias <literal>cat</literal> à l'instance <literal>Cat</literal>,
            nous pouvons donc utiliser cet alias ailleurs dans la requête. Le mot clé <literal>as</literal>
            est optionnel ; nous aurions pu écrire :
        </para>

        <programlisting><![CDATA[from Cat cat]]></programlisting>

        <para>
            Plusieurs classes peuvent apparaître, ce qui conduira à un produit
            cartésien (encore appelé jointures croisées).
        </para>

        <programlisting><![CDATA[from Formula, Parameter]]></programlisting>
        <programlisting><![CDATA[from Formula as form, Parameter as param]]></programlisting>

        <para>
            C'est une bonne pratique que de nommer les alias dans les requêtes en utilisant l'initiale
            en miniscule, ce qui a le mérite d'être en phase avec les standards de
            nommage Java pour les variables locales (<literal>domesticCat</literal>).
        </para>

    </sect1>

    <sect1 id="queryhql-joins" revision="1">
        <title>Associations et jointures</title>

        <para>
            On peut aussi assigner des alias à des entités associées, ou même aux éléments d'une collection
            de valeurs, en utilisant un <literal>join</literal> (jointure).
        </para>

        <programlisting><![CDATA[from Cat as cat
    inner join cat.mate as mate
    left outer join cat.kittens as kitten]]></programlisting>

        <programlisting><![CDATA[from Cat as cat left join cat.mate.kittens as kittens]]></programlisting>

        <programlisting><![CDATA[from Formula form full join form.parameter param]]></programlisting>

        <para>
            Les types de jointures supportées sont celles de ANSI SQL
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    <literal>inner join</literal> (jointure fermée)
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>left outer join</literal> (jointure ouverte par la gauche)
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>right outer join</literal> (jointure ouverte par la droite)
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>full join</literal> (jointure ouverte totalement - généralement inutile)
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Les constructions des jointures <literal>inner join</literal>, <literal>left outer join</literal>
            et <literal>right outer join</literal> peuvent être abbrégées.
        </para>

        <programlisting><![CDATA[from Cat as cat
    join cat.mate as mate
    left join cat.kittens as kitten]]></programlisting>

        <para>
            Nous pouvons soumettre des conditions de jointure supplémentaires en utilisant le mot-clef HQL <literal>with</literal>.
        </para>

        <programlisting><![CDATA[from Cat as cat
    left join cat.kittens as kitten
        with kitten.bodyWeight > 10.0]]></programlisting>

        <para>
            Par ailleurs, une jointure "fetchée" (rapportée) permet d'initialiser
            les associations ou collections de valeurs en même temps que leur objet parent,
            le tout n'utilisant qu'un seul Select.
            Ceci est particulièrement utile dans le cas des collections. Ce système permet de surcharger
            les déclarations "lazy" et "outer-join" des fichiers de mapping pour les associations et
            collections. Voir
            <xref linkend="performance-fetching"/> pour plus d'informations.
        </para>

        <programlisting><![CDATA[from Cat as cat
    inner join fetch cat.mate
    left join fetch cat.kittens]]></programlisting>

        <para>
            Une jointure "fetchée" (rapportée) n'a généralement pas besoin de se voir assigner
            un alias puisque les objets associés n'ont pas à être utilisés dans les autres clauses.
            Notez aussi que les objets associés ne sont pas retournés directement dans le résultat de
            la requête mais l'on peut y accéder via l'objet parent. La seule raison pour laquelle nous 
            pourrions avoir besoin d'un alias est si nous récupérions récursivement une collection supplémentaire :
        </para>

        <programlisting><![CDATA[from Cat as cat
    inner join fetch cat.mate
    left join fetch cat.kittens child
    left join fetch child.kittens]]></programlisting>

        <para>
            Notez que la construction de <literal>fetch</literal> ne peut pas être utilisée dans les requêtes appelées par
            <literal>scroll()</literal> ou <literal>iterate()</literal>.
            <literal>fetch</literal> ne devrait pas non plus être utilisé avec <literal>setMaxResults()</literal> ou
            <literal>setFirstResult()</literal>. <literal>fetch</literal> ne peut pas non plus être utilisé avec une 
            condition <literal>with</literal> ad hoc. Il est
            possible de créer un produit cartésien par jointure en récupérant plus d'une collection dans une requête, 
            donc faites attention dans ce cas. Récupérer par jointure de multiples collections donne aussi parfois 
            des résultats inattendus pour des mappings de bag, donc soyez prudent lorsque vous formulez vos requêtes dans de tels cas.
            Finalement, notez que <literal>full join fetch</literal> et <literal>right join fetch</literal> ne sont pas utiles en général.
        </para>

        <para>
            Si vous utilisez un chargement retardé pour les propriétés (avec une instrumentation par bytecode), il est possible 
            de forcer Hibernate à récupérer les propriétés non encore chargées immédiatement (dans la première requête) 
            en utilisant <literal>fetch all properties</literal>.
        </para>

        <programlisting><![CDATA[from Document fetch all properties order by name]]></programlisting>
        <programlisting><![CDATA[from Document doc fetch all properties where lower(doc.name) like '%cats%']]></programlisting>

    </sect1>
    
        <sect1 id="queryhql-joins-forms">
        <title>Formes de syntaxes pour les jointures</title>

        <para>
            HQL supporte deux formes pour joindre les associations: <literal>implicite</literal> et <literal>explicite</literal>.
        </para>

        <para>
            Les requêtes présentes dans la section précédente utilisent la forme <literal>explicite</literal> 
            où le mode clé join est explicitement utilisé dans la clause from. C'est la forme recommandée.
        </para>

        <para>
            La forme <literal>implicite</literal> n'utilise pas le mot clé join.
            A la place, les associations sont "déréférencées" en utilisant le notation '.'. Ces
            jointures peuvent apparaitre dans toutes les clauses. Les jointures <literal>implicites</literal> 
            résultent en des inner join dans le SQL généré.
        </para>

        <programlisting><![CDATA[from Cat as cat where cat.mate.name like '%s%']]></programlisting>
    </sect1>

    <sect1 id="queryhql-select">
        <title>La clause select</title>

        <para>
            La clause <literal>select</literal> sélectionne les objets et propriétés
            qui doivent être retournés dans le résultat de la requête.
        Soit :
        </para>

        <programlisting><![CDATA[select mate
from Cat as cat
    inner join cat.mate as mate]]></programlisting>

        <para>
            La requête recherchera les <literal>mate</literal>s liés aux <literal>Cat</literal>s.
            Vous pouvez explimer la requête d'une manière plus compacte :
        </para>

        <programlisting><![CDATA[select cat.mate from Cat cat]]></programlisting>

        <para>
            Les requêtes peuvent retourner des propriétés de n'importe quel type, même celles de type
        composant (component) :
        </para>

        <programlisting><![CDATA[select cat.name from DomesticCat cat
where cat.name like 'fri%']]></programlisting>

        <programlisting><![CDATA[select cust.name.firstName from Customer as cust]]></programlisting>

        <para>
            Les requêtes peuvent retourner plusieurs objets et/ou propriétés sous la forme
        d'un tableau du type <literal>Object[]</literal>,
        </para>

        <programlisting><![CDATA[select mother, offspr, mate.name
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr]]></programlisting>

        <para>
            ou sous la forme d'une <literal>List</literal>,
        </para>

        <programlisting><![CDATA[select new list(mother, offspr, mate.name)
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr]]></programlisting>

        <para>
            ou sous la forme d'un objet Java typé,
        </para>

        <programlisting><![CDATA[select new Family(mother, mate, offspr)
from DomesticCat as mother
    join mother.mate as mate
    left join mother.kittens as offspr]]></programlisting>

        <para>
            à condition que la classe <literal>Family</literal> possède le constructeur approprié.
        </para>

        <para>
            Vous pouvez assigner des alias aux expressions sélectionnées en utilisant <literal>as</literal> :
        </para>

        <programlisting><![CDATA[select max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n
from Cat cat]]></programlisting>

        <para>
            C'est surtout utile lorsque c'est utilisé avec
            <literal>select new map</literal> :
        </para>

        <programlisting><![CDATA[select new map( max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n )
from Cat cat]]></programlisting>

        <para>
            Cette requête retourne une <literal>Map</literal> à partir des alias vers les valeurs sélectionnées.
        </para>

    </sect1>

    <sect1 id="queryhql-aggregation">
        <title>Fonctions d'aggrégation</title>

        <para>
            Les requêtes HQL peuvent aussi retourner le résultat de fonctions d'aggrégation
            sur les propriétés :
        </para>

        <programlisting><![CDATA[select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat)
from Cat cat]]></programlisting>

<!-- NO LONGER SUPPORTED
        <para>
            Collections may also appear inside aggregate functions in the <literal>select</literal>
            clause.
        </para>

        <programlisting><![CDATA[select cat, count( elements(cat.kittens) )
from Cat cat group by cat]]></programlisting>
-->

        <para>
            Les fonctions supportées sont
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    <literal>avg(...), sum(...), min(...), max(...)</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>count(*)</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>count(...), count(distinct ...), count(all...)</literal>
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Vous pouvez utiliser des opérateurs arithmétiques, la concaténation, et des fonctions SQL reconnues dans la clause select :
        </para>

        <programlisting><![CDATA[select cat.weight + sum(kitten.weight)
from Cat cat
    join cat.kittens kitten
group by cat.id, cat.weight]]></programlisting>

        <programlisting><![CDATA[select firstName||' '||initial||' '||upper(lastName) from Person]]></programlisting>

        <para>
            Les mots clé <literal>distinct</literal> et <literal>all</literal> peuvent être utilisés et ont
        la même signification qu'en SQL.
        </para>

        <programlisting><![CDATA[select distinct cat.name from Cat cat

select count(distinct cat.name), count(cat) from Cat cat]]></programlisting>

    </sect1>

    <sect1 id="queryhql-polymorphism">
        <title>Requêtes polymorphiques</title>

        <para>
            Une requête comme:
        </para>

        <programlisting><![CDATA[from Cat as cat]]></programlisting>

        <para>
            retourne non seuleument les instances de <literal>Cat</literal>, mais aussi celles des
            sous classes comme <literal>DomesticCat</literal>. Les requêtes Hibernate peuvent nommer n'importe
            quelle classe ou interface Java dans la clause <literal>from</literal>. La requête retournera les
            instances de toutes les classes persistantes qui étendent cette classe ou implémente cette interface.
        La requête suivante retournera tous les objets persistants :
        </para>

        <programlisting><![CDATA[from java.lang.Object o]]></programlisting>

        <para>
            L'interface <literal>Named</literal> peut être implémentée par plusieurs classes persistantes :
        </para>

        <programlisting><![CDATA[from Named n, Named m where n.name = m.name]]></programlisting>

        <para>
            Notez que ces deux dernières requêtes nécessitent plus d'un <literal>SELECT</literal> SQL.
            Ce qui signifie que la clause <literal>order by</literal> ne trie pas correctement la totalité
            des résultats (cela signifie aussi que vous ne pouvez exécuter ces requêtes en appelant
        <literal>Query.scroll()</literal>).
        </para>

    </sect1>

    <sect1 id="queryhql-where">
        <title>La clause where</title>

        <para>
            La clause <literal>where</literal> vous permet de réduire la liste des instances retournées. 
            Si aucun alias n'existe, vous pouvez vous référer aux propriétés par leur nom :
        </para>

        <programlisting><![CDATA[from Cat where name='Fritz']]></programlisting>

        <para>
            S'il y a un alias, utilisez un nom de propriété qualifié :
        </para>

        <programlisting><![CDATA[from Cat as cat where cat.name='Fritz']]></programlisting>

        <para>
            retourne les instances de <literal>Cat</literal> dont name est égale à 'Fritz'.
        </para>

        <programlisting><![CDATA[select foo
from Foo foo, Bar bar
where foo.startDate = bar.date]]></programlisting>

        <para>
            retournera les instances de <literal>Foo</literal> pour lesquelles
            il existe une instance de <literal>bar</literal> avec la
            propriété <literal>date</literal> est égale à la
            propriété <literal>startDate</literal> de <literal>Foo</literal>.
            Les expressions utilisant la navigation rendent la clause <literal>where</literal>
        extrêmement puissante. Soit :
        </para>

        <programlisting><![CDATA[from Cat cat where cat.mate.name is not null]]></programlisting>

        <para>
            Cette requête se traduit en SQL par une jointure interne à une table.
        Si vous souhaitez écrire quelque chose comme :
        </para>

        <programlisting><![CDATA[from Foo foo
where foo.bar.baz.customer.address.city is not null]]></programlisting>

        <para>
            vous finiriez avec une requête qui nécessiterait quatre jointures en SQL.
        </para>

        <para>
            L'opérateur <literal>=</literal> peut être utilisé pour comparer aussi bien des propriétés que des instances :
        </para>

        <programlisting><![CDATA[from Cat cat, Cat rival where cat.mate = rival.mate]]></programlisting>

        <programlisting><![CDATA[select cat, mate
from Cat cat, Cat mate
where cat.mate = mate]]></programlisting>

        <para>
            La propriété spéciale (en minuscule) <literal>id</literal> peut être utilisée
            pour faire référence à l'identifiant d'un objet (vous pouvez aussi utiliser
        le nom de cette propriété).
        </para>

        <programlisting><![CDATA[from Cat as cat where cat.id = 123

from Cat as cat where cat.mate.id = 69]]></programlisting>

        <para>
            La seconde requête est particulièrement efficace. Aucune jointure n'est nécessaire !
        </para>

        <para>
            Les propriétés d'un identifiant composé peuvent aussi être utilisées. Supposez que
            <literal>Person</literal> ait un identifiant composé de <literal>country</literal> et
            <literal>medicareNumber</literal>.
        </para>

        <programlisting><![CDATA[from bank.Person person
where person.id.country = 'AU'
    and person.id.medicareNumber = 123456]]></programlisting>

        <programlisting><![CDATA[from bank.Account account
where account.owner.id.country = 'AU'
    and account.owner.id.medicareNumber = 123456]]></programlisting>

        <para>
            Une fois de plus, la seconde requête ne nécessite pas de jointure.
        </para>

        <para>
            De même, la propriété spéciale <literal>class</literal> interroge la valeur discriminante
            d'une instance dans le cas d'une persistance polymorphique. Le nom d'une classe Java incorporée
        dans la clause where sera traduite par sa valeur discriminante.
        </para>

        <programlisting><![CDATA[from Cat cat where cat.class = DomesticCat]]></programlisting>

        <para>
            Vous pouvez aussi spécifier les propriétés des composants ou types utilisateurs composés
            (components, composite user types etc). N'essayez jamais d'utiliser un expression de navigation
            qui se terminerait par une propriété de type composant (qui est différent d'une propriété d'un
            composant). Par exemple, si <literal>store.owner</literal> est une entité avec un composant
        <literal>address</literal>
        </para>

        <programlisting><![CDATA[store.owner.address.city    // okay
store.owner.address         // error!]]></programlisting>

        <para>
            Un type "any" possède les propriétés spéciales <literal>id</literal> et <literal>class</literal>,
            qui nous permettent d'exprimer une jointure de la manière suivante (où <literal>AuditLog.item</literal>
            est une propriété mappée avec <literal>&lt;any&gt;</literal>).
        </para>

        <programlisting><![CDATA[from AuditLog log, Payment payment
where log.item.class = 'Payment' and log.item.id = payment.id]]></programlisting>

        <para>
            Dans la requête précédente, notez que <literal>log.item.class</literal> et <literal>payment.class</literal>
            feraient référence à des valeurs de colonnes de la base de données complètement différentes.
        </para>

    </sect1>

    <sect1 id="queryhql-expressions">
        <title>Expressions</title>

        <para>
            Les expressions permises dans la clause <literal>where</literal> incluent
        la plupart des choses que vous pouvez utiliser en SQL :
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    opérateurs mathématiques <literal>+, -, *, /</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    opérateur de comparaison binaire <literal>=, &gt;=, &lt;=, &lt;&gt;, !=, like</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    opérateurs logiques <literal>and, or, not</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    Parenthèses <literal>( )</literal>, indiquant un regroupement
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>in</literal>,
                    <literal>not in</literal>,
                    <literal>between</literal>,
                    <literal>is null</literal>,
                    <literal>is not null</literal>,
                    <literal>is empty</literal>,
                    <literal>is not empty</literal>,
                    <literal>member of</literal> and
                    <literal>not member of</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    "Simple" case, <literal>case ... when ... then ... else ... end</literal>, and
                    "searched" case, <literal>case when ... then ... else ... end</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    concatenation de chaîne de caractères <literal>...||...</literal> ou <literal>concat(...,...)</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>current_date()</literal>, <literal>current_time()</literal>,
                    <literal>current_timestamp()</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>second(...)</literal>, <literal>minute(...)</literal>,
                    <literal>hour(...)</literal>, <literal>day(...)</literal>,
                    <literal>month(...)</literal>, <literal>year(...)</literal>,
                </para>
            </listitem>
            <listitem>
                <para>
                    N'importe quel fonction ou opérateur défini par EJB-QL 3.0 : <literal>substring(), trim(),
                    lower(), upper(), length(), locate(), abs(), sqrt(), bit_length(), mod()</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>coalesce()</literal> et <literal>nullif()</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>str()</literal> pour convertir des valeurs numériques ou temporelles vers une chaîne de caractères lisible
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>cast(... as ...)</literal>, où le second argument est le nom d'un type Hibernate, et <literal>extract(... from ...)</literal> si le
                    <literal>cast()</literal> ANSI et <literal>extract()</literal> sont supportés par la base de données sous-jacente
                </para>
            </listitem>
            <listitem>
                <para>
                    La fonction HQL <literal>index()</literal>, qui s'applique aux alias d'une collection indexée jointe
                </para>
            </listitem>
            <listitem>
                <para>
                    Les fonctions HQL qui s'appliquent expressions représentant des collections : <literal>size(),
                    minelement(), maxelement(), minindex(), maxindex()</literal>, ainsi que les fonctions spéciales <literal>elements()</literal> 
                    et <literal>indices</literal> qui peuvent être quantifiées en utilisant <literal>some, all, exists, any, in</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    N'importe quelle fonction scalaire supportée par la base de données comme
                    <literal>sign()</literal>,
                    <literal>trunc()</literal>, <literal>rtrim()</literal>, <literal>sin()</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    Les paramètres positionnels de JDBC
                    <literal>?</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    paramètres nommés <literal>:name</literal>, <literal>:start_date</literal>, <literal>:x1</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    littéral SQL <literal>'foo'</literal>, <literal>69</literal>, <literal>'1970-01-01 10:00:01.0'</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    Constantes Java <literal>public static final</literal> <literal>eg.Color.TABBY</literal>
                </para>
            </listitem>
        </itemizedlist>

        <para>
            <literal>in</literal> et <literal>between</literal> peuvent être utilisés comme suit :
        </para>

        <programlisting><![CDATA[from DomesticCat cat where cat.name between 'A' and 'B']]></programlisting>

        <programlisting><![CDATA[from DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )]]></programlisting>

        <para>
            et la forme négative peut être écrite
        </para>

        <programlisting><![CDATA[from DomesticCat cat where cat.name not between 'A' and 'B']]></programlisting>

        <programlisting><![CDATA[from DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )]]></programlisting>

        <para>
            De même, <literal>is null</literal> et <literal>is not null</literal> peuvent être utilisés pour tester
        les valeurs nulle.
        </para>

        <para>
            Les booléens peuvent être facilement utilisés en déclarant les substitutions de requêtes dans la
        configuration Hibernate :
        </para>

        <programlisting><![CDATA[<property name="hibernate.query.substitutions">true 1, false 0</property>]]></programlisting>

        <para>
            Ce qui remplacera les mots clés <literal>true</literal> et <literal>false</literal> par
            <literal>1</literal> et <literal>0</literal> dans la traduction SQL du HQL suivant :
        </para>

        <programlisting><![CDATA[from Cat cat where cat.alive = true]]></programlisting>

        <para>
            Vous pouvez tester la taille d'une collection par la propriété spéciale <literal>size</literal>, ou
            la fonction spéciale <literal>size()</literal>.
        </para>

        <programlisting><![CDATA[from Cat cat where cat.kittens.size > 0]]></programlisting>

        <programlisting><![CDATA[from Cat cat where size(cat.kittens) > 0]]></programlisting>

        <para>
            Pour les collections indexées, vous pouvez faire référence aux indices minimum et maximum en
            utilisant les fonctions <literal>minindex</literal> and <literal>maxindex</literal>. De manière similaire,
            vous pouvez faire référence aux éléments minimum et maximum d'une collection de type basiques
        en utilisant les fonctions <literal>minelement</literal> et <literal>maxelement</literal>.
        </para>

        <programlisting><![CDATA[from Calendar cal where maxelement(cal.holidays) > current date]]></programlisting>

        <programlisting><![CDATA[from Order order where maxindex(order.items) > 100]]></programlisting>

        <programlisting><![CDATA[from Order order where minelement(order.items) > 10000]]></programlisting>

        <para>
            Les fonctions SQL <literal>any, some, all, exists, in</literal> supportent que leur soient passées
            l'élément, l'index d'une collection (fonctions <literal>elements</literal> et <literal>indices</literal>)
        ou le résultat d'une sous requête (voir ci dessous).
        </para>

        <programlisting><![CDATA[select mother from Cat as mother, Cat as kit
where kit in elements(foo.kittens)]]></programlisting>

        <programlisting><![CDATA[select p from NameList list, Person p
where p.name = some elements(list.names)]]></programlisting>

        <programlisting><![CDATA[from Cat cat where exists elements(cat.kittens)]]></programlisting>

        <programlisting><![CDATA[from Player p where 3 > all elements(p.scores)]]></programlisting>

        <programlisting><![CDATA[from Show show where 'fizard' in indices(show.acts)]]></programlisting>

        <para>
            Notez que l'écriture de - <literal>size</literal>, <literal>elements</literal>,
            <literal>indices</literal>, <literal>minindex</literal>, <literal>maxindex</literal>,
            <literal>minelement</literal>, <literal>maxelement</literal> - peuvent seulement être utilisée dans la clause where dans Hibernate3.
        </para>

        <para>
            Les éléments de collections indexées (arrays, lists, maps) peuvent être référencés via index
        (dans une clause where seulement) :
        </para>

        <programlisting><![CDATA[from Order order where order.items[0].id = 1234]]></programlisting>

        <programlisting><![CDATA[select person from Person person, Calendar calendar
where calendar.holidays['national day'] = person.birthDay
    and person.nationality.calendar = calendar]]></programlisting>

        <programlisting><![CDATA[select item from Item item, Order order
where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11]]></programlisting>

        <programlisting><![CDATA[select item from Item item, Order order
where order.items[ maxindex(order.items) ] = item and order.id = 11]]></programlisting>

        <para>
            L'expression entre <literal>[]</literal> peut même être une expression arithmétique.
        </para>

        <programlisting><![CDATA[select item from Item item, Order order
where order.items[ size(order.items) - 1 ] = item]]></programlisting>

        <para>
            HQL propose aussi une fonction <literal>index()</literal> interne, pour les éléments
        d'une association one-to-many ou d'une collections de valeurs.
        </para>

        <programlisting><![CDATA[select item, index(item) from Order order
    join order.items item
where index(item) < 5]]></programlisting>

        <para>
            Les fonctions SQL scalaires supportées par la base de données utilisée peuvent être utilisées
        </para>

        <programlisting><![CDATA[from DomesticCat cat where upper(cat.name) like 'FRI%']]></programlisting>

        <para>
            Si vous n'êtes pas encore convaincu par tout cela, imaginez la taille et l'illisibilité qui caractériseraient
        la transformation SQL de la requête HQL suivante :
        </para>

        <programlisting><![CDATA[select cust
from Product prod,
    Store store
    inner join store.customers cust
where prod.name = 'widget'
    and store.location.name in ( 'Melbourne', 'Sydney' )
    and prod = all elements(cust.currentOrder.lineItems)]]></programlisting>

        <para>
            <emphasis>Un indice :</emphasis> cela donnerait quelque chose comme
        </para>

        <programlisting><![CDATA[SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order
FROM customers cust,
    stores store,
    locations loc,
    store_customers sc,
    product prod
WHERE prod.name = 'widget'
    AND store.loc_id = loc.id
    AND loc.name IN ( 'Melbourne', 'Sydney' )
    AND sc.store_id = store.id
    AND sc.cust_id = cust.id
    AND prod.id = ALL(
        SELECT item.prod_id
        FROM line_items item, orders o
        WHERE item.order_id = o.id
            AND cust.current_order = o.id
    )]]></programlisting>

    </sect1>

    <sect1 id="queryhql-ordering">
        <title>La clause order by</title>

        <para>
            La liste retounée par la requête peut être triée par n'importe quelle propriété de la classe ou
        du composant retourné :
        </para>

        <programlisting><![CDATA[from DomesticCat cat
order by cat.name asc, cat.weight desc, cat.birthdate]]></programlisting>

        <para>
            Le mot optionnel <literal>asc</literal> ou <literal>desc</literal> indique respectivement si le tri
        doit être croissant ou décroissant.
        </para>
    </sect1>

    <sect1 id="queryhql-grouping">
        <title>La clause group by</title>

        <para>
            Si la requête retourne des valeurs aggrégées, celles ci peuvent être groupées par propriété ou composant :
        </para>

        <programlisting><![CDATA[select cat.color, sum(cat.weight), count(cat)
from Cat cat
group by cat.color]]></programlisting>

        <programlisting><![CDATA[select foo.id, avg(name), max(name)
from Foo foo join foo.names name
group by foo.id]]></programlisting>

        <para>
            Une clause <literal>having</literal> est aussi permise.
        </para>

        <programlisting><![CDATA[select cat.color, sum(cat.weight), count(cat)
from Cat cat
group by cat.color
having cat.color in (eg.Color.TABBY, eg.Color.BLACK)]]></programlisting>

        <para>
            Les fonctions SQL et les fonctions d'aggrégations sont permises dans les clauses <literal>having</literal>
            et <literal>order by</literal>, si elles sont supportées par la base de données (ce que ne fait pas MySQL par exemple).
        </para>

        <programlisting><![CDATA[select cat
from Cat cat
    join cat.kittens kitten
group by cat
having avg(kitten.weight) > 100
order by count(kitten) asc, sum(kitten.weight) desc]]></programlisting>

        <para>
            Notez que ni la clause <literal>group by</literal> ni la clause
            <literal>order by</literal> ne peuvent contenir d'expressions arithmétiques.
        </para>

    </sect1>

    <sect1 id="queryhql-subqueries" revision="2">
        <title>Sous-requêtes</title>

        <para>
            Pour les bases de données le supportant, Hibernate supporte les sous requêtes dans les requêtes.
            Une sous requête doit être entre parenthèses (souvent pour un appel à une fonction d'agrégation SQL)
            Même les sous requêtes corrélées (celles qui font référence à un alias de la requête principale) sont
        supportées.
        </para>

        <programlisting><![CDATA[from Cat as fatcat
where fatcat.weight > (
    select avg(cat.weight) from DomesticCat cat
)]]></programlisting>

        <programlisting><![CDATA[from DomesticCat as cat
where cat.name = some (
    select name.nickName from Name as name
)]]></programlisting>

        <programlisting><![CDATA[from Cat as cat
where not exists (
    from Cat as mate where mate.mate = cat
)]]></programlisting>

        <programlisting><![CDATA[from DomesticCat as cat
where cat.name not in (
    select name.nickName from Name as name
)]]></programlisting>

        <programlisting><![CDATA[select cat.id, (select max(kit.weight) from cat.kitten kit)
from Cat as cat]]></programlisting>

        <para>
            Notez que les sous-requêtes HQL peuvent arriver seulememnt dans les clauses select ou where.
        </para>

        <para>
            Pour des sous-requêtes avec plus d'une expression dans le select, vous pouvez utiliser un constructeur de tuples :
        </para>

        <programlisting><![CDATA[from Cat as cat
where not ( cat.name, cat.color ) in (
    select cat.name, cat.color from DomesticCat cat
)]]></programlisting>

        <para>
            Notez que sur certaines bases de données (mais par Oracle ou HSQL), vous pouvez utiliser des constructeurs de tuples 
            dans d'autres contextes, par exemple lors du requêtage de composants ou de types utilisateur composites :
        </para>

        <programlisting><![CDATA[from Person where name = ('Gavin', 'A', 'King')]]></programlisting>

        <para>
            Ce qui est équivalent à la forme plus verbeuse suivante :
        </para>

        <programlisting><![CDATA[from Person where name.first = 'Gavin' and name.initial = 'A' and name.last = 'King')]]></programlisting>

        <para>
            Il y a deux bonnes raisons que vous ne puissiez ne pas vouloir faire cette sorte de choses : d'abord, ce n'est
            pas complètement portable entre les plateformes de base de données ; deuxièmement, la requête est maintenant
            dépendante de l'ordre des propriétés dans le document de mapping.
        </para>

    </sect1>

    <sect1 id="queryhql-examples">
        <title>Exemples HQL</title>

        <para>
            Les requêtes Hibernate peuvent être relativement puissantes et complexes. En fait, la puissance
            du langage de requêtage est l'un des avantages principaux d'Hibernate. Voici quelques exemples
            très similaires aux requêtes que nous avons utilisées lors d'un récent projet. Notez que la plupart
        des requêtes que vous écrirez seront plus simples que les exemples suivantes !
        </para>

        <para>
            La requête suivante retourne l'id de commande (order), le nombre d'articles (items) et la valeur
            totale de la commande (order) pour toutes les commandes non payées d'un client (customer) particulier
            pour un total minimum donné, le tout trié par la valeur totale. La requête SQL générée sur les tables
            <literal>ORDER</literal>, <literal>ORDER_LINE</literal>, <literal>PRODUCT</literal>,
            <literal>CATALOG</literal> et <literal>PRICE</literal> est composée de quatre jointures interne ainsi que
        d'une sous-requête (non corrélée).
        </para>

        <programlisting><![CDATA[select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog.effectiveDate < sysdate
    and catalog.effectiveDate >= all (
        select cat.effectiveDate
        from Catalog as cat
        where cat.effectiveDate < sysdate
    )
group by order
having sum(price.amount) > :minAmount
order by sum(price.amount) desc]]></programlisting>

        <para>
            Quel monstre !
            En principe, nous ne sommes pas très fan des sous-requêtes, la requête ressemblait donc plutôt
        à cela :
        </para>

        <programlisting><![CDATA[select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog = :currentCatalog
group by order
having sum(price.amount) > :minAmount
order by sum(price.amount) desc]]></programlisting>

        <para>
            La requête suivante compte le nombre de paiements (payments) pour chaque status, en excluant
            les paiements dans le status <literal>AWAITING_APPROVAL</literal> où le changement de status
            le plus récent à été fait par l'utilisateur courant. En SQL, cette requête effectue deux
            jointures internes et des sous requêtes corrélées sur les tables <literal>PAYMENT</literal>,
        <literal>PAYMENT_STATUS</literal> et <literal>PAYMENT_STATUS_CHANGE</literal>.
        </para>

        <programlisting><![CDATA[select count(payment), status.name
from Payment as payment
    join payment.currentStatus as status
    join payment.statusChanges as statusChange
where payment.status.name <> PaymentStatus.AWAITING_APPROVAL
    or (
        statusChange.timeStamp = (
            select max(change.timeStamp)
            from PaymentStatusChange change
            where change.payment = payment
        )
        and statusChange.user <> :currentUser
    )
group by status.name, status.sortOrder
order by status.sortOrder]]></programlisting>

        <para>
            Si nous avions mappé la collection <literal>statusChanges</literal> comme une liste, au lieu d'un ensemble,
            la requête aurait été plus facile à écrire.
        </para>

        <programlisting><![CDATA[select count(payment), status.name
from Payment as payment
    join payment.currentStatus as status
where payment.status.name <> PaymentStatus.AWAITING_APPROVAL
    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user <> :currentUser
group by status.name, status.sortOrder
order by status.sortOrder]]></programlisting>

        <para>
            La requête qui suit utilise la fonction de MS SQL <literal>isNull()</literal> pour retourner
            tous les comptes (accounts) et paiements (payments) impayés pour l'organisation à laquelle
            l'uilisateur (user) courant appartient. Elle est traduite en SQL par trois jointures internes,
            une jointure externe ainsi qu'une sous requête sur les tables <literal>ACCOUNT</literal>, <literal>PAYMENT</literal>,
            <literal>PAYMENT_STATUS</literal>, <literal>ACCOUNT_TYPE</literal>, <literal>ORGANIZATION</literal> et
            <literal>ORG_USER</literal>.
        </para>

        <programlisting><![CDATA[select account, payment
from Account as account
    left outer join account.payments as payment
where :currentUser in elements(account.holder.users)
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate]]></programlisting>

        <para>
            Pour d'autres base de données, nous aurions dû faire sans la sous-requête (corrélée).
        </para>

        <programlisting><![CDATA[select account, payment
from Account as account
    join account.holder.users as user
    left outer join account.payments as payment
where :currentUser = user
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate]]></programlisting>

   </sect1>

    <sect1 id="queryhql-bulk" revision="2">
        <title>Mise à jour et suppression</title>

        <para>
            HQL supporte maintenant les expressions <literal>update</literal>, <literal>delete</literal> et
            <literal>insert ... select ...</literal>.
            Voir <xref linkend="batch-direct"/> pour les détails.
        </para>
    </sect1>

    <sect1 id="queryhql-tipstricks">
        <title>Trucs &amp; Astuces</title>

        <para>
            Vous pouvez compter le nombre de résultats d'une requête sans les retourner :
        </para>

        <programlisting><![CDATA[( (Integer) session.createQuery("select count(*) from ....").iterate().next() ).intValue()]]></programlisting>

        <para>
            Pour trier les résultats par la taille d'une collection, utilisez la requête suivante :
        </para>

        <programlisting><![CDATA[select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
order by count(msg)]]></programlisting>

        <para>
            Si votre base de données supporte les sous-requêtes, vous pouvez placer des
        conditions sur la taille de la sélection dans la clause where de votre requête:
        </para>

        <programlisting><![CDATA[from User usr where size(usr.messages) >= 1]]></programlisting>

        <para>
            Si votre base de données ne supporte pas les sous-requêtes, utilisez la requête suivante :
        </para>

        <programlisting><![CDATA[select usr.id, usr.name
from User usr.name
    join usr.messages msg
group by usr.id, usr.name
having count(msg) >= 1]]></programlisting>

        <para>
            Cette solution ne peut pas retourner un <literal>User</literal> avec zéro message
            à cause de la jointure interne, la forme suivante peut donc être utile :
        </para>

        <programlisting><![CDATA[select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
having count(msg) = 0]]></programlisting>

        <para>
            Les propriétés d'un JavaBean peuvent être injectées dans les paramètres nommés d'un requête :
        </para>

        <programlisting><![CDATA[Query q = s.createQuery("from foo Foo as foo where foo.name=:name and foo.size=:size");
q.setProperties(fooBean); // fooBean has getName() and getSize()
List foos = q.list();]]></programlisting>

        <para>
            Les collections sont paginables via l'utilisation de l'interface <literal>Query</literal> avec un filtre :
        </para>

        <programlisting><![CDATA[Query q = s.createFilter( collection, "" ); // the trivial filter
q.setMaxResults(PAGE_SIZE);
q.setFirstResult(PAGE_SIZE * pageNumber);
List page = q.list();]]></programlisting>

        <para>
            Les éléments d'une collection peuvent être triés ou groupés en utilisant un filtre de requête :
        </para>

        <programlisting><![CDATA[Collection orderedCollection = s.filter( collection, "order by this.amount" );
Collection counts = s.filter( collection, "select this.type, count(this) group by this.type" );]]></programlisting>

        <para>
            Vous pouvez récupérer la taille d'une collection sans l'initialiser :
        </para>

        <programlisting><![CDATA[( (Integer) session.createQuery("select count(*) from ....").iterate().next() ).intValue();]]></programlisting>

    </sect1>

</chapter>
