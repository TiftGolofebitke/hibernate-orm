#, fuzzy
msgid ""
msgstr ""
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Content-Type: text/plain; charset=utf-8\n"
#: index.docbook:5
msgid "Configuration"
msgstr "<title>設定</title>"

#: index.docbook:7
msgid "Because Hibernate is designed to operate in many different environments, there are a large number of configuration parameters. Fortunately, most have sensible default values and Hibernate is distributed with an example <literal>hibernate.properties</literal> file in <literal>etc/</literal> that shows the various options. Just put the example file in your classpath and customize it."
msgstr "Hibernateはさまざまな環境で動作するようにデザインされているため、非常に多くの設定要素があります。 幸いなことに、Hibernateは、公開されているパッケージの <literal>etc/</literal> フォルダの <literal>hibernate.properties</literal> に、ほとんどの設定要素の適切なデフォルト値が記述されています。 この <literal>hibernate.properties</literal> をクラスパスに設定し、設定要素をカスタマイズするだけです。"

#: index.docbook:16
msgid "Programmatic configuration"
msgstr "プログラム上の設定"

#: index.docbook:18
msgid "An instance of <literal>org.hibernate.cfg.Configuration</literal> represents an entire set of mappings of an application's Java types to an SQL database. The <literal>Configuration</literal> is used to build an (immutable) <literal>SessionFactory</literal>. The mappings are compiled from various XML mapping files."
msgstr "<literal>org.hibernate.cfg.Configuration</literal> のインスタンスは、 Javaの型とSQLデータベースのマッピング情報をすべて持っています。 The <literal>Configuration</literal> は、（不変の） <literal>SessionFactory</literal> を生成するときに使用します。 複数のXMLマッピングファイルを変換し、マッピング情報にします。"

#: index.docbook:26
msgid "You may obtain a <literal>Configuration</literal> instance by instantiating it directly and specifying XML mapping documents. If the mapping files are in the classpath, use <literal>addResource()</literal>:"
msgstr "通常、<literal>Configuration</literal> インスタンスは、特定のXMLマッピングファイル によって直接初期化されます。もし、マッピングファイルがクラスパスに設定されている場合、 次のメソッドを使ってください。 <literal>addResource()</literal> :"

#: index.docbook:32
msgid ""
      "<![CDATA[Configuration cfg = new Configuration()\n"
      "    .addResource(\"Item.hbm.xml\")\n"
      "    .addResource(\"Bid.hbm.xml\");]]>"
msgstr ""
      "<![CDATA[Configuration cfg = new Configuration()\n"
      "    .addResource(\"Item.hbm.xml\")\n"
      "    .addResource(\"Bid.hbm.xml\");]]>"

#: index.docbook:34
msgid "An alternative (sometimes better) way is to specify the mapped class, and let Hibernate find the mapping document for you:"
msgstr "代替案(こちらのほうが良いときもあります)としてマッピングクラスを指定する方法もあります。Hibernateに、マッピングファイルを 見つけさせてください："

#: index.docbook:39
msgid ""
      "<![CDATA[Configuration cfg = new Configuration()\n"
      "    .addClass(org.hibernate.auction.Item.class)\n"
      "    .addClass(org.hibernate.auction.Bid.class);]]>"
msgstr ""
      "<![CDATA[Configuration cfg = new Configuration()\n"
      "    .addClass(org.hibernate.auction.Item.class)\n"
      "    .addClass(org.hibernate.auction.Bid.class);]]>"

#: index.docbook:41
msgid "Then Hibernate will look for mapping files named <literal>/org/hibernate/auction/Item.hbm.xml</literal> and <literal>/org/hibernate/auction/Bid.hbm.xml</literal> in the classpath. This approach eliminates any hardcoded filenames."
msgstr "Hibernateは、クラスパスにある以下のような名前のマッピングファイルを見つけます。 <literal>/org/hibernate/auction/Item.hbm.xml</literal> 、 <literal>/org/hibernate/auction/Bid.hbm.xml</literal> 。 この方法だと、ハードコーディングされたファイル名を排除できます。"

#: index.docbook:48
msgid "A <literal>Configuration</literal> also allows you to specify configuration properties:"
msgstr "<literal>Configuration</literal> は、設定プロパティを指定することもできます："

#: index.docbook:53
msgid ""
      "<![CDATA[Configuration cfg = new Configuration()\n"
      "    .addClass(org.hibernate.auction.Item.class)\n"
      "    .addClass(org.hibernate.auction.Bid.class)\n"
      "    .setProperty(\"hibernate.dialect\", \"org.hibernate.dialect.MySQLInnoDBDialect\")\n"
      "    .setProperty(\"hibernate.connection.datasource\", \"java:comp/env/jdbc/test\")\n"
      "    .setProperty(\"hibernate.order_updates\", \"true\");]]>"
msgstr ""
      "<![CDATA[Configuration cfg = new Configuration()\n"
      "    .addClass(org.hibernate.auction.Item.class)\n"
      "    .addClass(org.hibernate.auction.Bid.class)\n"
      "    .setProperty(\"hibernate.dialect\", \"org.hibernate.dialect.MySQLInnoDBDialect\")\n"
      "    .setProperty(\"hibernate.connection.datasource\", \"java:comp/env/jdbc/test\")\n"
      "    .setProperty(\"hibernate.order_updates\", \"true\");]]>"

#: index.docbook:55
msgid "This is not the only way to pass configuration properties to Hibernate. The various options include:"
msgstr "Hibernateに設定プロパティを通す方法は1つではありません。 さまざまなオプションを用意しています："

#: index.docbook:62
msgid "Pass an instance of <literal>java.util.Properties</literal> to <literal>Configuration.setProperties()</literal>."
msgstr "<literal>java.util.Properties</literal> インスタンスを <literal>Configuration.setProperties()</literal> に渡します。"

#: index.docbook:68
msgid "Place <literal>hibernate.properties</literal> in a root directory of the classpath."
msgstr "<literal>hibernate.properties</literal> を クラスパスのルートディレクトリに置きます。"

#: index.docbook:74
msgid "Set <literal>System</literal> properties using <literal>java -Dproperty=value</literal>."
msgstr "<literal>System</literal> プロパティが <literal>java -Dproperty=value</literal> を使うように設定します。"

#: index.docbook:80
msgid "Include <literal>&lt;property&gt;</literal> elements in <literal>hibernate.cfg.xml</literal> (discussed later)."
msgstr "<literal>&lt;property&gt;</literal> 要素を <literal>hibernate.cfg.xml</literal> （後述）に設定します。"

#: index.docbook:87
msgid "<literal>hibernate.properties</literal> is the easiest approach if you want to get started quickly."
msgstr "今すぐ始めたいのなら、<literal>hibernate.properties</literal> を使うのが一番の近道です。"

#: index.docbook:92
msgid "The <literal>Configuration</literal> is intended as a startup-time object, to be discarded once a <literal>SessionFactory</literal> is created."
msgstr "<literal>Configuration</literal> は、起動時にだけあるオブジェクトであり、 一度 <literal>SessionFactory</literal> を生成した後は、破棄されることを意図しています。"

#: index.docbook:100
msgid "Obtaining a SessionFactory"
msgstr "SessionFactoryを取得する"

#: index.docbook:102
msgid "When all mappings have been parsed by the <literal>Configuration</literal>, the application must obtain a factory for <literal>Session</literal> instances. This factory is intended to be shared by all application threads:"
msgstr "<literal>Configuration</literal> がすべてのマッピング情報を解析したら、 アプリケーションは、 <literal>Session</literal> ファクトリインスタンスを取得します。 このSessionFactoryは、Hibernateを使用するすべてのスレッドで共有されるべきです。"

#: index.docbook:108
msgid "<![CDATA[SessionFactory sessions = cfg.buildSessionFactory();]]>"
msgstr "<![CDATA[SessionFactory sessions = cfg.buildSessionFactory();]]>"

#: index.docbook:110
msgid "Hibernate does allow your application to instantiate more than one <literal>SessionFactory</literal>. This is useful if you are using more than one database."
msgstr "Hibernateは、 <literal>SessionFactory</literal> を複数生成することができます。 これは、複数のデータベースを使用する場合に便利です。"

#: index.docbook:119
msgid "JDBC connections"
msgstr "JDBCコネクション"

#: index.docbook:121
msgid "Usually, you want to have the <literal>SessionFactory</literal> create and pool JDBC connections for you. If you take this approach, opening a <literal>Session</literal> is as simple as:"
msgstr "通常、開発者は <literal>SessionFactory</literal> を生成し、SessionFactoryでJDBCコネクションをプーリングしたいと考えます。 そのアプローチを採用する場合、単純に <literal>Session</literal> をオープンしてください："

#: index.docbook:127
msgid "<![CDATA[Session session = sessions.openSession(); // open a new Session]]>"
msgstr "<![CDATA[Session session = sessions.openSession(); // open a new Session]]>"

#: index.docbook:129
msgid "As soon as you do something that requires access to the database, a JDBC connection will be obtained from the pool."
msgstr "これだけで、プーリングしたJDBCコネクションを使って目的のデータベース にアクセスすることができます。"

#: index.docbook:134
msgid "For this to work, we need to pass some JDBC connection properties to Hibernate. All Hibernate property names and semantics are defined on the class <literal>org.hibernate.cfg.Environment</literal>. We will now describe the most important settings for JDBC connection configuration."
msgstr "そのためには、JDBCコネクションのプロパティをHibernateに設定する必要があります。 すべてのHibernateプロパティ名とセマンティクスは <literal>org.hibernate.cfg.Environment</literal> クラスに定義されています。 この設定はJDBCコネクション設定の中で一番重要なものです。"

#: index.docbook:141
msgid "Hibernate will obtain (and pool) connections using <literal>java.sql.DriverManager</literal> if you set the following properties:"
msgstr "もし、以下のプロパティを設定すると、Hibernateはコネクションを取得する（プールも）ために <literal>java.sql.DriverManager</literal> を使います。"

#: index.docbook:147
msgid "Hibernate JDBC Properties"
msgstr "Hibernate JDBCプロパティ"

#: index.docbook:153, index.docbook:241, index.docbook:338, index.docbook:529, index.docbook:725, index.docbook:832, index.docbook:920
msgid "Property name"
msgstr "プロパティ名"

#: index.docbook:154, index.docbook:242, index.docbook:339, index.docbook:530, index.docbook:726, index.docbook:833, index.docbook:921
msgid "Purpose"
msgstr "<entry>意味</entry>"

#: index.docbook:160
msgid "hibernate.connection.driver_class"
msgstr "hibernate.connection.driver_class"

#: index.docbook:163
msgid "JDBC driver class"
msgstr "JDBCドライバクラス"

#: index.docbook:168
msgid "hibernate.connection.url"
msgstr "hibernate.connection.url"

#: index.docbook:171
msgid "JDBC URL"
msgstr "jdbc URL"

#: index.docbook:176, index.docbook:272
msgid "hibernate.connection.username"
msgstr "hibernate.connection.username"

#: index.docbook:179
msgid "database user"
msgstr "database user"

#: index.docbook:184, index.docbook:280
msgid "hibernate.connection.password"
msgstr "hibernate.connection.password"

#: index.docbook:187
msgid "database user password"
msgstr "database user password"

#: index.docbook:192
msgid "hibernate.connection.pool_size"
msgstr "hibernate.connection.pool_size"

#: index.docbook:195
msgid "maximum number of pooled connections"
msgstr "プールするコネクションの最大数"

#: index.docbook:202
msgid "Hibernate's own connection pooling algorithm is however quite rudimentary. It is intended to help you get started and is <emphasis>not intended for use in a production system</emphasis> or even for performance testing. You should use a third party pool for best performance and stability. Just replace the <literal>hibernate.connection.pool_size</literal> property with connection pool specific settings. This will turn off Hibernate's internal pool. For example, you might like to use C3P0."
msgstr "Hibernateのコネクションプールアルゴリズムは非常に初歩的なものです。 これはすぐに始められるようにと用意されたもので、<emphasis>製品として使用することを意図していません</emphasis> 。 また、パフォーマンスのテストのためのものでもありません。 最高のパフォーマンスと安定性を持ったプールを実現したければ、サードパーティのツールをお勧めします。 <literal>hibernate.connection.pool_size</literal> プロパティに 適切なコネクションプールサイズを記述してください。 このままだとHibernateのコネクションプールを使います。 例えば次のようにC3P0を使います。"

#: index.docbook:212
msgid "C3P0 is an open source JDBC connection pool distributed along with Hibernate in the <literal>lib</literal> directory. Hibernate will use its <literal>C3P0ConnectionProvider</literal> for connection pooling if you set <literal>hibernate.c3p0.*</literal> properties. If you'd like to use Proxool refer to the packaged <literal>hibernate.properties</literal> and the Hibernate web site for more information."
msgstr "C3P0はオープンソースJDBCコネクションプールで、Hibernateの <literal>lib</literal> ディレクトリにあります。もし、<literal>hibernate.c3p0.*</literal> プロパティを セットすれば、Hibernateは、 <literal>C3P0ConnectionProvider</literal> を使います。 もしProxoolを使いたい場合は、 <literal>hibernate.properties</literal> パッケージを 参照したり、HibernateのWebサイトでより多くの情報を取得してください。"

#: index.docbook:221
msgid "Here is an example <literal>hibernate.properties</literal> file for C3P0:"
msgstr "C3P0用の <literal>hibernate.properties</literal> ファイルを例として示します："

#: index.docbook:225
msgid ""
      "<![CDATA[hibernate.connection.driver_class = org.postgresql.Driver\n"
      "hibernate.connection.url = jdbc:postgresql://localhost/mydatabase\n"
      "hibernate.connection.username = myuser\n"
      "hibernate.connection.password = secret\n"
      "hibernate.c3p0.min_size=5\n"
      "hibernate.c3p0.max_size=20\n"
      "hibernate.c3p0.timeout=1800\n"
      "hibernate.c3p0.max_statements=50\n"
      "hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect]]>"
msgstr ""
      "<![CDATA[hibernate.connection.driver_class = org.postgresql.Driver\n"
      "hibernate.connection.url = jdbc:postgresql://localhost/mydatabase\n"
      "hibernate.connection.username = myuser\n"
      "hibernate.connection.password = secret\n"
      "hibernate.c3p0.min_size=5\n"
      "hibernate.c3p0.max_size=20\n"
      "hibernate.c3p0.timeout=1800\n"
      "hibernate.c3p0.max_statements=50\n"
      "hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect]]>"

#: index.docbook:227
msgid "For use inside an application server, you should almost always configure Hibernate to obtain connections from an application server <literal>Datasource</literal> registered in JNDI. You'll need to set at least one of the following properties:"
msgstr "アプリケーションサーバ上で使う場合は、Hibernateを設定し、 アプリケーションサーバからコネクションを取得するようにしてください。 <literal>Datasource</literal> をJNDIに登録します。そして プロパティを以下のように設定してください。"

#: index.docbook:235
msgid "Hibernate Datasource Properties"
msgstr "Hibernate データソースプロパティ"

#: index.docbook:248
msgid "hibernate.connection.datasource"
msgstr "hibernate.connection.datasource"

#: index.docbook:251
msgid "datasource JNDI name"
msgstr "データソースのJNDI名"

#: index.docbook:256
msgid "hibernate.jndi.url"
msgstr "hibernate.jndi.url"

#: index.docbook:258
msgid "<emphasis>URL of the JNDI provider</emphasis> (optional)"
msgstr "<emphasis>JNDIプロバイダのURL</emphasis> (オプション)"

#: index.docbook:264
msgid "hibernate.jndi.class"
msgstr "hibernate.jndi.class"

#: index.docbook:266
msgid "<emphasis>class of the JNDI <literal>InitialContextFactory</literal></emphasis> (optional)"
msgstr "<emphasis>JNDIクラス <literal>InitialContextFactory</literal> </emphasis> (オプション)"

#: index.docbook:274
msgid "<emphasis>database user</emphasis> (optional)"
msgstr "<emphasis>database user</emphasis> (オプション)"

#: index.docbook:282
msgid "<emphasis>database user password</emphasis> (optional)"
msgstr "<emphasis>database user password</emphasis> (オプション)"

#: index.docbook:290
msgid "Here's an example <literal>hibernate.properties</literal> file for an application server provided JNDI datasource:"
msgstr "アプリケーションサーバから提供されたJNDIデータソースを使う <literal>hibernate.properties</literal> ファイルの例を示します："

#: index.docbook:295
msgid ""
      "<![CDATA[hibernate.connection.datasource = java:/comp/env/jdbc/test\n"
      "hibernate.transaction.factory_class = \\\n"
      "    org.hibernate.transaction.JTATransactionFactory\n"
      "hibernate.transaction.manager_lookup_class = \\\n"
      "    org.hibernate.transaction.JBossTransactionManagerLookup\n"
      "hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect]]>"
msgstr ""
      "<![CDATA[hibernate.connection.datasource = java:/comp/env/jdbc/test\n"
      "hibernate.transaction.factory_class = ¥\n"
      "    org.hibernate.transaction.JTATransactionFactory\n"
      "hibernate.transaction.manager_lookup_class = ¥\n"
      "    org.hibernate.transaction.JBossTransactionManagerLookup\n"
      "hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect]]>"

#: index.docbook:297
msgid "JDBC connections obtained from a JNDI datasource will automatically participate in the container-managed transactions of the application server."
msgstr "JNDIデータソースから取得したJDBCコネクションは、アプリケーションサーバの コンテナ管理トランザクションに自動的に参加します。"

#: index.docbook:302
msgid "Arbitrary connection properties may be given by prepending \"<literal>hibernate.connection</literal>\" to the property name. For example, you may specify a <literal>charSet</literal> using <literal>hibernate.connection.charSet</literal>."
msgstr "任意のコネクションプロパティは、与えられた” <literal>hibernate.connnection</literal> ” プロパティ名によって与えられます。例えば、 <literal>charSet</literal> を設定したい場合は、 <literal>hibernate.connection.charSet</literal> を使います。"

#: index.docbook:308
msgid "You may define your own plugin strategy for obtaining JDBC connections by implementing the interface <literal>org.hibernate.connection.ConnectionProvider</literal>. You may select a custom implementation by setting <literal>hibernate.connection.provider_class</literal>."
msgstr "JDBCコネクションを取得する戦略を持つ独自のプラグインを定義する場合は、 <literal>org.hibernate.connection.ConnectionProvider</literal> インターフェイスを 実装してください。そして、実装クラスを <literal>hibernate.connection.provider_class</literal> に設定してください。"

#: index.docbook:317
msgid "Optional configuration properties"
msgstr "オプション設定プロパティ"

#: index.docbook:319
msgid "There are a number of other properties that control the behaviour of Hibernate at runtime. All are optional and have reasonable default values."
msgstr "これらのプロパティはHibernateの挙動を制御するものです。 これらのプロパティはすべて妥当なデフォルト値があり、任意で設定します。"

#: index.docbook:324
msgid "<emphasis>Warning: some of these properties are \"system-level\" only.</emphasis> System-level properties can be set only via <literal>java -Dproperty=value</literal> or <literal>hibernate.properties</literal>. They may <emphasis>not</emphasis> be set by the other techniques described above."
msgstr "<emphasis>注意：これらのプロパティは\"システムレベル\"のみです。</emphasis> システムレベルプロパティは <literal>java -Dproperty=value</literal> 、もしくは <literal>hibernate.properties</literal> でのみ設定可能です。 それ以外の設定方法は <emphasis>ありません</emphasis> 。"

#: index.docbook:332
msgid "Hibernate Configuration Properties"
msgstr "Hibernate設定プロパティ"

#: index.docbook:345
msgid "hibernate.dialect"
msgstr "hibernate.dialect"

#: index.docbook:347
msgid "The classname of a Hibernate <literal>Dialect</literal> which allows Hibernate to generate SQL optimized for a particular relational database."
msgstr "Hibernate <literal>Dialect</literal> クラス名が入ります。 これはリレーショナルデータベースごとに最適化されたSQLを生成します。"

#: index.docbook:351
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>full.classname.of.Dialect</literal>"
msgstr "<emphasis role=\"strong\">例：</emphasis> <literal>full.classname.of.Dialect</literal>"

#: index.docbook:359
msgid "hibernate.show_sql"
msgstr "hibernate.show_sql"

#: index.docbook:361
msgid "Write all SQL statements to console. This is an alternative to setting the log category <literal>org.hibernate.SQL</literal> to <literal>debug</literal>."
msgstr "発行されたすべてのSQLをコンソールに出力します。 これはログカテゴリの <literal>org.hibernate.SQL</literal> に <literal>debug</literal> を設定する方法の代替手段です。"

#: index.docbook:365, index.docbook:377, index.docbook:471, index.docbook:484, index.docbook:497, index.docbook:510, index.docbook:564, index.docbook:591, index.docbook:605, index.docbook:660, index.docbook:888, index.docbook:903, index.docbook:993
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>true</literal> | <literal>false</literal>"
msgstr "<emphasis role=\"strong\">例：</emphasis> <literal>true</literal> | <literal>false</literal>"

#: index.docbook:373
msgid "hibernate.format_sql"
msgstr "hibernate.format_sql"

#: index.docbook:375
msgid "Pretty print the SQL in the log and console."
msgstr "ログとコンソールのSQLを美しく表示します。"

#: index.docbook:385
msgid "hibernate.default_schema"
msgstr "hibernate.default_schema"

#: index.docbook:387
msgid "Qualify unqualified table names with the given schema/tablespace in generated SQL."
msgstr "生成されるSQL文のテーブルに設定するスキーマ/テーブルスペースです。"

#: index.docbook:390
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>SCHEMA_NAME</literal>"
msgstr "<emphasis role=\"strong\">例：</emphasis> <literal>SCHEMA_NAME</literal>"

#: index.docbook:398
msgid "hibernate.default_catalog"
msgstr "hibernate.default_catalog"

#: index.docbook:400
msgid "Qualify unqualified table names with the given catalog in generated SQL."
msgstr "生成されるSQL文のテーブルに設定するカタログです。"

#: index.docbook:403
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>CATALOG_NAME</literal>"
msgstr "<emphasis role=\"strong\">例：</emphasis> <literal>CATALOG_NAME</literal>"

#: index.docbook:411
msgid "hibernate.session_factory_name"
msgstr "hibernate.session_factory_name"

#: index.docbook:413
msgid "The <literal>SessionFactory</literal> will be automatically bound to this name in JNDI after it has been created."
msgstr "<literal>SessionFactory</literal> は生成後、この名前でJNDIに登録されます。"

#: index.docbook:416, index.docbook:859
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>jndi/composite/name</literal>"
msgstr "<emphasis role=\"strong\">例：</emphasis> <literal>jndi/composite/name</literal>"

#: index.docbook:424
msgid "hibernate.max_fetch_depth"
msgstr "hibernate.max_fetch_depth"

#: index.docbook:426
msgid "Set a maximum \"depth\" for the outer join fetch tree for single-ended associations (one-to-one, many-to-one). A <literal>0</literal> disables default outer join fetching."
msgstr "外部結合フェッチの最大深度を設定します。結合する関連は 対一関連のみ（一対一、多対一）です。 <literal>0</literal> を指定すると外部結合フェッチは無効になります。"

#: index.docbook:430
msgid "<emphasis role=\"strong\">eg.</emphasis> recommended values between <literal>0</literal> and <literal>3</literal>"
msgstr "<emphasis role=\"strong\">例：</emphasis> 推奨する値は <literal>0</literal> から <literal>3</literal> です。"

#: index.docbook:439
msgid "hibernate.default_batch_fetch_size"
msgstr "hibernate.default_batch_fetch_size"

#: index.docbook:441
msgid "Set a default size for Hibernate batch fetching of associations."
msgstr "関連フェッチのデフォルトバッチサイズを指定します。"

#: index.docbook:443
msgid "<emphasis role=\"strong\">eg.</emphasis> recommended values <literal>4</literal>, <literal>8</literal>, <literal>16</literal>"
msgstr "<emphasis role=\"strong\">例：</emphasis> 推奨する値は <literal>4</literal> , <literal>8</literal> , <literal>16</literal> です。"

#: index.docbook:452
msgid "hibernate.default_entity_mode"
msgstr "hibernate.default_entity_mode"

#: index.docbook:454
msgid "Set a default mode for entity representation for all sessions opened from this <literal>SessionFactory</literal>"
msgstr "<literal>SessionFactory</literal> からセッションをオープンしたときに 使用するエンティティのデフォルトモードを設定します。"

#: index.docbook:457
msgid "<literal>dynamic-map</literal>, <literal>dom4j</literal>, <literal>pojo</literal>"
msgstr "<literal>dynamic-map</literal>, <literal>dom4j</literal>, <literal>pojo</literal>"

#: index.docbook:465
msgid "hibernate.order_updates"
msgstr "hibernate.order_updates"

#: index.docbook:467
msgid "Force Hibernate to order SQL updates by the primary key value of the items being updated. This will result in fewer transaction deadlocks in highly concurrent systems."
msgstr "項目が更新されたときに、別のSQLで主キーを更新することを強制します。 この場合、同時実行可能なシステムでは、まれにデッドロックが発生する可能性があります。"

#: index.docbook:479
msgid "hibernate.generate_statistics"
msgstr "hibernate.generate_statistics"

#: index.docbook:481
msgid "If enabled, Hibernate will collect statistics useful for performance tuning."
msgstr "有効の場合、Hibernateはパフォーマンスチューニングに 有効な統計情報を収集します。"

#: index.docbook:492
msgid "hibernate.use_identifier_rollback"
msgstr "hibernate.use_identifer_rollback"

#: index.docbook:494
msgid "If enabled, generated identifier properties will be reset to default values when objects are deleted."
msgstr "有効の場合、オブジェクトが削除されたときに 識別子プロパティをリセットし、デフォルト値にしたものを生成します。"

#: index.docbook:505
msgid "hibernate.use_sql_comments"
msgstr "hibernate.use_sql_comments"

#: index.docbook:507
msgid "If turned on, Hibernate will generate comments inside the SQL, for easier debugging, defaults to <literal>false</literal>."
msgstr "有効の場合、SQL内にコメントを生成します。これはデバックを容易にします。 デフォルトの値は <literal>false</literal> です。"

#: index.docbook:521
msgid "Hibernate JDBC and Connection Properties"
msgstr "Hibernate JDBC とコネクションプロパティ"

#: index.docbook:536
msgid "hibernate.jdbc.fetch_size"
msgstr "hibernate.jdbc.fetch_size"

#: index.docbook:538
msgid "A non-zero value determines the JDBC fetch size (calls <literal>Statement.setFetchSize()</literal>)."
msgstr "値が0でない場合、JDBCフェッチサイズを決定します ( <literal>Statement.setFetchSize()</literal> を呼びます)。"

#: index.docbook:545
msgid "hibernate.jdbc.batch_size"
msgstr "hibernate.jdbc.batch_size"

#: index.docbook:547
msgid "A non-zero value enables use of JDBC2 batch updates by Hibernate."
msgstr "値が0でない場合、HibernateがJDBC2バッチ更新を使用します。"

#: index.docbook:549
msgid "<emphasis role=\"strong\">eg.</emphasis> recommended values between <literal>5</literal> and <literal>30</literal>"
msgstr "<emphasis role=\"strong\">例：</emphasis> 推奨する値は <literal>5</literal> から <literal>30</literal> です。"

#: index.docbook:557
msgid "hibernate.jdbc.batch_versioned_data"
msgstr "hibernate.jdbc.batch_versioned_data"

#: index.docbook:559
msgid "Set this property to <literal>true</literal> if your JDBC driver returns correct row counts from <literal>executeBatch()</literal> (it is usually safe to turn this option on). Hibernate will then use batched DML for automatically versioned data. Defaults to <literal>false</literal>."
msgstr "もしJDBCドライバが <literal>executeBatch()</literal> によって正確な行数を 返す場合、このプロパティを <literal>true</literal> にしてください （通常はこのオプションをONにします）。 Hibernateは、自動バージョンデータのためバッチDMLを使います。 デフォルトの値は <literal>false</literal> です。"

#: index.docbook:572
msgid "hibernate.jdbc.factory_class"
msgstr "hibernate.jdbc.factory_class"

#: index.docbook:574
msgid "Select a custom <literal>Batcher</literal>. Most applications will not need this configuration property."
msgstr "カスタム <literal>Batcher</literal> を選びます。 ほとんどのアプリケーションに、この設定は必要ありません。"

#: index.docbook:577
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>classname.of.BatcherFactory</literal>"
msgstr "<emphasis role=\"strong\">例：</emphasis> <literal>classname.of.BatcherFactory</literal>"

#: index.docbook:585
msgid "hibernate.jdbc.use_scrollable_resultset"
msgstr "hibernate.jdbc.use_scrollable_resultset"

#: index.docbook:587
msgid "Enables use of JDBC2 scrollable resultsets by Hibernate. This property is only necessary when using user supplied JDBC connections, Hibernate uses connection metadata otherwise."
msgstr "スクロール可能なリザルトセットを、Hibernateが使用します。 このプロパティは、JDBCコネクションがコネクションメタデータを サポートしていることが必須条件になります。"

#: index.docbook:599
msgid "hibernate.jdbc.use_streams_for_binary"
msgstr "hibernate.jdbc.use_streams_for_binary"

#: index.docbook:601
msgid "Use streams when writing/reading <literal>binary</literal> or <literal>serializable</literal> types to/from JDBC (system-level property)."
msgstr "JDBCへ/から <literal>binary</literal> や <literal>serializable</literal> の書き込み/読み込みストリームを使います(システムレベルのプロパティ)。"

#: index.docbook:613
msgid "hibernate.jdbc.use_get_generated_keys"
msgstr "hibernate.jdbc.use_get_generated_keys"

#: index.docbook:615
msgid "Enable use of JDBC3 <literal>PreparedStatement.getGeneratedKeys()</literal> to retrieve natively generated keys after insert. Requires JDBC3+ driver and JRE1.4+, set to false if your driver has problems with the Hibernate identifier generators. By default, tries to determine the driver capabilities using connection metadata."
msgstr "挿入の後に自動生成された主キーを取得するための JDBC3 <literal>PreparedStatement.getGeneratedKeys()</literal> の使用を有効にします。 これはJDBC3+ドライバとJRE1.4+を必要とし、 もしHibernateの識別子ジェネレータに問題が発生するようならfalseに設定してください。 デフォルトではコネクションメタデータを使いドライバの能力を決定します。"

#: index.docbook:621, index.docbook:751, index.docbook:763, index.docbook:777, index.docbook:815
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>true|false</literal>"
msgstr "<emphasis role=\"strong\">例：</emphasis> <literal>true|false</literal>"

#: index.docbook:629
msgid "hibernate.connection.provider_class"
msgstr "hibernate.connection.provider_class"

#: index.docbook:631
msgid "The classname of a custom <literal>ConnectionProvider</literal> which provides JDBC connections to Hibernate."
msgstr "JDBCコネクションをHibernateに提供する独自の <literal>ConnectionProvider</literal> の 名前を指定します。"

#: index.docbook:634
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>classname.of.ConnectionProvider</literal>"
msgstr "<emphasis role=\"strong\">例：</emphasis> <literal>classname.of.ConnectionProvider</literal>"

#: index.docbook:642
msgid "hibernate.connection.isolation"
msgstr "hibernate.connection.isolation"

#: index.docbook:644
msgid "Set the JDBC transaction isolation level. Check <literal>java.sql.Connection</literal> for meaningful values but note that most databases do not support all isolation levels."
msgstr "JDBCトランザクション分離レベルを設定します。 妥当な値を調べるためには <literal>java.sql.Connection</literal> をチェックしてください。 しかし使用するデータベースが、すべての分離レベルをサポートしているとは限りません。"

#: index.docbook:648
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>1, 2, 4, 8</literal>"
msgstr "<emphasis role=\"strong\">例：</emphasis> <literal>1, 2, 4, 8</literal>"

#: index.docbook:656
msgid "hibernate.connection.autocommit"
msgstr "hibernate.connection.autocommit"

#: index.docbook:658
msgid "Enables autocommit for JDBC pooled connections (not recommended)."
msgstr "プールされているJDBCコネクションの自動コミットを有効にする（非推奨）。"

#: index.docbook:668
msgid "hibernate.connection.release_mode"
msgstr "hibernate.connection.release_mode"

#: index.docbook:670
msgid "Specify when Hibernate should release JDBC connections. By default, a JDBC connection is held until the session is explicitly closed or disconnected. For an application server JTA datasource, you should use <literal>after_statement</literal> to aggressively release connections after every JDBC call. For a non-JTA connection, it often makes sense to release the connection at the end of each transaction, by using <literal>after_transaction</literal>. <literal>auto</literal> will choose <literal>after_statement</literal> for the JTA and CMT transaction strategies and <literal>after_transaction</literal> for the JDBC transaction strategy."
msgstr "HibernateがJDBCコネクションをリリースするかを指定します。デフォルトでは セッションが明示的にクローズまたは切断されてもコネクションは保持します。 アプリケーションサーバのJTAデータソースの場合、 すべてのJDBCコールの後、強制的にコネクションをリリースするために <literal>after_statement</literal> を 使ってください。 非JTAコネクションの場合、各トランザクションが終了したときに <literal>after_transaction</literal> を使い、コネクションをリリースしてください。 <literal>auto</literal> にすると、 JTAやCMTトランザクションの場合、 <literal>after_statement</literal> でクローズし、 JDBCトランザクションの場合、 <literal>after_transaction</literal> でクローズします。"

#: index.docbook:681
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>auto</literal> (default) | <literal>on_close</literal> | <literal>after_transaction</literal> | <literal>after_statement</literal>"
msgstr "<emphasis role=\"strong\">例：</emphasis> <literal>auto</literal> (default) | <literal>on_close</literal> | <literal>after_transaction</literal> | <literal>after_statement</literal>"

#: index.docbook:686
msgid "Note that this setting only affects <literal>Session</literal>s returned from <literal>SessionFactory.openSession</literal>. For <literal>Session</literal>s obtained through <literal>SessionFactory.getCurrentSession</literal>, the <literal>CurrentSessionContext</literal> implementation configured for use controls the connection release mode for those <literal>Session</literal>s. See"
msgstr "注意してください。この設定は <literal>SessionFactory.openSession</literal> から 取得した <literal>Session</literal> だけに効果があります。 <literal>SessionFactory.getCurrentSession</literal> を通じて取得した <literal>Session</literal> では、<literal>CurrentSessionContext</literal> の実装によって、コネクションのリリースモードを設定します。 <xref linkend=\"architecture-current-session\"/> を参照してください。"

#: index.docbook:698
msgid "hibernate.connection.<emphasis>&lt;propertyName&gt;</emphasis>"
msgstr "hibernate.connection.<emphasis>&lt;propertyName&gt;</emphasis>"

#: index.docbook:700
msgid "Pass the JDBC property <literal>propertyName</literal> to <literal>DriverManager.getConnection()</literal>."
msgstr "JDBCの <literal>propertyName</literal> プロパティを、 <literal>DriverManager.getConnection()</literal> に渡します。"

#: index.docbook:707
msgid "hibernate.jndi.<emphasis>&lt;propertyName&gt;</emphasis>"
msgstr "hibernate.jndi.<emphasis>&lt;propertyName&gt;</emphasis>"

#: index.docbook:709
msgid "Pass the property <literal>propertyName</literal> to the JNDI <literal>InitialContextFactory</literal>."
msgstr "<literal>propertyName</literal> プロパティを、 JNDI <literal>InitialContextFactory</literal> に渡します。"

#: index.docbook:719
msgid "Hibernate Cache Properties"
msgstr "Hibernate キャッシュプロパティ"

#: index.docbook:732
msgid "hibernate.cache.provider_class"
msgstr "hibernate.cache.provider_class"

#: index.docbook:734
msgid "The classname of a custom <literal>CacheProvider</literal>."
msgstr "カスタム <literal>CacheProvider</literal> のクラス名です。"

#: index.docbook:736
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>classname.of.CacheProvider</literal>"
msgstr "<emphasis role=\"strong\">例：</emphasis> <literal>classname.of.CacheProvider</literal>"

#: index.docbook:744
msgid "hibernate.cache.use_minimal_puts"
msgstr "hibernate.cache.use_minimal_puts"

#: index.docbook:746
msgid "Optimize second-level cache operation to minimize writes, at the cost of more frequent reads. This setting is most useful for clustered caches and, in Hibernate3, is enabled by default for clustered cache implementations."
msgstr "書き込みを最小限にするために、二次キャッシュの操作を最適化します。 その代わりに、読み込みがより頻繁に発生するようになります。 このセッティングはクラスタキャッシュで役に立ちます。 Hibernate3ではクラスタキャッシュ実装用にデフォルトでは有効になっています。"

#: index.docbook:759
msgid "hibernate.cache.use_query_cache"
msgstr "hibernate.cache.use_query_cache"

#: index.docbook:761
msgid "Enable the query cache, individual queries still have to be set cachable."
msgstr "特定のクエリがキャッシュ可能な場合に、クエリキャッシュを有効にします。"

#: index.docbook:771
msgid "hibernate.cache.use_second_level_cache"
msgstr "hibernate.cache.use_second_level_cache"

#: index.docbook:773
msgid "May be used to completely disable the second level cache, which is enabled by default for classes which specify a <literal>&lt;cache&gt;</literal> mapping."
msgstr "二次キャッシュを完全に無効にする場合に使います。 デフォルトでは有効で、クラスの <literal>&lt;cache&gt;</literal> マッピング で制御します。"

#: index.docbook:785
msgid "hibernate.cache.query_cache_factory"
msgstr "hibernate.cache.query_cache_factory"

#: index.docbook:787
msgid "The classname of a custom <literal>QueryCache</literal> interface, defaults to the built-in <literal>StandardQueryCache</literal>."
msgstr "カスタム <literal>QueryCache</literal> インターフェイスのクラス名を 指定します。デフォルトでは <literal>StandardQueryCache</literal> になります。"

#: index.docbook:790
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>classname.of.QueryCache</literal>"
msgstr "<emphasis role=\"strong\">例：</emphasis> <literal>classname.of.QueryCache</literal>"

#: index.docbook:798
msgid "hibernate.cache.region_prefix"
msgstr "hibernate.cache.region_prefix"

#: index.docbook:800
msgid "A prefix to use for second-level cache region names."
msgstr "二次キャッシュの領域名の接頭辞です。"

#: index.docbook:802
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>prefix</literal>"
msgstr "<emphasis role=\"strong\">例：</emphasis> <literal>prefix</literal>"

#: index.docbook:810
msgid "hibernate.cache.use_structured_entries"
msgstr "hibernate.cache.use_structured_entries"

#: index.docbook:812
msgid "Forces Hibernate to store data in the second-level cache in a more human-friendly format."
msgstr "二次キャッシュに格納するデータを、人が理解しやすいフォーマットにします。"

#: index.docbook:826
msgid "Hibernate Transaction Properties"
msgstr "Hibernate トランザクションプロパティ"

#: index.docbook:839
msgid "hibernate.transaction.factory_class"
msgstr "hibernate.transaction.factory_class"

#: index.docbook:841
msgid "The classname of a <literal>TransactionFactory</literal> to use with Hibernate <literal>Transaction</literal> API (defaults to <literal>JDBCTransactionFactory</literal>)."
msgstr "Hibernate <literal>Transaction</literal> APIと一緒に使われる <literal>TransactionFactory</literal> のクラス名です。 （デフォルトでは <literal>JDBCTransactionFactory</literal> です）。"

#: index.docbook:845
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>classname.of.TransactionFactory</literal>"
msgstr "<emphasis role=\"strong\">例：</emphasis> <literal>classname.of.TransactionFactory</literal>"

#: index.docbook:853
msgid "jta.UserTransaction"
msgstr "jta.UserTransaction"

#: index.docbook:855
msgid "A JNDI name used by <literal>JTATransactionFactory</literal> to obtain the JTA <literal>UserTransaction</literal> from the application server."
msgstr "アプリケーションサーバからJTA <literal>UserTransaction</literal> を取得するために <literal>JTATransactionFactory</literal> に使われるJNDI名です。"

#: index.docbook:867
msgid "hibernate.transaction.manager_lookup_class"
msgstr "hibernate.transaction.manager_lookup_class"

#: index.docbook:869
msgid "The classname of a <literal>TransactionManagerLookup</literal> - required when JVM-level caching is enabled or when using hilo generator in a JTA environment."
msgstr "<literal>TransactionManagerLookup</literal> のクラス名です。 JTA環境において、JVMレベルのキャッシュを有効にするために必要です。"

#: index.docbook:873
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>classname.of.TransactionManagerLookup</literal>"
msgstr "<emphasis role=\"strong\">例：</emphasis> <literal>classname.of.TransactionManagerLookup</literal>"

#: index.docbook:881
msgid "hibernate.transaction.flush_before_completion"
msgstr "hibernate.transaction.flush_before_completion"

#: index.docbook:883
msgid "If enabled, the session will be automatically flushed during the before completion phase of the transaction. Built-in and automatic session context management is preferred, see <xref linkend=\"architecture-current-session\"/>."
msgstr "有効の場合、トランザクションのcompletionフェーズの前に自動的に セッションをフラッシュします。内臓の自動セッションコンテキスト管理に適しています。 <xref linkend=\"architecture-current-session\"/>を参照してください。"

#: index.docbook:896
msgid "hibernate.transaction.auto_close_session"
msgstr "hibernate.transaction.auto_close_session"

#: index.docbook:898
msgid "If enabled, the session will be automatically closed during the after completion phase of the transaction. Built-in and utomatic session context management is preferred, see <xref linkend=\"architecture-current-session\"/>."
msgstr "有効の場合、トランザクションのcompletionフェーズの後に セッションを自動的にクローズします。内臓の自動セッションコンテキスト管理に適しています。 <xref linkend=\"architecture-current-session\"/>を参照してください。"

#: index.docbook:914
msgid "Miscellaneous Properties"
msgstr "その他のプロパティ"

#: index.docbook:927
msgid "hibernate.current_session_context_class"
msgstr "hibernate.current_session_context_class"

#: index.docbook:929
msgid "Supply a (custom) strategy for the scoping of the \"current\" <literal>Session</literal>. See <xref linkend=\"architecture-current-session\"/> for more information about the built-in strategies."
msgstr "「現在の」<literal>Session</literal> のための（カスタム）戦略を提供します。 ビルトインストラテジーに関するその他の情報については <xref linkend=\"architecture-current-session\"/>を参照してください。"

#: index.docbook:934
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>jta</literal> | <literal>thread</literal> | <literal>managed</literal> | <literal>custom.Class</literal>"
msgstr "<emphasis role=\"strong\">例：</emphasis> <literal>jta</literal> | <literal>thread</literal> | <literal>managed</literal> | <literal>custom.Class</literal>"

#: index.docbook:943
msgid "hibernate.query.factory_class"
msgstr "hibernate.query.factory_class"

#: index.docbook:945
msgid "Chooses the HQL parser implementation."
msgstr "HQLパーサーの実装を選択します。"

#: index.docbook:947
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>org.hibernate.hql.ast.ASTQueryTranslatorFactory</literal> or <literal>org.hibernate.hql.classic.ClassicQueryTranslatorFactory</literal>"
msgstr "<emphasis role=\"strong\">例：</emphasis> <literal>org.hibernate.hql.ast.ASTQueryTranslatorFactory</literal> or <literal>org.hibernate.hql.classic.ClassicQueryTranslatorFactory</literal>"

#: index.docbook:956
msgid "hibernate.query.substitutions"
msgstr "hibernate.query.substitutions"

#: index.docbook:958
msgid "Mapping from tokens in Hibernate queries to SQL tokens (tokens might be function or literal names, for example)."
msgstr "HQLとSQLのトークンをマッピングします。 （例えば、トークンは関数やリテラル名です）。"

#: index.docbook:961
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</literal>"
msgstr "<emphasis role=\"strong\">例：</emphasis> <literal>hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</literal>"

#: index.docbook:969
msgid "hibernate.hbm2ddl.auto"
msgstr "hibernate.hbm2ddl.auto"

#: index.docbook:971
msgid "Automatically validate or export schema DDL to the database when the <literal>SessionFactory</literal> is created. With <literal>create-drop</literal>, the database schema will be dropped when the <literal>SessionFactory</literal> is closed explicitly."
msgstr "<literal>SessionFactory</literal> を生成したときに、 自動的にスキーマDDLをDBに出力します。 <literal>create-drop</literal> の場合、 <literal>SessionFactory</literal> を クローズしたときに、データベーススキーマをドロップします。"

#: index.docbook:977
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>validate</literal> | <literal>update</literal> | <literal>create</literal> | <literal>create-drop</literal>"
msgstr "<emphasis role=\"strong\">例：</emphasis> <literal>validate</literal> | <literal>update</literal> | <literal>create</literal> | <literal>create-drop</literal>"

#: index.docbook:986
msgid "hibernate.cglib.use_reflection_optimizer"
msgstr "hibernate.cglib.use_reflection_optimizer"

#: index.docbook:988
msgid "Enables use of CGLIB instead of runtime reflection (System-level property). Reflection can sometimes be useful when troubleshooting, note that Hibernate always requires CGLIB even if you turn off the optimizer. You can not set this property in <literal>hibernate.cfg.xml</literal>."
msgstr "実行時リフレクションの代わりのCGLIBの使用を有効にします （システムレベルのプロパティ） リフレクションはトラブルシューティングのときに役立つことがあります。 オプティマイザをオフにしているときでさえ、 Hibernateには必ずCGLIBが必要なことに注意してください。 このプロパティは <literal>hibernate.cfg.xml</literal> で設定できません。"

#: index.docbook:1004
msgid "SQL Dialects"
msgstr "SQL 方言（Dialect）"

#: index.docbook:1006
msgid "You should always set the <literal>hibernate.dialect</literal> property to the correct <literal>org.hibernate.dialect.Dialect</literal> subclass for your database. If you specify a dialect, Hibernate will use sensible defaults for some of the other properties listed above, saving you the effort of specifying them manually."
msgstr "<literal>hibernate.dialect</literal> プロパティには、 使用するデータベースの正しい <literal>org.hibernate.dialect.Dialect</literal> のサブクラスを、 必ず指定すべきです。 しかし方言を指定すれば、Hibernateは上述したプロパティのいくつかについて、 より適切なデフォルト値を使います。 そうすれば、それらを手作業で設定する手間が省けます。"

#: index.docbook:1014
msgid "Hibernate SQL Dialects (<literal>hibernate.dialect</literal>)"
msgstr "Hibernate SQL Dialects (<literal>hibernate.dialect</literal>)"

#: index.docbook:1022
msgid "RDBMS"
msgstr "RDBMS"

#: index.docbook:1023
msgid "Dialect"
msgstr "Dialect"

#: index.docbook:1028
msgid "<entry>DB2</entry>"
msgstr "<entry>DB2</entry>"

#: index.docbook:1028
msgid "org.hibernate.dialect.DB2Dialect"
msgstr "org.hibernate.dialect.DB2Dialect"

#: index.docbook:1031
msgid "DB2 AS/400"
msgstr "DB2 AS/400"

#: index.docbook:1031
msgid "org.hibernate.dialect.DB2400Dialect"
msgstr "org.hibernate.dialect.DB2400Dialect"

#: index.docbook:1034
msgid "DB2 OS390"
msgstr "DB2 OS390"

#: index.docbook:1034
msgid "org.hibernate.dialect.DB2390Dialect"
msgstr "org.hibernate.dialect.DB2390Dialect"

#: index.docbook:1037
msgid "PostgreSQL"
msgstr "PostgreSQL"

#: index.docbook:1037
msgid "org.hibernate.dialect.PostgreSQLDialect"
msgstr "org.hibernate.dialect.PostgreSQLDialect"

#: index.docbook:1040
msgid "MySQL"
msgstr "MySQL"

#: index.docbook:1040
msgid "org.hibernate.dialect.MySQLDialect"
msgstr "org.hibernate.dialect.MySQLDialect"

#: index.docbook:1043
msgid "MySQL with InnoDB"
msgstr "MySQL with InnoDB"

#: index.docbook:1043
msgid "org.hibernate.dialect.MySQLInnoDBDialect"
msgstr "org.hibernate.dialect.MySQLInnoDBDialect"

#: index.docbook:1046
msgid "MySQL with MyISAM"
msgstr "MySQL with MyISAM"

#: index.docbook:1046
msgid "org.hibernate.dialect.MySQLMyISAMDialect"
msgstr "org.hibernate.dialect.MySQLMyISAMDialect"

#: index.docbook:1049
msgid "Oracle (any version)"
msgstr "Oracle (any version)"

#: index.docbook:1049
msgid "org.hibernate.dialect.OracleDialect"
msgstr "org.hibernate.dialect.OracleDialect"

#: index.docbook:1052
msgid "Oracle 9i/10g"
msgstr "Oracle 9i/10g"

#: index.docbook:1052
msgid "org.hibernate.dialect.Oracle9Dialect"
msgstr "org.hibernate.dialect.Oracle9Dialect"

#: index.docbook:1055
msgid "Sybase"
msgstr "Sybase"

#: index.docbook:1055
msgid "org.hibernate.dialect.SybaseDialect"
msgstr "org.hibernate.dialect.SybaseDialect"

#: index.docbook:1058
msgid "Sybase Anywhere"
msgstr "Sybase Anywhere"

#: index.docbook:1058
msgid "org.hibernate.dialect.SybaseAnywhereDialect"
msgstr "org.hibernate.dialect.SybaseAnywhereDialect"

#: index.docbook:1061
msgid "Microsoft SQL Server"
msgstr "Microsoft SQL Server"

#: index.docbook:1061
msgid "org.hibernate.dialect.SQLServerDialect"
msgstr "org.hibernate.dialect.SQLServerDialect"

#: index.docbook:1064
msgid "SAP DB"
msgstr "SAP DB"

#: index.docbook:1064
msgid "org.hibernate.dialect.SAPDBDialect"
msgstr "org.hibernate.dialect.SAPDBDialect"

#: index.docbook:1067
msgid "Informix"
msgstr "Informix"

#: index.docbook:1067
msgid "org.hibernate.dialect.InformixDialect"
msgstr "org.hibernate.dialect.InformixDialect"

#: index.docbook:1070
msgid "HypersonicSQL"
msgstr "HypersonicSQL"

#: index.docbook:1070
msgid "org.hibernate.dialect.HSQLDialect"
msgstr "org.hibernate.dialect.HSQLDialect"

#: index.docbook:1073
msgid "Ingres"
msgstr "Ingres"

#: index.docbook:1073
msgid "org.hibernate.dialect.IngresDialect"
msgstr "org.hibernate.dialect.IngresDialect"

#: index.docbook:1076
msgid "Progress"
msgstr "Progress"

#: index.docbook:1076
msgid "org.hibernate.dialect.ProgressDialect"
msgstr "org.hibernate.dialect.ProgressDialect"

#: index.docbook:1079
msgid "Mckoi SQL"
msgstr "Mckoi SQL"

#: index.docbook:1079
msgid "org.hibernate.dialect.MckoiDialect"
msgstr "org.hibernate.dialect.MckoiDialect"

#: index.docbook:1082
msgid "Interbase"
msgstr "Interbase"

#: index.docbook:1082
msgid "org.hibernate.dialect.InterbaseDialect"
msgstr "org.hibernate.dialect.InterbaseDialect"

#: index.docbook:1085
msgid "Pointbase"
msgstr "Pointbase"

#: index.docbook:1085
msgid "org.hibernate.dialect.PointbaseDialect"
msgstr "org.hibernate.dialect.PointbaseDialect"

#: index.docbook:1088
msgid "FrontBase"
msgstr "FrontBase"

#: index.docbook:1088
msgid "org.hibernate.dialect.FrontbaseDialect"
msgstr "org.hibernate.dialect.FrontbaseDialect"

#: index.docbook:1091
msgid "Firebird"
msgstr "Firebird"

#: index.docbook:1091
msgid "org.hibernate.dialect.FirebirdDialect"
msgstr "org.hibernate.dialect.FirebirdDialect"

#: index.docbook:1100
msgid "Outer Join Fetching"
msgstr "外部結合フェッチ"

#: index.docbook:1102
msgid "If your database supports ANSI, Oracle or Sybase style outer joins, <emphasis>outer join fetching</emphasis> will often increase performance by limiting the number of round trips to and from the database (at the cost of possibly more work performed by the database itself). Outer join fetching allows a whole graph of objects connected by many-to-one, one-to-many, many-to-many and one-to-one associations to be retrieved in a single SQL <literal>SELECT</literal>."
msgstr "もしDBがANSIか、OracleかSybaseスタイルの外部結合をサポートしている場合、 <emphasis>outer join fetching</emphasis> は、DBのSQL発行回数を節約し パフォーマンスを良くします。（DB内でより多くの処理コストが発生します） 外部結合フェッチは、多対一、一対多、多対多、一対一のオブジェクト関連で グループオブジェクトを1つのSQLで <literal>SELECT</literal> します。"

#: index.docbook:1111
msgid "Outer join fetching may be disabled <emphasis>globally</emphasis> by setting the property <literal>hibernate.max_fetch_depth</literal> to <literal>0</literal>. A setting of <literal>1</literal> or higher enables outer join fetching for one-to-one and many-to-one associations which have been mapped with <literal>fetch=\"join\"</literal>."
msgstr "<literal>hibernate.max_fetch_depth</literal> プロパティの値を <literal>0</literal> にすると Outer join fetchingを <emphasis>すべて</emphasis> 無効にすることになります。 <literal>1</literal> やそれ以上の値を設定すると、外部結合フェッチが有効になり、 一対一と多対一関連が <literal>fetch=\"join\"</literal> としてマッピングされます。"

#: index.docbook:1119
msgid "See <xref linkend=\"performance-fetching\"/> for more information."
msgstr "See <xref linkend=\"performance-fetching\"/> for more information."

#: index.docbook:1126
msgid "Binary Streams"
msgstr "バイナリストリーム"

#: index.docbook:1128
msgid "Oracle limits the size of <literal>byte</literal> arrays that may be passed to/from its JDBC driver. If you wish to use large instances of <literal>binary</literal> or <literal>serializable</literal> type, you should enable <literal>hibernate.jdbc.use_streams_for_binary</literal>. <emphasis>This is a system-level setting only.</emphasis>"
msgstr "OracleはJDBCドライバとの間でやりとりされる <literal>byte</literal> 配列のサイズを制限します。 <literal>binary</literal> や <literal>serializable</literal> 型の大きなインスタンスを使いたければ、 <literal>hibernate.jdbc.use_streams_for_binary</literal> を有効にしてください。 ただし <emphasis>これはシステムレベルの設定だけです</emphasis> 。"

#: index.docbook:1139
msgid "Second-level and query cache"
msgstr "2次キャッシュとクエリーキャッシュ"

#: index.docbook:1141
msgid "The properties prefixed by <literal>hibernate.cache</literal> allow you to use a process or cluster scoped second-level cache system with Hibernate. See the <xref linkend=\"performance-cache\"/> for more details."
msgstr "<literal>hibernate.cache</literal> プロパティ接頭辞は Hibernateでプロセスやクラスタ二次キャッシュを使うとことを許可します。 <xref linkend=\"performance-cache\"/>により多くの詳細があります。"

#: index.docbook:1151
msgid "Query Language Substitution"
msgstr "クエリー言語の置き換え"

#: index.docbook:1153
msgid "You may define new Hibernate query tokens using <literal>hibernate.query.substitutions</literal>. For example:"
msgstr "<literal>hibernate.query.substitutions</literal> を使うことで、 新しいHibernateクエリトークンを定義できます。 例："

#: index.docbook:1158
msgid "hibernate.query.substitutions true=1, false=0"
msgstr "hibernate.query.substitutions true=1, false=0"

#: index.docbook:1160
msgid "would cause the tokens <literal>true</literal> and <literal>false</literal> to be translated to integer literals in the generated SQL."
msgstr "これはトークン <literal>true</literal> と <literal>false</literal> を、 生成されるSQLにおいて整数リテラルに翻訳します。"

#: index.docbook:1165
msgid "hibernate.query.substitutions toLowercase=LOWER"
msgstr "hibernate.query.substitutions toLowercase=LOWER"

#: index.docbook:1167
msgid "would allow you to rename the SQL <literal>LOWER</literal> function."
msgstr "これはSQLの <literal>LOWER</literal> 関数の名前の付け替えを可能にします。"

#: index.docbook:1174
msgid "Hibernate statistics"
msgstr "Hibernate 統計"

#: index.docbook:1176
msgid "If you enable <literal>hibernate.generate_statistics</literal>, Hibernate will expose a number of metrics that are useful when tuning a running system via <literal>SessionFactory.getStatistics()</literal>. Hibernate can even be configured to expose these statistics via JMX. Read the Javadoc of the interfaces in <literal>org.hibernate.stats</literal> for more information."
msgstr "<literal>hibernate.generate_statistics</literal> を有効にした場合、 動作しているシステムをチューニングするときに、<literal>SessionFactory.getStatistics()</literal> を経由して、Hibernateは便利な統計情報を出力します。 JMXを経由して統計情報を出力することも可能です。 Javadocの <literal>org.hibernate.stats</literal> パッケージ内の インターフェイスにはより多くの情報があります。"

#: index.docbook:1188
msgid "Logging"
msgstr "ロギング"

#: index.docbook:1190
msgid "Hibernate logs various events using Apache commons-logging."
msgstr "HibernateはApache commons-logginを使って、さまざまなイベントをログとして 出力します。"

#: index.docbook:1194
msgid "The commons-logging service will direct output to either Apache Log4j (if you include <literal>log4j.jar</literal> in your classpath) or JDK1.4 logging (if running under JDK1.4 or above). You may download Log4j from <literal>http://jakarta.apache.org</literal>. To use Log4j you will need to place a <literal>log4j.properties</literal> file in your classpath, an example properties file is distributed with Hibernate in the <literal>src/</literal> directory."
msgstr "commons-loggingサービスは（クラスパスに <literal>log4j.jar</literal> を含めれば）Apache Log4jに、 また（JDK1.4かそれ以上で実行させれば）JDK1.4 loggingに直接出力します。 Log4jは <literal>http://jakarta.apache.org</literal> からダウンロードできます。 Log4jを使うためには、クラスパスに <literal>log4j.properties</literal> ファイルを配置する必要があります。 例のプロパティファイルはHibernateと一緒に配布され、それは <literal>src/</literal> ディレクトリにあります。"

#: index.docbook:1204
msgid "We strongly recommend that you familiarize yourself with Hibernate's log messages. A lot of work has been put into making the Hibernate log as detailed as possible, without making it unreadable. It is an essential troubleshooting device. The most interesting log categories are the following:"
msgstr "Hibernateのログメッセージに慣れることを強くおすすめします。 Hibernateのログは読みやすく、できる限り詳細になるように努力されています。 これは必須のトラブルシューティングデバイスです。 以下に重要なログのカテゴリを示します。"

#: index.docbook:1213
msgid "Hibernate Log Categories"
msgstr "Hibernate ログカテゴリ"

#: index.docbook:1219
msgid "Category"
msgstr "カテゴリ"

#: index.docbook:1220
msgid "Function"
msgstr "<entry>機能</entry>"

#: index.docbook:1225
msgid "org.hibernate.SQL"
msgstr "org.hibernate.SQL"

#: index.docbook:1226
msgid "Log all SQL DML statements as they are executed"
msgstr "実行したすべてのSQL（DDL）ステートメントをロギングします。"

#: index.docbook:1229
msgid "org.hibernate.type"
msgstr "org.hibernate.type"

#: index.docbook:1230
msgid "Log all JDBC parameters"
msgstr "すべてのJDBCパラメータをロギングします。"

#: index.docbook:1233
msgid "org.hibernate.tool.hbm2ddl"
msgstr "org.hibernate.tool.hbm2ddl"

#: index.docbook:1234
msgid "Log all SQL DDL statements as they are executed"
msgstr "実行したすべてのSQL（DDL）ステートメントをロギングします。"

#: index.docbook:1237
msgid "org.hibernate.pretty"
msgstr "org.hibernate.pretty"

#: index.docbook:1238
msgid "Log the state of all entities (max 20 entities) associated with the session at flush time"
msgstr "sessionに関連するすべてのエンティティ（最大２０）のフラッシュ時間をロギングします。"

#: index.docbook:1244
msgid "org.hibernate.cache"
msgstr "org.hibernate.cache"

#: index.docbook:1245
msgid "Log all second-level cache activity"
msgstr "すべての２次キャッシュの動作をロギングします。"

#: index.docbook:1248
msgid "org.hibernate.transaction"
msgstr "org.hibernate.transaction"

#: index.docbook:1249
msgid "Log transaction related activity"
msgstr "トランザクションに関連する動作をロギングします。"

#: index.docbook:1252
msgid "org.hibernate.jdbc"
msgstr "org.hibernate.jdbc"

#: index.docbook:1253
msgid "Log all JDBC resource acquisition"
msgstr "JDBCリソース取得をロギングします。"

#: index.docbook:1256
msgid "org.hibernate.hql.ast.AST"
msgstr "org.hibernate.hql.ast.AST"

#: index.docbook:1257
msgid "Log HQL and SQL ASTs during query parsing"
msgstr "HQLとSQLのASTのクエリーパースをロギングします。"

#: index.docbook:1262
msgid "org.hibernate.secure"
msgstr "org.hibernate.secure"

#: index.docbook:1263
msgid "Log all JAAS authorization requests"
msgstr "すべてのJAAS分析をロギングします。"

#: index.docbook:1266
msgid "org.hibernate"
msgstr "org.hibernate"

#: index.docbook:1267
msgid "Log everything (a lot of information, but very useful for troubleshooting)"
msgstr "すべてをロギングします。（情報が大量になりますが、トラブルシューティングには便利です）"

#: index.docbook:1276
msgid "When developing applications with Hibernate, you should almost always work with <literal>debug</literal> enabled for the category <literal>org.hibernate.SQL</literal>, or, alternatively, the property <literal>hibernate.show_sql</literal> enabled."
msgstr "Hibernateでアプリケーションを作成するときは、<literal>org.hibernate.SQL</literal> カテゴリの <literal>debug</literal> を常に有効にしておいたほうが良いでしょう。 代替方法として、<literal>hibernate.show_sql</literal> を有効にする方法があります。"

#: index.docbook:1286
msgid "Implementing a <literal>NamingStrategy</literal>"
msgstr "<literal>NamingStrategy</literal> の実装"

#: index.docbook:1288
msgid "The interface <literal>org.hibernate.cfg.NamingStrategy</literal> allows you to specify a \"naming standard\" for database objects and schema elements."
msgstr "インターフェイス <literal>net.sf.hibernate.cfg.NamingStrategy</literal> を使うと データベースオブジェクトとスキーマ要素のための「命名標準」を指定できます。"

#: index.docbook:1293
msgid "You may provide rules for automatically generating database identifiers from Java identifiers or for processing \"logical\" column and table names given in the mapping file into \"physical\" table and column names. This feature helps reduce the verbosity of the mapping document, eliminating repetitive noise (<literal>TBL_</literal> prefixes, for example). The default strategy used by Hibernate is quite minimal."
msgstr "Javaの識別子からデータベースの識別子を自動生成するためのルールや、 マッピングファイルで与えた「論理的な」カラムとテーブル名から 「物理的な」テーブルとカラム名を生成するためのルールを用意することができます。 この機能は繰り返しの雑音（例えば <literal>TBL_</literal> プリフィックス）を取り除き、 マッピングドキュメントの冗長さを減らすことに役立ちます。 Hibernateが使うデフォルトの戦略はかなり最小限に近いものです。"

#: index.docbook:1302
msgid "You may specify a different strategy by calling <literal>Configuration.setNamingStrategy()</literal> before adding mappings:"
msgstr "マッピングを追加する前に <literal>Configuration.setNamingStrategy()</literal> を呼ぶことで 以下のように異なる戦略を指定することができます："

#: index.docbook:1307
msgid ""
      "<![CDATA[SessionFactory sf = new Configuration()\n"
      "    .setNamingStrategy(ImprovedNamingStrategy.INSTANCE)\n"
      "    .addFile(\"Item.hbm.xml\")\n"
      "    .addFile(\"Bid.hbm.xml\")\n"
      "    .buildSessionFactory();]]>"
msgstr ""
      "<![CDATA[SessionFactory sf = new Configuration()\n"
      "    .setNamingStrategy(ImprovedNamingStrategy.INSTANCE)\n"
      "    .addFile(\"Item.hbm.xml\")\n"
      "    .addFile(\"Bid.hbm.xml\")\n"
      "    .buildSessionFactory();]]>"

#: index.docbook:1309
msgid "<literal>org.hibernate.cfg.ImprovedNamingStrategy</literal> is a built-in strategy that might be a useful starting point for some applications."
msgstr "<literal>org.hibernate.cfg.ImprovedNamingStrategy</literal> は組み込みの戦略です。 これはいくつかのアプリケーションにとって有用な開始点となるかもしれません。"

#: index.docbook:1317
msgid "XML configuration file"
msgstr "XML設定ファイル"

#: index.docbook:1319
msgid "An alternative approach to configuration is to specify a full configuration in a file named <literal>hibernate.cfg.xml</literal>. This file can be used as a replacement for the <literal>hibernate.properties</literal> file or, if both are present, to override properties."
msgstr "もう1つの方法は <literal>hibernate.cfg.xml</literal> という名前のファイルで 十分な設定を指定する方法です。 このファイルは <literal>hibernate.properties</literal> ファイルの代わりとなります。 もし両方のファイルがあれば、プロパティが置き換えられます。"

#: index.docbook:1326
msgid "The XML configuration file is by default expected to be in the root o your <literal>CLASSPATH</literal>. Here is an example:"
msgstr "XML設定ファイルは初期設定で <literal>CLASSPATH</literal> に配置してください。 これが例です："

#: index.docbook:1331
msgid ""
      "<![CDATA[<?xml version='1.0' encoding='utf-8'?>\n"
      "<!DOCTYPE hibernate-configuration PUBLIC\n"
      "    \"-//Hibernate/Hibernate Configuration DTD//EN\"\n"
      "    \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\">\n"
      "\n"
      "<hibernate-configuration>\n"
      "\n"
      "    <!-- a SessionFactory instance listed as /jndi/name -->\n"
      "    <session-factory\n"
      "        name=\"java:hibernate/SessionFactory\">\n"
      "\n"
      "        <!-- properties -->\n"
      "        <property name=\"connection.datasource\">java:/comp/env/jdbc/MyDB</property>\n"
      "        <property name=\"dialect\">org.hibernate.dialect.MySQLDialect</property>\n"
      "        <property name=\"show_sql\">false</property>\n"
      "        <property name=\"transaction.factory_class\">\n"
      "            org.hibernate.transaction.JTATransactionFactory\n"
      "        </property>\n"
      "        <property name=\"jta.UserTransaction\">java:comp/UserTransaction</property>\n"
      "\n"
      "        <!-- mapping files -->\n"
      "        <mapping resource=\"org/hibernate/auction/Item.hbm.xml\"/>\n"
      "        <mapping resource=\"org/hibernate/auction/Bid.hbm.xml\"/>\n"
      "\n"
      "        <!-- cache settings -->\n"
      "        <class-cache class=\"org.hibernate.auction.Item\" usage=\"read-write\"/>\n"
      "        <class-cache class=\"org.hibernate.auction.Bid\" usage=\"read-only\"/>\n"
      "        <collection-cache collection=\"org.hibernate.auction.Item.bids\" usage=\"read-write\"/>\n"
      "\n"
      "    </session-factory>\n"
      "\n"
      "</hibernate-configuration>]]>"
msgstr ""
      "<![CDATA[<?xml version='1.0' encoding='utf-8'?>\n"
      "<!DOCTYPE hibernate-configuration PUBLIC\n"
      "    \"-//Hibernate/Hibernate Configuration DTD//EN\"\n"
      "    \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\">\n"
      "\n"
      "<hibernate-configuration>\n"
      "\n"
      "    <!-- a SessionFactory instance listed as /jndi/name -->\n"
      "    <!-- /jndi/nameのようにリストアップされたSessionFactoryインスタンス -->\n"
      "    <session-factory\n"
      "        name=\"java:hibernate/SessionFactory\">\n"
      "\n"
      "        <!-- properties -->\n"
      "        <property name=\"connection.datasource\">java:/comp/env/jdbc/MyDB</property>\n"
      "        <property name=\"dialect\">org.hibernate.dialect.MySQLDialect</property>\n"
      "        <property name=\"show_sql\">false</property>\n"
      "        <property name=\"transaction.factory_class\">\n"
      "            org.hibernate.transaction.JTATransactionFactory\n"
      "        </property>\n"
      "        <property name=\"jta.UserTransaction\">java:comp/UserTransaction</property>\n"
      "\n"
      "        <!-- mapping files -->\n"
      "        <mapping resource=\"org/hibernate/auction/Item.hbm.xml\"/>\n"
      "        <mapping resource=\"org/hibernate/auction/Bid.hbm.xml\"/>\n"
      "\n"
      "        <!-- cache settings -->\n"
      "        <class-cache class=\"org.hibernate.auction.Item\" usage=\"read-write\"/>\n"
      "        <class-cache class=\"org.hibernate.auction.Bid\" usage=\"read-only\"/>\n"
      "        <collection-cache collection=\"org.hibernate.auction.Item.bids\" usage=\"read-write\"/>\n"
      "\n"
      "    </session-factory>\n"
      "\n"
      "</hibernate-configuration>]]>"

#: index.docbook:1333
msgid "As you can see, the advantage of this approach is the externalization of the mapping file names to configuration. The <literal>hibernate.cfg.xml</literal> is also more convenient once you have to tune the Hibernate cache. Note that is your choice to use either <literal>hibernate.properties</literal> or <literal>hibernate.cfg.xml</literal>, both are equivalent, except for the above mentioned benefits of using the XML syntax."
msgstr "見てのとおり、この方法の優位性は設定のためのマッピングファイル名を外出しにできることです。 Hibernateキャッシュをチューニングしなければならないのであれば、 <literal>hibernate.cfg.xml</literal> はより便利です。 <literal>hibernate.properties</literal> と <literal>hibernate.cfg.xml</literal> の どちらかを使えることを覚えておいてください。 二つは同じもので、違うところといえばXML構文を使うことの利点だけです。"

#: index.docbook:1342
msgid "With the XML configuration, starting Hibernate is then as simple as"
msgstr "XML設定を使うことで、Hibernateは以下のようにシンプルになります。"

#: index.docbook:1346
msgid "<![CDATA[SessionFactory sf = new Configuration().configure().buildSessionFactory();]]>"
msgstr "<![CDATA[SessionFactory sf = new Configuration().configure().buildSessionFactory();]]>"

#: index.docbook:1348
msgid "You can pick a different XML configuration file using"
msgstr "違うXML設定ファイルを使うこともできます。"

#: index.docbook:1352
msgid ""
      "<![CDATA[SessionFactory sf = new Configuration()\n"
      "    .configure(\"catdb.cfg.xml\")\n"
      "    .buildSessionFactory();]]>"
msgstr ""
      "<![CDATA[SessionFactory sf = new Configuration()\n"
      "    .configure(\"catdb.cfg.xml\")\n"
      "    .buildSessionFactory();]]>"

#: index.docbook:1357
msgid "J2EE Application Server integration"
msgstr "J2EEアプリケーションサーバとの統合"

#: index.docbook:1359
msgid "Hibernate has the following integration points for J2EE infrastructure:"
msgstr "HibernateはJ2EE構造と統合するポイントをサポートしています。"

#: index.docbook:1365
msgid "<emphasis>Container-managed datasources</emphasis>: Hibernate can use JDBC connections managed by the container and provided through JNDI. Usually, a JTA compatible <literal>TransactionManager</literal> and a <literal>ResourceManager</literal> take care of transaction management (CMT), esp. distributed transaction handling across several datasources. You may of course also demarcate transaction boundaries programmatically (BMT) or you might want to use the optional Hibernate <literal>Transaction</literal> API for this to keep your code portable."
msgstr "<emphasis>コンテナ管理データソース</emphasis>：Hibernateは JNDIが提供し、コンテナが管理するJDBCコネクションを使用できます。 通常、JTA準拠の <literal>TransactionManager</literal> と <literal>ResourceManager</literal> がトランザクション管理(CMT)、 特に様々なデータソースにまたがる分散トランザクションを扱います。 当然プログラムでトランザクション境界を指定できます(BMT)。 あるいは、記述したコードのポータビリティを保つために、 オプションのHibernateの <literal>Transaction</literal> APIを使いたくなるかもしれません。"

#: index.docbook:1380
msgid "<emphasis>Automatic JNDI binding</emphasis>: Hibernate can bind its <literal>SessionFactory</literal> to JNDI after startup."
msgstr "<emphasis>自動JNDIバインディング</emphasis>：HibernateはJNDIが立ち上がった後に <literal>SessionFactory</literal> を生成します。"

#: index.docbook:1389
msgid "<emphasis>JTA Session binding:</emphasis> The Hibernate <literal>Session</literal> may be automatically bound to the scope of JTA transactions. Simply lookup the <literal>SessionFactory</literal> from JNDI and get the current <literal>Session</literal>. Let Hibernate take care of flushing and closing the <literal>Session</literal> when your JTA transaction completes. Transaction demarcation is either declarative (CMT) or programmatic (BMT/UserTransaction)."
msgstr "<emphasis>JTAセッションバインディング</emphasis> ： Hibernate <literal>Session</literal> のトランザクション境界はJTAトランザクションと同じになります。 単純に <literal>SessionFactory</literal> をJNDIからlookupして、 現在の <literal>Session</literal> を取得します。 JTAトランザクションが完了したときに、Hibernateが <literal>Session</literal> をフラッシュし、クローズします。 EJBデプロイメントディスクリプタの中に、トランザクション境界を宣言します。"

#: index.docbook:1402
msgid "<emphasis>JMX deployment:</emphasis> If you have a JMX capable application server (e.g. JBoss AS), you can chose to deploy Hibernate as a managed MBean. This saves you the one line startup code to build your <literal>SessionFactory</literal> from a <literal>Configuration</literal>. The container will startup your <literal>HibernateService</literal>, and ideally also take care of service dependencies (Datasource has to be available before Hibernate starts, etc)."
msgstr "<emphasis>JMXデプロイ:</emphasis> もしJMXが使用可能なアプリケーションサーバ（例えばJBOSS） がある場合、HibernateをMBeanとしてデプロイすることを選べます。 これは <literal>Configuration</literal> から <literal>SessionFactory</literal> を 生成するコードを無くすことができます。 コンテナは <literal>HibernateService</literal> を起動し、 サービスの依存を理想的に管理します（データソースはHibernateやその他が起動する前に 使用できるようにしなければなりません）。"

#: index.docbook:1413
msgid "Depending on your environment, you might have to set the configuration option <literal>hibernate.connection.aggressive_release</literal> to true if your application server shows \"connection containment\" exceptions."
msgstr "環境に依存しますが、もし、アプリケーションサーバが\"connection containment\"の例外をスローするなら 設定のオプション <literal>hibernate.connection.aggressive_release</literal> をtrueにしてください。"

#: index.docbook:1420
msgid "Transaction strategy configuration"
msgstr "トランザクション戦略設定"

#: index.docbook:1422
msgid "The Hibernate <literal>Session</literal> API is independent of any transaction demarcation system in your architecture. If you let Hibernate use JDBC directly, through a connection pool, you may begin and end your transactions by calling the JDBC API. If you run in a J2EE application server, you might want to use bean-managed transactions and call the JTA API and <literal>UserTransaction</literal> when needed."
msgstr "Hibernate <literal>Session</literal> APIは、アーキテクチャ内のシステムの管轄である あらゆるトランザクションに依存しません。 もしコネクションプールのJDBCを直接使いたい場合、JDBC APIから トランザクションを呼ぶことができます。 もし、J2EEアプリケーションサーバで動作させるなら、Bean管理トランザクションを使い、 必要に応じて <literal>UserTransaction</literal> をJTA APIから呼ぶことになるでしょう。"

#: index.docbook:1430
msgid "To keep your code portable between these two (and other) environments we recommend the optional Hibernate <literal>Transaction</literal> API, which wraps and hides the underlying system. You have to specify a factory class for <literal>Transaction</literal> instances by setting the Hibernate configuration property <literal>hibernate.transaction.factory_class</literal>."
msgstr "2つ（それ以上）の環境で互換性のあるコードを維持するために、オプションとして根本的なシステムを ラッピングするHibernate <literal>Transaction</literal> APIを推奨します。 Hibernate設定プロパティの <literal>hibernate.transaction.factory_class</literal> を設定することで ある特定の <literal>Transaction</literal> クラスのインスタンスを持つことができます。"

#: index.docbook:1437
msgid "There are three standard (built-in) choices:"
msgstr "3つの基本的な（既にある）選択を挙げます："

#: index.docbook:1443
msgid "org.hibernate.transaction.JDBCTransactionFactory"
msgstr "org.hibernate.transaction.JDBCTransactionFactory"

#: index.docbook:1445
msgid "delegates to database (JDBC) transactions (default)"
msgstr "データベース(JDBC)トランザクションに委譲します（デフォルト）"

#: index.docbook:1449
msgid "org.hibernate.transaction.JTATransactionFactory"
msgstr "org.hibernate.transaction.JTATransactionFactory"

#: index.docbook:1451
msgid "delegates to container-managed transaction if an existing transaction is underway in this context (e.g. EJB session bean method), otherwise a new transaction is started and bean-managed transaction are used."
msgstr "もし、このコンテキスト（例えば、EJBセッションBeanメソッド）で進行中のトランザクションが存在する、もしくは 新しいトランザクションが開始されており、Bean管理トランザクションが使われている場合、 コンテナ管理トランザクションに委譲します。"

#: index.docbook:1459
msgid "org.hibernate.transaction.CMTTransactionFactory"
msgstr "org.hibernate.transaction.CMTTransactionFactory"

#: index.docbook:1461
msgid "delegates to container-managed JTA transactions"
msgstr "コンテナ管理JTAトランザクションに委譲します"

#: index.docbook:1466
msgid "You may also define your own transaction strategies (for a CORBA transaction service, for example)."
msgstr "自分自身のトランザクション戦略（例えば、CORBAトランザクションサービス）を定義することもできます。"

#: index.docbook:1471
msgid "Some features in Hibernate (i.e. the second level cache, Contextual Sessions with JTA, etc.) require access to the JTA <literal>TransactionManager</literal> in a managed environment. In an application server you have to specify how Hibernate should obtain a reference to the <literal>TransactionManager</literal>, since J2EE does not standardize a single mechanism:"
msgstr "Hibernateのいくつかの機能（例えば、二次キャッシュ、JTAによるコンテキストセッション 等）は 管理された環境の中のJTA <literal>TransactionManager</literal> へのアクセスを要求します。 J2EEがひとつのメカニズムに規格化されていないので、 アプリケーションサーバにおいて、Hibernateが <literal>TransactionManager</literal> のリファレンス を取得する方法を明確にする必要があります。"

#: index.docbook:1479
msgid "JTA TransactionManagers"
msgstr "JTA トランザクションマネージャ"

#: index.docbook:1485
msgid "Transaction Factory"
msgstr "Transaction Factory"

#: index.docbook:1486
msgid "Application Server"
msgstr "Application Server"

#: index.docbook:1491
msgid "org.hibernate.transaction.JBossTransactionManagerLookup"
msgstr "org.hibernate.transaction.JBossTransactionManagerLookup"

#: index.docbook:1492
msgid "JBoss"
msgstr "JBoss"

#: index.docbook:1495
msgid "org.hibernate.transaction.WeblogicTransactionManagerLookup"
msgstr "org.hibernate.transaction.WeblogicTransactionManagerLookup"

#: index.docbook:1496
msgid "Weblogic"
msgstr "Weblogic"

#: index.docbook:1499
msgid "org.hibernate.transaction.WebSphereTransactionManagerLookup"
msgstr "org.hibernate.transaction.WebSphereTransactionManagerLookup"

#: index.docbook:1500
msgid "WebSphere"
msgstr "WebSphere"

#: index.docbook:1503
msgid "org.hibernate.transaction.WebSphereExtendedJTATransactionLookup"
msgstr "org.hibernate.transaction.WebSphereExtendedJTATransactionLookup"

#: index.docbook:1504
msgid "WebSphere 6"
msgstr "WebSphere 6"

#: index.docbook:1507
msgid "org.hibernate.transaction.OrionTransactionManagerLookup"
msgstr "org.hibernate.transaction.OrionTransactionManagerLookup"

#: index.docbook:1508
msgid "Orion"
msgstr "Orion"

#: index.docbook:1511
msgid "org.hibernate.transaction.ResinTransactionManagerLookup"
msgstr "org.hibernate.transaction.ResinTransactionManagerLookup"

#: index.docbook:1512
msgid "Resin"
msgstr "Resin"

#: index.docbook:1515
msgid "org.hibernate.transaction.JOTMTransactionManagerLookup"
msgstr "org.hibernate.transaction.JOTMTransactionManagerLookup"

#: index.docbook:1516
msgid "JOTM"
msgstr "JOTM"

#: index.docbook:1519
msgid "org.hibernate.transaction.JOnASTransactionManagerLookup"
msgstr "org.hibernate.transaction.JOnASTransactionManagerLookup"

#: index.docbook:1520
msgid "JOnAS"
msgstr "JOnAS"

#: index.docbook:1523
msgid "org.hibernate.transaction.JRun4TransactionManagerLookup"
msgstr "org.hibernate.transaction.JRun4TransactionManagerLookup"

#: index.docbook:1524
msgid "JRun4"
msgstr "JRun4"

#: index.docbook:1527
msgid "org.hibernate.transaction.BESTransactionManagerLookup"
msgstr "org.hibernate.transaction.BESTransactionManagerLookup"

#: index.docbook:1528
msgid "Borland ES"
msgstr "Borland ES"

#: index.docbook:1537
msgid "JNDI-bound <literal>SessionFactory</literal>"
msgstr "<literal>SessionFactory</literal> のJNDIへの登録"

#: index.docbook:1539
msgid "A JNDI bound Hibernate <literal>SessionFactory</literal> can simplify the lookup of the factory and the creation of new <literal>Session</literal>s. Note that this is not related to a JNDI bound <literal>Datasource</literal>, both simply use the same registry!"
msgstr "JNDIに登録したHibernate <literal>SessionFactory</literal> は単純に ファクトリをルックアップし、新しい <literal>Session</literal> を作ります。 これはJNDIに登録された <literal>Datasource</literal> には関連せず、 お互いにシンプルにこれらの登録を使うことに注意してください。"

#: index.docbook:1546
msgid "If you wish to have the <literal>SessionFactory</literal> bound to a JNDI namespace, specify a name (eg. <literal>java:hibernate/SessionFactory</literal>) using the property <literal>hibernate.session_factory_name</literal>. If this property is omitted, the <literal>SessionFactory</literal> will not be bound to JNDI. (This is especially useful in environments with a read-only JNDI default implementation, e.g. Tomcat.)"
msgstr "もし <literal>SessionFactory</literal> をJNDIネームスペースに登録したい場合、 特別な名前（例えば、 <literal>java:hibernate/SessionFactory</literal> ）を <literal>hibernate.session_factory_name</literal> プロパティに使ってください もしこのプロパティを省略した場合、 <literal>SessionFactory</literal> は JNDIに登録されません。（これはTomcatのようなデフォルト実装でJNDIが読みより専用の環境の場合特に便利です。）"

#: index.docbook:1554
msgid "When binding the <literal>SessionFactory</literal> to JNDI, Hibernate will use the values of <literal>hibernate.jndi.url</literal>, <literal>hibernate.jndi.class</literal> to instantiate an initial context. If they are not specified, the default <literal>InitialContext</literal> will be used."
msgstr "<literal>SessionFactory</literal> をJNDIに登録するとき、Hibernateは <literal>hibernate.jndi.url</literal> の値を使用し、<literal>hibernate.jndi.class</literal> をイニシャルコンテキストとして具体化します。 もし何も設定しない場合は、デフォルトの <literal>InitialContext</literal> を使用します。"

#: index.docbook:1561
msgid "Hibernate will automatically place the <literal>SessionFactory</literal> in JNDI after you call <literal>cfg.buildSessionFactory()</literal>. This means you will at least have this call in some startup code (or utility class) in your application, unless you use JMX deployment with the <literal>HibernateService</literal> (discussed later)."
msgstr "<literal>cfg.buildSessionFactory()</literal> をコール後 Hibernateは自動的に <literal>SessionFactory</literal> をJNDIに配置します。 <literal>HibernateService</literal> と一緒にJMXデプロイメントを使わない限り、 これはこの呼び出しをアプリケーション内の何らかのスタートアップコード（もしくはユーティリティクラス） に配置しなければならないことを意味します。（後で議論します）"

#: index.docbook:1568
msgid "If you use a JNDI <literal>SessionFactory</literal>, an EJB or any other class may obtain the <literal>SessionFactory</literal> using a JNDI lookup."
msgstr "もしJNDI <literal>SessionFactory</literal> を使う場合、EJBや他のクラスは JNDIルックアップを使って <literal>SessionFactory</literal> を取得します。"

#: index.docbook:1573
msgid "We recommend that you bind the <literal>SessionFactory</literal> to JNDI in a managed environment and use a <literal>static</literal> singleton otherwise. To shield your application code from these details, we also recommend to hide the actual lookup code for a <literal>SessionFactory</literal> in a helper class, such as <literal>HibernateUtil.getSessionFactory()</literal>. Note that such a class is also a convenient way to startup Hibernate&mdash;see chapter 1."
msgstr "管理された環境では <literal>SessionFactory</literal> をJNDIにバインドし、 そうでなければ <literal>static</literal> シングルトンを使うことを推奨します。 こういった詳細からアプリケーションコードを保護するために、 <literal>HibernateUtil.getSessionFactory()</literal> のようなヘルパークラスの中に、 <literal>SessionFactory</literal> をルックアップするコードを隠すことを推奨します。 このようなヘルパークラスはHibernateを開始する便利な手段でもあります。 &mdash;１章を参照してください。"

#: index.docbook:1585
msgid "Current Session context management with JTA"
msgstr "JTAによる現在のセッションコンテキストマネージメント"

#: index.docbook:1587
msgid "The easiest way to handle <literal>Session</literal>s and transactions is Hibernates automatic \"current\" <literal>Session</literal> management. See the discussion of <xref linkend=\"architecture-current-session\"/>current sessions. Using the <literal>\"jta\"</literal> session context, if there is no Hibernate <literal>Session</literal> associated with the current JTA transaction, one will be started and associated with that JTA transaction the first time you call <literal>sessionFactory.getCurrentSession()</literal>. The <literal>Session</literal>s retrieved via <literal>getCurrentSession()</literal> in <literal>\"jta\"</literal> context will be set to automatically flush before the transaction completes, close after the transaction completes, and aggressively release JDBC connections after each statement. This allows the <literal>Session</literal>s to be managed by the life cycle of the JTA transaction to which it is associated, keeping user code clean of such management concerns. Your code can either use JTA programmatically through <literal>UserTransaction</literal>, or (recommended for portable code) use the Hibernate <literal>Transaction</literal> API to set transaction boundaries. If you run in an EJB container, declarative transaction demarcation with CMT is preferred."
msgstr "もっとも簡単に <literal>Session</literal> とトランザクションを扱う方法は、 Hibernateが自動的に「現在の」 <literal>Session</literal> を管理することです。 <xref linkend=\"architecture-current-session\"/>カレントセッション の説明を参照してください。 もし <literal>「JTA」</literal> セッションコンテキストを使った上で、 現在のJTAトランザクションとHibernate <literal>Session</literal> が関連していない場合は、 最初に <literal>sessionFactory.getCurrentSession()</literal> をコールし、 JTAトランザクションとの関連付けを行ってください。 <literal>「JTA」</literal> コンテキストの <literal>getCurrentSession()</literal> を 通じて取得した <literal>Session</literal> は、トランザクションが完了する前に 自動的にフラッシュし、完了した後には自動的にクローズします。 また、各ステートメント後にJDBCコネクションを積極的にリリースします。 これによりJTAトランザクションのライフサイクルで <literal>Session</literal> を管理することができ、 ユーザーのコードからそのような管理をするコードを排除できます。 <literal>UserTransaction</literal> を通じてJTAをプログラムで管理することができます。 または、（ポータブルなコードであれば）Hibernate <literal>Transaction</literal> APIを トランザクション境界として使うこともできます。 EJBコンテナを使うときは、CMTによる宣言的トランザクション境界が好ましいです。"

#: index.docbook:1610
msgid "JMX deployment"
msgstr "JMXデプロイメント"

#: index.docbook:1612
msgid "The line <literal>cfg.buildSessionFactory()</literal> still has to be executed somewhere to get a <literal>SessionFactory</literal> into JNDI. You can do this either in a <literal>static</literal> initializer block (like the one in <literal>HibernateUtil</literal>) or you deploy Hibernate as a <emphasis>managed service</emphasis>."
msgstr "<literal>SessionFactory</literal> をJNDIから取得するためには <literal>cfg.buildSessionFactory()</literal> 行をどこかで実行していなければなりません。 あなたはこれを、<literal>static</literal> 初期化ブロック内（ <literal>HibernateUtil</literal> のような）か <emphasis>managed service</emphasis> としてHibernateをデプロイするか、どちらかで実行できます。"

#: index.docbook:1620
msgid "Hibernate is distributed with <literal>org.hibernate.jmx.HibernateService</literal> for deployment on an application server with JMX capabilities, such as JBoss AS. The actual deployment and configuration is vendor specific. Here is an example <literal>jboss-service.xml</literal> for JBoss 4.0.x:"
msgstr "JBOSSのようなJMXの機能でアプリケーションサーバにデプロイするために <literal>org.hibernate.jmx.HibernateService</literal> を使って、配置します。 実際のデプロイメントと設定はベンダー特有です。 ここで例としてJBOSS 4.0.x用の <literal>jboss-service.xml</literal> を示します。"

#: index.docbook:1627
msgid ""
      "<![CDATA[<?xml version=\"1.0\"?>\n"
      "<server>\n"
      "\n"
      "<mbean code=\"org.hibernate.jmx.HibernateService\"\n"
      "    name=\"jboss.jca:service=HibernateFactory,name=HibernateFactory\">\n"
      "\n"
      "    <!-- Required services -->\n"
      "    <depends>jboss.jca:service=RARDeployer</depends>\n"
      "    <depends>jboss.jca:service=LocalTxCM,name=HsqlDS</depends>\n"
      "\n"
      "    <!-- Bind the Hibernate service to JNDI -->\n"
      "    <attribute name=\"JndiName\">java:/hibernate/SessionFactory</attribute>\n"
      "\n"
      "    <!-- Datasource settings -->\n"
      "    <attribute name=\"Datasource\">java:HsqlDS</attribute>\n"
      "    <attribute name=\"Dialect\">org.hibernate.dialect.HSQLDialect</attribute>\n"
      "\n"
      "    <!-- Transaction integration -->\n"
      "    <attribute name=\"TransactionStrategy\">\n"
      "        org.hibernate.transaction.JTATransactionFactory</attribute>\n"
      "    <attribute name=\"TransactionManagerLookupStrategy\">\n"
      "        org.hibernate.transaction.JBossTransactionManagerLookup</attribute>\n"
      "    <attribute name=\"FlushBeforeCompletionEnabled\">true</attribute>\n"
      "    <attribute name=\"AutoCloseSessionEnabled\">true</attribute>\n"
      "\n"
      "    <!-- Fetching options -->\n"
      "    <attribute name=\"MaximumFetchDepth\">5</attribute>\n"
      "\n"
      "    <!-- Second-level caching -->\n"
      "    <attribute name=\"SecondLevelCacheEnabled\">true</attribute>\n"
      "    <attribute name=\"CacheProviderClass\">org.hibernate.cache.EhCacheProvider</attribute>\n"
      "    <attribute name=\"QueryCacheEnabled\">true</attribute>\n"
      "\n"
      "    <!-- Logging -->\n"
      "    <attribute name=\"ShowSqlEnabled\">true</attribute>\n"
      "\n"
      "    <!-- Mapping files -->\n"
      "    <attribute name=\"MapResources\">auction/Item.hbm.xml,auction/Category.hbm.xml</attribute>\n"
      "\n"
      "</mbean>\n"
      "\n"
      "</server>]]>"
msgstr ""
      "<![CDATA[<?xml version=\"1.0\"?>\n"
      "<server>\n"
      "\n"
      "<mbean code=\"org.hibernate.jmx.HibernateService\"\n"
      "    name=\"jboss.jca:service=HibernateFactory,name=HibernateFactory\">\n"
      "\n"
      "    <!-- Required services -->\n"
      "    <depends>jboss.jca:service=RARDeployer</depends>\n"
      "    <depends>jboss.jca:service=LocalTxCM,name=HsqlDS</depends>\n"
      "\n"
      "    <!-- Bind the Hibernate service to JNDI -->\n"
      "    <attribute name=\"JndiName\">java:/hibernate/SessionFactory</attribute>\n"
      "\n"
      "    <!-- Datasource settings -->\n"
      "    <attribute name=\"Datasource\">java:HsqlDS</attribute>\n"
      "    <attribute name=\"Dialect\">org.hibernate.dialect.HSQLDialect</attribute>\n"
      "\n"
      "    <!-- Transaction integration -->\n"
      "    <attribute name=\"TransactionStrategy\">\n"
      "        org.hibernate.transaction.JTATransactionFactory</attribute>\n"
      "    <attribute name=\"TransactionManagerLookupStrategy\">\n"
      "        org.hibernate.transaction.JBossTransactionManagerLookup</attribute>\n"
      "    <attribute name=\"FlushBeforeCompletionEnabled\">true</attribute>\n"
      "    <attribute name=\"AutoCloseSessionEnabled\">true</attribute>\n"
      "\n"
      "    <!-- Fetching options -->\n"
      "    <attribute name=\"MaximumFetchDepth\">5</attribute>\n"
      "\n"
      "    <!-- Second-level caching -->\n"
      "    <attribute name=\"SecondLevelCacheEnabled\">true</attribute>\n"
      "    <attribute name=\"CacheProviderClass\">org.hibernate.cache.EhCacheProvider</attribute>\n"
      "    <attribute name=\"QueryCacheEnabled\">true</attribute>\n"
      "\n"
      "    <!-- Logging -->\n"
      "    <attribute name=\"ShowSqlEnabled\">true</attribute>\n"
      "\n"
      "    <!-- Mapping files -->\n"
      "    <attribute name=\"MapResources\">auction/Item.hbm.xml,auction/Category.hbm.xml</attribute>\n"
      "\n"
      "</mbean>\n"
      "\n"
      "</server>]]>"

#: index.docbook:1629
msgid "This file is deployed in a directory called <literal>META-INF</literal> and packaged in a JAR file with the extension <literal>.sar</literal> (service archive). You also need to package Hibernate, its required third-party libraries, your compiled persistent classes, as well as your mapping files in the same archive. Your enterprise beans (usually session beans) may be kept in their own JAR file, but you may include this EJB JAR file in the main service archive to get a single (hot-)deployable unit. Consult the JBoss AS documentation for more information about JMX service and EJB deployment."
msgstr "このファイルは <literal>META-INF</literal> ディレクトリに配置され、 JARファイルを拡張した <literal>.sar</literal> (service archive)でパッケージ化されます。 同様にHibernateパッケージも必要です。また、Hibernateはサードパーティのライブラリも要求します。 コンパイルした永続化クラスとそのマッピングファイルも同様にアーカイブ（.sarファイル）に入れます。 エンタープライズbean（通常はセッションbean）は自身のJARファイルを保持しますが、 1回で（ホット）デプロイ可能なユニットのためにメインサービスアーカイブとしてこのEJB JARファイルをインクルードする ことができます。JBossアプリケーションサーバのドキュメントにJXMサービスと EJBデプロイメントのより多くの情報があります。"

msgid "ROLES_OF_TRANSLATORS"
msgstr "<!--TRANS:ROLES_OF_TRANSLATORS-->"

msgid "CREDIT_FOR_TRANSLATORS"
msgstr "<!--TRANS:CREDIT_FOR_TRANSLATORS-->"

