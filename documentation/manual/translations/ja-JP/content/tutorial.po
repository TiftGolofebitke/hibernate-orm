#, fuzzy
msgid ""
msgstr ""
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Content-Type: text/plain; charset=utf-8\n"
#: index.docbook:7
msgid "Introduction to Hibernate"
msgstr "Hibernateの導入"

#: index.docbook:10
msgid "Preface"
msgstr "<title>前書き</title>"

#: index.docbook:12
msgid "This chapter is an introductory tutorial for new users of Hibernate. We start with a simple command line application using an in-memory database and develop it in easy to understand steps."
msgstr "この章はHibernateを初めて使うユーザ向けの入門的なチュートリアルです。 インメモリデータベースを使う簡単なコマンドラインアプリケーションから始め、 一歩一歩わかりやすいやり方で開発を進めます。"

#: index.docbook:18
msgid "This tutorial is intended for new users of Hibernate but requires Java and SQL knowledge. It is based on a tutorial by Michael Gloegl, the third-party libraries we name are for JDK 1.4 and 5.0. You might need others for JDK 1.3."
msgstr "このチュートリアルはHibernateを初めて使うユーザを想定していますが、 理解するにはJavaとSQLについての知識が必要です。 これはMichael Gloeglの手によるチュートリアルを下敷きにしていますが、 ここでサードパーティライブラリと言っているのは、JDK 1.4と5.0用のものです。 JDK 1.3を利用するのであれば他のライブラリが必要かもしれません。"

#: index.docbook:24
msgid "The source code for the tutorial is included in the distribution in the <literal>doc/reference/tutorial/</literal> directory."
msgstr "チュートリアルのソースコードはHibernateディストリビューションの <literal>doc/reference/tutorial/</literal> にあります。"

#: index.docbook:32
msgid "Part 1 - The first Hibernate Application"
msgstr "パート1 - 初めてのHibernateアプリケーション"

#: index.docbook:34
msgid "First, we'll create a simple console-based Hibernate application. We use an Java database (HSQL DB), so we do not have to install any database server."
msgstr "最初にコンソールベースの簡単なHibernateアプリケーションを作成します。 Javaデータベース（HSQL DB）を利用するので、 データベースサーバをインストールする必要はありません。"

#: index.docbook:39
msgid "Let's assume we need a small database application that can store events we want to attend, and information about the hosts of these events."
msgstr "仮に小さなデータベースアプリケーションが必要だとしましょう。 そのアプリケーションには出席したいイベントと、 そのイベントのホストについての情報を格納するものとします。"

#: index.docbook:44
msgid "The first thing we do, is set up our development directory and put all the Java libraries we need into it. Download the Hibernate distribution from the Hibernate website. Extract the package and place all required libraries found in <literal>/lib</literal> into into the <literal>/lib</literal> directory of your new development working directory. It should look like this:"
msgstr "まず最初にすることは開発用のディレクトリをセットアップして、 必要となるすべてのJavaライブラリを配置することです。 HibernateウェブサイトからHibernateディストリビューションをダウンロードしてください。 ファイルを解凍して <literal>/lib</literal> にある必要なライブラリのすべてを、 新しい開発用ディレクトリの <literal>/lib</literal> ディレクトリに配置してください。 このようになっているはずです："

#: index.docbook:52
msgid ""
      "<![CDATA[.\n"
      "+lib\n"
      "  antlr.jar\n"
      "  cglib.jar\n"
      "  asm.jar\n"
      "  asm-attrs.jars\n"
      "  commons-collections.jar\n"
      "  commons-logging.jar\n"
      "  hibernate3.jar\n"
      "  jta.jar\n"
      "  dom4j.jar\n"
      "  log4j.jar ]]>"
msgstr ""
      "<![CDATA[.\n"
      "+lib\n"
      "  antlr.jar\n"
      "  cglib.jar\n"
      "  asm.jar\n"
      "  asm-attrs.jars\n"
      "  commons-collections.jar\n"
      "  commons-logging.jar\n"
      "  hibernate3.jar\n"
      "  jta.jar\n"
      "  dom4j.jar\n"
      "  log4j.jar ]]>"

#: index.docbook:54
msgid "This is the minimum set of required libraries (note that we also copied hibernate3.jar, the main archive) for Hibernate <emphasis>at the time of writing</emphasis>. The Hibernate release you are using might require more or less libraries. See the <literal>README.txt</literal> file in the <literal>lib/</literal> directory of the Hibernate distribution for more information about required and optional third-party libraries. (Actually, Log4j is not required but preferred by many developers.)"
msgstr "これが <emphasis>本ドキュメント執筆時点での</emphasis> Hibernateの必要最低限のライブラリです （メインアーカイブのhibernate3.jarもコピーしていることに注意してください）。 Hibernateのバージョンによってはさらに必要なライブラリや、不要なライブラリがあるかもしれません。 Hibernateディストリビューションの <literal>lib/</literal> ディレクトリにある <literal>README.txt</literal> ファイルを見てください。 必須またはオプションのサードパーティライブラリについての情報を載せています （実際Log4jは必須ではありませんが、多くの開発者が好んでいます）。"

#: index.docbook:63
msgid "Next we create a class that represents the event we want to store in database."
msgstr "次にデータベースに格納するイベントを表すクラスを作成します。"

#: index.docbook:68
msgid "The first class"
msgstr "最初のクラス"

#: index.docbook:70
msgid "Our first persistent class is a simple JavaBean class with some properties:"
msgstr "最初の永続クラスは、プロパティをいくつか持つシンプルなJavaBeanです："

#: index.docbook:74
msgid ""
      "<![CDATA[package events;\n"
      "\n"
      "import java.util.Date;\n"
      "\n"
      "public class Event {\n"
      "    private Long id;\n"
      "\n"
      "    private String title;\n"
      "    private Date date;\n"
      "\n"
      "    public Event() {}\n"
      "\n"
      "    public Long getId() {\n"
      "        return id;\n"
      "    }\n"
      "\n"
      "    private void setId(Long id) {\n"
      "        this.id = id;\n"
      "    }\n"
      "\n"
      "    public Date getDate() {\n"
      "        return date;\n"
      "    }\n"
      "\n"
      "    public void setDate(Date date) {\n"
      "        this.date = date;\n"
      "    }\n"
      "\n"
      "    public String getTitle() {\n"
      "        return title;\n"
      "    }\n"
      "\n"
      "    public void setTitle(String title) {\n"
      "        this.title = title;\n"
      "    }\n"
      "}]]>"
msgstr ""
      "<![CDATA[package events;\n"
      "\n"
      "import java.util.Date;\n"
      "\n"
      "public class Event {\n"
      "    private Long id;\n"
      "\n"
      "    private String title;\n"
      "    private Date date;\n"
      "\n"
      "    public Event() {}\n"
      "\n"
      "    public Long getId() {\n"
      "        return id;\n"
      "    }\n"
      "\n"
      "    private void setId(Long id) {\n"
      "        this.id = id;\n"
      "    }\n"
      "\n"
      "    public Date getDate() {\n"
      "        return date;\n"
      "    }\n"
      "\n"
      "    public void setDate(Date date) {\n"
      "        this.date = date;\n"
      "    }\n"
      "\n"
      "    public String getTitle() {\n"
      "        return title;\n"
      "    }\n"
      "\n"
      "    public void setTitle(String title) {\n"
      "        this.title = title;\n"
      "    }\n"
      "}]]>"

#: index.docbook:76
msgid "You can see that this class uses standard JavaBean naming conventions for property getter and setter methods, as well as private visibility for the fields. This is a recommended design - but not required. Hibernate can also access fields directly, the benefit of accessor methods is robustness for refactoring. The no-argument constructor is required to instantiate an object of this class through reflection."
msgstr "ご覧のとおり、このクラスはフィールドがprivateの可視性を持っているのと同時に、 JavaBean標準のゲッター、セッターメソッドの命名規約に従っています。 このような設計は推奨されていますが必須ではありません。 アクセサメソッドを設けるのはリファクタリングを考えた頑健性のためで、 Hibernateはフィールドに直接アクセスすることも可能です。 引数のないコンストラクタは、リフレクションでこのクラスのインスタンスを作成するために 必要です。"

#: index.docbook:84
msgid "The <literal>id</literal> property holds a unique identifier value for a particular event. All persistent entity classes (there are less important dependent classes as well) will need such an identifier property if we want to use the full feature set of Hibernate. In fact, most applications (esp. web applications) need to distinguish objects by identifier, so you should consider this a feature rather than a limitation. However, we usually don't manipulate the identity of an object, hence the setter method should be private. Only Hibernate will assign identifiers when an object is saved. You can see that Hibernate can access public, private, and protected accessor methods, as well as (public, private, protected) fields directly. The choice is up to you and you can match it to fit your application design."
msgstr "<literal>id</literal> プロパティは、ある特定のイベントに対するユニークな識別子の値を保持します。 Hibernateの完全な機能を使いたければ、すべての永続エンティティクラス （それほど重要ではない依存クラスというものもあります） にこのような識別子プロパティが必要になります。 事実上ほとんどのアプリケーション（特にwebアプリケーション）では、 識別子でオブジェクトを区別する必要があるため、これは制限というよりも特徴であると考えるべきです。 しかし通常オブジェクトのIDを操作するようなことはしません。 そのためセッターメソッドはprivateにするべきです。 Hibernateだけがオブジェクトがセーブされたときに識別子へ値を代入します。 Hibernateが（public, private, protected）フィールドに直接アクセスできるのと同様に、 public, private, protectedのアクセサメソッドにアクセスできるということがわかるでしょう。 選択はあなたに任されているので、あなたのアプリケーションの設計に合わせることができます。"

#: index.docbook:96
msgid "The no-argument constructor is a requirement for all persistent classes; Hibernate has to create objects for you, using Java Reflection. The constructor can be private, however, package visibility is required for runtime proxy generation and efficient data retrieval without bytecode instrumentation."
msgstr "引数のないコンストラクタはすべての永続クラスに必須です。 これはHibernateがJavaのリフレクションを使って、オブジェクトを作成しなければならないためです。 コンストラクタをprivateにすることは可能ですが、 実行時のプロキシ生成と、バイトコード操作なしの効率的なデータの抽出には、 package可視性が必要です。"

#: index.docbook:103
msgid "Place this Java source file in a directory called <literal>src</literal> in the development folder, and in its correct package. The directory should now look like this:"
msgstr "開発フォルダの <literal>src</literal> というディレクトリの適切なパッケージに、 このJavaソースファイルを配置してください。 この時点でディレクトリは以下のようになっているはずです："

#: index.docbook:108
msgid ""
      "<![CDATA[.\n"
      "+lib\n"
      "  <Hibernate and third-party libraries>\n"
      "+src\n"
      "  +events\n"
      "    Event.java]]>"
msgstr ""
      "<![CDATA[.\n"
      "+lib\n"
      "  <Hibernate and third-party libraries>\n"
      "+src\n"
      "  +events\n"
      "    Event.java]]>"

#: index.docbook:110
msgid "In the next step, we tell Hibernate about this persistent class."
msgstr "次のステップでは、Hibernateにこの永続クラスの情報を教えます。"

#: index.docbook:117
msgid "The mapping file"
msgstr "マッピングファイル"

#: index.docbook:119
msgid "Hibernate needs to know how to load and store objects of the persistent class. This is where the Hibernate mapping file comes into play. The mapping file tells Hibernate what table in the database it has to access, and what columns in that table it should use."
msgstr "Hibernateは、どのように永続クラスのオブジェクトをロードし格納すればよいかを知る必要があります。 ここでHibernateマッピングファイルが登場します。 マッピングファイルは、データベース内のどのテーブルにアクセスしなければならないか、 そのテーブルのどのカラムを使うべきかを、Hibernateに教えます。"

#: index.docbook:126
msgid "The basic structure of a mapping file looks like this:"
msgstr "マッピングファイルの基本的な構造はこのようになります："

#: index.docbook:130
msgid ""
      "<![CDATA[<?xml version=\"1.0\"?>\n"
      "<!DOCTYPE hibernate-mapping PUBLIC\n"
      "        \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
      "        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\">\n"
      "\n"
      "<hibernate-mapping>\n"
      "[...]\n"
      "</hibernate-mapping>]]>"
msgstr ""
      "<![CDATA[<?xml version=\"1.0\"?>\n"
      "<!DOCTYPE hibernate-mapping PUBLIC\n"
      "        \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
      "        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\">\n"
      "\n"
      "<hibernate-mapping>\n"
      "[...]\n"
      "</hibernate-mapping>]]>"

#: index.docbook:132
msgid "Note that the Hibernate DTD is very sophisticated. You can use it for auto-completion of XML mapping elements and attributes in your editor or IDE. You also should open up the DTD file in your text editor - it's the easiest way to get an overview of all elements and attributes and to see the defaults, as well as some comments. Note that Hibernate will not load the DTD file from the web, but first look it up from the classpath of the application. The DTD file is included in <literal>hibernate3.jar</literal> as well as in the <literal>src/</literal> directory of the Hibernate distribution."
msgstr "Hibernate DTDが非常に洗練されていることに注目してください。 このDTDは、エディタやIDEでのXMLマッピング要素と属性のオートコンプリーション機能に利用できます。 またDTDファイルをテキストエディタで開けてみてください。 というのも、すべての要素と属性を概観し、 コメントやデフォルトの値を見るには一番簡単な方法だからです。 Hibernateは、webからDTDファイルをロードせずに、 まずアプリケーションのクラスパスからこれを探し出そうとすることに注意してください。 DTDファイルはHibernateディストリビューションの <literal>src/</literal> ディレクトリと同様、<literal>hibernate3.jar</literal> にも含まれています。"

#: index.docbook:143
msgid "We will omit the DTD declaration in future examples to shorten the code. It is of course not optional."
msgstr "以降の例ではコードを短くするためにDTD宣言を省略します。 当然ですがこれはオプションではありません。"

#: index.docbook:148
msgid "Between the two <literal>hibernate-mapping</literal> tags, include a <literal>class</literal> element. All persistent entity classes (again, there might be dependent classes later on, which are not first-class entities) need such a mapping, to a table in the SQL database:"
msgstr "2つの <literal>hibernate-mapping</literal> タグの間に <literal>class</literal> 要素を含めてください。 すべての永続エンティティクラス（念を押しますが、 ファーストクラスのエンティティではない依存クラスというものが後ほど登場します） はSQLデータベース内のテーブルへのこのようなマッピングを必要とします。"

#: index.docbook:155
msgid ""
      "<![CDATA[<hibernate-mapping>\n"
      "\n"
      "    <class name=\"events.Event\" table=\"EVENTS\">\n"
      "\n"
      "    </class>\n"
      "\n"
      "</hibernate-mapping>]]>"
msgstr ""
      "<![CDATA[<hibernate-mapping>\n"
      "\n"
      "    <class name=\"events.Event\" table=\"EVENTS\">\n"
      "\n"
      "    </class>\n"
      "\n"
      "</hibernate-mapping>]]>"

#: index.docbook:157
msgid "So far we told Hibernate how to persist and load object of class <literal>Event</literal> to the table <literal>EVENTS</literal>, each instance represented by a row in that table. Now we continue with a mapping of the unique identifier property to the tables primary key. In addition, as we don't want to care about handling this identifier, we configure Hibernate's identifier generation strategy for a surrogate primary key column:"
msgstr "これまで私たちは、<literal>Event</literal> クラスのオブジェクトを <literal>EVENTS</literal> テーブルに対して、どのように永続化したりロードしたりするのかを Hibernateに教えてきました。そして個々のインスタンスはテーブルの行として表現されます。 それでは引き続きテーブルの主キーに対するユニークな識別子プロパティをマッピングしていきます。 さらに、この識別子の扱いに気を使いたくなかったのと同様に、 代理の主キーカラムに対するHibernateの識別子生成戦略を設定します。"

#: index.docbook:165
msgid ""
      "<![CDATA[<hibernate-mapping>\n"
      "\n"
      "    <class name=\"events.Event\" table=\"EVENTS\">\n"
      "        <id name=\"id\" column=\"EVENT_ID\">\n"
      "            <generator class=\"native\"/>\n"
      "        </id>\n"
      "    </class>\n"
      "\n"
      "</hibernate-mapping>]]>"
msgstr ""
      "<![CDATA[<hibernate-mapping>\n"
      "\n"
      "    <class name=\"events.Event\" table=\"EVENTS\">\n"
      "        <id name=\"id\" column=\"EVENT_ID\">\n"
      "            <generator class=\"native\"/>\n"
      "        </id>\n"
      "    </class>\n"
      "\n"
      "</hibernate-mapping>]]>"

#: index.docbook:167
msgid "The <literal>id</literal> element is the declaration of the identifer property, <literal>name=\"id\"</literal> declares the name of the Java property - Hibernate will use the getter and setter methods to access the property. The column attribute tells Hibernate which column of the <literal>EVENTS</literal> table we use for this primary key. The nested <literal>generator</literal> element specifies the identifier generation strategy, in this case we used <literal>native</literal>, which picks the best strategy depending on the configured database (dialect). Hibernate supports database generated, globally unique, as well as application assigned identifiers (or any strategy you have written an extension for)."
msgstr "<literal>id</literal> 要素は識別子プロパティの宣言であり、 <literal>name=\"id\"</literal> でJavaプロパティの名前を宣言します。 Hibernateはこのプロパティへアクセスするためにゲッター、セッターメソッドを使います。 カラム属性では <literal>EVENTS</literal> テーブルのどのカラムを主キーとして使うのかを Hibernateに教えます。 入れ子になっている <literal>generator</literal> 要素は、識別子を生成する時の戦略を指定します。 （この例では <literal>native</literal> を用いました）。 この要素は、設定したデータベース（dialect）に対する最良な識別子生成戦略を選定するものです。 Hibernateは、アプリケーションで値を割り当てる戦略（もしくは独自に拡張した戦略）と同様に、 グローバルにユニークな値をデータベースに生成させる戦略もサポートしています。"

#: index.docbook:180
msgid "Finally we include declarations for the persistent properties of the class in the mapping file. By default, no properties of the class are considered persistent:"
msgstr "最後にクラスの永続プロパティの宣言をマッピングファイルに含めます。 デフォルトでは、クラスのプロパティは永続と見なされません："

#: index.docbook:186
msgid ""
      "<![CDATA[\n"
      "<hibernate-mapping>\n"
      "\n"
      "    <class name=\"events.Event\" table=\"EVENTS\">\n"
      "        <id name=\"id\" column=\"EVENT_ID\">\n"
      "            <generator class=\"native\"/>\n"
      "        </id>\n"
      "        <property name=\"date\" type=\"timestamp\" column=\"EVENT_DATE\"/>\n"
      "        <property name=\"title\"/>\n"
      "    </class>\n"
      "\n"
      "</hibernate-mapping>]]>"
msgstr ""
      "<![CDATA[\n"
      "<hibernate-mapping>\n"
      "\n"
      "    <class name=\"events.Event\" table=\"EVENTS\">\n"
      "        <id name=\"id\" column=\"EVENT_ID\">\n"
      "            <generator class=\"native\"/>\n"
      "        </id>\n"
      "        <property name=\"date\" type=\"timestamp\" column=\"EVENT_DATE\"/>\n"
      "        <property name=\"title\"/>\n"
      "    </class>\n"
      "\n"
      "</hibernate-mapping>]]>"

#: index.docbook:188
msgid "Just as with the <literal>id</literal> element, the <literal>name</literal> attribute of the <literal>property</literal> element tells Hibernate which getter and setter methods to use. So, in this case, Hibernate will look for <literal>getDate()/setDate()</literal>, as well as <literal>getTitle()/setTitle()</literal>."
msgstr "<literal>id</literal> 要素の場合と同様に、 <literal>property</literal> 要素の <literal>name</literal> 属性で、どのゲッターとセッターメソッドを使うべきかをHibernateに教えます。 この例では、Hibernateは <literal>getDate()/setDate()</literal> と <literal>getTitle()/setTitle()</literal> を 探します。"

#: index.docbook:195
msgid "Why does the <literal>date</literal> property mapping include the <literal>column</literal> attribute, but the <literal>title</literal> doesn't? Without the <literal>column</literal> attribute Hibernate by default uses the property name as the column name. This works fine for <literal>title</literal>. However, <literal>date</literal> is a reserved keyword in most database, so we better map it to a different name."
msgstr "なぜ <literal>date</literal> プロパティのマッピングには <literal>column</literal> 属性があり、<literal>title</literal> プロパティにはないのでしょうか？ <literal>column</literal> 属性がなければ、Hibernateはプロパティ名をカラム名として使います。 これは <literal>title</literal> では上手く行きます。 しかし <literal>date</literal> はほとんどのデータベースで予約語なので、 違う名前でマッピングした方がよいのです。"

#: index.docbook:204
msgid "The next interesting thing is that the <literal>title</literal> mapping also lacks a <literal>type</literal> attribute. The types we declare and use in the mapping files are not, as you might expect, Java data types. They are also not SQL database types. These types are so called <emphasis>Hibernate mapping types</emphasis>, converters which can translate from Java to SQL data types and vice versa. Again, Hibernate will try to determine the correct conversion and mapping type itself if the <literal>type</literal> attribute is not present in the mapping. In some cases this automatic detection (using Reflection on the Java class) might not have the default you expect or need. This is the case with the <literal>date</literal> property. Hibernate can't know if the property (which is of <literal>java.util.Date</literal>) should map to a SQL <literal>date</literal>, <literal>timestamp</literal>, or <literal>time</literal> column. We preserve full date and time information by mapping the property with a <literal>timestamp</literal> converter."
msgstr "次に興味深いのは <literal>title</literal> マッピングが <literal>type</literal> 属性をも欠いている点です。 マッピングファイルで宣言して使うtypeは、おわかりかもしれませんがJavaのデータ型ではありません。 SQLデータベースの型でもありません。 これは <emphasis>Hibernateマッピング型</emphasis> と呼ばれる、 JavaからSQLデータの型へまたはSQLからJavaデータ型へ翻訳するコンバータです。 繰り返しになりますが、Hibernateは <literal>type</literal> 属性がマッピングファイル内になければ、 正しいコンバージョンとマッピング型を自分で解決しようとします。 （Javaクラスのリフレクションを使った）この自動検知は、 場合によってはあなたが期待または必要とするデフォルト値にならないかもしれません。 <literal>date</literal> プロパティの場合がそうでした。 Hibernateはこの（ <literal>java.util.Date</literal> の）プロパティを SQLの <literal>date</literal> , <literal>timestamp</literal> , <literal>time</literal> のうち、どのカラムにマッピングするべきなのかわかりません。 <literal>timestamp</literal> コンバータでプロパティをマッピングすることにより、完全な日時を保存します。"

#: index.docbook:220
msgid "This mapping file should be saved as <literal>Event.hbm.xml</literal>, right in the directory next to the <literal>Event</literal> Java class source file. The naming of mapping files can be arbitrary, however the <literal>hbm.xml</literal> suffix is a convention in the Hibernate developer community. The directory structure should now look like this:"
msgstr "このマッピングファイルは、<literal>Event.hbm.xml</literal> として <literal>Event</literal> Javaクラスソースファイルのすぐ隣にセーブするべきです。 マッピングファイルの命名方法は任意ですが、<literal>hbm.xml</literal> サフィックスがHibernateの開発者のコミュニティ内での習慣となっています。 現在ディレクトリ構造はこのようになっているはずです："

#: index.docbook:228
msgid ""
      "<![CDATA[.\n"
      "+lib\n"
      "  <Hibernate and third-party libraries>\n"
      "+src\n"
      "  +events\n"
      "    Event.java\n"
      "    Event.hbm.xml]]>"
msgstr ""
      "<![CDATA[.\n"
      "+lib\n"
      "  <Hibernate and third-party libraries>\n"
      "+src\n"
      "  +events\n"
      "    Event.java\n"
      "    Event.hbm.xml]]>"

#: index.docbook:230
msgid "We continue with the main configuration of Hibernate."
msgstr "Hibernateの主要な設定を続けます。"

#: index.docbook:237
msgid "Hibernate configuration"
msgstr "Hibernateの設定"

#: index.docbook:239
msgid "We now have a persistent class and its mapping file in place. It is time to configure Hibernate. Before we do this, we will need a database. HSQL DB, a java-based SQL DBMS, can be downloaded from the HSQL DB website(http://hsqldb.org/). Actually, you only need the <literal>hsqldb.jar</literal> from this download. Place this file in the <literal>lib/</literal> directory of the development folder."
msgstr "ここまでで永続クラスとマッピングファイルが揃いました。これからHibernateの設定を行いますが、 その前にデータベースが必要です。 HSQL DBはJavaベースのインメモリSQL DBMSであり、HSQL DBウェブサイトからダウンロードできます。 実際にはダウンロードした中の <literal>hsqldb.jar</literal> だけが必要です。 このファイルを開発フォルダの <literal>lib/</literal> ディレクトリに配置してください。"

#: index.docbook:247
msgid "Create a directory called <literal>data</literal> in the root of the development directory - this is where HSQL DB will store its data files. Now start the database by running <literal>java -classpath ../lib/hsqldb.jar org.hsqldb.Server</literal> in this data directory. You can see it start up and bind to a TCP/IP socket, this is where our application will connect later. If you want to start with a fresh database during this tutorial, shutdown HSQL DB (press <literal>CTRL + C</literal> in the window), delete all files in the <literal>data/</literal> directory, and start HSQL DB again."
msgstr "<literal>data</literal> というディレクトリを開発ディレクトリのルートに作成してください。 HSQL DBはここにデータファイルを格納します。 このデータディレクトリにおいて <literal>java -classpath lib/hsqldb.jar org.hsqldb.Server</literal> を実行し、 データベースを起動させてください。 動作の開始と、TCP/IPソケットのバインドが確認できます。 後ほど作成するアプリケーションはここに接続します。 もしこのチュートリアル中にデータベースを初期化したければ、 HSQL DBをシャットダウンして（作業ウィンドウで <literal>CTRL + C</literal> を押します） <literal>data/</literal> ディレクトリ内のファイルを全て消去した後、 HSQL DBを再起動します。"

#: index.docbook:257
msgid "Hibernate is the layer in your application which connects to this database, so it needs connection information. The connections are made through a JDBC connection pool, which we also have to configure. The Hibernate distribution contains several open source JDBC connection pooling tools, but will use the Hibernate built-in connection pool for this tutorial. Note that you have to copy the required library into your classpath and use different connection pooling settings if you want to use a production-quality third party JDBC pooling software."
msgstr "Hibernateはアプリケーションのデータベースに接続する層なので、 コネクションの情報が必要になります。 コネクションはJDBCコネクションプールを通じて行われますが、これも設定する必要があります。 HibernateディストリビューションにはいくつかのオープンソースのJDBCコネクションプールツールが含まれていますが、 このチュートリアルではHibernateに組み込まれたコネクションプールを使います。 もし製品レベルの品質のサードパーティJDBCコネクションプールソフトウェアを使いたければ、 クラスパスに必要なライブラリをコピーして、異なるコネクションプールを設定しなければ ならないことに注意してください。"

#: index.docbook:267
msgid "For Hibernate's configuration, we can use a simple <literal>hibernate.properties</literal> file, a slightly more sophisticated <literal>hibernate.cfg.xml</literal> file, or even complete programmatic setup. Most users prefer the XML configuration file:"
msgstr "Hibernateの設定では、単純な <literal>hibernate.properties</literal> ファイル、 それより少し洗練されている <literal>hibernate.cfg.xml</literal> ファイル、 または完全にプログラム上でセットアップする方法が利用できます。 ほとんどのユーザが好むのはXML設定ファイルです："

#: index.docbook:273
msgid ""
      "<![CDATA[<?xml version='1.0' encoding='utf-8'?>\n"
      "<!DOCTYPE hibernate-configuration PUBLIC\n"
      "        \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n"
      "        \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\">\n"
      "\n"
      "<hibernate-configuration>\n"
      "\n"
      "    <session-factory>\n"
      "\n"
      "        <!-- Database connection settings -->\n"
      "        <property name=\"connection.driver_class\">org.hsqldb.jdbcDriver</property>\n"
      "        <property name=\"connection.url\">jdbc:hsqldb:hsql://localhost</property>\n"
      "        <property name=\"connection.username\">sa</property>\n"
      "        <property name=\"connection.password\"></property>\n"
      "\n"
      "        <!-- JDBC connection pool (use the built-in) -->\n"
      "        <property name=\"connection.pool_size\">1</property>\n"
      "\n"
      "        <!-- SQL dialect -->\n"
      "        <property name=\"dialect\">org.hibernate.dialect.HSQLDialect</property>\n"
      "\n"
      "        <!-- Enable Hibernate's automatic session context management -->\n"
      "        <property name=\"current_session_context_class\">thread</property>\n"
      "\n"
      "        <!-- Disable the second-level cache  -->\n"
      "        <property name=\"cache.provider_class\">org.hibernate.cache.NoCacheProvider</property>\n"
      "\n"
      "        <!-- Echo all executed SQL to stdout -->\n"
      "        <property name=\"show_sql\">true</property>\n"
      "\n"
      "        <!-- Drop and re-create the database schema on startup -->\n"
      "        <property name=\"hbm2ddl.auto\">create</property>\n"
      "\n"
      "        <mapping resource=\"events/Event.hbm.xml\"/>\n"
      "\n"
      "    </session-factory>\n"
      "\n"
      "</hibernate-configuration>]]>"
msgstr ""
      "<![CDATA[<?xml version='1.0' encoding='utf-8'?>\n"
      "<!DOCTYPE hibernate-configuration PUBLIC\n"
      "        \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n"
      "        \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\">\n"
      "\n"
      "<hibernate-configuration>\n"
      "\n"
      "    <session-factory>\n"
      "\n"
      "        <!-- Database connection settings -->\n"
      "        <property name=\"connection.driver_class\">org.hsqldb.jdbcDriver</property>\n"
      "        <property name=\"connection.url\">jdbc:hsqldb:hsql://localhost</property>\n"
      "        <property name=\"connection.username\">sa</property>\n"
      "        <property name=\"connection.password\"></property>\n"
      "\n"
      "        <!-- JDBC connection pool (use the built-in) -->\n"
      "        <property name=\"connection.pool_size\">1</property>\n"
      "\n"
      "        <!-- SQL dialect -->\n"
      "        <property name=\"dialect\">org.hibernate.dialect.HSQLDialect</property>\n"
      "\n"
      "        <!-- Enable Hibernate's automatic session context management -->\n"
      "        <property name=\"current_session_context_class\">thread</property>\n"
      "\n"
      "        <!-- Disable the second-level cache  -->\n"
      "        <property name=\"cache.provider_class\">org.hibernate.cache.NoCacheProvider</property>\n"
      "\n"
      "        <!-- Echo all executed SQL to stdout -->\n"
      "        <property name=\"show_sql\">true</property>\n"
      "\n"
      "        <!-- Drop and re-create the database schema on startup -->\n"
      "        <property name=\"hbm2ddl.auto\">create</property>\n"
      "\n"
      "        <mapping resource=\"events/Event.hbm.xml\"/>\n"
      "\n"
      "    </session-factory>\n"
      "\n"
      "</hibernate-configuration>]]>"

#: index.docbook:275
msgid "Note that this XML configuration uses a different DTD. We configure Hibernate's <literal>SessionFactory</literal> - a global factory responsible for a particular database. If you have several databases, use several <literal>&lt;session-factory&gt;</literal> configurations, usually in several configuration files (for easier startup)."
msgstr "このXMLの設定が異なるDTDを使うことに注意してください。 特定のデータベースを受け持つグローバルファクトリであるHibernateの <literal>SessionFactory</literal> を設定します。 もし複数のデータベースがある場合には、 （スタートアップを簡単にするため）通常いくつかの設定ファイル内で、 いくつかの <literal>&lt;session-factory&gt;</literal> を使う設定にしてください。"

#: index.docbook:283
msgid "The first four <literal>property</literal> elements contain the necessary configuration for the JDBC connection. The dialect <literal>property</literal> element specifies the particular SQL variant Hibernate generates. Hibernate's automatic session management for persistence contexts will come in handy as you will soon see. The <literal>hbm2ddl.auto</literal> option turns on automatic generation of database schemas - directly into the database. This can of course also be turned off (by removing the config option) or redirected to a file with the help of the <literal>SchemaExport</literal> Ant task. Finally, we add the mapping file(s) for persistent classes to the configuration."
msgstr "最初の4つの <literal>property</literal> 要素はJDBCコネクションに必要な設定を含んでいます。 dialectという名前の <literal>property</literal> 要素は、Hibernateが生成する特定のSQL方言を指定します。 永続的なコンテキストに対するHibernateのセッションの自動管理は、後の例ですぐにわかるように、役に立つことでしょう。 <literal>hbm2ddl.auto</literal> オプションはデータベーススキーマの自動生成をonにします。 これは直接データベースに対して生成されます。 当然（configオプションを削除して）offにしたり、 <literal>SchemaExport</literal> というAntタスクの助けを借りてファイルにリダイレクトしたりできます。 最後に永続クラスのためのマッピングファイルを設定に追加します。"

#: index.docbook:296
msgid "Copy this file into the source directory, so it will end up in the root of the classpath. Hibernate automatically looks for a file called <literal>hibernate.cfg.xml</literal> in the root of the classpath, on startup."
msgstr "このファイルをソースディレクトリにコピーしてください。 するとこれはクラスパスのルートにあることになります。 Hibernateは、スタートアップ時にクラスパスのルートで <literal>hibernate.cfg.xml</literal> というファイルを自動的に探します。"

#: index.docbook:305
msgid "Building with Ant"
msgstr "Antによるビルド"

#: index.docbook:307
msgid "We'll now build the tutorial with Ant. You will need to have Ant installed - get it from the <ulink url=\"http://ant.apache.org/bindownload.cgi\">Ant download page</ulink>. How to install Ant will not be covered here. Please refer to the <ulink url=\"http://ant.apache.org/manual/index.html\">Ant manual</ulink>. After you have installed Ant, we can start to create the buildfile. It will be called <literal>build.xml</literal> and placed directly in the development directory."
msgstr "それではAntを使ってチュートリアルをビルドしましょう。 それにはAntがインストールされていなければなりません。 <ulink url=\"http://ant.apache.org/bindownload.cgi\">Antダウンロードページ</ulink> からダウンロードしてください。 Antのインストール方法はここでは説明しませんので、 <ulink url=\"http://ant.apache.org/manual/index.html\">Antマニュアル</ulink> を参照してください。 Antをインストールすれば、ビルドファイルの作成を開始できます。 このファイルは <literal>build.xml</literal> と呼ばれ、開発ディレクトリに直接配置します。"

#: index.docbook:316
msgid "A basic build file looks like this:"
msgstr "基本的なビルドファイルはこのようになります："

#: index.docbook:320
msgid ""
      "<![CDATA[<project name=\"hibernate-tutorial\" default=\"compile\">\n"
      "\n"
      "    <property name=\"sourcedir\" value=\"${basedir}/src\"/>\n"
      "    <property name=\"targetdir\" value=\"${basedir}/bin\"/>\n"
      "    <property name=\"librarydir\" value=\"${basedir}/lib\"/>\n"
      "\n"
      "    <path id=\"libraries\">\n"
      "        <fileset dir=\"${librarydir}\">\n"
      "            <include name=\"*.jar\"/>\n"
      "        </fileset>\n"
      "    </path>\n"
      "\n"
      "    <target name=\"clean\">\n"
      "        <delete dir=\"${targetdir}\"/>\n"
      "        <mkdir dir=\"${targetdir}\"/>\n"
      "    </target>\n"
      "\n"
      "    <target name=\"compile\" depends=\"clean, copy-resources\">\n"
      "      <javac srcdir=\"${sourcedir}\"\n"
      "             destdir=\"${targetdir}\"\n"
      "             classpathref=\"libraries\"/>\n"
      "    </target>\n"
      "\n"
      "    <target name=\"copy-resources\">\n"
      "        <copy todir=\"${targetdir}\">\n"
      "            <fileset dir=\"${sourcedir}\">\n"
      "                <exclude name=\"**/*.java\"/>\n"
      "            </fileset>\n"
      "        </copy>\n"
      "    </target>\n"
      "\n"
      "</project>]]>"
msgstr ""
      "<![CDATA[<project name=\"hibernate-tutorial\" default=\"compile\">\n"
      "\n"
      "    <property name=\"sourcedir\" value=\"${basedir}/src\"/>\n"
      "    <property name=\"targetdir\" value=\"${basedir}/bin\"/>\n"
      "    <property name=\"librarydir\" value=\"${basedir}/lib\"/>\n"
      "\n"
      "    <path id=\"libraries\">\n"
      "        <fileset dir=\"${librarydir}\">\n"
      "            <include name=\"*.jar\"/>\n"
      "        </fileset>\n"
      "    </path>\n"
      "\n"
      "    <target name=\"clean\">\n"
      "        <delete dir=\"${targetdir}\"/>\n"
      "        <mkdir dir=\"${targetdir}\"/>\n"
      "    </target>\n"
      "\n"
      "    <target name=\"compile\" depends=\"clean, copy-resources\">\n"
      "      <javac srcdir=\"${sourcedir}\"\n"
      "             destdir=\"${targetdir}\"\n"
      "             classpathref=\"libraries\"/>\n"
      "    </target>\n"
      "\n"
      "    <target name=\"copy-resources\">\n"
      "        <copy todir=\"${targetdir}\">\n"
      "            <fileset dir=\"${sourcedir}\">\n"
      "                <exclude name=\"**/*.java\"/>\n"
      "            </fileset>\n"
      "        </copy>\n"
      "    </target>\n"
      "\n"
      "</project>]]>"

#: index.docbook:322
msgid "This will tell Ant to add all files in the lib directory ending with <literal>.jar</literal> to the classpath used for compilation. It will also copy all non-Java source files to the target directory, e.g. configuration and Hibernate mapping files. If you now run Ant, you should get this output:"
msgstr "これは <literal>.jar</literal> で終わるlibディレクトリのすべてのファイルを、 コンパイルに使用するクラスパスに追加することをAntに教えます。 また、Javaソースファイルでないすべてのファイルをターゲットディレクトリにコピーするということでもあります。 例えば設定ファイルやHibernateマッピングファイルなどです。 今Antを実行すると、このような出力があるはずです："

#: index.docbook:329
msgid ""
      "<![CDATA[C:\\hibernateTutorial\\>ant\n"
      "Buildfile: build.xml\n"
      "\n"
      "copy-resources:\n"
      "     [copy] Copying 2 files to C:\\hibernateTutorial\\bin\n"
      "\n"
      "compile:\n"
      "    [javac] Compiling 1 source file to C:\\hibernateTutorial\\bin\n"
      "\n"
      "BUILD SUCCESSFUL\n"
      "Total time: 1 second ]]>"
msgstr ""
      "<![CDATA[C:¥hibernateTutorial¥>ant\n"
      "Buildfile: build.xml\n"
      "\n"
      "copy-resources:\n"
      "     [copy] Copying 2 files to C:¥hibernateTutorial¥bin\n"
      "\n"
      "compile:\n"
      "    [javac] Compiling 1 source file to C:¥hibernateTutorial¥bin\n"
      "\n"
      "BUILD SUCCESSFUL\n"
      "Total time: 1 second ]]>"

#: index.docbook:334
msgid "Startup and helpers"
msgstr "スタートアップとヘルパ"

#: index.docbook:336
msgid "It's time to load and store some <literal>Event</literal> objects, but first we have to complete the setup with some infrastructure code. We have to startup Hibernate. This startup includes building a global <literal>SessionFactory</literal> object and to store it somewhere for easy access in application code. A <literal>SessionFactory</literal> can open up new <literal>Session</literal>'s. A <literal>Session</literal> represents a single-threaded unit of work, the <literal>SessionFactory</literal> is a thread-safe global object, instantiated once."
msgstr "さて <literal>Event</literal> オブジェクトをロードしたり格納したりする準備ができました。 しかしまずはインフラストラクチャのコードを書いて、セットアップを完了する必要があります。 まずはHibernateをスタートアップしなければなりません。 このスタートアップには、グローバルの <literal>SessionFactory</literal> オブジェクトを生成して、 それをアプリケーションのコードでアクセスしやすい場所に格納することが含まれます。 <literal>SessionFactory</literal> は新しく <literal>Session</literal> をオープンすることができます。 <literal>Session</literal> はシングルスレッドの作業単位(Unit of Work)を表現します。 それに対し<literal>SessionFactory</literal> はスレッドセーフのグローバルオブジェクトであり、 一度だけインスタンス化されます。"

#: index.docbook:346
msgid "We'll create a <literal>HibernateUtil</literal> helper class which takes care of startup and makes accessing a <literal>SessionFactory</literal> convenient. Let's have a look at the implementation:"
msgstr "ここでスタートアップを行い、 便利に <literal>SessionFactory</literal> へアクセスする <literal>HibernateUtil</literal> ヘルパクラスを作成します。 実装を見てみましょう："

#: index.docbook:352
msgid ""
      "<![CDATA[package util;\n"
      "\n"
      "import org.hibernate.*;\n"
      "import org.hibernate.cfg.*;\n"
      "\n"
      "public class HibernateUtil {\n"
      "\n"
      "    private static final SessionFactory sessionFactory;\n"
      "\n"
      "    static {\n"
      "        try {\n"
      "            // Create the SessionFactory from hibernate.cfg.xml\n"
      "            sessionFactory = new Configuration().configure().buildSessionFactory();\n"
      "        } catch (Throwable ex) {\n"
      "            // Make sure you log the exception, as it might be swallowed\n"
      "            System.err.println(\"Initial SessionFactory creation failed.\" + ex);\n"
      "            throw new ExceptionInInitializerError(ex);\n"
      "        }\n"
      "    }\n"
      "\n"
      "    public static SessionFactory getSessionFactory() {\n"
      "        return sessionFactory;\n"
      "    }\n"
      "\n"
      "}]]>"
msgstr ""
      "<![CDATA[package util;\n"
      "\n"
      "import org.hibernate.*;\n"
      "import org.hibernate.cfg.*;\n"
      "\n"
      "public class HibernateUtil {\n"
      "\n"
      "    private static final SessionFactory sessionFactory;\n"
      "\n"
      "    static {\n"
      "        try {\n"
      "            // Create the SessionFactory from hibernate.cfg.xml\n"
      "            sessionFactory = new Configuration().configure().buildSessionFactory();\n"
      "        } catch (Throwable ex) {\n"
      "            // Make sure you log the exception, as it might be swallowed\n"
      "            System.err.println(\"Initial SessionFactory creation failed.\" + ex);\n"
      "            throw new ExceptionInInitializerError(ex);\n"
      "        }\n"
      "    }\n"
      "\n"
      "    public static SessionFactory getSessionFactory() {\n"
      "        return sessionFactory;\n"
      "    }\n"
      "\n"
      "}]]>"

#: index.docbook:354
msgid "This class does not only produce the global <literal>SessionFactory</literal> in its static initializer (called once by the JVM when the class is loaded), but also hides the fact that it uses a static singleton. It might as well lookup the <literal>SessionFactory</literal> from JNDI in an application server."
msgstr "このクラスは静的初期化ブロック（クラスがロードされるときにJVMによって一度だけ呼ばれる） でグローバルの <literal>SessionFactory</literal> を生成するだけではなく、 静的シングルトンの使用を隠蔽します。 アプリケーションサーバーのJNDIから <literal>SessionFactory</literal> を ルックアップするのと同様です。"

#: index.docbook:361
msgid "If you give the <literal>SessionFactory</literal> a name in your configuration file, Hibernate will in fact try to bind it to JNDI after it has been built. To avoid this code completely you could also use JMX deployment and let the JMX-capable container instantiate and bind a <literal>HibernateService</literal> to JNDI. These advanced options are discussed in the Hibernate reference documentation."
msgstr "設定ファイル内で <literal>SessionFactory</literal> に名前を与えると、 Hibernateは <literal>SessionFactory</literal> 構築後にJNDIに対しバインドを行おうとします。 このコードを完全に排除するためには、 JMXデプロイメントを利用して JMXを利用できるコンテナをインスタンス化し、 <literal>HibernateService</literal> をJNDIへバインドすることもできます。 これらの高度なオプションは、Hibernateのリファレンスドキュメントで説明されています。"

#: index.docbook:370
msgid "Place <literal>HibernateUtil.java</literal> in the development source directory, in a package next to <literal>events</literal>:"
msgstr "<literal>HibernateUtil.java</literal> を開発ソースディレクトリにある <literal>events</literal> パッケージの 隣に配置してください。"

#: index.docbook:375
msgid ""
      "<![CDATA[.\n"
      "+lib\n"
      "  <Hibernate and third-party libraries>\n"
      "+src\n"
      "  +events\n"
      "    Event.java\n"
      "    Event.hbm.xml\n"
      "  +util\n"
      "    HibernateUtil.java\n"
      "  hibernate.cfg.xml\n"
      "+data\n"
      "build.xml]]>"
msgstr ""
      "<![CDATA[.\n"
      "+lib\n"
      "  <Hibernate and third-party libraries>\n"
      "+src\n"
      "  +events\n"
      "    Event.java\n"
      "    Event.hbm.xml\n"
      "  +util\n"
      "    HibernateUtil.java\n"
      "  hibernate.cfg.xml\n"
      "+data\n"
      "build.xml]]>"

#: index.docbook:377
msgid "This should again compile without problems. We finally need to configure a logging system - Hibernate uses commons logging and leaves you the choice between Log4j and JDK 1.4 logging. Most developers prefer Log4j: copy <literal>log4j.properties</literal> from the Hibernate distribution (it's in the <literal>etc/</literal> directory) to your <literal>src</literal> directory, next to <literal>hibernate.cfg.xml</literal>. Have a look at the example configuration and change the settings if you like to have more verbose output. By default, only Hibernate startup message are shown on stdout."
msgstr "これは問題なく再コンパイルできるはずです。 最後にロギングシステムを設定する必要があります。 Hibernateはcommons loggingを使うため、Log4jとJDK 1.4 loggingの選択をする必要がありません。 ほとんどの開発者が好むのはLog4jです。 Hibernateディストリビューション（の<literal>etc/</literal> ディレクトリ）から <literal>log4j.properties</literal> をあなたの <literal>src</literal> ディレクトリ内の <literal>hibernate.cfg.xml</literal> の隣にコピーしてください。 設定例を見て、冗長な出力がよければ設定を変更してください。 デフォルトではHibernateのスタートアップメッセージだけが標準出力に表示されます。"

#: index.docbook:387
msgid "The tutorial infrastructure is complete - and we are ready to do some real work with Hibernate."
msgstr "チュートリアルのインフラは完全です。 Hibernateを使って実際の作業をする準備が整いました。"

#: index.docbook:395
msgid "Loading and storing objects"
msgstr "オブジェクトのロードと格納"

#: index.docbook:397
msgid "Finally, we can use Hibernate to load and store objects. We write an <literal>EventManager</literal> class with a <literal>main()</literal> method:"
msgstr "ついにオブジェクトのロードと格納にHibernateを使うことができます。 <literal>main()</literal> メソッドを持つ <literal>EventManager</literal> クラスを書きます："

#: index.docbook:402
msgid ""
      "<![CDATA[package events;\n"
      "import org.hibernate.Session;\n"
      "\n"
      "import java.util.Date;\n"
      "\n"
      "import util.HibernateUtil;\n"
      "\n"
      "public class EventManager {\n"
      "\n"
      "    public static void main(String[] args) {\n"
      "        EventManager mgr = new EventManager();\n"
      "\n"
      "        if (args[0].equals(\"store\")) {\n"
      "            mgr.createAndStoreEvent(\"My Event\", new Date());\n"
      "        }\n"
      "\n"
      "        HibernateUtil.getSessionFactory().close();\n"
      "    }\n"
      "\n"
      "    private void createAndStoreEvent(String title, Date theDate) {\n"
      "\n"
      "        Session session = HibernateUtil.getSessionFactory().getCurrentSession();\n"
      "\n"
      "        session.beginTransaction();\n"
      "\n"
      "        Event theEvent = new Event();\n"
      "        theEvent.setTitle(title);\n"
      "        theEvent.setDate(theDate);\n"
      "\n"
      "        session.save(theEvent);\n"
      "\n"
      "        session.getTransaction().commit();\n"
      "    }\n"
      "\n"
      "}]]>"
msgstr ""
      "<![CDATA[package events;\n"
      "import org.hibernate.Session;\n"
      "\n"
      "import java.util.Date;\n"
      "\n"
      "import util.HibernateUtil;\n"
      "\n"
      "public class EventManager {\n"
      "\n"
      "    public static void main(String[] args) {\n"
      "        EventManager mgr = new EventManager();\n"
      "\n"
      "        if (args[0].equals(\"store\")) {\n"
      "            mgr.createAndStoreEvent(\"My Event\", new Date());\n"
      "        }\n"
      "\n"
      "        HibernateUtil.getSessionFactory().close();\n"
      "    }\n"
      "\n"
      "    private void createAndStoreEvent(String title, Date theDate) {\n"
      "\n"
      "        Session session = HibernateUtil.getSessionFactory().getCurrentSession();\n"
      "\n"
      "        session.beginTransaction();\n"
      "\n"
      "        Event theEvent = new Event();\n"
      "        theEvent.setTitle(title);\n"
      "        theEvent.setDate(theDate);\n"
      "\n"
      "        session.save(theEvent);\n"
      "\n"
      "        session.getTransaction().commit();\n"
      "    }\n"
      "\n"
      "}]]>"

#: index.docbook:404
msgid "We create a new <literal>Event</literal> object, and hand it over to Hibernate. Hibernate now takes care of the SQL and executes <literal>INSERT</literal>s on the database. Let's have a look at the <literal>Session</literal> and <literal>Transaction</literal>-handling code before we run this."
msgstr "新しい <literal>Event</literal> オブジェクトを生成し、それをHibernateに渡します。 今ではHibernateがSQLを処理し、データベースで <literal>INSERT</literal> を実行します。 実行前に <literal>Session</literal> と <literal>Transaction</literal> を処理するコードを確認してください。"

#: index.docbook:411
msgid "A <literal>Session</literal> is a single unit of work. For now we'll keep things simple and assume a one-to-one granularity between a Hibernate <literal>Session</literal> and a database transaction. To shield our code from the actual underlying transaction system (in this case plain JDBC, but it could also run with JTA) we use the <literal>Transaction</literal> API that is available on the Hibernate <literal>Session</literal>."
msgstr "<literal>Session</literal> は1つの作業単位(Unit of Work)です。 当分の間、話を簡単にするために、 <literal>Session</literal> と <literal>Transaction</literal> の対応を一対一と仮定します。 使用しているトランザクション・システム（このケースではJTAと共存できる単純なJDBC）からコードを保護するために、 Hibernate <literal>Session</literal> 上で利用可能な <literal>Transaction</literal> APIを使用します。"

#: index.docbook:419
msgid "What does <literal>sessionFactory.getCurrentSession()</literal> do? First, you can call it as many times and anywhere you like, once you get hold of your <literal>SessionFactory</literal> (easy thanks to <literal>HibernateUtil</literal>). The <literal>getCurrentSession()</literal> method always returns the \"current\" unit of work. Remember that we switched the configuration option for this mechanism to \"thread\" in <literal>hibernate.cfg.xml</literal>? Hence, the current unit of work is bound to the current Java thread that executes our application. However, this is not the full picture, you also have to consider scope, when a unit of work begins and when it ends."
msgstr "<literal>sessionFactory.getCurrentSession()</literal> はなにをするのでしょうか？ まず、いったん <literal>SessionFactory</literal> を取得し保持すれば （ <literal>HibernateUtil</literal> のおかげで簡単です）、このメソッドを何度でも、 どこからでも呼び出すことが出来ます。 <literal>getCurrentSession()</literal> メソッドは常に「現在の」作業単位(Unit of Work)を返します。 <literal>hibernate.cfg.xml</literal> のこの機能の設定で、\"thread\"を指定したことを思い出してください。 このため現在の作業単位のスコープは、このアプリケーションを実行する現在のJavaスレッドです。 しかしこれで全てではありません。 <literal>Session</literal> は最初に必要となったとき、つまり最初に <literal>getCurrentSession()</literal> が 呼ばれたときに開始します。 そのときHibernateにより現在のスレッドに結び付けられます。 トランザクションが終了（コミットもしくはロールバック）したとき、 Hibernateもスレッドから <literal>Session</literal> を切り離し、クローズします。 再び <literal>getCurrentSession()</literal> を呼ぶと、 新しい <literal>Session</literal> を取得して新しい作業単位をスタートできます。 この <emphasis>thread-bound</emphasis> プログラミング・モデルはHibernateを利用する上で最も人気があります。"

#: index.docbook:430
msgid "A <literal>Session</literal> begins when it is first needed, when the first call to <literal>getCurrentSession()</literal> is made. It is then bound by Hibernate to the current thread. When the transaction ends, either through commit or rollback, Hibernate automatically unbinds the <literal>Session</literal> from the thread and closes it for you. If you call <literal>getCurrentSession()</literal> again, you get a new <literal>Session</literal> and can start a new unit of work. This <emphasis>thread-bound</emphasis> programming model is the most popular way of using Hibernate, as it allows flexible layering of your code (transaction demarcation code can be separated from data access code, we'll do this later in this tutorial)."
msgstr "トランザクションの扱いと境界の詳しい情報については、 <xref linkend=\"transactions\"/> を見てください。 この例ではエラー処理やロールバックも割愛します。"

#: index.docbook:441
msgid "Related to the unit of work scope, should the Hibernate <literal>Session</literal> be used to execute one or several database operations? The above example uses one <literal>Session</literal> for one operation. This is pure coincidence, the example is just not complex enough to show any other approach. The scope of a Hibernate <literal>Session</literal> is flexible but you should never design your application to use a new Hibernate <literal>Session</literal> for <emphasis>every</emphasis> database operation. So even if you see it a few more times in the following (very trivial) examples, consider <emphasis>session-per-operation</emphasis> an anti-pattern. A real (web) application is shown later in this tutorial."
msgstr "この最初のルーチンを実行するには、Antのビルドファイルに呼び出し可能なターゲットを 追加しなければなりません："

#: index.docbook:452
msgid "Have a look at <xref linkend=\"transactions\"/> for more information about transaction handling and demarcation. We also skipped any error handling and rollback in the previous example."
msgstr ""
      "<![CDATA[<target name=\"run\" depends=\"compile\">\n"
      "    <java fork=\"true\" classname=\"events.EventManager\" classpathref=\"libraries\">\n"
      "        <classpath path=\"${targetdir}\"/>\n"
      "        <arg value=\"${action}\"/>\n"
      "    </java>\n"
      "</target>]]>"

#: index.docbook:458
msgid "To run this first routine we have to add a callable target to the Ant build file:"
msgstr "<literal>action</literal> 引数の値は、ターゲットを呼ぶときにコマンドラインで設定します："

#: index.docbook:462
msgid ""
      "<![CDATA[<target name=\"run\" depends=\"compile\">\n"
      "    <java fork=\"true\" classname=\"events.EventManager\" classpathref=\"libraries\">\n"
      "        <classpath path=\"${targetdir}\"/>\n"
      "        <arg value=\"${action}\"/>\n"
      "    </java>\n"
      "</target>]]>"
msgstr "<![CDATA[C:¥hibernateTutorial¥>ant run -Daction=store]]>"

#: index.docbook:464
msgid "The value of the <literal>action</literal> argument is set on the command line when calling the target:"
msgstr "コンパイルすると、Hibernateがスタートし、あなたの設定によりますが、 多くのログ出力があるはずです。 その最後には以下の行があるでしょう："

#: index.docbook:469
msgid "<![CDATA[C:\\hibernateTutorial\\>ant run -Daction=store]]>"
msgstr "<![CDATA[[java] Hibernate: insert into EVENTS (EVENT_DATE, title, EVENT_ID) values (?, ?, ?)]]>"

#: index.docbook:471
msgid "You should see, after compilation, Hibernate starting up and, depending on your configuration, lots of log output. At the end you will find the following line:"
msgstr "これはHibernateが実行する <literal>INSERT</literal> で、 クエスチョンマークはJDBCバインドパラメータを表しています。 引数としてバインドされる値を見るため、あるいはログの冗長性を減らすためには、 <literal>log4j.properties</literal> をチェックしてください。"

#: index.docbook:476
msgid "<![CDATA[[java] Hibernate: insert into EVENTS (EVENT_DATE, title, EVENT_ID) values (?, ?, ?)]]>"
msgstr "それでは同じように格納されたイベントの一覧を見ようと思います。 そのためメインメソッドにオプションを追加します："

#: index.docbook:478
msgid "This is the <literal>INSERT</literal> executed by Hibernate, the question marks represent JDBC bind parameters. To see the values bound as arguments, or to reduce the verbosity of the log, check your <literal>log4j.properties</literal>."
msgstr ""
      "<![CDATA[if (args[0].equals(\"store\")) {\n"
      "    mgr.createAndStoreEvent(\"My Event\", new Date());\n"
      "}\n"
      "else if (args[0].equals(\"list\")) {\n"
      "    List events = mgr.listEvents();\n"
      "    for (int i = 0; i < events.size(); i++) {\n"
      "        Event theEvent = (Event) events.get(i);\n"
      "        System.out.println(\"Event: \" + theEvent.getTitle() +\n"
      "                           \" Time: \" + theEvent.getDate());\n"
      "    }\n"
      "}]]>"

#: index.docbook:484
msgid "Now we'd like to list stored events as well, so we add an option to the main method:"
msgstr "新しい <literal>listEvents()メソッド</literal> も追加します。"

#: index.docbook:488
msgid ""
      "<![CDATA[if (args[0].equals(\"store\")) {\n"
      "    mgr.createAndStoreEvent(\"My Event\", new Date());\n"
      "}\n"
      "else if (args[0].equals(\"list\")) {\n"
      "    List events = mgr.listEvents();\n"
      "    for (int i = 0; i < events.size(); i++) {\n"
      "        Event theEvent = (Event) events.get(i);\n"
      "        System.out.println(\"Event: \" + theEvent.getTitle() +\n"
      "                           \" Time: \" + theEvent.getDate());\n"
      "    }\n"
      "}]]>"
msgstr ""
      "<![CDATA[private List listEvents() {\n"
      "\n"
      "    Session session = HibernateUtil.getSessionFactory().getCurrentSession();\n"
      "\n"
      "    session.beginTransaction();\n"
      "\n"
      "    List result = session.createQuery(\"from Event\").list();\n"
      "\n"
      "    session.getTransaction().commit();\n"
      "\n"
      "    return result;\n"
      "}]]>"

#: index.docbook:490
msgid "We also add a new <literal>listEvents() method</literal>:"
msgstr "ここですることは、データベースから存在するすべての <literal>Event</literal> オブジェクトをロードするHQL (Hibernate Query Language) クエリを使うことです。 Hibernateは適切なSQLを生成し、それをデータベースに送り、 そのデータを使って <literal>Event</literal> オブジェクトを生成します。 当然HQLでさらに複雑なクエリを作成できます。"

#: index.docbook:494
msgid ""
      "<![CDATA[private List listEvents() {\n"
      "\n"
      "    Session session = HibernateUtil.getSessionFactory().getCurrentSession();\n"
      "\n"
      "    session.beginTransaction();\n"
      "\n"
      "    List result = session.createQuery(\"from Event\").list();\n"
      "\n"
      "    session.getTransaction().commit();\n"
      "\n"
      "    return result;\n"
      "}]]>"
msgstr "以下のステップで、すべての実行とテストを行います。"

#: index.docbook:496
msgid "What we do here is use an HQL (Hibernate Query Language) query to load all existing <literal>Event</literal> objects from the database. Hibernate will generate the appropriate SQL, send it to the database and populate <literal>Event</literal> objects with the data. You can create more complex queries with HQL, of course."
msgstr "hbm2ddlを通す前にデータベースのデータを作成し、データベーススキーマを生成するために、 <literal>ant run -Daction=store</literal> を実行してください。"

#: index.docbook:503
msgid "Now, to execute and test all of this, follow these steps:"
msgstr "今は <literal>hibernate.cfg.xml</literal> ファイルのプロパティをコメントアウトしてhbm2ddlを無効にしてください。 通常は継続的に単体テストをしている間はhbm2ddlを有効にしておくのですが、 それ以外の場合にhbm2ddlを起動すると格納しておいた全てのデータを <emphasis>ドロップ</emphasis> するでしょう。 設定を <literal>create</literal> にすると、結果として 「SessionFactory生成の際、スキーマから全てのテーブルをドロップして再作成する」という設定になります。"

#: index.docbook:509
msgid "Run <literal>ant run -Daction=store</literal> to store something into the database and, of course, to generate the database schema before through hbm2ddl."
msgstr "今 <literal>-Daction=list</literal> と指定してAntを呼ぶと、 これまで格納したイベントが見えるはずです。 <literal>store</literal> アクションを数回以上呼ぶことも可能です。"

#: index.docbook:515
msgid "Now disable hbm2ddl by commenting out the property in your <literal>hibernate.cfg.xml</literal> file. Usually you only leave it turned on in continous unit testing, but another run of hbm2ddl would <emphasis>drop</emphasis> everything you have stored - the <literal>create</literal> configuration setting actually translates into \"drop all tables from the schema, then re-create all tables, when the SessionFactory is build\"."
msgstr "注意：初めてHibernateに触れる人々の多くがここで失敗するため、<emphasis>Table not found</emphasis> エラーメッセージに 関する質問を定期的に見かけます。 しかし上記のステップに従えば、hbm2ddlが最初に実行されたときにデータベーススキーマを作成し、 その後の実行においてもこのスキーマを使用するので、問題は起こらないでしょう。 マッピングやデータベーススキーマを変更したときは、もう一度hbm2ddlを有効にしてください。"

#: index.docbook:525
msgid "If you now call Ant with <literal>-Daction=list</literal>, you should see the events you have stored so far. You can of course also call the <literal>store</literal> action a few times more."
msgstr "パート2 - 関連のマッピング"

#: index.docbook:531
msgid "Note: Most new Hibernate users fail at this point and we see questions about <emphasis>Table not found</emphasis> error messages regularly. However, if you follow the steps outlined above you will not have this problem, as hbm2ddl creates the database schema on the first run, and subsequent application restarts will use this schema. If you change the mapping and/or database schema, you have to re-enable hbm2ddl once again."
msgstr "永続エンティティクラスをテーブルにマッピングしました。 さらにこの上にいくつかのクラスの関連を追加しましょう。 まず初めにアプリケーションに人々を追加し、彼らが参加するイベントのリストを格納します。"

#: index.docbook:544
msgid "Part 2 - Mapping associations"
msgstr "Personクラスのマッピング"

#: index.docbook:546
msgid "We mapped a persistent entity class to a table. Let's build on this and add some class associations. First we'll add people to our application, and store a list of events they participate in."
msgstr "最初の <literal>Person</literal> クラスは単純です："

#: index.docbook:552
msgid "Mapping the Person class"
msgstr ""
      "<![CDATA[package events;\n"
      "\n"
      "public class Person {\n"
      "\n"
      "    private Long id;\n"
      "    private int age;\n"
      "    private String firstname;\n"
      "    private String lastname;\n"
      "\n"
      "    public Person() {}\n"
      "\n"
      "    // Accessor methods for all properties, private setter for 'id'\n"
      "\n"
      "}]]>"

#: index.docbook:554
msgid "The first cut of the <literal>Person</literal> class is simple:"
msgstr "<literal>Person.hbm.xml</literal> という新しいマッピングファイルを作成してください （ファイルの最初にDTDへの参照を忘れずに入れてください）："

#: index.docbook:558
msgid ""
      "<![CDATA[package events;\n"
      "\n"
      "public class Person {\n"
      "\n"
      "    private Long id;\n"
      "    private int age;\n"
      "    private String firstname;\n"
      "    private String lastname;\n"
      "\n"
      "    public Person() {}\n"
      "\n"
      "    // Accessor methods for all properties, private setter for 'id'\n"
      "\n"
      "}]]>"
msgstr ""
      "<![CDATA[<hibernate-mapping>\n"
      "\n"
      "    <class name=\"events.Person\" table=\"PERSON\">\n"
      "        <id name=\"id\" column=\"PERSON_ID\">\n"
      "            <generator class=\"native\"/>\n"
      "        </id>\n"
      "        <property name=\"age\"/>\n"
      "        <property name=\"firstname\"/>\n"
      "        <property name=\"lastname\"/>\n"
      "    </class>\n"
      "\n"
      "</hibernate-mapping>]]>"

#: index.docbook:560
msgid "Create a new mapping file called <literal>Person.hbm.xml</literal> (don't forget the DTD reference at the top):"
msgstr "最後にHibernateの設定に新しいマッピングを追加してください："

#: index.docbook:565
msgid ""
      "<![CDATA[<hibernate-mapping>\n"
      "\n"
      "    <class name=\"events.Person\" table=\"PERSON\">\n"
      "        <id name=\"id\" column=\"PERSON_ID\">\n"
      "            <generator class=\"native\"/>\n"
      "        </id>\n"
      "        <property name=\"age\"/>\n"
      "        <property name=\"firstname\"/>\n"
      "        <property name=\"lastname\"/>\n"
      "    </class>\n"
      "\n"
      "</hibernate-mapping>]]>"
msgstr ""
      "<![CDATA[<mapping resource=\"events/Event.hbm.xml\"/>\n"
      "<mapping resource=\"events/Person.hbm.xml\"/>]]>"

#: index.docbook:567
msgid "Finally, add the new mapping to Hibernate's configuration:"
msgstr "それではこれら2つのエンティティ間の関連を作成します。 人々がイベントに参加でき、イベントが参加者を持つのは明らかです。 扱わなければならない設計の問題は、方向、多重度、コレクションの振る舞いです。"

#: index.docbook:571
msgid ""
      "<![CDATA[<mapping resource=\"events/Event.hbm.xml\"/>\n"
      "<mapping resource=\"events/Person.hbm.xml\"/>]]>"
msgstr "単方向Setベース関連"

#: index.docbook:573
msgid "We'll now create an association between these two entities. Obviously, persons can participate in events, and events have participants. The design questions we have to deal with are: directionality, multiplicity, and collection behavior."
msgstr "イベントのコレクションを <literal>Person</literal> クラスに追加します。 こうしておくと、明示的なクエリ、つまりわざわざ<literal>aPerson.getEvents()</literal>を呼び出さずに、 特定の人に紐付くイベントを簡単にナビゲートすることができます。 私たちはJavaのコレクション、<literal>Set</literal> を使います。 コレクションは重複要素を持たないし、順番は私たちには意味がないからです。"

#: index.docbook:583
msgid "A unidirectional Set-based association"
msgstr "<literal>Set</literal> で実装される単方向、多値関連が必要です。 Javaクラス内に対応するコードを書いてマッピングしましょう："

#: index.docbook:585
msgid "We'll add a collection of events to the <literal>Person</literal> class. That way we can easily navigate to the events for a particular person, without executing an explicit query - by calling <literal>aPerson.getEvents()</literal>. We use a Java collection, a <literal>Set</literal>, because the collection will not contain duplicate elements and the ordering is not relevant for us."
msgstr ""
      "<![CDATA[public class Person {\n"
      "\n"
      "    private Set events = new HashSet();\n"
      "\n"
      "    public Set getEvents() {\n"
      "        return events;\n"
      "    }\n"
      "\n"
      "    public void setEvents(Set events) {\n"
      "        this.events = events;\n"
      "    }\n"
      "}]]>"

#: index.docbook:592
msgid "We need a unidirectional, many-valued associations, implemented with a <literal>Set</literal>. Let's write the code for this in the Java classes and then map it:"
msgstr "この関連をマッピングする前に、反対側について考えてください。 明らかなことですが、今はこれを単方向にしただけです。 逆に、 <literal>Event</literal> 側にも別のコレクションを作ることもできます。 例えば <literal>anEvent.getParticipants()</literal> のように、 双方向にナビゲートしたければ、そうすることもできます。 これは機能的にみて必要ではありません。 特定のイベントに関係するデータを取得する明確なクエリを、いつでも実行することが出来ました。 この設計の選択は開発者に任されていて、この議論により明らかなのは関連の多重度です。 つまり両側を「多」値にする、 <emphasis>多対多</emphasis> と呼ばれる関連です。 そのためHibernateのmany-to-manyマッピングを使います："

#: index.docbook:597
msgid ""
      "<![CDATA[public class Person {\n"
      "\n"
      "    private Set events = new HashSet();\n"
      "\n"
      "    public Set getEvents() {\n"
      "        return events;\n"
      "    }\n"
      "\n"
      "    public void setEvents(Set events) {\n"
      "        this.events = events;\n"
      "    }\n"
      "}]]>"
msgstr ""
      "<![CDATA[<class name=\"events.Person\" table=\"PERSON\">\n"
      "    <id name=\"id\" column=\"PERSON_ID\">\n"
      "        <generator class=\"native\"/>\n"
      "    </id>\n"
      "    <property name=\"age\"/>\n"
      "    <property name=\"firstname\"/>\n"
      "    <property name=\"lastname\"/>\n"
      "\n"
      "    <set name=\"events\" table=\"PERSON_EVENT\">\n"
      "        <key column=\"PERSON_ID\"/>\n"
      "        <many-to-many column=\"EVENT_ID\" class=\"events.Event\"/>\n"
      "    </set>\n"
      "\n"
      "</class>]]>"

#: index.docbook:599
msgid "Before we map this association, think about the other side. Clearly, we could just keep this unidirectional. Or, we could create another collection on the <literal>Event</literal>, if we want to be able to navigate it bi-directional, i.e. <literal>anEvent.getParticipants()</literal>. This is not necessary, from a functional perspective. You could always execute an explicit query to retrieve the participants for a particular event. This is a design choice left to you, but what is clear from this discussion is the multiplicity of the association: \"many\" valued on both sides, we call this a <emphasis>many-to-many</emphasis> association. Hence, we use Hibernate's many-to-many mapping:"
msgstr "Hibernateはありとあらゆる種類のコレクションマッピングをサポートしていますが、 最も一般的なものが <literal>&lt;set&gt;</literal> です。 多対多関連（または <emphasis>n:m</emphasis> エンティティリレーションシップ）には、 関連テーブルが必要です。 このテーブルのそれぞれの行は、人とイベント間のリンクを表現します。 テーブル名は <literal>set</literal> 要素の <literal>table</literal> 属性で設定します。 人側の関連の識別子カラム名は <literal>&lt;key&gt;</literal> 要素で、 イベント側のカラム名は <literal>&lt;many-to-many&gt;</literal> の <literal>column</literal> 属性で定義します。 Hibernateにコレクションのオブジェクトのクラス （正確には、参照のコレクションの反対側のクラス）を教えなければなりません。"

#: index.docbook:610
msgid ""
      "<![CDATA[<class name=\"events.Person\" table=\"PERSON\">\n"
      "    <id name=\"id\" column=\"PERSON_ID\">\n"
      "        <generator class=\"native\"/>\n"
      "    </id>\n"
      "    <property name=\"age\"/>\n"
      "    <property name=\"firstname\"/>\n"
      "    <property name=\"lastname\"/>\n"
      "\n"
      "    <set name=\"events\" table=\"PERSON_EVENT\">\n"
      "        <key column=\"PERSON_ID\"/>\n"
      "        <many-to-many column=\"EVENT_ID\" class=\"events.Event\"/>\n"
      "    </set>\n"
      "\n"
      "</class>]]>"
msgstr "そのためこのマッピングのデータベーススキーマは以下のようになります。："

#: index.docbook:612
msgid "Hibernate supports all kinds of collection mappings, a <literal>&lt;set&gt;</literal> being most common. For a many-to-many association (or <emphasis>n:m</emphasis> entity relationship), an association table is needed. Each row in this table represents a link between a person and an event. The table name is configured with the <literal>table</literal> attribute of the <literal>set</literal> element. The identifier column name in the association, for the person's side, is defined with the <literal>&lt;key&gt;</literal> element, the column name for the event's side with the <literal>column</literal> attribute of the <literal>&lt;many-to-many&gt;</literal>. You also have to tell Hibernate the class of the objects in your collection (correct: the class on the other side of the collection of references)."
msgstr ""
      "<![CDATA[\n"
      "    _____________        __________________\n"
      "   |             |      |                  |       _____________\n"
      "   |   EVENTS    |      |   PERSON_EVENT   |      |             |\n"
      "   |_____________|      |__________________|      |    PERSON   |\n"
      "   |             |      |                  |      |_____________|\n"
      "   | *EVENT_ID   | <--> | *EVENT_ID        |      |             |\n"
      "   |  EVENT_DATE |      | *PERSON_ID       | <--> | *PERSON_ID  |\n"
      "   |  TITLE      |      |__________________|      |  AGE        |\n"
      "   |_____________|                                |  FIRSTNAME  |\n"
      "                                                  |  LASTNAME   |\n"
      "                                                  |_____________|\n"
      " ]]>"

#: index.docbook:624
msgid "The database schema for this mapping is therefore:"
msgstr "関連を働かせる"

#: index.docbook:628
msgid ""
      "<![CDATA[\n"
      "    _____________        __________________\n"
      "   |             |      |                  |       _____________\n"
      "   |   EVENTS    |      |   PERSON_EVENT   |      |             |\n"
      "   |_____________|      |__________________|      |    PERSON   |\n"
      "   |             |      |                  |      |_____________|\n"
      "   | *EVENT_ID   | <--> | *EVENT_ID        |      |             |\n"
      "   |  EVENT_DATE |      | *PERSON_ID       | <--> | *PERSON_ID  |\n"
      "   |  TITLE      |      |__________________|      |  AGE        |\n"
      "   |_____________|                                |  FIRSTNAME  |\n"
      "                                                  |  LASTNAME   |\n"
      "                                                  |_____________|\n"
      " ]]>"
msgstr "<literal>EventManager</literal> の新しいメソッドで人々とイベントを一緒にしましょう："

#: index.docbook:633
msgid "Working the association"
msgstr ""
      "<![CDATA[private void addPersonToEvent(Long personId, Long eventId) {\n"
      "\n"
      "    Session session = HibernateUtil.getSessionFactory().getCurrentSession();\n"
      "    session.beginTransaction();\n"
      "\n"
      "    Person aPerson = (Person) session.load(Person.class, personId);\n"
      "    Event anEvent = (Event) session.load(Event.class, eventId);\n"
      "\n"
      "    aPerson.getEvents().add(anEvent);\n"
      "\n"
      "    session.getTransaction().commit();\n"
      "}]]>"

#: index.docbook:635
msgid "Let's bring some people and events together in a new method in <literal>EventManager</literal>:"
msgstr "<literal>Person</literal> と <literal>Event</literal> をロードした後、 普通のコレクションメソッドを使って単純にそのコレクションを修正してください。 ご覧のとおり <literal>update()</literal> や <literal>save()</literal> の明示的な呼び出しはありません。 Hibernateは、修正されたことにより更新する必要のあるコレクションを自動的に検知します。 これは <emphasis>自動ダーティチェック</emphasis> と呼ばれ、 オブジェクトの名前やdateプロパティを修正することで試すことも可能です。 それらが <emphasis>永続</emphasis> 状態にある限り、 つまり特定のHibernate <literal>Session</literal> にバインドされている限り （例えば作業単位(Unit of Work)の中で単にロードまたはセーブされた）、 Hibernateはどんな変更もモニターし、遅延書き込み(write-behind)でSQLを実行します。 通常、作業単位(Unit of Work)の最後にだけ行われるデータベースとメモリの状態を同期させる処理は、 <emphasis>フラッシュ</emphasis> と呼ばれます。 このコードでは、作業単位(Unit of Work)はデータベーストランザクションのコミット（もしくはロールバック）で終了します。 これは、 <literal>CurrentSessionContext</literal> クラスに対して <literal>thread</literal> を設定したためです。"

#: index.docbook:639
msgid ""
      "<![CDATA[private void addPersonToEvent(Long personId, Long eventId) {\n"
      "\n"
      "    Session session = HibernateUtil.getSessionFactory().getCurrentSession();\n"
      "    session.beginTransaction();\n"
      "\n"
      "    Person aPerson = (Person) session.load(Person.class, personId);\n"
      "    Event anEvent = (Event) session.load(Event.class, eventId);\n"
      "\n"
      "    aPerson.getEvents().add(anEvent);\n"
      "\n"
      "    session.getTransaction().commit();\n"
      "}]]>"
msgstr "異なる作業単位(Unit of Work)で人々とイベントをロードすることも当然できます。 そうでなければ、永続状態にないとき（以前に永続であったなら、この状態を <emphasis>分離（detached）</emphasis> と呼びます）、 <literal>Session</literal> の外部でオブジェクトを修正します。 分離されるときにはコレクションを変更することも可能です："

#: index.docbook:641
msgid "After loading a <literal>Person</literal> and an <literal>Event</literal>, simply modify the collection using the normal collection methods. As you can see, there is no explicit call to <literal>update()</literal> or <literal>save()</literal>, Hibernate automatically detects that the collection has been modified and needs to be updated. This is called <emphasis>automatic dirty checking</emphasis>, and you can also try it by modifying the name or the date property of any of your objects. As long as they are in <emphasis>persistent</emphasis> state, that is, bound to a particular Hibernate <literal>Session</literal> (i.e. they have been just loaded or saved in a unit of work), Hibernate monitors any changes and executes SQL in a write-behind fashion. The process of synchronizing the memory state with the database, usually only at the end of a unit of work, is called <emphasis>flushing</emphasis>. In our code, the unit of work ends with a commit (or rollback) of the database transaction - as defined by the <literal>thread</literal> configuration option for the <literal>CurrentSessionContext</literal> class."
msgstr ""
      "<![CDATA[private void addPersonToEvent(Long personId, Long eventId) {\n"
      "\n"
      "    Session session = HibernateUtil.getSessionFactory().getCurrentSession();\n"
      "    session.beginTransaction();\n"
      "\n"
      "    Person aPerson = (Person) session\n"
      "            .createQuery(\"select p from Person p left join fetch p.events where p.id = :pid\")\n"
      "            .setParameter(\"pid\", personId)\n"
      "            .uniqueResult(); // Eager fetch the collection so we can use it detached\n"
      "\n"
      "    Event anEvent = (Event) session.load(Event.class, eventId);\n"
      "\n"
      "    session.getTransaction().commit();\n"
      "\n"
      "    // End of first unit of work\n"
      "\n"
      "    aPerson.getEvents().add(anEvent); // aPerson (and its collection) is detached\n"
      "\n"
      "    // Begin second unit of work\n"
      "\n"
      "    Session session2 = HibernateUtil.getSessionFactory().getCurrentSession();\n"
      "    session2.beginTransaction();\n"
      "\n"
      "    session2.update(aPerson); // Reattachment of aPerson\n"
      "\n"
      "    session2.getTransaction().commit();\n"
      "}]]>"

#: index.docbook:656
msgid "You might of course load person and event in different units of work. Or you modify an object outside of a <literal>Session</literal>, when it is not in persistent state (if it was persistent before, we call this state <emphasis>detached</emphasis>). You can even modify a collection when it is detached:"
msgstr "<literal>update</literal> の呼び出しは分離オブジェクトを再び永続化します。 これは、新しい作業単位(Unit of Work)にバインドすると言えるでしょう。 そのため分離の間に加えられたどのような修正もデータベースにセーブできます。 エンティティオブジェクトのコレクションへの修正（追加･削除）も同様にセーブできます。"

#: index.docbook:663
msgid ""
      "<![CDATA[private void addPersonToEvent(Long personId, Long eventId) {\n"
      "\n"
      "    Session session = HibernateUtil.getSessionFactory().getCurrentSession();\n"
      "    session.beginTransaction();\n"
      "\n"
      "    Person aPerson = (Person) session\n"
      "            .createQuery(\"select p from Person p left join fetch p.events where p.id = :pid\")\n"
      "            .setParameter(\"pid\", personId)\n"
      "            .uniqueResult(); // Eager fetch the collection so we can use it detached\n"
      "\n"
      "    Event anEvent = (Event) session.load(Event.class, eventId);\n"
      "\n"
      "    session.getTransaction().commit();\n"
      "\n"
      "    // End of first unit of work\n"
      "\n"
      "    aPerson.getEvents().add(anEvent); // aPerson (and its collection) is detached\n"
      "\n"
      "    // Begin second unit of work\n"
      "\n"
      "    Session session2 = HibernateUtil.getSessionFactory().getCurrentSession();\n"
      "    session2.beginTransaction();\n"
      "\n"
      "    session2.update(aPerson); // Reattachment of aPerson\n"
      "\n"
      "    session2.getTransaction().commit();\n"
      "}]]>"
msgstr "これは今はあまり使いみちがありませんが、 自分のアプリケーションの設計に組み込むことができる重要なコンセプトです。 それではこのエクササイズの最後に、 <literal>EventManager</literal> のメインメソッドに新しいアクションを追加して コマンドラインから呼び出してみましょう。 人やイベントの識別子が必要なら、 <literal>save()</literal> メソッドが返してくれます （場合によっては識別子を返すためにメソッドを修正する必要があるかもしれません）。"

#: index.docbook:665
msgid "The call to <literal>update</literal> makes a detached object persistent again, you could say it binds it to a new unit of work, so any modifications you made to it while detached can be saved to the database. This includes any modifications (additions/deletions) you made to a collection of that entity object."
msgstr ""
      "<![CDATA[else if (args[0].equals(\"addpersontoevent\")) {\n"
      "    Long eventId = mgr.createAndStoreEvent(\"My Event\", new Date());\n"
      "    Long personId = mgr.createAndStorePerson(\"Foo\", \"Bar\");\n"
      "    mgr.addPersonToEvent(personId, eventId);\n"
      "    System.out.println(\"Added person \" + personId + \" to event \" + eventId);\n"
      "}]]>"

#: index.docbook:672
msgid "Well, this is not much use in our current situation, but it's an important concept you can design into your own application. For now, complete this exercise by adding a new action to the <literal>EventManager</literal>'s main method and call it from the command line. If you need the identifiers of a person and an event - the <literal>save()</literal> method returns it (you might have to modify some of the previous methods to return that identifier):"
msgstr "これは同じように重要な2つのクラス、つまり2つのエンティティ間の関連の例でした。 前に述べたように、典型的なモデルには、普通「比較的重要ではない」他のクラスと型があります。 これまでに見たような <literal>int</literal> や <literal>String</literal> のようなものです。 このようなクラスを <emphasis>値型</emphasis> と言います。 このインスタンスは特定のエンティティに <emphasis>依存</emphasis> します。 この型のインスタンスは独自のIDを持ちませんし、 エンティティ間で共有されることもありません （ファーストネームが同じだったとしても、2人の人は同じ <literal>firstname</literal> オブジェクトを参照しません）。 値型はもちろんJDK内に見つかりますが、それだけではなく （実際、HibernateアプリケーションにおいてすべてのJDKクラスは値型と見なせます）、 例えば <literal>Address</literal> や <literal>MonetaryAmount</literal> のような独自の依存クラスを書くこともできます。"

#: index.docbook:680
msgid ""
      "<![CDATA[else if (args[0].equals(\"addpersontoevent\")) {\n"
      "    Long eventId = mgr.createAndStoreEvent(\"My Event\", new Date());\n"
      "    Long personId = mgr.createAndStorePerson(\"Foo\", \"Bar\");\n"
      "    mgr.addPersonToEvent(personId, eventId);\n"
      "    System.out.println(\"Added person \" + personId + \" to event \" + eventId);\n"
      "}]]>"
msgstr "値型のコレクションを設計することもできます。 これは他のエンティティへの参照のコレクションとは概念的に非常に異なりますが、 Javaではほとんど同じように見えます。"

#: index.docbook:682
msgid "This was an example of an association between two equally important classes, two entities. As mentioned earlier, there are other classes and types in a typical model, usually \"less important\". Some you have already seen, like an <literal>int</literal> or a <literal>String</literal>. We call these classes <emphasis>value types</emphasis>, and their instances <emphasis>depend</emphasis> on a particular entity. Instances of these types don't have their own identity, nor are they shared between entities (two persons don't reference the same <literal>firstname</literal> object, even if they have the same first name). Of course, value types can not only be found in the JDK (in fact, in a Hibernate application all JDK classes are considered value types), but you can also write dependent classes yourself, <literal>Address</literal> or <literal>MonetaryAmount</literal>, for example."
msgstr "値のコレクション"

#: index.docbook:695
msgid "You can also design a collection of value types. This is conceptually very different from a collection of references to other entities, but looks almost the same in Java."
msgstr "値型オブジェクトのコレクションを <literal>Person</literal> エンティティへ追加します。 Eメールアドレスを格納したいのですが、<literal>String</literal> 型を使っているので、 コレクションは再び <literal>Set</literal> です："

#: index.docbook:703
msgid "Collection of values"
msgstr ""
      "<![CDATA[private Set emailAddresses = new HashSet();\n"
      "\n"
      "public Set getEmailAddresses() {\n"
      "    return emailAddresses;\n"
      "}\n"
      "\n"
      "public void setEmailAddresses(Set emailAddresses) {\n"
      "    this.emailAddresses = emailAddresses;\n"
      "}]]>"

#: index.docbook:705
msgid "We add a collection of value typed objects to the <literal>Person</literal> entity. We want to store email addresses, so the type we use is <literal>String</literal>, and the collection is again a <literal>Set</literal>:"
msgstr "この <literal>Set</literal> のマッピングです："

#: index.docbook:710
msgid ""
      "<![CDATA[private Set emailAddresses = new HashSet();\n"
      "\n"
      "public Set getEmailAddresses() {\n"
      "    return emailAddresses;\n"
      "}\n"
      "\n"
      "public void setEmailAddresses(Set emailAddresses) {\n"
      "    this.emailAddresses = emailAddresses;\n"
      "}]]>"
msgstr ""
      "<![CDATA[<set name=\"emailAddresses\" table=\"PERSON_EMAIL_ADDR\">\n"
      "    <key column=\"PERSON_ID\"/>\n"
      "    <element type=\"string\" column=\"EMAIL_ADDR\"/>\n"
      "</set>]]>"

#: index.docbook:712
msgid "The mapping of this <literal>Set</literal>:"
msgstr "前のマッピングと比べて違うのは <literal>element</literal> の部分ですが、 Hibernateにこのコレクションが他のエンティティへの参照を含まず、 <literal>String</literal> 型の要素のコレクションを含むことを教えます。 （小文字の名前(string)はHibernateのマッピング型またはコンバータであるということです）。 繰り返しますが、<literal>set</literal> 要素の <literal>table</literal> 属性は、 コレクションのためのテーブル名を指定します。 <literal>key</literal> 要素はコレクションテーブルの外部キーカラム名を定義します。 <literal>element</literal> 要素の <literal>column</literal> 属性は <literal>String</literal> の値が実際に格納されるカラムの名前を定義します。"

#: index.docbook:716
msgid ""
      "<![CDATA[<set name=\"emailAddresses\" table=\"PERSON_EMAIL_ADDR\">\n"
      "    <key column=\"PERSON_ID\"/>\n"
      "    <element type=\"string\" column=\"EMAIL_ADDR\"/>\n"
      "</set>]]>"
msgstr "更新したスキーマを見てください："

#: index.docbook:718
msgid "The difference compared with the earlier mapping is the <literal>element</literal> part, which tells Hibernate that the collection does not contain references to another entity, but a collection of elements of type <literal>String</literal> (the lowercase name tells you it's a Hibernate mapping type/converter). Once again, the <literal>table</literal> attribute of the <literal>set</literal> element determines the table name for the collection. The <literal>key</literal> element defines the foreign-key column name in the collection table. The <literal>column</literal> attribute in the <literal>element</literal> element defines the column name where the <literal>String</literal> values will actually be stored."
msgstr ""
      "<![CDATA[\n"
      "  _____________        __________________\n"
      " |             |      |                  |       _____________\n"
      " |   EVENTS    |      |   PERSON_EVENT   |      |             |       ___________________\n"
      " |_____________|      |__________________|      |    PERSON   |      |                   |\n"
      " |             |      |                  |      |_____________|      | PERSON_EMAIL_ADDR |\n"
      " | *EVENT_ID   | <--> | *EVENT_ID        |      |             |      |___________________|\n"
      " |  EVENT_DATE |      | *PERSON_ID       | <--> | *PERSON_ID  | <--> |  *PERSON_ID       |\n"
      " |  TITLE      |      |__________________|      |  AGE        |      |  *EMAIL_ADDR      |\n"
      " |_____________|                                |  FIRSTNAME  |      |___________________|\n"
      "                                                |  LASTNAME   |\n"
      "                                                |_____________|\n"
      " ]]>"

#: index.docbook:728
msgid "Have a look at the updated schema:"
msgstr "コレクションテーブルの主キーは、実際は両方のカラムを使った複合キーであることがわかります。 これは人ごとにEメールアドレスが重複できないということで、 Javaのsetに要求されるセマンティクスそのものです。"

#: index.docbook:732
msgid ""
      "<![CDATA[\n"
      "  _____________        __________________\n"
      " |             |      |                  |       _____________\n"
      " |   EVENTS    |      |   PERSON_EVENT   |      |             |       ___________________\n"
      " |_____________|      |__________________|      |    PERSON   |      |                   |\n"
      " |             |      |                  |      |_____________|      | PERSON_EMAIL_ADDR |\n"
      " | *EVENT_ID   | <--> | *EVENT_ID        |      |             |      |___________________|\n"
      " |  EVENT_DATE |      | *PERSON_ID       | <--> | *PERSON_ID  | <--> |  *PERSON_ID       |\n"
      " |  TITLE      |      |__________________|      |  AGE        |      |  *EMAIL_ADDR      |\n"
      " |_____________|                                |  FIRSTNAME  |      |___________________|\n"
      "                                                |  LASTNAME   |\n"
      "                                                |_____________|\n"
      " ]]>"
msgstr "以前人とイベントを関連づけたときと全く同じように、 今や試しにコレクションに要素を追加することができるようになりました。 両方ともJavaでは同じコードです。"

#: index.docbook:734
msgid "You can see that the primary key of the collection table is in fact a composite key, using both columns. This also implies that there can't be duplicate email addresses per person, which is exactly the semantics we need for a set in Java."
msgstr ""
      "<![CDATA[private void addEmailToPerson(Long personId, String emailAddress) {\n"
      "\n"
      "    Session session = HibernateUtil.getSessionFactory().getCurrentSession();\n"
      "    session.beginTransaction();\n"
      "\n"
      "    Person aPerson = (Person) session.load(Person.class, personId);\n"
      "\n"
      "    // The getEmailAddresses() might trigger a lazy load of the collection\n"
      "    aPerson.getEmailAddresses().add(emailAddress);\n"
      "\n"
      "    session.getTransaction().commit();\n"
      "}]]>"

#: index.docbook:740
msgid "You can now try and add elements to this collection, just like we did before by linking persons and events. It's the same code in Java:"
msgstr "今回、コレクションの初期化に <emphasis>fetch</emphasis> クエリを使用しませんでした。 そのため、getterメソッドの呼び出しによってコレクションを初期化するためのSELECTが 実行されるので、コレクションに要素を追加できます。 SQLのログを監視して、即時フェッチを使って最適化してください。"

#: index.docbook:745
msgid ""
      "<![CDATA[private void addEmailToPerson(Long personId, String emailAddress) {\n"
      "\n"
      "    Session session = HibernateUtil.getSessionFactory().getCurrentSession();\n"
      "    session.beginTransaction();\n"
      "\n"
      "    Person aPerson = (Person) session.load(Person.class, personId);\n"
      "\n"
      "    // The getEmailAddresses() might trigger a lazy load of the collection\n"
      "    aPerson.getEmailAddresses().add(emailAddress);\n"
      "\n"
      "    session.getTransaction().commit();\n"
      "}]]>"
msgstr "双方向関連"

#: index.docbook:747
msgid "This time we didnt' use a <emphasis>fetch</emphasis> query to initialize the collection. Hence, the call to its getter method will trigger an additional select to initialize it, so we can add an element to it. Monitor the SQL log and try to optimize this with an eager fetch."
msgstr "次に双方向関連をマッピングします。 Javaで両側から人とイベントの関連を動作させます。 もちろん、データベーススキーマは変わりませんが、多重度は多対多のままです。 リレーショナルデータベースはネットワークプログラミング言語よりも柔軟なので、 ナビゲーションの方向のようなものを必要としません。 データはあらゆるの方法で見たり復元できるということです。"

#: index.docbook:757
msgid "Bi-directional associations"
msgstr "まず <literal>Event</literal> イベントクラスに参加者のコレクションを追加します："

#: index.docbook:759
msgid "Next we are going to map a bi-directional association - making the association between person and event work from both sides in Java. Of course, the database schema doesn't change, we still have many-to-many multiplicity. A relational database is more flexible than a network programming language, so it doesn't need anything like a navigation direction - data can be viewed and retrieved in any possible way."
msgstr ""
      "<![CDATA[private Set participants = new HashSet();\n"
      "\n"
      "public Set getParticipants() {\n"
      "    return participants;\n"
      "}\n"
      "\n"
      "public void setParticipants(Set participants) {\n"
      "    this.participants = participants;\n"
      "}]]>"

#: index.docbook:767
msgid "First, add a collection of participants to the <literal>Event</literal> Event class:"
msgstr "それでは <literal>Event.hbm.xml</literal> で関連のこちら側をマッピングしてください。"

#: index.docbook:771
msgid ""
      "<![CDATA[private Set participants = new HashSet();\n"
      "\n"
      "public Set getParticipants() {\n"
      "    return participants;\n"
      "}\n"
      "\n"
      "public void setParticipants(Set participants) {\n"
      "    this.participants = participants;\n"
      "}]]>"
msgstr ""
      "<![CDATA[<set name=\"participants\" table=\"PERSON_EVENT\" inverse=\"true\">\n"
      "    <key column=\"EVENT_ID\"/>\n"
      "    <many-to-many column=\"PERSON_ID\" class=\"events.Person\"/>\n"
      "</set>]]>"

#: index.docbook:773
msgid "Now map this side of the association too, in <literal>Event.hbm.xml</literal>."
msgstr "ご覧のとおり、いずれのマッピングドキュメント(XMLファイル)でも、普通の <literal>set</literal> マッピングを使っています。 <literal>key</literal> と <literal>many-to-many</literal> のカラム名が、 両方のマッピングドキュメントで入れ替えになっていることに注目してください。 ここで最も重要な追加項目は、 <literal>Event</literal> のコレクションマッピングの <literal>set</literal> 要素にある <literal>inverse=\"true\"</literal> 属性です。"

#: index.docbook:777
msgid ""
      "<![CDATA[<set name=\"participants\" table=\"PERSON_EVENT\" inverse=\"true\">\n"
      "    <key column=\"EVENT_ID\"/>\n"
      "    <many-to-many column=\"PERSON_ID\" class=\"events.Person\"/>\n"
      "</set>]]>"
msgstr "この指定の意味は、2つの間のエンティティ間のリンクについての情報を探す必要があるとき、 Hibernateは反対側のエンティティ、つまり <literal>Person</literal> クラスから探すということです。 一度2つのエンティティ間の双方向リンクがどのように作成されるかがわかれば、 これを理解することはとても簡単です。"

#: index.docbook:779
msgid "As you see, these are normal <literal>set</literal> mappings in both mapping documents. Notice that the column names in <literal>key</literal> and <literal>many-to-many</literal> are swapped in both mapping documents. The most important addition here is the <literal>inverse=\"true\"</literal> attribute in the <literal>set</literal> element of the <literal>Event</literal>'s collection mapping."
msgstr "双方向リンクの動作"

#: index.docbook:787
msgid "What this means is that Hibernate should take the other side - the <literal>Person</literal> class - when it needs to find out information about the link between the two. This will be a lot easier to understand once you see how the bi-directional link between our two entities is created ."
msgstr "まず、Hibernateが通常のJavaのセマンティクスに影響を及ぼさないことを心に留めておいてください。 私たちは、単方向の例としてどのように <literal>Person</literal> と <literal>Event</literal> の間のリンクを作成したでしょうか？ <literal>Person</literal> のインスタンスのイベントへの参照のコレクションに <literal>Event</literal> のインスタンスを追加しました。 そのためこのリンクを双方向にしたければ、 当たり前ですが反対側にも同じことをしなければなりません。 <literal>Event</literal> のコレクションに <literal>Person</literal> への 参照を追加するということです。 この「両側でリンクを設定すること」は絶対に必要なので、決して忘れないでください。"

#: index.docbook:796
msgid "Working bi-directional links"
msgstr "多くの開発者は慎重にプログラムするので、 エンティティの両側に正しく関連を設定するリンク管理メソッドを作成します。 例えば <literal>Person</literal> では以下のようになります。："

#: index.docbook:798
msgid "First, keep in mind that Hibernate does not affect normal Java semantics. How did we create a link between a <literal>Person</literal> and an <literal>Event</literal> in the unidirectional example? We added an instance of <literal>Event</literal> to the collection of event references, of an instance of <literal>Person</literal>. So, obviously, if we want to make this link working bi-directional, we have to do the same on the other side - adding a <literal>Person</literal> reference to the collection in an <literal>Event</literal>. This \"setting the link on both sides\" is absolutely necessary and you should never forget doing it."
msgstr ""
      "<![CDATA[protected Set getEvents() {\n"
      "    return events;\n"
      "}\n"
      "\n"
      "protected void setEvents(Set events) {\n"
      "    this.events = events;\n"
      "}\n"
      "\n"
      "public void addToEvent(Event event) {\n"
      "    this.getEvents().add(event);\n"
      "    event.getParticipants().add(this);\n"
      "}\n"
      "\n"
      "public void removeFromEvent(Event event) {\n"
      "    this.getEvents().remove(event);\n"
      "    event.getParticipants().remove(this);\n"
      "}]]>"

#: index.docbook:808
msgid "Many developers program defensive and create link management methods to correctly set both sides, e.g. in <literal>Person</literal>:"
msgstr "コレクションのゲットとセットメソッドが現在protectedになっていることに注意してください。 これは同じパッケージのクラスやサブクラスのメソッドは依然アクセスが可能ですが、 （ほとんど）そのパッケージ外のどのクラスでも直接そのコレクションを台無しにすることを防ぎます。 おそらく反対側のコレクションにも同じことをした方がいいでしょう。"

#: index.docbook:813
msgid ""
      "<![CDATA[protected Set getEvents() {\n"
      "    return events;\n"
      "}\n"
      "\n"
      "protected void setEvents(Set events) {\n"
      "    this.events = events;\n"
      "}\n"
      "\n"
      "public void addToEvent(Event event) {\n"
      "    this.getEvents().add(event);\n"
      "    event.getParticipants().add(this);\n"
      "}\n"
      "\n"
      "public void removeFromEvent(Event event) {\n"
      "    this.getEvents().remove(event);\n"
      "    event.getParticipants().remove(this);\n"
      "}]]>"
msgstr "<literal>inverse</literal> マッピング属性とはいったい何でしょうか？ 開発者とJavaにとっては、双方向リンクは単に両側の参照を正しく設定するということです。 しかしHibernateは（制約違反を避けるために）SQLの <literal>INSERT</literal> と <literal>UPDATE</literal> 文を正確に変更するための十分な情報を持っていないので、 双方向関連プロパティを扱うための何らかの助けを必要とします。 関連の片側を <literal>inverse</literal> に設定することで、Hibernateは基本的には設定した側を無視し、 反対側の <emphasis>鏡</emphasis> として考えます。 これだけで、Hibernateは方向を持つナビゲーションモデルをSQLデータベーススキーマへ変換するときの すべての問題にうまく対処できます。 覚えておかなければならないルールは簡単です。 双方向関連は必ず片側を <literal>inverse</literal> にする必要があるということです。 一対多関連ではそれは多側でなければなりません。 多対多関連ではどちら側でも構いません。どちらでも違いはありません。"

#: index.docbook:815
msgid "Notice that the get and set methods for the collection are now protected - this allows classes in the same package and subclasses to still access the methods, but prevents everybody else from messing with the collections directly (well, almost). You should probably do the same with the collection on the other side."
msgstr "ではこれを小さなWebアプリケーションにしてみましょう。"

#: index.docbook:822
msgid "What about the <literal>inverse</literal> mapping attribute? For you, and for Java, a bi-directional link is simply a matter of setting the references on both sides correctly. Hibernate however doesn't have enough information to correctly arrange SQL <literal>INSERT</literal> and <literal>UPDATE</literal> statements (to avoid constraint violations), and needs some help to handle bi-directional associations properly. Making one side of the association <literal>inverse</literal> tells Hibernate to basically ignore it, to consider it a <emphasis>mirror</emphasis> of the other side. That's all that is necessary for Hibernate to work out all of the issues when transformation a directional navigation model to a SQL database schema. The rules you have to remember are straightforward: All bi-directional associations need one side as <literal>inverse</literal>. In a one-to-many association it has to be the many-side, in many-to-many association you can pick either side, there is no difference."
msgstr "パート3 - EventManager Webアプリケーション"

#: index.docbook:837
msgid "Let's turn this into a small web application."
msgstr "HibernateのWebアプリケーションは、スタンドアローンのアプリケーションのように <literal>Session</literal> と <literal>Transaction</literal> を使用します。 しかしいくつかの一般的なパターンが役立ちます。 ここで <literal>EventManagerServlet</literal> を作成します。このサーブレットは、 データベースに格納した全てのイベントをリストにでき、さらにHTMLフォームから新しいイベントを入力できるものです。"

#: index.docbook:844
msgid "Part 3 - The EventManager web application"
msgstr "基本的なServletの記述"

#: index.docbook:846
msgid "A Hibernate web application uses <literal>Session</literal> and <literal>Transaction</literal> almost like a standalone application. However, some common patterns are useful. We now write an <literal>EventManagerServlet</literal>. This servlet can list all events stored in the database, and it provides an HTML form to enter new events."
msgstr "新しいクラスを、ソースディレクトリの <literal>events</literal> パッケージに作成してください。"

#: index.docbook:854
msgid "Writing the basic servlet"
msgstr ""
      "<![CDATA[package events;\n"
      "\n"
      "// Imports\n"
      "\n"
      "public class EventManagerServlet extends HttpServlet {\n"
      "\n"
      "    // Servlet code\n"
      "}]]>"

#: index.docbook:856
msgid "Create a new class in your source directory, in the <literal>events</literal> package:"
msgstr "ServletはHTTPの <literal>GET</literal> リクエストのみを処理するので、 <literal>doGet()</literal> を実装します。"

#: index.docbook:861
msgid ""
      "<![CDATA[package events;\n"
      "\n"
      "// Imports\n"
      "\n"
      "public class EventManagerServlet extends HttpServlet {\n"
      "\n"
      "    // Servlet code\n"
      "}]]>"
msgstr ""
      "<![CDATA[protected void doGet(HttpServletRequest request,\n"
      "                     HttpServletResponse response)\n"
      "        throws ServletException, IOException {\n"
      "\n"
      "    SimpleDateFormat dateFormatter = new SimpleDateFormat(\"dd.MM.yyyy\");\n"
      "\n"
      "    try {\n"
      "        // Begin unit of work\n"
      "        HibernateUtil.getSessionFactory()\n"
      "                .getCurrentSession().beginTransaction();\n"
      "\n"
      "        // Process request and render page...\n"
      "\n"
      "        // End unit of work\n"
      "        HibernateUtil.getSessionFactory()\n"
      "                .getCurrentSession().getTransaction().commit();\n"
      "\n"
      "    } catch (Exception ex) {\n"
      "        HibernateUtil.getSessionFactory()\n"
      "                .getCurrentSession().getTransaction().rollback();\n"
      "        throw new ServletException(ex);\n"
      "    }\n"
      "\n"
      "}]]>"

#: index.docbook:863
msgid "The servlet handles HTTP <literal>GET</literal> requests only, hence, the method we implement is <literal>doGet()</literal>:"
msgstr "これは <emphasis>session-per-request</emphasis> というパターンです。 Servletがリクエストを受け取ると、 <literal>SessionFactory</literal> の <literal>getCurrentSession()</literal> の最初の呼び出しで、 Hibernateの新しい <literal>Session</literal> が開かれます。 そのときデータベーストランザクションが開始されます。 データの読み書きに関わらず、すべてのデータアクセスはトランザクション内で行います。 （アプリケーション内ではオートコミットモードを使用しません）。"

#: index.docbook:868
msgid ""
      "<![CDATA[protected void doGet(HttpServletRequest request,\n"
      "                     HttpServletResponse response)\n"
      "        throws ServletException, IOException {\n"
      "\n"
      "    SimpleDateFormat dateFormatter = new SimpleDateFormat(\"dd.MM.yyyy\");\n"
      "\n"
      "    try {\n"
      "        // Begin unit of work\n"
      "        HibernateUtil.getSessionFactory()\n"
      "                .getCurrentSession().beginTransaction();\n"
      "\n"
      "        // Process request and render page...\n"
      "\n"
      "        // End unit of work\n"
      "        HibernateUtil.getSessionFactory()\n"
      "                .getCurrentSession().getTransaction().commit();\n"
      "\n"
      "    } catch (Exception ex) {\n"
      "        HibernateUtil.getSessionFactory()\n"
      "                .getCurrentSession().getTransaction().rollback();\n"
      "        throw new ServletException(ex);\n"
      "    }\n"
      "\n"
      "}]]>"
msgstr "次に、リクエストのアクションは処理され、レスポンスであるHTMLが描画されます。 これについてはすぐに説明します。"

#: index.docbook:870
msgid "The pattern we are applying here is called <emphasis>session-per-request</emphasis>. When a request hits the servlet, a new Hibernate <literal>Session</literal> is opened through the first call to <literal>getCurrentSession()</literal> on the <literal>SessionFactory</literal>. Then a database transaction is started&mdash;all data access as to occur inside a transaction, no matter if data is read or written (we don't use the auto-commit mode in applications)."
msgstr "最後にリクエストの処理とHTML描画が完了したときに、作業単位(Unit of Work)を終了します。 もし処理や描画中に問題が発生した場合、exceptionが投げられてデータベーストランザクションをロールバックします。 これで <literal>session-per-request</literal> パターンが完了します。 全てのサーブレットにトランザクション境界のコードを書く代わりに、サーブレットフィルタに記述することも可能です。 <emphasis>Open Session in View</emphasis> と呼ばれるこのパターンについては、 HibernateのWebサイトやWikiを参照してください。 サーブレットではなくJSPでHTML描画をしようとすると、すぐにこのパターンについての情報が必要になるでしょう。"

#: index.docbook:879
msgid "Do <emphasis>not</emphasis> use a new Hibernate <literal>Session</literal> for every database operation. Use one Hibernate <literal>Session</literal> that is scoped to the whole request. Use <literal>getCurrentSession()</literal>, so that it is automatically bound to the current Java thread."
msgstr "処理と描画"

#: index.docbook:886
msgid "Next, the possible actions of the request are processed and the response HTML is rendered. We'll get to that part soon."
msgstr "では、リクエストの処理とページの描画を実装します。"

#: index.docbook:891
msgid "Finally, the unit of work ends when processing and rendering is complete. If any problem occured during processing or rendering, an exception will be thrown and the database transaction rolled back. This completes the <literal>session-per-request</literal> pattern. Instead of the transaction demarcation code in every servlet you could also write a servlet filter. See the Hibernate website and Wiki for more information about this pattern, called <emphasis>Open Session in View</emphasis>&mdash;you'll need it as soon as you consider rendering your view in JSP, not in a servlet."
msgstr ""
      "<![CDATA[// Write HTML header\n"
      "PrintWriter out = response.getWriter();\n"
      "out.println(\"<html><head><title>Event Manager</title></head><body>\");\n"
      "\n"
      "// Handle actions\n"
      "if ( \"store\".equals(request.getParameter(\"action\")) ) {\n"
      "\n"
      "    String eventTitle = request.getParameter(\"eventTitle\");\n"
      "    String eventDate = request.getParameter(\"eventDate\");\n"
      "\n"
      "    if ( \"\".equals(eventTitle) || \"\".equals(eventDate) ) {\n"
      "        out.println(\"<b><i>Please enter event title and date.</i></b>\");\n"
      "    } else {\n"
      "        createAndStoreEvent(eventTitle, dateFormatter.parse(eventDate));\n"
      "        out.println(\"<b><i>Added event.</i></b>\");\n"
      "    }\n"
      "}\n"
      "\n"
      "// Print page\n"
      "printEventForm(out);\n"
      "listEvents(out, dateFormatter);\n"
      "\n"
      "// Write HTML footer\n"
      "out.println(\"</body></html>\");\n"
      "out.flush();\n"
      "out.close();]]>"

#: index.docbook:905
msgid "Processing and rendering"
msgstr "JavaとHTMLが混在するコーディングスタイルは、より複雑なアプリケーションには適していないでしょう （このチュートリアルでは、基本的なHibernateのコンセプトを示しているだけであることを覚えておいてください）。 このコードはHTMLのヘッダーとフッターの記述です。 このページには、イベントを入力するHTMLフォームと、データベースにある全てのイベントのリストが表示されます。 最初のメソッドはごく単純なHTML出力です。"

#: index.docbook:907
msgid "Let's implement the processing of the request and rendering of the page."
msgstr ""
      "<![CDATA[private void printEventForm(PrintWriter out) {\n"
      "    out.println(\"<h2>Add new event:</h2>\");\n"
      "    out.println(\"<form>\");\n"
      "    out.println(\"Title: <input name='eventTitle' length='50'/><br/>\");\n"
      "    out.println(\"Date (e.g. 24.12.2009): <input name='eventDate' length='10'/><br/>\");\n"
      "    out.println(\"<input type='submit' name='action' value='store'/>\");\n"
      "    out.println(\"</form>\");\n"
      "}]]>"

#: index.docbook:911
msgid ""
      "<![CDATA[// Write HTML header\n"
      "PrintWriter out = response.getWriter();\n"
      "out.println(\"<html><head><title>Event Manager</title></head><body>\");\n"
      "\n"
      "// Handle actions\n"
      "if ( \"store\".equals(request.getParameter(\"action\")) ) {\n"
      "\n"
      "    String eventTitle = request.getParameter(\"eventTitle\");\n"
      "    String eventDate = request.getParameter(\"eventDate\");\n"
      "\n"
      "    if ( \"\".equals(eventTitle) || \"\".equals(eventDate) ) {\n"
      "        out.println(\"<b><i>Please enter event title and date.</i></b>\");\n"
      "    } else {\n"
      "        createAndStoreEvent(eventTitle, dateFormatter.parse(eventDate));\n"
      "        out.println(\"<b><i>Added event.</i></b>\");\n"
      "    }\n"
      "}\n"
      "\n"
      "// Print page\n"
      "printEventForm(out);\n"
      "listEvents(out, dateFormatter);\n"
      "\n"
      "// Write HTML footer\n"
      "out.println(\"</body></html>\");\n"
      "out.flush();\n"
      "out.close();]]>"
msgstr "<literal>listEvents()</literal> メソッドは、現在のスレッドに結びつく Hibernateの <literal>Session</literal> を使用して、クエリを実行します。"

#: index.docbook:913
msgid "Granted, this coding style with a mix of Java and HTML would not scale in a more complex application&mdash;keep in mind that we are only illustrating basic Hibernate concepts in this tutorial. The code prints an HTML header and a footer. Inside this page, an HTML form for event entry and a list of all events in the database are printed. The first method is trivial and only outputs HTML:"
msgstr ""
      "<![CDATA[private void listEvents(PrintWriter out, SimpleDateFormat dateFormatter) {\n"
      "\n"
      "    List result = HibernateUtil.getSessionFactory()\n"
      "                    .getCurrentSession().createCriteria(Event.class).list();\n"
      "    if (result.size() > 0) {\n"
      "        out.println(\"<h2>Events in database:</h2>\");\n"
      "        out.println(\"<table border='1'>\");\n"
      "        out.println(\"<tr>\");\n"
      "        out.println(\"<th>Event title</th>\");\n"
      "        out.println(\"<th>Event date</th>\");\n"
      "        out.println(\"</tr>\");\n"
      "        for (Iterator it = result.iterator(); it.hasNext();) {\n"
      "            Event event = (Event) it.next();\n"
      "            out.println(\"<tr>\");\n"
      "            out.println(\"<td>\" + event.getTitle() + \"</td>\");\n"
      "            out.println(\"<td>\" + dateFormatter.format(event.getDate()) + \"</td>\");\n"
      "            out.println(\"</tr>\");\n"
      "        }\n"
      "        out.println(\"</table>\");\n"
      "    }\n"
      "}]]>"

#: index.docbook:922
msgid ""
      "<![CDATA[private void printEventForm(PrintWriter out) {\n"
      "    out.println(\"<h2>Add new event:</h2>\");\n"
      "    out.println(\"<form>\");\n"
      "    out.println(\"Title: <input name='eventTitle' length='50'/><br/>\");\n"
      "    out.println(\"Date (e.g. 24.12.2009): <input name='eventDate' length='10'/><br/>\");\n"
      "    out.println(\"<input type='submit' name='action' value='store'/>\");\n"
      "    out.println(\"</form>\");\n"
      "}]]>"
msgstr "最後に、 <literal>store</literal> アクションが <literal>createAndStoreEvent()</literal> メソッドを 呼び出します。このメソッドでも現在のスレッドの <literal>Session</literal> を利用します。"

#: index.docbook:924
msgid "The <literal>listEvents()</literal> method uses the Hibernate <literal>Session</literal> bound to the current thread to execute a query:"
msgstr ""
      "<![CDATA[protected void createAndStoreEvent(String title, Date theDate) {\n"
      "    Event theEvent = new Event();\n"
      "    theEvent.setTitle(title);\n"
      "    theEvent.setDate(theDate);\n"
      "\n"
      "    HibernateUtil.getSessionFactory()\n"
      "                    .getCurrentSession().save(theEvent);\n"
      "}]]>"

#: index.docbook:930
msgid ""
      "<![CDATA[private void listEvents(PrintWriter out, SimpleDateFormat dateFormatter) {\n"
      "\n"
      "    List result = HibernateUtil.getSessionFactory()\n"
      "                    .getCurrentSession().createCriteria(Event.class).list();\n"
      "    if (result.size() > 0) {\n"
      "        out.println(\"<h2>Events in database:</h2>\");\n"
      "        out.println(\"<table border='1'>\");\n"
      "        out.println(\"<tr>\");\n"
      "        out.println(\"<th>Event title</th>\");\n"
      "        out.println(\"<th>Event date</th>\");\n"
      "        out.println(\"</tr>\");\n"
      "        for (Iterator it = result.iterator(); it.hasNext();) {\n"
      "            Event event = (Event) it.next();\n"
      "            out.println(\"<tr>\");\n"
      "            out.println(\"<td>\" + event.getTitle() + \"</td>\");\n"
      "            out.println(\"<td>\" + dateFormatter.format(event.getDate()) + \"</td>\");\n"
      "            out.println(\"</tr>\");\n"
      "        }\n"
      "        out.println(\"</table>\");\n"
      "    }\n"
      "}]]>"
msgstr "これでサーブレットの完成です。 サーブレットへのリクエストは、一つの <literal>Session</literal> と <literal>Transaction</literal> で処理されるでしょう。 最初のスタンドアローンのアプリケーションのように、 Hibernateは自動的にこれらのオブジェクトを実行するスレッドに結び付けることができます。 これにより、開発者が自由にコードをレイヤー分けでき、 好きな方法で <literal>SessionFactory</literal> へのアクセスができるようになります。 通常、開発者はより洗練されたデザインを使用して、データアクセスのコードを データアクセスオブジェクトに移動するでしょう（DAOパターン）。 より多くの例は、HibernateのWikiを参照してください。"

#: index.docbook:932
msgid "Finally, the <literal>store</literal> action is dispatched to the <literal>createAndStoreEvent()</literal> method, which also uses the <literal>Session</literal> of the current thread:"
msgstr "デプロイとテスト"

#: index.docbook:938
msgid ""
      "<![CDATA[protected void createAndStoreEvent(String title, Date theDate) {\n"
      "    Event theEvent = new Event();\n"
      "    theEvent.setTitle(title);\n"
      "    theEvent.setDate(theDate);\n"
      "\n"
      "    HibernateUtil.getSessionFactory()\n"
      "                    .getCurrentSession().save(theEvent);\n"
      "}]]>"
msgstr "このアプリケーションのデプロイのために、Webアーカイブ（WAR）を作成してください。 以下のAntターゲットを <literal>build.xml</literal> に加えてください。"

#: index.docbook:940
msgid "That's it, the servlet is complete. A request to the servlet will be processed in a single <literal>Session</literal> and <literal>Transaction</literal>. As earlier in the standalone application, Hibernate can automatically bind these ojects to the current thread of execution. This gives you the freedom to layer your code and access the <literal>SessionFactory</literal> in any way you like. Usually you'd use a more sophisticated design and move the data access code into data access objects (the DAO pattern). See the Hibernate Wiki for more examples."
msgstr ""
      "<![CDATA[<target name=\"war\" depends=\"compile\">\n"
      "    <war destfile=\"hibernate-tutorial.war\" webxml=\"web.xml\">\n"
      "        <lib dir=\"${librarydir}\">\n"
      "          <exclude name=\"jsdk*.jar\"/>\n"
      "        </lib>\n"
      "\n"
      "        <classes dir=\"${targetdir}\"/>\n"
      "    </war>\n"
      "</target>]]>"

#: index.docbook:954
msgid "Deploying and testing"
msgstr "このターゲットは <literal>hibernate-tutorial.war</literal> というファイルを プロジェクトディレクトリに作成します。 このファイルはすべてのライブラリと <literal>web.xml</literal> 記述子を含んでおり、 プロジェクトのベースディレクトリに置かれることを期待されます。"

#: index.docbook:956
msgid "To deploy this application you have to create a web archive, a WAR. Add the following Ant target to your <literal>build.xml</literal>:"
msgstr ""
      "<![CDATA[<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
      "<web-app version=\"2.4\"\n"
      "    xmlns=\"http://java.sun.com/xml/ns/j2ee\"\n"
      "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
      "    xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\">\n"
      "\n"
      "    <servlet>\n"
      "        <servlet-name>Event Manager</servlet-name>\n"
      "        <servlet-class>events.EventManagerServlet</servlet-class>\n"
      "    </servlet>\n"
      "\n"
      "    <servlet-mapping>\n"
      "        <servlet-name>Event Manager</servlet-name>\n"
      "        <url-pattern>/eventmanager</url-pattern>\n"
      "    </servlet-mapping>\n"
      "</web-app>]]>"

#: index.docbook:961
msgid ""
      "<![CDATA[<target name=\"war\" depends=\"compile\">\n"
      "    <war destfile=\"hibernate-tutorial.war\" webxml=\"web.xml\">\n"
      "        <lib dir=\"${librarydir}\">\n"
      "          <exclude name=\"jsdk*.jar\"/>\n"
      "        </lib>\n"
      "\n"
      "        <classes dir=\"${targetdir}\"/>\n"
      "    </war>\n"
      "</target>]]>"
msgstr "Webアプリケーションのコンパイルとデプロイの前に、 <literal>jsdk.jar</literal> という 追加のライブラリが必要なことに注意してください。 これはJavaサーブレットの開発キットです。 もしまだこのライブラリを持っていないなら、Sunのウェブサイトで入手して、 ライブラリディレクトリにコピーしてください。 しかし、これはコンパイルにのみ使用され、WARパッケージからは除外されます。"

#: index.docbook:963
msgid "This target creates a file called <literal>hibernate-tutorial.war</literal> in your project directory. It packages all libraries and the <literal>web.xml</literal> descriptor, which is expected in the base directory of your project:"
msgstr "ビルドとデプロイのために、プロジェクトディレクトリで <literal>ant war</literal> を呼び出し、 <literal>hibernate-tutorial.war</literal> ファイルをTomcatの <literal>webapp</literal> ディレクトリにコピーしてください。 まだTomcatをインストールしていなければ、ダウンロードして、以下のインストールガイドに従ってください。 しかし、このアプリケーションのデプロイするために、Tomcatの設定を変更する必要はありません。"

#: index.docbook:969
msgid ""
      "<![CDATA[<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
      "<web-app version=\"2.4\"\n"
      "    xmlns=\"http://java.sun.com/xml/ns/j2ee\"\n"
      "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
      "    xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\">\n"
      "\n"
      "    <servlet>\n"
      "        <servlet-name>Event Manager</servlet-name>\n"
      "        <servlet-class>events.EventManagerServlet</servlet-class>\n"
      "    </servlet>\n"
      "\n"
      "    <servlet-mapping>\n"
      "        <servlet-name>Event Manager</servlet-name>\n"
      "        <url-pattern>/eventmanager</url-pattern>\n"
      "    </servlet-mapping>\n"
      "</web-app>]]>"
msgstr "一度デプロイしてTomcatを起動すれば、 <literal>http://localhost:8080/hibernate-tutorial/eventmanager</literal> で アプリケーションへのアクセスが可能です。 最初のリクエストが作成したサーブレットに渡ったときに、Tomcatのログで Hibernateの初期化処理を確認してください （ <literal>HibernateUtil</literal> 内の静的初期化ブロックが呼ばれています）。 また、exceptionが発生したなら詳細を確認してください。"

#: index.docbook:971
msgid "Before you compile and deploy the web application, note that an additional library is required: <literal>jsdk.jar</literal>. This is the Java servlet development kit, if you don't have this library already, get it from the Sun website and copy it to your library directory. However, it will be only used for compliation and excluded from the WAR package."
msgstr "<title>要約</title>"

#: index.docbook:979
msgid "To build and deploy call <literal>ant war</literal> in your project directory and copy the <literal>hibernate-tutorial.war</literal> file into your Tomcat <literal>webapp</literal> directory. If you don't have Tomcat installed, download it and follow the installation instructions. You don't have to change any Tomcat configuration to deploy this application though."
msgstr "このチュートリアルでは、簡単なスタンドアローンのHibernateアプリケーションと 小規模のWebアプリケーションを書くための基本を紹介しました。"

#: index.docbook:987
msgid "Once deployed and Tomcat is running, access the application at <literal>http://localhost:8080/hibernate-tutorial/eventmanager</literal>. Make sure you watch the Tomcat log to see Hibernate initialize when the first request hits your servlet (the static initializer in <literal>HibernateUtil</literal> is called) and to get the detailed output if any exceptions occurs."
msgstr "もうHibernateに自信があれば、リファレンスドキュメントの目次に目を通して、 面白そうだと思うトピックを探してください。 最も頻繁に質問があるのは、トランザクション処理（<xref linkend=\"transactions\"/>）、 フェッチのパフォーマンス（<xref linkend=\"performance\"/>）、 APIの使い方（<xref linkend=\"objectstate\"/>）とクエリ （<xref linkend=\"objectstate-querying\"/>）です。"

#: index.docbook:1000
msgid "Summary"
msgstr "さらに（特別な）チュートリアルが必要なら、Hibernateウェブサイトを忘れずにチェックしてください。"

#: index.docbook:1002
msgid "This tutorial covered the basics of writing a simple standalone Hibernate application and a small web application."
msgstr ""

#: index.docbook:1007
msgid "If you already feel confident with Hibernate, continue browsing through the reference documentation table of contents for topics you find interesting - most asked are transactional processing (<xref linkend=\"transactions\"/>), fetch performance (<xref linkend=\"performance\"/>), or the usage of the API (<xref linkend=\"objectstate\"/>) and the query features (<xref linkend=\"objectstate-querying\"/>)."
msgstr ""

#: index.docbook:1015
msgid "Don't forget to check the Hibernate website for more (specialized) tutorials."
msgstr ""

msgid "ROLES_OF_TRANSLATORS"
msgstr "<!--TRANS:ROLES_OF_TRANSLATORS-->"

msgid "CREDIT_FOR_TRANSLATORS"
msgstr "<!--TRANS:CREDIT_FOR_TRANSLATORS-->"

