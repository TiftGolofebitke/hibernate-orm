#, fuzzy
msgid ""
msgstr ""
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Content-Type: text/plain; charset=utf-8\n"
#: index.docbook:5
msgid "Component Mapping"
msgstr "コンポーネントのマッピング"

#: index.docbook:7
msgid "The notion of a <emphasis>component</emphasis> is re-used in several different contexts, for different purposes, throughout Hibernate."
msgstr "<emphasis>コンポーネント</emphasis> の概念は、Hibernateを通して様々な状況の中で 異なる目的のために再利用されます。"

#: index.docbook:13
msgid "Dependent objects"
msgstr "依存オブジェクト"

#: index.docbook:15
msgid "A component is a contained object that is persisted as a value type, not an entity reference. The term \"component\" refers to the object-oriented notion of composition (not to architecture-level components). For example, you might model a person like this:"
msgstr "コンポーネントは、エンティティの参照ではなく値型として永続化された、 包含されたオブジェクトです。コンポーネントという言葉については、コンポジションという オブジェクト指向の概念を参照してください（アーキテクチャレベルのコンポーネントではありません）。 例えば、以下のPersonモデルのようなものです。"

#: index.docbook:21
msgid ""
      "<![CDATA[public class Person {\n"
      "    private java.util.Date birthday;\n"
      "    private Name name;\n"
      "    private String key;\n"
      "    public String getKey() {\n"
      "        return key;\n"
      "    }\n"
      "    private void setKey(String key) {\n"
      "        this.key=key;\n"
      "    }\n"
      "    public java.util.Date getBirthday() {\n"
      "        return birthday;\n"
      "    }\n"
      "    public void setBirthday(java.util.Date birthday) {\n"
      "        this.birthday = birthday;\n"
      "    }\n"
      "    public Name getName() {\n"
      "        return name;\n"
      "    }\n"
      "    public void setName(Name name) {\n"
      "        this.name = name;\n"
      "    }\n"
      "    ......\n"
      "    ......\n"
      "}]]>"
msgstr ""
      "<![CDATA[public class Person {\n"
      "    private java.util.Date birthday;\n"
      "    private Name name;\n"
      "    private String key;\n"
      "    public String getKey() {\n"
      "        return key;\n"
      "    }\n"
      "    private void setKey(String key) {\n"
      "        this.key=key;\n"
      "    }\n"
      "    public java.util.Date getBirthday() {\n"
      "        return birthday;\n"
      "    }\n"
      "    public void setBirthday(java.util.Date birthday) {\n"
      "        this.birthday = birthday;\n"
      "    }\n"
      "    public Name getName() {\n"
      "        return name;\n"
      "    }\n"
      "    public void setName(Name name) {\n"
      "        this.name = name;\n"
      "    }\n"
      "    ......\n"
      "    ......\n"
      "}]]>"

#: index.docbook:23
msgid ""
      "<![CDATA[public class Name {\n"
      "    char initial;\n"
      "    String first;\n"
      "    String last;\n"
      "    public String getFirst() {\n"
      "        return first;\n"
      "    }\n"
      "    void setFirst(String first) {\n"
      "        this.first = first;\n"
      "    }\n"
      "    public String getLast() {\n"
      "        return last;\n"
      "    }\n"
      "    void setLast(String last) {\n"
      "        this.last = last;\n"
      "    }\n"
      "    public char getInitial() {\n"
      "        return initial;\n"
      "    }\n"
      "    void setInitial(char initial) {\n"
      "        this.initial = initial;\n"
      "    }\n"
      "}]]>"
msgstr ""
      "<![CDATA[public class Name {\n"
      "    char initial;\n"
      "    String first;\n"
      "    String last;\n"
      "    public String getFirst() {\n"
      "        return first;\n"
      "    }\n"
      "    void setFirst(String first) {\n"
      "        this.first = first;\n"
      "    }\n"
      "    public String getLast() {\n"
      "        return last;\n"
      "    }\n"
      "    void setLast(String last) {\n"
      "        this.last = last;\n"
      "    }\n"
      "    public char getInitial() {\n"
      "        return initial;\n"
      "    }\n"
      "    void setInitial(char initial) {\n"
      "        this.initial = initial;\n"
      "    }\n"
      "}]]>"

#: index.docbook:25
msgid "Now <literal>Name</literal> may be persisted as a component of <literal>Person</literal>. Notice that <literal>Name</literal> defines getter and setter methods for its persistent properties, but doesn't need to declare any interfaces or identifier properties."
msgstr "いま、<literal>Name</literal> は <literal>Person</literal> のコンポーネントとして 永続化することが出来ます。ここで <literal>Name</literal> は永続化属性に対してgetter、 setterメソッドを定義しますが、インターフェイスや識別子プロパティを定義する必要が ないことに注意して下さい。"

#: index.docbook:32
msgid "Our Hibernate mapping would look like:"
msgstr "マッピング定義は以下のようになります。"

#: index.docbook:36
msgid ""
      "<![CDATA[<class name=\"eg.Person\" table=\"person\">\n"
      "    <id name=\"Key\" column=\"pid\" type=\"string\">\n"
      "        <generator class=\"uuid\"/>\n"
      "    </id>\n"
      "    <property name=\"birthday\" type=\"date\"/>\n"
      "    <component name=\"Name\" class=\"eg.Name\"> <!-- class attribute optional -->\n"
      "        <property name=\"initial\"/>\n"
      "        <property name=\"first\"/>\n"
      "        <property name=\"last\"/>\n"
      "    </component>\n"
      "</class>]]>"
msgstr ""
      "<![CDATA[<class name=\"eg.Person\" table=\"person\">\n"
      "    <id name=\"Key\" column=\"pid\" type=\"string\">\n"
      "        <generator class=\"uuid\"/>\n"
      "    </id>\n"
      "    <property name=\"birthday\" type=\"date\"/>\n"
      "    <component name=\"Name\" class=\"eg.Name\"> <!-- class attribute optional -->\n"
      "        <property name=\"initial\"/>\n"
      "        <property name=\"first\"/>\n"
      "        <property name=\"last\"/>\n"
      "    </component>\n"
      "</class>]]>"

#: index.docbook:38
msgid "The person table would have the columns <literal>pid</literal>, <literal>birthday</literal>, <literal>initial</literal>, <literal>first</literal> and <literal>last</literal>."
msgstr "Personテーブルは <literal>pid</literal>、 <literal>birthday</literal>、 <literal>initial</literal>、 <literal>first</literal>、 <literal>last</literal> カラムを持ちます。"

#: index.docbook:46
msgid "Like all value types, components do not support shared references. In other words, two persons could have the same name, but the two person objects would contain two independent name ojects, only \"the same\" by value. The null value semantics of a component are <emphasis>ad hoc</emphasis>. When reloading the containing object, Hibernate will assume that if all component columns are null, then the entire component is null. This should be okay for most purposes."
msgstr "全ての値型のように、コンポーネントは参照の共有をすることができません。 言い換えると、二人のPersonは同じ名前を持つことができますが、二つのPersonオブジェクトは \"値が同じだけ\"の別々のnameオブジェクトを含んでいるということです。 コンポーネントのnull値のセマンティクスは <emphasis>アドホック</emphasis> です。 コンポーネントのオブジェクトを再読み込みする際、Hibernateはコンポーネントのすべてのカラムが nullであるならコンポーネント自体がnullであると考えます。 これは大抵の場合問題ありません。"

#: index.docbook:55
msgid "The properties of a component may be of any Hibernate type (collections, many-to-one associations, other components, etc). Nested components should <emphasis>not</emphasis> be considered an exotic usage. Hibernate is intended to support a very fine-grained object model."
msgstr "コンポーネントの属性はどんなHibernateの型でも構いません（コレクション、many-to-one関連、 他のコンポーネントなど）。ネストされたコンポーネントは滅多に使わないと考えるべきでは <emphasis>ありません</emphasis> 。Hibernateは非常にきめの細かいオブジェクトモデルをサポートするように意図されています。"

#: index.docbook:62
msgid "The <literal>&lt;component&gt;</literal> element allows a <literal>&lt;parent&gt;</literal> subelement that maps a property of the component class as a reference back to the containing entity."
msgstr "<literal>&lt;component&gt;</literal> 要素は親エンティティへの逆参照として、コンポーネントクラスの 属性をマッピングする <literal>&lt;parent&gt;</literal> サブ要素を使用できます。"

#: index.docbook:68
msgid ""
      "<![CDATA[<class name=\"eg.Person\" table=\"person\">\n"
      "    <id name=\"Key\" column=\"pid\" type=\"string\">\n"
      "        <generator class=\"uuid\"/>\n"
      "    </id>\n"
      "    <property name=\"birthday\" type=\"date\"/>\n"
      "    <component name=\"Name\" class=\"eg.Name\" unique=\"true\">\n"
      "        <parent name=\"namedPerson\"/> <!-- reference back to the Person -->\n"
      "        <property name=\"initial\"/>\n"
      "        <property name=\"first\"/>\n"
      "        <property name=\"last\"/>\n"
      "    </component>\n"
      "</class>]]>"
msgstr ""
      "<![CDATA[<class name=\"eg.Person\" table=\"person\">\n"
      "    <id name=\"Key\" column=\"pid\" type=\"string\">\n"
      "        <generator class=\"uuid\"/>\n"
      "    </id>\n"
      "    <property name=\"birthday\" type=\"date\"/>\n"
      "    <component name=\"Name\" class=\"eg.Name\" unique=\"true\">\n"
      "        <parent name=\"namedPerson\"/> <!-- reference back to the Person -->\n"
      "        <property name=\"initial\"/>\n"
      "        <property name=\"first\"/>\n"
      "        <property name=\"last\"/>\n"
      "    </component>\n"
      "</class>]]>"

#: index.docbook:73
msgid "Collections of dependent objects"
msgstr "従属するオブジェクトのコレクション"

#: index.docbook:75
msgid "Collections of components are supported (eg. an array of type <literal>Name</literal>). Declare your component collection by replacing the <literal>&lt;element&gt;</literal> tag with a <literal>&lt;composite-element&gt;</literal> tag."
msgstr "Hibernateはコンポーネントのコレクションをサポートしています（例えば <literal>Name</literal> 型の配列）。 <literal>&lt;element&gt;</literal> タグを <literal>&lt;composite-element&gt;</literal> タグに取り替えることにより コンポーネントコレクションを宣言してください。"

#: index.docbook:82
msgid ""
      "<![CDATA[<set name=\"someNames\" table=\"some_names\" lazy=\"true\">\n"
      "    <key column=\"id\"/>\n"
      "    <composite-element class=\"eg.Name\"> <!-- class attribute required -->\n"
      "        <property name=\"initial\"/>\n"
      "        <property name=\"first\"/>\n"
      "        <property name=\"last\"/>\n"
      "    </composite-element>\n"
      "</set>]]>"
msgstr ""
      "<![CDATA[<set name=\"someNames\" table=\"some_names\" lazy=\"true\">\n"
      "    <key column=\"id\"/>\n"
      "    <composite-element class=\"eg.Name\"> <!-- class attribute required -->\n"
      "        <property name=\"initial\"/>\n"
      "        <property name=\"first\"/>\n"
      "        <property name=\"last\"/>\n"
      "    </composite-element>\n"
      "</set>]]>"

#: index.docbook:84
msgid "Note: if you define a <literal>Set</literal> of composite elements, it is very important to implement <literal>equals()</literal> and <literal>hashCode()</literal> correctly."
msgstr "注意: コンポジットエレメントの <literal>Set</literal> を定義したなら、 <literal>equals()</literal> と <literal>hashCode()</literal> を正しく実装することが重要です。"

#: index.docbook:90
msgid "Composite elements may contain components but not collections. If your composite element itself contains components, use the <literal>&lt;nested-composite-element&gt;</literal> tag. This is a pretty exotic case - a collection of components which themselves have components. By this stage you should be asking yourself if a one-to-many association is more appropriate. Try remodelling the composite element as an entity - but note that even though the Java model is the same, the relational model and persistence semantics are still slightly different."
msgstr "コンポジットエレメントはコレクションを含まず、コンポーネントを含むこともあります。 コンポジットエレメント自身がコンポーネントを含んでいる場合は <literal>&lt;nested-composite-element&gt;</literal> を 使用してください。コンポーネントのコレクション自身がコンポーネントを持つというケースはめったにありません。 この段階までに、one-to-many関連の方がより適切でないかと熟考してください。 コンポジットエレメントをエンティティとして再度モデリングしてみてください。 しかしこれはJavaのモデルとしては同じですが、リレーショナルモデルと永続動作はまだ若干異なることに注意してください。"

#: index.docbook:102
msgid "Please note that a composite element mapping doesn't support null-able properties if you're using a <literal>&lt;set&gt;</literal>. Hibernate has to use each columns value to identify a record when deleting objects (there is no separate primary key column in the composite element table), which is not possible with null values. You have to either use only not-null properties in a composite-element or choose a <literal>&lt;list&gt;</literal>, <literal>&lt;map&gt;</literal>, <literal>&lt;bag&gt;</literal> or <literal>&lt;idbag&gt;</literal>."
msgstr "もし <literal>&lt;set&gt;</literal> を使用するのであれば、コンポジットエレメントのマッピングがnull値が可能な 属性をサポートしていないことに注意してください。Hibernateはオブジェクトを削除するとき、 レコードを識別するためにそれぞれのカラムの値を使用する必要があるため、null値を持つことが出来ません （コンポジットエレメントテーブルには別の主キーカラムはありません）。 コンポジットエレメントにnot-nullの属性のみを使用するか、または <literal>&lt;list&gt;</literal>、<literal>&lt;map&gt;</literal>、 <literal>&lt;bag&gt;</literal>、<literal>&lt;idbag&gt;</literal> を選択する必要があります。"

#: index.docbook:113
msgid "A special case of a composite element is a composite element with a nested <literal>&lt;many-to-one&gt;</literal> element. A mapping like this allows you to map extra columns of a many-to-many association table to the composite element class. The following is a many-to-many association from <literal>Order</literal> to <literal>Item</literal> where <literal>purchaseDate</literal>, <literal>price</literal> and <literal>quantity</literal> are properties of the association:"
msgstr "コンポジットエレメントの特別なケースとして、ネストされた <literal>&lt;many-to-one&gt;</literal> 属性を持つ コンポジットエレメントがあります。 このマッピングは、コンポジットエレメントクラスを多対多関連テーブルの 余分なカラムへマッピングします。 次の例は <literal>Order</literal> から、<literal>Item</literal> への多対多関連です。 <literal>purchaseDate</literal>、<literal>price</literal>、<literal>quantity</literal> は関連の属性となります。"

#: index.docbook:123
msgid ""
      "<![CDATA[<class name=\"eg.Order\" .... >\n"
      "    ....\n"
      "    <set name=\"purchasedItems\" table=\"purchase_items\" lazy=\"true\">\n"
      "        <key column=\"order_id\">\n"
      "        <composite-element class=\"eg.Purchase\">\n"
      "            <property name=\"purchaseDate\"/>\n"
      "            <property name=\"price\"/>\n"
      "            <property name=\"quantity\"/>\n"
      "            <many-to-one name=\"item\" class=\"eg.Item\"/> <!-- class attribute is optional -->\n"
      "        </composite-element>\n"
      "    </set>\n"
      "</class>]]>"
msgstr ""
      "<![CDATA[<class name=\"eg.Order\" .... >\n"
      "    ....\n"
      "    <set name=\"purchasedItems\" table=\"purchase_items\" lazy=\"true\">\n"
      "        <key column=\"order_id\">\n"
      "        <composite-element class=\"eg.Purchase\">\n"
      "            <property name=\"purchaseDate\"/>\n"
      "            <property name=\"price\"/>\n"
      "            <property name=\"quantity\"/>\n"
      "            <many-to-one name=\"item\" class=\"eg.Item\"/> <!-- class attribute is optional -->\n"
      "        </composite-element>\n"
      "    </set>\n"
      "</class>]]>"

#: index.docbook:125
msgid "Of course, there can't be a reference to the purchae on the other side, for bidirectional association navigation. Remember that components are value types and don't allow shared references. A single <literal>Purchase</literal> can be in the set of an <literal>Order</literal>, but it can't be referenced by the <literal>Item</literal> at the same time."
msgstr "もちろん、双方向関連のナビゲーションのために反対側からpurchaseへの参照を作ることは出来ません。 コンポーネントは値型であり、参照を共有できないことを覚えておいてください。 一つの <literal>Purchase</literal> は一つの <literal>Order</literal> のsetに存在できますが、 同時に <literal>Item</literal> から参照することは出来ません。"

#: index.docbook:133
msgid "Even ternary (or quaternary, etc) associations are possible:"
msgstr "3項関連（あるいは4項など）も可能です。"

#: index.docbook:135
msgid ""
      "<![CDATA[<class name=\"eg.Order\" .... >\n"
      "    ....\n"
      "    <set name=\"purchasedItems\" table=\"purchase_items\" lazy=\"true\">\n"
      "        <key column=\"order_id\">\n"
      "        <composite-element class=\"eg.OrderLine\">\n"
      "            <many-to-one name=\"purchaseDetails class=\"eg.Purchase\"/>\n"
      "            <many-to-one name=\"item\" class=\"eg.Item\"/>\n"
      "        </composite-element>\n"
      "    </set>\n"
      "</class>]]>"
msgstr ""
      "<![CDATA[<class name=\"eg.Order\" .... >\n"
      "    ....\n"
      "    <set name=\"purchasedItems\" table=\"purchase_items\" lazy=\"true\">\n"
      "        <key column=\"order_id\">\n"
      "        <composite-element class=\"eg.OrderLine\">\n"
      "            <many-to-one name=\"purchaseDetails\" class=\"eg.Purchase\"/>\n"
      "            <many-to-one name=\"item\" class=\"eg.Item\"/>\n"
      "        </composite-element>\n"
      "    </set>\n"
      "</class>]]>"

#: index.docbook:137
msgid "Composite elements may appear in queries using the same syntax as associations to other entities."
msgstr "コンポジットエレメントは他のエンティティへの関連として、 同じシンタックスを使っているクエリ内で使用できます。"

#: index.docbook:145
msgid "Components as Map indices"
msgstr "Mapのインデックスとしてのコンポーネント"

#: index.docbook:147
msgid "The <literal>&lt;composite-map-key&gt;</literal> element lets you map a component class as the key of a <literal>Map</literal>. Make sure you override <literal>hashCode()</literal> and <literal>equals()</literal> correctly on the component class."
msgstr "<literal>&lt;composite-map-key&gt;</literal> 要素は <literal>Map</literal> のキーとしてコンポーネントクラスを マッピングします。コンポーネントクラス上で <literal>hashCode()</literal> と <literal>equals()</literal> を正確にオーバーライドしてください。"

#: index.docbook:156
msgid "Components as composite identifiers"
msgstr "複合識別子としてのコンポーネント"

#: index.docbook:158
msgid "You may use a component as an identifier of an entity class. Your component class must satisfy certain requirements:"
msgstr "コンポーネントをエンティティクラスの識別子として使うことができます。 コンポーネントクラスは以下の条件を満たす必要があります。"

#: index.docbook:165
msgid "It must implement <literal>java.io.Serializable</literal>."
msgstr "<literal>java.io.Serializable</literal> を実装しなければなりません。"

#: index.docbook:170
msgid "It must re-implement <literal>equals()</literal> and <literal>hashCode()</literal>, consistently with the database's notion of composite key equality."
msgstr "データベース上の複合キーの等価性と矛盾のないように、<literal>equals()</literal> と <literal>hashCode()</literal> を再実装しなければなりません。"

#: index.docbook:179
msgid "Note: in Hibernate3, the second requirement is not an absolutely hard requirement of Hibernate. But do it anyway."
msgstr "注意: Hibernate3において、2番目の条件は絶対的な条件ではありません。 しかしとにかく条件を満たしてください。"

#: index.docbook:183
msgid "You can't use an <literal>IdentifierGenerator</literal> to generate composite keys. Instead the application must assign its own identifiers."
msgstr "複合キーを生成するために <literal>IdentifierGenerator</literal> を使用することはできません。 代わりにアプリケーションが識別子を割り当てなくてはなりません。"

#: index.docbook:188
msgid "Use the <literal>&lt;composite-id&gt;</literal> tag (with nested <literal>&lt;key-property&gt;</literal> elements) in place of the usual <literal>&lt;id&gt;</literal> declaration. For example, the <literal>OrderLine</literal> class has a primary key that depends upon the (composite) primary key of <literal>Order</literal>."
msgstr "通常の <literal>&lt;id&gt;</literal> 宣言の代わりに <literal>&lt;composite-id&gt;</literal> タグを （ネストされた <literal>&lt;key-property&gt;</literal> 属性と共に）使います。 以下の例では、<literal>OrderLine</literal> クラスは <literal>Order</literal> の（複合）主キーに 依存した主キーを持っています。"

#: index.docbook:196
msgid ""
      "<![CDATA[<class name=\"OrderLine\">\n"
      "    \n"
      "    <composite-id name=\"id\" class=\"OrderLineId\">\n"
      "        <key-property name=\"lineId\"/>\n"
      "        <key-property name=\"orderId\"/>\n"
      "        <key-property name=\"customerId\"/>\n"
      "    </composite-id>\n"
      "    \n"
      "    <property name=\"name\"/>\n"
      "    \n"
      "    <many-to-one name=\"order\" class=\"Order\"\n"
      "            insert=\"false\" update=\"false\">\n"
      "        <column name=\"orderId\"/>\n"
      "        <column name=\"customerId\"/>\n"
      "    </many-to-one>\n"
      "    ....\n"
      "    \n"
      "</class>]]>"
msgstr ""
      "<![CDATA[<class name=\"OrderLine\">\n"
      "    \n"
      "    <composite-id name=\"id\" class=\"OrderLineId\">\n"
      "        <key-property name=\"lineId\"/>\n"
      "        <key-property name=\"orderId\"/>\n"
      "        <key-property name=\"customerId\"/>\n"
      "    </composite-id>\n"
      "    \n"
      "    <property name=\"name\"/>\n"
      "    \n"
      "    <many-to-one name=\"order\" class=\"Order\"\n"
      "            insert=\"false\" update=\"false\">\n"
      "        <column name=\"orderId\"/>\n"
      "        <column name=\"customerId\"/>\n"
      "    </many-to-one>\n"
      "    ....\n"
      "    \n"
      "</class>]]>"

#: index.docbook:198
msgid "Now, any foreign keys referencing the <literal>OrderLine</literal> table are also composite. You must declare this in your mappings for other classes. An association to <literal>OrderLine</literal> would be mapped like this:"
msgstr "このとき、<literal>OrderLine</literal> テーブルへ関連する外部キーもまた複合です。 他のクラスのマッピングでこれを宣言しなければなりません。 <literal>OrderLine</literal> への関連は次のようにマッピングされます。"

#: index.docbook:204
msgid ""
      "<![CDATA[<many-to-one name=\"orderLine\" class=\"OrderLine\">\n"
      "<!-- the \"class\" attribute is optional, as usual -->\n"
      "    <column name=\"lineId\"/>\n"
      "    <column name=\"orderId\"/>\n"
      "    <column name=\"customerId\"/>\n"
      "</many-to-one>]]>"
msgstr ""
      "<![CDATA[<many-to-one name=\"orderLine\" class=\"OrderLine\">\n"
      "<!-- the \"class\" attribute is optional, as usual -->\n"
      "    <column name=\"lineId\"/>\n"
      "    <column name=\"orderId\"/>\n"
      "    <column name=\"customerId\"/>\n"
      "</many-to-one>]]>"

#: index.docbook:206
msgid "(Note that the <literal>&lt;column&gt;</literal> tag is an alternative to the <literal>column</literal> attribute everywhere.)"
msgstr "（<literal>&lt;column&gt;</literal> タグはどこであっても <literal>column</literal> 属性の 代わりになります。）"

#: index.docbook:211
msgid "A <literal>many-to-many</literal> association to <literal>OrderLine</literal> also uses the composite foreign key:"
msgstr "<literal>OrderLine</literal> への <literal>many-to-many</literal> 関連も 複合外部キーを使います。"

#: index.docbook:216
msgid ""
      "<![CDATA[<set name=\"undeliveredOrderLines\">\n"
      "    <key column name=\"warehouseId\"/>\n"
      "    <many-to-many class=\"OrderLine\">\n"
      "        <column name=\"lineId\"/>\n"
      "        <column name=\"orderId\"/>\n"
      "        <column name=\"customerId\"/>\n"
      "    </many-to-many>\n"
      "</set>]]>"
msgstr ""
      "<![CDATA[<set name=\"undeliveredOrderLines\">\n"
      "    <key column name=\"warehouseId\"/>\n"
      "    <many-to-many class=\"OrderLine\">\n"
      "        <column name=\"lineId\"/>\n"
      "        <column name=\"orderId\"/>\n"
      "        <column name=\"customerId\"/>\n"
      "    </many-to-many>\n"
      "</set>]]>"

#: index.docbook:218
msgid "The collection of <literal>OrderLine</literal>s in <literal>Order</literal> would use:"
msgstr "<literal>Order</literal> にある <literal>OrderLine</literal> のコレクションは 次のものを使用します。"

#: index.docbook:223
msgid ""
      "<![CDATA[<set name=\"orderLines\" inverse=\"true\">\n"
      "    <key>\n"
      "        <column name=\"orderId\"/>\n"
      "        <column name=\"customerId\"/>\n"
      "    </key>\n"
      "    <one-to-many class=\"OrderLine\"/>\n"
      "</set>]]>"
msgstr ""
      "<![CDATA[<set name=\"orderLines\" inverse=\"true\">\n"
      "    <key>\n"
      "        <column name=\"orderId\"/>\n"
      "        <column name=\"customerId\"/>\n"
      "    </key>\n"
      "    <one-to-many class=\"OrderLine\"/>\n"
      "</set>]]>"

#: index.docbook:225
msgid "(The <literal>&lt;one-to-many&gt;</literal> element, as usual, declares no columns.)"
msgstr "（<literal>&lt;one-to-many&gt;</literal> 属性は、例によってカラムを宣言しません）"

#: index.docbook:229
msgid "If <literal>OrderLine</literal> itself owns a collection, it also has a composite foreign key."
msgstr "<literal>OrderLine</literal> 自身がコレクションを持っている場合、 同時に複合外部キーも持っています。"

#: index.docbook:234
msgid ""
      "<![CDATA[<class name=\"OrderLine\">\n"
      "    ....\n"
      "    ....\n"
      "    <list name=\"deliveryAttempts\">\n"
      "        <key>   <!-- a collection inherits the composite key type -->\n"
      "            <column name=\"lineId\"/>\n"
      "            <column name=\"orderId\"/>\n"
      "            <column name=\"customerId\"/>\n"
      "        </key>\n"
      "        <list-index column=\"attemptId\" base=\"1\"/>\n"
      "        <composite-element class=\"DeliveryAttempt\">\n"
      "            ...\n"
      "        </composite-element>\n"
      "    </set>\n"
      "</class>]]>"
msgstr ""
      "<![CDATA[<class name=\"OrderLine\">\n"
      "    ....\n"
      "    ....\n"
      "    <list name=\"deliveryAttempts\">\n"
      "        <key>   <!-- a collection inherits the composite key type -->\n"
      "            <column name=\"lineId\"/>\n"
      "            <column name=\"orderId\"/>\n"
      "            <column name=\"customerId\"/>\n"
      "        </key>\n"
      "        <list-index column=\"attemptId\" base=\"1\"/>\n"
      "        <composite-element class=\"DeliveryAttempt\">\n"
      "            ...\n"
      "        </composite-element>\n"
      "    </set>\n"
      "</class>]]>"

#: index.docbook:239
msgid "Dynamic components"
msgstr "動的コンポーネント"

#: index.docbook:241
msgid "You may even map a property of type <literal>Map</literal>:"
msgstr "<literal>Map</literal> 型のプロパティのマッピングも可能です。"

#: index.docbook:245
msgid ""
      "<![CDATA[<dynamic-component name=\"userAttributes\">\n"
      "    <property name=\"foo\" column=\"FOO\" type=\"string\"/>\n"
      "    <property name=\"bar\" column=\"BAR\" type=\"integer\"/>\n"
      "    <many-to-one name=\"baz\" class=\"Baz\" column=\"BAZ_ID\"/>\n"
      "</dynamic-component>]]>"
msgstr ""
      "<![CDATA[<dynamic-component name=\"userAttributes\">\n"
      "    <property name=\"foo\" column=\"FOO\" type=\"string\"/>\n"
      "    <property name=\"bar\" column=\"BAR\" type=\"integer\"/>\n"
      "    <many-to-one name=\"baz\" class=\"Baz\" column=\"BAZ_ID\"/>\n"
      "</dynamic-component>]]>"

#: index.docbook:247
msgid "The semantics of a <literal>&lt;dynamic-component&gt;</literal> mapping are identical to <literal>&lt;component&gt;</literal>. The advantage of this kind of mapping is the ability to determine the actual properties of the bean at deployment time, just by editing the mapping document. Runtime manipulation of the mapping document is also possible, using a DOM parser. Even better, you can access (and change) Hibernate's configuration-time metamodel via the <literal>Configuration</literal> object."
msgstr "<literal>&lt;dynamic-component&gt;</literal> マッピングのセマンティクスは <literal>&lt;component&gt;</literal> と同一のものです。この種のマッピングの利点は、マッピングドキュメントの編集により、配置時にbeanの属性を 決定できる点です。また、DOMパーサを利用して、マッピングドキュメントのランタイム操作が可能です。 さらに、<literal>Configuration</literal> オブジェクト経由でHibernateのコンフィグレーション時のメタモデルに アクセス（または変更）が可能です。"

msgid "ROLES_OF_TRANSLATORS"
msgstr "<!--TRANS:ROLES_OF_TRANSLATORS-->"

msgid "CREDIT_FOR_TRANSLATORS"
msgstr "<!--TRANS:CREDIT_FOR_TRANSLATORS-->"

