#, fuzzy
msgid ""
msgstr ""
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Content-Type: text/plain; charset=utf-8\n"
#: index.docbook:5
msgid "Batch processing"
msgstr "バッチ処理"

#: index.docbook:7
msgid "A naive approach to inserting 100 000 rows in the database using Hibernate might look like this:"
msgstr "Hibernateを使ってデータベースに100,000行を挿入する愚直な方法は、このようなものです："

#: index.docbook:12
msgid ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "for ( int i=0; i<100000; i++ ) {\n"
      "    Customer customer = new Customer(.....);\n"
      "    session.save(customer);\n"
      "}\n"
      "tx.commit();\n"
      "session.close();]]>"
msgstr ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "for ( int i=0; i<100000; i++ ) {\n"
      "    Customer customer = new Customer(.....);\n"
      "    session.save(customer);\n"
      "}\n"
      "tx.commit();\n"
      "session.close();]]>"

#: index.docbook:14
msgid "This would fall over with an <literal>OutOfMemoryException</literal> somewhere around the 50 000th row. That's because Hibernate caches all the newly inserted <literal>Customer</literal> instances in the session-level cache."
msgstr "これは50,000番目の行のあたりで <literal>OutOfMemoryException</literal> で失敗するでしょう。 Hibernateがセッションレベルキャッシュで、 新しく挿入されたすべての <literal>Customer</literal> インスタンスをキャッシュするからです。"

#: index.docbook:20
msgid "In this chapter we'll show you how to avoid this problem. First, however, if you are doing batch processing, it is absolutely critical that you enable the use of JDBC batching, if you intend to achieve reasonable performance. Set the JDBC batch size to a reasonable number (say, 10-50):"
msgstr "この章では、この問題を回避する方法を紹介します。 しかしバッチ処理をするなら、JDBCバッチが使用可能であることが非常に重要です。 そうでなければ手頃なパフォーマンスが得られません。 JDBCバッチサイズを手頃な数値（例えば、10から50）に設定してください："

#: index.docbook:27
msgid "<![CDATA[hibernate.jdbc.batch_size 20]]>"
msgstr "<![CDATA[hibernate.jdbc.batch_size 20]]>"

#: index.docbook:29
msgid "Note that Hibernate disables insert batching at the JDBC level transparently if you use an <literal>identiy</literal> identifier generator."
msgstr "また二次キャッシュが全く効かないプロセスで、 このような作業をしたいと思うかもしれません："

#: index.docbook:34
msgid "You also might like to do this kind of work in a process where interaction with the second-level cache is completely disabled:"
msgstr "<![CDATA[hibernate.cache.use_second_level_cache false]]>"

#: index.docbook:39
msgid "<![CDATA[hibernate.cache.use_second_level_cache false]]>"
msgstr "しかし、これは絶対に必要というわけではありません。 なぜなら明示的に <literal>CacheMode</literal> を設定して、 二次キャッシュとの相互作用を無効にすることができるからです。"

#: index.docbook:41
msgid "However, this is not absolutely necessary, since we can explicitly set the <literal>CacheMode</literal> to disable interaction with the second-level cache."
msgstr "バッチ挿入"

#: index.docbook:47
msgid "Batch inserts"
msgstr "新しいオブジェクトを永続化するとき、一次キャッシュのサイズを制限するため、 セッションを <literal>flush()</literal> して <literal>clear()</literal> しなければなりません。"

#: index.docbook:49
msgid "When making new objects persistent, you must <literal>flush()</literal> and then <literal>clear()</literal> the session regularly, to control the size of the first-level cache."
msgstr ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "   \n"
      "for ( int i=0; i<100000; i++ ) {\n"
      "    Customer customer = new Customer(.....);\n"
      "    session.save(customer);\n"
      "    if ( i % 20 == 0 ) { //20, same as the JDBC batch size\n"
      "        //flush a batch of inserts and release memory:\n"
      "        session.flush();\n"
      "        session.clear();\n"
      "    }\n"
      "}\n"
      "   \n"
      "tx.commit();\n"
      "session.close();]]>"

#: index.docbook:55
msgid ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "   \n"
      "for ( int i=0; i<100000; i++ ) {\n"
      "    Customer customer = new Customer(.....);\n"
      "    session.save(customer);\n"
      "    if ( i % 20 == 0 ) { //20, same as the JDBC batch size\n"
      "        //flush a batch of inserts and release memory:\n"
      "        session.flush();\n"
      "        session.clear();\n"
      "    }\n"
      "}\n"
      "   \n"
      "tx.commit();\n"
      "session.close();]]>"
msgstr "バッチ更新"

#: index.docbook:60
msgid "Batch updates"
msgstr "データを復元したり更新したりするには同じアイディアを適用します。 それに加えて、データの行を多く返すクエリに対して有効な サーバーサイドのカーソルの利点を生かしたければ <literal>scroll()</literal> を使う必要があります。"

#: index.docbook:62
msgid "For retrieving and updating data the same ideas apply. In addition, you need to use <literal>scroll()</literal> to take advantage of server-side cursors for queries that return many rows of data."
msgstr ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "   \n"
      "ScrollableResults customers = session.getNamedQuery(\"GetCustomers\")\n"
      "    .setCacheMode(CacheMode.IGNORE)\n"
      "    .scroll(ScrollMode.FORWARD_ONLY);\n"
      "int count=0;\n"
      "while ( customers.next() ) {\n"
      "    Customer customer = (Customer) customers.get(0);\n"
      "    customer.updateStuff(...);\n"
      "    if ( ++count % 20 == 0 ) {\n"
      "        //flush a batch of updates and release memory:\n"
      "        session.flush();\n"
      "        session.clear();\n"
      "    }\n"
      "}\n"
      "   \n"
      "tx.commit();\n"
      "session.close();]]>"

#: index.docbook:68
msgid ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "   \n"
      "ScrollableResults customers = session.getNamedQuery(\"GetCustomers\")\n"
      "    .setCacheMode(CacheMode.IGNORE)\n"
      "    .scroll(ScrollMode.FORWARD_ONLY);\n"
      "int count=0;\n"
      "while ( customers.next() ) {\n"
      "    Customer customer = (Customer) customers.get(0);\n"
      "    customer.updateStuff(...);\n"
      "    if ( ++count % 20 == 0 ) {\n"
      "        //flush a batch of updates and release memory:\n"
      "        session.flush();\n"
      "        session.clear();\n"
      "    }\n"
      "}\n"
      "   \n"
      "tx.commit();\n"
      "session.close();]]>"
msgstr "StatelessSessionインターフェイス"

#: index.docbook:73
msgid "The StatelessSession interface"
msgstr "また別の方法として、Hibernateはコマンド指向のAPIを用意しています。 これは分離オブジェクトの形で、 データベースとのデータストリームのやり取りに使うことができます。 <literal>StatelessSession</literal> は関連する永続コンテキストを持たず、 高レベルのライフサイクルセマンティクスの多くを提供しません。 特にステートレスセッションは、一時キャッシュを実装せず、 またどのような二次キャッシュやクエリキャッシュとも相互作用しません。 トランザクショナルなwrite-behindや自動ダーティチェックも実装しません。 ステートレスセッションを使って行われる操作が、 関連するインスタンスへカスケードされることは決してありません。 コレクションは、ステートレスセッションからは無視されます。 ステートレスセッションを通して行われる操作は、 Hibernateのイベントモデルやインターセプタの影響を受けません。 一時キャッシュを持たないため、 ステートレスセッションは別名を持つデータに上手く対処できません。 ステートレスセッションは低レベルの抽象化であり、JDBCに非常によく似ています。"

#: index.docbook:74
msgid "Alternatively, Hibernate provides a command-oriented API that may be used for streaming data to and from the database in the form of detached objects. A <literal>StatelessSession</literal> has no persistence context associated with it and does not provide many of the higher-level life cycle semantics. In particular, a stateless session does not implement a first-level cache nor interact with any second-level or query cache. It does not implement transactional write-behind or automatic dirty checking. Operations performed using a stateless session do not ever cascade to associated instances. Collections are ignored by a stateless session. Operations performed via a stateless session bypass Hibernate's event model and interceptors. Stateless sessions are vulnerable to data aliasing effects, due to the lack of a first-level cache. A stateless session is a lower-level abstraction, much closer to the underlying JDBC."
msgstr ""
      "<![CDATA[StatelessSession session = sessionFactory.openStatelessSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "   \n"
      "ScrollableResults customers = session.getNamedQuery(\"GetCustomers\")\n"
      "    .scroll(ScrollMode.FORWARD_ONLY);\n"
      "while ( customers.next() ) {\n"
      "    Customer customer = (Customer) customers.get(0);\n"
      "    customer.updateStuff(...);\n"
      "    session.update(customer);\n"
      "}\n"
      "   \n"
      "tx.commit();\n"
      "session.close();]]>"

#: index.docbook:89
msgid ""
      "<![CDATA[StatelessSession session = sessionFactory.openStatelessSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "   \n"
      "ScrollableResults customers = session.getNamedQuery(\"GetCustomers\")\n"
      "    .scroll(ScrollMode.FORWARD_ONLY);\n"
      "while ( customers.next() ) {\n"
      "    Customer customer = (Customer) customers.get(0);\n"
      "    customer.updateStuff(...);\n"
      "    session.update(customer);\n"
      "}\n"
      "   \n"
      "tx.commit();\n"
      "session.close();]]>"
msgstr "このコード例では、クエリが返す <literal>Customer</literal> インスタンスは即座に（セッションから）分離されることに注意してください。 これは、どのような永続コンテキストとも決して関連しません。"

#: index.docbook:91
msgid "Note that in this code example, the <literal>Customer</literal> instances returned by the query are immediately detached. They are never associated with any persistence context."
msgstr "<literal>StatelessSession</literal> インターフェイスで定義されている <literal>insert(), update(), delete()</literal> は、 低レベルの直接的なデータベース操作と考えられます。 結果として、SQLの <literal>INSERT, UPDATE, DELETE</literal> がそれぞれ即座に実行されます。 このように、これらは <literal>Session</literal> インターフェイスで定義されている <literal>save(), saveOrUpdate(), delete()</literal> とは非常に異なる意味を持ちます。"

#: index.docbook:97
msgid "The <literal>insert(), update()</literal> and <literal>delete()</literal> operations defined by the <literal>StatelessSession</literal> interface are considered to be direct database row-level operations, which result in immediate execution of a SQL <literal>INSERT, UPDATE</literal> or <literal>DELETE</literal> respectively. Thus, they have very different semantics to the <literal>save(), saveOrUpdate()</literal> and <literal>delete()</literal> operations defined by the <literal>Session</literal> interface."
msgstr "DMLスタイルの操作"

#: index.docbook:110
msgid "DML-style operations"
msgstr "すでに議論したように、自動的かつ透過的なオブジェクト/リレーショナルマッピングは、 オブジェクトの状態の管理であると考えられます。 これはメモリ内のオブジェクトの状態を利用できるということです。 そのため（SQLの <literal>データ操作言語</literal> (DML) 文： <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal> を使って）データベース内のデータを直接操作しても、 メモリ内の状態には影響を与えません。 しかしHibernateは、バルクSQLスタイルのDML文実行に対応するメソッドを用意しています。 これはHibernateクエリ言語（<xref linkend=\"queryhql\"/>HQL） を通して実行されます。"

#: index.docbook:112
msgid "As already discussed, automatic and transparent object/relational mapping is concerned with the management of object state. This implies that the object state is available in memory, hence manipulating (using the SQL <literal>Data Manipulation Language</literal> (DML) statements: <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>) data directly in the database will not affect in-memory state. However, Hibernate provides methods for bulk SQL-style DML statement execution which are performed through the Hibernate Query Language (<xref linkend=\"queryhql\"/>HQL)."
msgstr "<literal>UPDATE</literal> と <literal>DELETE</literal> 文の疑似構文は： <literal>( UPDATE | DELETE ) FROM? エンティティ名 (WHERE 条件節)?</literal> です。 注意すべき点がいくつかあります："

#: index.docbook:122
msgid "The pseudo-syntax for <literal>UPDATE</literal> and <literal>DELETE</literal> statements is: <literal>( UPDATE | DELETE ) FROM? EntityName (WHERE where_conditions)?</literal>. Some points to note:"
msgstr "from節において、FROMキーワードはオプションです。"

#: index.docbook:130
msgid "In the from-clause, the FROM keyword is optional"
msgstr "from節では単一のエンティティ名だけが可能で、 任意で別名を付けることができます。 エンティティ名に別名が与えられると、どのようなプロパティ参照も、 その別名を使って修飾しなければなりません。 もしエンティティ名に別名が与えられなければ、 どのようなプロパティ参照も修飾してはなりません。"

#: index.docbook:135
msgid "There can only be a single entity named in the from-clause; it can optionally be aliased. If the entity name is aliased, then any property references must be qualified using that alias; if the entity name is not aliased, then it is illegal for any property references to be qualified."
msgstr "（暗黙的であれ明示的であれ）<xref linkend=\"queryhql-joins-forms\"/>結合 をバルクHQLクエリ内で指定することはできません。 サブクエリはwhere節で使うことができます サブクエリそのものは、結合を含められます。"

#: index.docbook:143
msgid "No <xref linkend=\"queryhql-joins-forms\"/>joins (either implicit or explicit) can be specified in a bulk HQL query. Sub-queries may be used in the where-clause; the subqueries, themselves, may contain joins."
msgstr "where節はオプションです。"

#: index.docbook:150
msgid "The where-clause is also optional."
msgstr "例として、HQLの <literal>UPDATE</literal> を実行するには、 <literal>Query.executeUpdate()</literal> メソッドを使ってください。 （このメソッドはおなじみのJDBC <literal>PreparedStatement.executeUpdate()</literal> から名付けられました）： d"

#: index.docbook:156
msgid "As an example, to execute an HQL <literal>UPDATE</literal>, use the <literal>Query.executeUpdate()</literal> method (the method is named for those familiar with JDBC's <literal>PreparedStatement.executeUpdate()</literal>):"
msgstr ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "\n"
      "String hqlUpdate = \"update Customer c set c.name = :newName where c.name = :oldName\";\n"
      "// or String hqlUpdate = \"update Customer set name = :newName where name = :oldName\";\n"
      "int updatedEntities = s.createQuery( hqlUpdate )\n"
      "        .setString( \"newName\", newName )\n"
      "        .setString( \"oldName\", oldName )\n"
      "        .executeUpdate();\n"
      "tx.commit();\n"
      "session.close();]]>"

#: index.docbook:162
msgid ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "\n"
      "String hqlUpdate = \"update Customer c set c.name = :newName where c.name = :oldName\";\n"
      "// or String hqlUpdate = \"update Customer set name = :newName where name = :oldName\";\n"
      "int updatedEntities = s.createQuery( hqlUpdate )\n"
      "        .setString( \"newName\", newName )\n"
      "        .setString( \"oldName\", oldName )\n"
      "        .executeUpdate();\n"
      "tx.commit();\n"
      "session.close();]]>"
msgstr "HQLの <literal>UPDATE</literal> 文は、デフォルトでは、作用するエンティティの <xref linkend=\"mapping-declaration-version\"/>version や <xref linkend=\"mapping-declaration-timestamp\"/>timestamp プロパティの値には影響しません。 これはEJB3の仕様にも受け継がれています。 しかし <literal>versioned update</literal> を使って、 <literal>version</literal> や <literal>timestamp</literal> プロパティの値を強制的にリセットさせることができます。 これは <literal>UPDATE</literal> キーワードの後に <literal>VERSIONED</literal> キーワードを追加することで行えます。"

#: index.docbook:164
msgid "HQL <literal>UPDATE</literal> statements, by default do not effect the <xref linkend=\"mapping-declaration-version\"/>version or the <xref linkend=\"mapping-declaration-timestamp\"/>timestamp property values for the affected entities; this is in keeping with the EJB3 specification. However, you can force Hibernate to properly reset the <literal>version</literal> or <literal>timestamp</literal> property values through the use of a <literal>versioned update</literal>. This is achieved by adding the <literal>VERSIONED</literal> keyword after the <literal>UPDATE</literal> keyword."
msgstr ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "String hqlVersionedUpdate = \"update versioned Customer set name = :newName where name = :oldName\";\n"
      "int updatedEntities = s.createQuery( hqlUpdate )\n"
      "        .setString( \"newName\", newName )\n"
      "        .setString( \"oldName\", oldName )\n"
      "        .executeUpdate();\n"
      "tx.commit();\n"
      "session.close();]]>"

#: index.docbook:174
msgid ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "String hqlVersionedUpdate = \"update versioned Customer set name = :newName where name = :oldName\";\n"
      "int updatedEntities = s.createQuery( hqlUpdate )\n"
      "        .setString( \"newName\", newName )\n"
      "        .setString( \"oldName\", oldName )\n"
      "        .executeUpdate();\n"
      "tx.commit();\n"
      "session.close();]]>"
msgstr "カスタムバージョン型（<literal>org.hibernate.usertype.UserVersionType</literal>） は <literal>update versioned</literal> 文と一緒に使えないことに注意してください。"

#: index.docbook:176
msgid "Note that custom version types (<literal>org.hibernate.usertype.UserVersionType</literal>) are not allowed in conjunction with a <literal>update versioned</literal> statement."
msgstr "HQLの <literal>DELETE</literal> を実行するには、 同じ <literal>Query.executeUpdate()</literal> メソッドを使ってください："

#: index.docbook:181
msgid "To execute an HQL <literal>DELETE</literal>, use the same <literal>Query.executeUpdate()</literal> method:"
msgstr ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "\n"
      "String hqlDelete = \"delete Customer c where c.name = :oldName\";\n"
      "// or String hqlDelete = \"delete Customer where name = :oldName\";\n"
      "int deletedEntities = s.createQuery( hqlDelete )\n"
      "        .setString( \"oldName\", oldName )\n"
      "        .executeUpdate();\n"
      "tx.commit();\n"
      "session.close();]]>"

#: index.docbook:186
msgid ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "\n"
      "String hqlDelete = \"delete Customer c where c.name = :oldName\";\n"
      "// or String hqlDelete = \"delete Customer where name = :oldName\";\n"
      "int deletedEntities = s.createQuery( hqlDelete )\n"
      "        .setString( \"oldName\", oldName )\n"
      "        .executeUpdate();\n"
      "tx.commit();\n"
      "session.close();]]>"
msgstr "<literal>Query.executeUpdate()</literal> メソッドが返す <literal>int</literal> の値は、この操作が影響を及ぼしたエンティティの数です。 これが影響するデータベース内の行数と、相互に関係するかどうかを考えてみてください。 HQLバルク操作は、結果として、実際のSQL文が複数実行されることになります。 例えばjoined-subclassです。 返される数は、その文によって影響された実際のエンティティの数を示します。 joined-subclassの例に戻ると、サブクラスの一つに対する削除は、 そのサブクラスがマッピングされたテーブルだけではなく、 「ルート」テーブルと継承階層をさらに下ったjoined-subclassのテーブルの削除になります。"

#: index.docbook:188
msgid "The <literal>int</literal> value returned by the <literal>Query.executeUpdate()</literal> method indicate the number of entities effected by the operation. Consider this may or may not correlate to the number of rows effected in the database. An HQL bulk operation might result in multiple actual SQL statements being executed, for joined-subclass, for example. The returned number indicates the number of actual entities affected by the statement. Going back to the example of joined-subclass, a delete against one of the subclasses may actually result in deletes against not just the table to which that subclass is mapped, but also the \"root\" table and potentially joined-subclass tables further down the inheritence hierarchy."
msgstr "<literal>INSERT</literal> 文の疑似構文は： <literal>INSERT INTO エンティティ名 プロパティリスト select文</literal> です。 注意すべき点がいくつかあります："

#: index.docbook:199
msgid "The pseudo-syntax for <literal>INSERT</literal> statements is: <literal>INSERT INTO EntityName properties_list select_statement</literal>. Some points to note:"
msgstr "INSERT INTO ... SELECT ... の形式だけがサポートされています。 INSERT INTO ... VALUES ... の形式はサポートされていません。"

#: index.docbook:207
msgid "Only the INSERT INTO ... SELECT ... form is supported; not the INSERT INTO ... VALUES ... form."
msgstr "プロパティリストは、SQLの <literal>INSERT</literal> 文における <literal>カラムの仕様</literal> に類似しています。 継承のマッピングに含まれるエンティティに対して、 クラスレベルで直接定義されたプロパティだけが、プロパティリストに使えます。 スーパークラスのプロパティは認められず、サブクラスのプロパティは効果がありません。 言い換えると <literal>INSERT</literal> 文は、本質的にポリモーフィックではありません。"

#: index.docbook:210
msgid "The properties_list is analogous to the <literal>column speficiation</literal> in the SQL <literal>INSERT</literal> statement. For entities involved in mapped inheritence, only properties directly defined on that given class-level can be used in the properties_list. Superclass properties are not allowed; and subclass properties do not make sense. In other words, <literal>INSERT</literal> statements are inherently non-polymorphic."
msgstr "select文の返り値の型がinsert文が期待する型とマッチしていれば、 そのselect文は妥当なHQL selectクエリとなりえます。 現在このチェックをデータベースへ任せるのではなく、クエリのコンパイル時にチェックします。 このことは、<emphasis>equal</emphasis>とは違い、 Hibernateの <literal>Type</literal> 間の <emphasis>equivalent</emphasis> に関する 問題を引き起こすことに注意してください。 これは <literal>org.hibernate.type.DataType</literal> として定義されたプロパティと、 <literal>org.hibernate.type.TimestampType</literal> として定義されたプロパティの間のミスマッチの問題を引き起こします。 データベースがそれらを区別できなくても、変換することができても、この問題は発生します。"

#: index.docbook:220
msgid "select_statement can be any valid HQL select query, with the caveat that the return types must match the types expected by the insert. Currently, this is checked during query compilation rather than allowing the check to relegate to the database. Note however that this might cause problems between Hibernate <literal>Type</literal>s which are <emphasis>equivalent</emphasis> as opposed to <emphasis>equal</emphasis>. This might cause issues with mismatches between a property defined as a <literal>org.hibernate.type.DateType</literal> and a property defined as a <literal>org.hibernate.type.TimestampType</literal>, even though the database might not make a distinction or might be able to handle the conversion."
msgstr "idプロパティに対して、insert文には二つの選択肢があります。 プロパティリストで明示的にidプロパティを指定するか （この場合、対応するselect式から値が取られます）、 プロパティリストから除外するか （この場合、生成される値が使われます）のいずれかです。 後者の選択肢は、データベース内を操作するidジェネレータを使うときのみ、利用可能です。 この選択肢を採る場合、「インメモリ」型のジェネレータを使うと、構文解析時に例外が発生します。 この議論では、インデータベース型ジェネレータは <literal>org.hibernate.id.SequenceGenerator</literal> （とそのサブクラス）と、<literal>org.hibernate.id.PostInsertIdentifierGenerator</literal> の実装であると考えています。 ここで最も注意すべき例外は、<literal>org.hibernate.id.TableHiLoGenerator</literal> です。 値を取得する選択可能な方法がないため、このジェネレータを使うことはできません。"

#: index.docbook:232
msgid "For the id property, the insert statement gives you two options. You can either explicitly specify the id property in the properties_list (in which case its value is taken from the corresponding select expression) or omit it from the properties_list (in which case a generated value is used). This later option is only available when using id generators that operate in the database; attempting to use this option with any \"in memory\" type generators will cause an exception during parsing. Note that for the purposes of this discussion, in-database generators are considered to be <literal>org.hibernate.id.SequenceGenerator</literal> (and its subclasses) and any implementors of <literal>org.hibernate.id.PostInsertIdentifierGenerator</literal>. The most notable exception here is <literal>org.hibernate.id.TableHiLoGenerator</literal>, which cannot be used because it does not expose a selectable way to get its values."
msgstr "<literal>version</literal> や <literal>timestamp</literal> としてマッピングされるプロパティに対して、 insert文には二つの選択肢があります。 プロパティリストで明示的にプロパティを指定するか （この場合、対応するselect式から値が取られます）、 プロパティリストから除外するか （この場合、<literal>org.hibernate.type.VersionType</literal> で定義された <literal>シード値</literal> が使われます）のいずれかです。"

#: index.docbook:247
msgid "For properties mapped as either <literal>version</literal> or <literal>timestamp</literal>, the insert statement gives you two options. You can either specify the property in the properties_list (in which case its value is taken from the corresponding select expressions) or omit it from the properties_list (in which case the <literal>seed value</literal> defined by the <literal>org.hibernate.type.VersionType</literal> is used)."
msgstr "HQLの <literal>INSERT</literal> 文の実行例です："

#: index.docbook:257
msgid "An example HQL <literal>INSERT</literal> statement execution:"
msgstr ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "\n"
      "String hqlInsert = \"insert into DelinquentAccount (id, name) select c.id, c.name from Customer c where ...\";\n"
      "int createdEntities = s.createQuery( hqlInsert )\n"
      "        .executeUpdate();\n"
      "tx.commit();\n"
      "session.close();]]>"

#: index.docbook:261
msgid ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "\n"
      "String hqlInsert = \"insert into DelinquentAccount (id, name) select c.id, c.name from Customer c where ...\";\n"
      "int createdEntities = s.createQuery( hqlInsert )\n"
      "        .executeUpdate();\n"
      "tx.commit();\n"
      "session.close();]]>"
msgstr ""

msgid "ROLES_OF_TRANSLATORS"
msgstr "<!--TRANS:ROLES_OF_TRANSLATORS-->"

msgid "CREDIT_FOR_TRANSLATORS"
msgstr "<!--TRANS:CREDIT_FOR_TRANSLATORS-->"

