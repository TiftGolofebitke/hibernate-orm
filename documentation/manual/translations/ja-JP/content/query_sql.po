#, fuzzy
msgid ""
msgstr ""
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Content-Type: text/plain; charset=utf-8\n"
#: index.docbook:5
msgid "Native SQL"
msgstr "ネイティブSQL"

#: index.docbook:7
msgid "You may also express queries in the native SQL dialect of your database. This is useful if you want to utilize database specific features such as query hints or the <literal>CONNECT</literal> keyword in Oracle. It also provides a clean migration path from a direct SQL/JDBC based application to Hibernate."
msgstr "データベースのネイティブSQL方言を使ってクエリを表現することもできます。 クエリヒントやOracleの <literal>CONNECT</literal> キーワードのように、 データベース独自の機能を利用したいときに使えます。 SQL/JDBCを直接使用しているアプリケーションからHibernateへの移行も容易にしています。"

#: index.docbook:13
msgid "Hibernate3 allows you to specify handwritten SQL (including stored procedures) for all create, update, delete, and load operations."
msgstr "Hibernate3では、生成、更新、削除、読み込み処理のようなすべての SQL（ストアドプロシージャを含む）を手書きできます。"

#: index.docbook:17
msgid "Using a <literal>SQLQuery</literal>"
msgstr "<literal>SQLQuery</literal> の使用"

#: index.docbook:19
msgid "Execution of native SQL queries is controlled via the <literal>SQLQuery</literal> interface, which is obtained by calling <literal>Session.createSQLQuery()</literal>. The following describes how to use this API for querying."
msgstr "ネイティブなSQLクエリの実行は <literal>SQLQuery</literal> インターフェイスを通して制御します。 <literal>SQLQuery</literal> インターフェイスは <literal>Session.createSQLQuery()</literal> を呼び出して取得します。 このAPIを使って問い合わせする方法を以下で説明します。"

#: index.docbook:25
msgid "Scalar queries"
msgstr "スカラーのクエリ"

#: index.docbook:27
msgid "The most basic SQL query is to get a list of scalars (values)."
msgstr "最も基本的なSQLクエリはスカラー（値）のリストを得ることです。"

#: index.docbook:30
msgid ""
      "<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\").list();\n"
      "sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE FROM CATS\").list();\n"
      "]]>"
msgstr ""
      "<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\").list();\n"
      "sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE FROM CATS\").list();\n"
      "]]>"

#: index.docbook:32
msgid "These will both return a List of Object arrays (Object[]) with scalar values for each column in the CATS table. Hibernate will use ResultSetMetadata to deduce the actual order and types of the returned scalar values."
msgstr "これらはどちらも、CATSテーブルの各カラムのスカラー値を含む Object配列（Object[]）のリストを返します。 返すスカラー値の実際の順番と型を推定するために、 HibernateはResultSetMetadataを使用します。"

#: index.docbook:37
msgid "To avoid the overhead of using <literal>ResultSetMetadata</literal> or simply to be more explicit in what is returned one can use <literal>addScalar()</literal>."
msgstr "<literal>ResultSetMetadata</literal> を使用するオーバーヘッドを避けるため、 もしくは単に何が返されるか明確にするため、<literal>addScalar()</literal> を使えます。"

#: index.docbook:41
msgid ""
      "<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\")\n"
      " .addScalar(\"ID\", Hibernate.LONG)\n"
      " .addScalar(\"NAME\", Hibernate.STRING)\n"
      " .addScalar(\"BIRTHDATE\", Hibernate.DATE)\n"
      "]]>"
msgstr ""
      "<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\")\n"
      " .addScalar(\"ID\", Hibernate.LONG)\n"
      " .addScalar(\"NAME\", Hibernate.STRING)\n"
      " .addScalar(\"BIRTHDATE\", Hibernate.DATE)\n"
      "]]>"

#: index.docbook:43, index.docbook:89, index.docbook:170, index.docbook:321
msgid "This query specified:"
msgstr "このクエリで指定されているものを下記に示します。"

#: index.docbook:47, index.docbook:93, index.docbook:325
msgid "the SQL query string"
msgstr "SQLクエリ文字列"

#: index.docbook:51
msgid "the columns and types to return"
msgstr "返されるカラムと型"

#: index.docbook:55
msgid "This will still return Object arrays, but now it will not use <literal>ResultSetMetdata</literal> but will instead explicitly get the ID, NAME and BIRTHDATE column as respectively a Long, String and a Short from the underlying resultset. This also means that only these three columns will be returned, even though the query is using <literal>*</literal> and could return more than the three listed columns."
msgstr "これはまだObject配列を返しますが、 <literal>ResultSetMetdata</literal> を使用しません。 ただし、その代わりに基礎にあるリザルトセットから ID、NAME、BIRTHDATE カラムをそれぞれ Long、String、Short として明示的に取得します。 これは３つのカラムを返すのみであることも意味します。 たとえ、クエリが <literal>*</literal> を使用し、 列挙した３つより多くのカラムを返せるとしてもです。"

#: index.docbook:63
msgid "It is possible to leave out the type information for all or some of the scalars."
msgstr "スカラーの型情報を省くこともできます。"

#: index.docbook:66
msgid ""
      "<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\")\n"
      " .addScalar(\"ID\", Hibernate.LONG)\n"
      " .addScalar(\"NAME\")\n"
      " .addScalar(\"BIRTHDATE\")\n"
      "]]>"
msgstr ""
      "<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\")\n"
      " .addScalar(\"ID\", Hibernate.LONG)\n"
      " .addScalar(\"NAME\")\n"
      " .addScalar(\"BIRTHDATE\")\n"
      "]]>"

#: index.docbook:68
msgid "This is essentially the same query as before, but now <literal>ResultSetMetaData</literal> is used to decide the type of NAME and BIRTHDATE where as the type of ID is explicitly specified."
msgstr "これは本質的に前と同じクエリですが、、 NAME と BIRTHDATE の型を決めるために <literal>ResultSetMetaData</literal> を使用します。一方、ID の型は明示的に指定されています。"

#: index.docbook:72
msgid "How the java.sql.Types returned from ResultSetMetaData is mapped to Hibernate types is controlled by the Dialect. If a specific type is not mapped or does not result in the expected type it is possible to customize it via calls to <literal>registerHibernateType</literal> in the Dialect."
msgstr "ResultSetMetaData から返される java.sql.Types を Hibernate の型に マッピングすることは、Dialect が制御します。 明示された型がマッピングされていないか、結果の型が期待したものと異なる場合、 Dialect の <literal>registerHibernateType</literal> を呼び出し、 カスタマイズできます。"

#: index.docbook:80
msgid "Entity queries"
msgstr "エンティティのクエリ"

#: index.docbook:82
msgid "The above queries were all about returning scalar values, basically returning the \"raw\" values from the resultset. The following shows how to get entity objects from a native sql query via <literal>addEntity()</literal>."
msgstr "ここまでのクエリは、すべてスカラー値を返すものでした。 基本的に、リザルトセットから「未加工」の値を返します。 以降では、<literal>addEntity()</literal> により、ネイティブSQLクエリから エンティティオブジェクトを取得する方法を示します。"

#: index.docbook:87
msgid ""
      "<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\").addEntity(Cat.class);\n"
      "sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE FROM CATS\").addEntity(Cat.class);\n"
      "]]>"
msgstr ""
      "<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\").addEntity(Cat.class);\n"
      "sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE FROM CATS\").addEntity(Cat.class);\n"
      "]]>"

#: index.docbook:97
msgid "the entity returned by the query"
msgstr "クエリが返すエンティティとSQLテーブルの別名"

#: index.docbook:101
msgid "Assuming that Cat is mapped as a class with the columns ID, NAME and BIRTHDATE the above queries will both return a List where each element is a Cat entity."
msgstr "CatがID, NAME, BIRTHDATEのカラムを使ってクラスにマッピングされる場合、 上記のクエリはどちらも、要素がCatエンティティであるリストを返します。"

#: index.docbook:105
msgid "If the entity is mapped with a <literal>many-to-one</literal> to another entity it is required to also return this when performing the native query, otherwise a database specific \"column not found\" error will occur. The additional columns will automatically be returned when using the * notation, but we prefer to be explicit as in the following example for a <literal>many-to-one</literal> to a <literal>Dog</literal>:"
msgstr "エンティティを別のエンティティに <literal>多対一</literal> でマッピングしている場合は、 ネイティブクエリを実行する際に、この別のエンティティを返すことも要求します。 さもなければ、データベース固有の「column not found(カラムが見つかりません)」エラーが発生します。 * 表記を使用した際は、追加のカラムが自動的に返されますが、 次の例のように、<literal>Dog</literal> に <literal>多対一</literal> であることを 明示することを私たちは好みます。"

#: index.docbook:113
msgid ""
      "<![CDATA[sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE, DOG_ID FROM CATS\").addEntity(Cat.class);\n"
      "]]>"
msgstr ""
      "<![CDATA[sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE, DOG_ID FROM CATS\").addEntity(Cat.class);\n"
      "]]>"

#: index.docbook:115
msgid "This will allow cat.getDog() to function properly."
msgstr "これにより cat.getDog() が正しく機能します。"

#: index.docbook:119
msgid "Handling associations and collections"
msgstr "関連とコレクションの操作"

#: index.docbook:121
msgid "It is possible to eagerly join in the <literal>Dog</literal> to avoid the possible extra roundtrip for initializing the proxy. This is done via the <literal>addJoin()</literal> method, which allows you to join in an association or collection."
msgstr "プロキシを初期化するための余分な処理を避けるため、 <literal>Dog</literal> の中で即時結合できます。 これは <literal>addJoin()</literal> メソッドにより行います。 関連もしくはコレクションに結合できます。"

#: index.docbook:126
msgid ""
      "<![CDATA[sess.createSQLQuery(\"SELECT c.ID, NAME, BIRTHDATE, DOG_ID, D_ID, D_NAME FROM CATS c, DOGS d WHERE c.DOG_ID = d.D_ID\")\n"
      " .addEntity(\"cat\", Cat.class)\n"
      " .addJoin(\"cat.dog\");\n"
      "]]>"
msgstr ""
      "<![CDATA[sess.createSQLQuery(\"SELECT c.ID, NAME, BIRTHDATE, DOG_ID, D_ID, D_NAME FROM CATS c, DOGS d WHERE c.DOG_ID = d.D_ID\")\n"
      " .addEntity(\"cat\", Cat.class)\n"
      " .addJoin(\"cat.dog\");\n"
      "]]>"

#: index.docbook:128
msgid "In this example the returned <literal>Cat</literal>'s will have their <literal>dog</literal> property fully initialized without any extra roundtrip to the database. Notice that we added a alias name (\"cat\") to be able to specify the target property path of the join. It is possible to do the same eager joining for collections, e.g. if the <literal>Cat</literal> had a one-to-many to <literal>Dog</literal> instead."
msgstr "この例の中で、返される <literal>Cat</literal> は、 データベースへの余分処理なしで、 完全に初期化された <literal>dog</literal> プロパティを持ちます。 結合対象のプロパティへのパスを指定できるように、 別名（「cat」）を追加したことに注意してください。 コレクションの即時結合も同じようにできます。 たとえば、<literal>Cat</literal> が一対多で <literal>Dog</literal> を持っていた場合、次のようになります。"

#: index.docbook:136
msgid ""
      "<![CDATA[sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE, D_ID, D_NAME, CAT_ID FROM CATS c, DOGS d WHERE c.ID = d.CAT_ID\")\n"
      " .addEntity(\"cat\", Cat.class)\n"
      " .addJoin(\"cat.dogs\");\n"
      "]]>"
msgstr ""
      "<![CDATA[sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE, D_ID, D_NAME, CAT_ID FROM CATS c, DOGS d WHERE c.ID = d.CAT_ID\")\n"
      " .addEntity(\"cat\", Cat.class)\n"
      " .addJoin(\"cat.dogs\");\n"
      "]]>"

#: index.docbook:138
msgid "At this stage we are reaching the limits of what is possible with native queries without starting to enhance the sql queries to make them usable in Hibernate; the problems starts to arise when returning multiple entities of the same type or when the default alias/column names are not enough."
msgstr "現在のところ、 Hibernateで使いやすくするためのSQLクエリの拡張なしに、 ネイティブクエリで何かを可能にする限界に来ています。 同じ型のエンティティを複数返す際や、デフォルトの別名や列名で十分ではない場合に、 問題は起こり始めます。"

#: index.docbook:146
msgid "Returning multiple entities"
msgstr "複数エンティティの取得"

#: index.docbook:148
msgid "Until now the result set column names are assumed to be the same as the column names specified in the mapping document. This can be problematic for SQL queries which join multiple tables, since the same column names may appear in more than one table."
msgstr "ここまでは、リザルトセットのカラム名は、 マッピングファイルで指定されたカラム名と同じであると仮定していました。 複数のテーブルが同じカラム名を持つ場合があるため、 複数テーブルを結合するSQLクエリで問題となる場合があります。"

#: index.docbook:153
msgid "Column alias injection is needed in the following query (which most likely will fail):"
msgstr "下記のような（失敗しそうな）クエリでは、 カラム別名インジェクション（column alias injection）が必要です。"

#: index.docbook:156
msgid ""
      "<![CDATA[sess.createSQLQuery(\"SELECT c.*, m.*  FROM CATS c, CATS m WHERE c.MOTHER_ID = c.ID\")\n"
      " .addEntity(\"cat\", Cat.class)\n"
      " .addEntity(\"mother\", Cat.class)\n"
      "]]>"
msgstr ""
      "<![CDATA[sess.createSQLQuery(\"SELECT c.*, m.*  FROM CATS c, CATS m WHERE c.MOTHER_ID = m.ID\")\n"
      " .addEntity(\"cat\", Cat.class)\n"
      " .addEntity(\"mother\", Cat.class)\n"
      "]]>"

#: index.docbook:158
msgid "The intention for this query is to return two Cat instances per row, a cat and its mother. This will fail since there is a conflict of names since they are mapped to the same column names and on some databases the returned column aliases will most likely be on the form \"c.ID\", \"c.NAME\", etc. which are not equal to the columns specificed in the mappings (\"ID\" and \"NAME\")."
msgstr "このクエリの意図は、 １行ごとに２つのCatインスタンス、つまり猫とその母親を返すということです。 同じカラム名にマッピングすることにより名前が衝突するため、このクエリは失敗します。 ベータベースによっては、返されるカラムの別名が \"c.ID\"、\"c.NAME\" などの形式であり、 マッピングで指定されたカラム（\"ID\" と \"NAME\"）と等しくないため、失敗します。"

#: index.docbook:165
msgid "The following form is not vulnerable to column name duplication:"
msgstr "下記の形式は、カラム名が重複しても大丈夫です。"

#: index.docbook:168
msgid ""
      "<![CDATA[sess.createSQLQuery(\"SELECT {cat.*}, {mother.*}  FROM CATS c, CATS m WHERE c.MOTHER_ID = c.ID\")\n"
      " .addEntity(\"cat\", Cat.class)\n"
      " .addEntity(\"mother\", Cat.class)\n"
      "]]>"
msgstr ""
      "<![CDATA[sess.createSQLQuery(\"SELECT {cat.*}, {mother.*}  FROM CATS c, CATS m WHERE c.MOTHER_ID = m.ID\")\n"
      " .addEntity(\"cat\", Cat.class)\n"
      " .addEntity(\"mother\", Cat.class)\n"
      "]]>"

#: index.docbook:174
msgid "the SQL query string, with placeholders for Hibernate to inject column aliases"
msgstr "SQLクエリ文字列 （Hibernateがカラムの別名を挿入するためのプレースホルダを含む）"

#: index.docbook:179
msgid "the entities returned by the query"
msgstr "クエリによって返されるエンティティ"

#: index.docbook:183
msgid "The {cat.*} and {mother.*} notation used above is a shorthand for \"all properties\". Alternatively, you may list the columns explicity, but even in this case we let Hibernate inject the SQL column aliases for each property. The placeholder for a column alias is just the property name qualified by the table alias. In the following example, we retrieve Cats and their mothers from a different table (cat_log) to the one declared in the mapping metadata. Notice that we may even use the property aliases in the where clause if we like."
msgstr "上記で使用している {cat.*} と {mother.*} という表記は、 「すべてのプロパティ」を表す省略形です。 代わりに、明示的にカラムを列挙してもよいですが、 その場合は、Hibernateに各プロパティに対応するSQLカラムの別名を挿入させるべきでしょう。 カラムの別名のためのプレースホルダは、テーブルの別名によって修飾されたプロパティ名です。 下記の例では、別のテーブル cat_log から マッピングメタデータで定義された Cat とその母親を復元します。 もし好むなら、where節の中でも、プロパティの別名を使えます。"

#: index.docbook:192
msgid ""
      "<![CDATA[String sql = \"SELECT ID as {c.id}, NAME as {c.name}, \" + \n"
      "         \"BIRTHDATE as {c.birthDate}, MOTHER_ID as {c.mother}, {mother.*} \" +\n"
      "         \"FROM CAT_LOG c, CAT_LOG m WHERE {c.mother} = c.ID\";\n"
      "\n"
      "List loggedCats = sess.createSQLQuery(sql)\n"
      "        .addEntity(\"cat\", Cat.class)\n"
      "        .addEntity(\"mother\", Cat.class).list()\n"
      "]]>"
msgstr ""
      "<![CDATA[String sql = \"SELECT ID as {c.id}, NAME as {c.name}, \" + \n"
      "         \"BIRTHDATE as {c.birthDate}, MOTHER_ID as {c.mother}, {mother.*} \" +\n"
      "         \"FROM CAT_LOG c, CAT_LOG m WHERE {c.mother} = c.ID\";\n"
      "\n"
      "List loggedCats = sess.createSQLQuery(sql)\n"
      "        .addEntity(\"cat\", Cat.class)\n"
      "        .addEntity(\"mother\", Cat.class).list()\n"
      "]]>"

#: index.docbook:195
msgid "Alias and property references"
msgstr "別名とプロパティのリファレンス"

#: index.docbook:197
msgid "For most cases the above alias injection is needed, but for queries relating to more complex mappings like composite properties, inheritance discriminators, collections etc. there are some specific aliases to use to allow Hibernate to inject the proper aliases."
msgstr "多くの場合、上記のような別名インジェクションが必要です。 ただし、複合プロパティ、継承識別子、コレクションなどのような より複雑なマッピングと関連するクエリがなければです。 ある特定の別名を使用することにより、Hibernateは適切な別名を挿入できます。"

#: index.docbook:202
msgid "The following table shows the different possibilities of using the alias injection. Note: the alias names in the result are examples, each alias will have a unique and probably different name when used."
msgstr "別名インジェクションとして使用できるものを下表に示します。 注意：下表の別名は一例です。 それぞれの別名は一意であり、使用する際にはおそらく異なる名前を持ちます。"

#: index.docbook:208
msgid "Alias injection names"
msgstr "別名に挿入する名前"

#: index.docbook:219
msgid "Description"
msgstr "<entry>説明</entry>"

#: index.docbook:221
msgid "Syntax"
msgstr "<entry>構文</entry>"

#: index.docbook:223
msgid "Example"
msgstr "<entry>例</entry>"

#: index.docbook:229
msgid "A simple property"
msgstr "単純なプロパティ"

#: index.docbook:231
msgid "{[aliasname].[propertyname]"
msgstr "{[aliasname].[propertyname]}"

#: index.docbook:233
msgid "A_NAME as {item.name}"
msgstr "A_NAME as {item.name}"

#: index.docbook:237
msgid "A composite property"
msgstr "複合プロパティ"

#: index.docbook:239
msgid "{[aliasname].[componentname].[propertyname]}"
msgstr "{[aliasname].[componentname].[propertyname]}"

#: index.docbook:241
msgid "CURRENCY as {item.amount.currency}, VALUE as {item.amount.value}"
msgstr "CURRENCY as {item.amount.currency}, VALUE as {item.amount.value}"

#: index.docbook:246
msgid "Discriminator of an entity"
msgstr "エンティティのクラスを識別する値"

#: index.docbook:248
msgid "{[aliasname].class}"
msgstr "{[aliasname].class}"

#: index.docbook:250
msgid "DISC as {item.class}"
msgstr "DISC as {item.class}"

#: index.docbook:254
msgid "All properties of an entity"
msgstr "エンティティの全プロパティ"

#: index.docbook:256, index.docbook:304
msgid "{[aliasname].*}"
msgstr "{[aliasname].*}"

#: index.docbook:258
msgid "{item.*}"
msgstr "{item.*}"

#: index.docbook:262
msgid "A collection key"
msgstr "コレクションのキー"

#: index.docbook:264
msgid "{[aliasname].key}"
msgstr "{[aliasname].key}"

#: index.docbook:266
msgid "ORGID as {coll.key}"
msgstr "ORGID as {coll.key}"

#: index.docbook:270
msgid "The id of an collection"
msgstr "コレクションのID"

#: index.docbook:272
msgid "{[aliasname].id}"
msgstr "{[aliasname].id}"

#: index.docbook:274
msgid "EMPID as {coll.id}"
msgstr "EMPID as {coll.id}"

#: index.docbook:278
msgid "The element of an collection"
msgstr "コレクションの要素"

#: index.docbook:280
msgid "{[aliasname].element}"
msgstr "{[aliasname].element}"

#: index.docbook:282
msgid "XID as {coll.element}"
msgstr "XID as {coll.element}"

#: index.docbook:286
msgid "roperty of the element in the collection"
msgstr "コレクションの要素のプロパティ"

#: index.docbook:288
msgid "{[aliasname].element.[propertyname]}"
msgstr "{[aliasname].element.[propertyname]}"

#: index.docbook:290
msgid "NAME as {coll.element.name}"
msgstr "NAME as {coll.element.name}"

#: index.docbook:294
msgid "All properties of the element in the collection"
msgstr "コレクションの要素の全プロパティ"

#: index.docbook:296
msgid "{[aliasname].element.*}"
msgstr "{[aliasname].element.*}"

#: index.docbook:298
msgid "{coll.element.*}"
msgstr "{coll.element.*}"

#: index.docbook:302
msgid "All properties of the the collection"
msgstr "コレクションの全プロパティ"

#: index.docbook:306
msgid "{coll.*}"
msgstr "{coll.*}"

#: index.docbook:315
msgid "Returning non-managed entities"
msgstr "管理されていないエンティティの取得"

#: index.docbook:317
msgid "It is possible to apply a ResultTransformer to native sql queries. Allowing it to e.g. return non-managed entities."
msgstr "ネイティブSQLクエリに ResultTransformer を適用できます。 下記のように、例えば、管理されていないエンティティを返します。"

#: index.docbook:319
msgid ""
      "<![CDATA[sess.createSQLQuery(\"SELECT NAME, BIRTHDATE FROM CATS\")\n"
      "        .setResultTransformer(Transformers.aliasToBean(CatDTO.class))]]>"
msgstr ""
      "<![CDATA[sess.createSQLQuery(\"SELECT NAME, BIRTHDATE FROM CATS\")\n"
      "        .setResultTransformer(Transformers.aliasToBean(CatDTO.class))]]>"

#: index.docbook:329
msgid "a result transformer"
msgstr "結果を変換したもの"

#: index.docbook:333
msgid "The above query will return a list of <literal>CatDTO</literal> which has been instantiated and injected the values of NAME and BIRTHNAME into its corresponding properties or fields."
msgstr "上記のクエリは、インスタンス化し、NAME と BIRTHDATE の値を 対応するプロパティもしくはフィールドに挿入した <literal>CatDTO</literal> のリストを返します。"

#: index.docbook:340
msgid "Handling inheritance"
msgstr "継承の制御"

#: index.docbook:342
msgid "Native sql queries which query for entities that is mapped as part of an inheritance must include all properties for the baseclass and all it subclasses."
msgstr "継承の一部としてマッピングされたエンティティを問い合わせるネイティブSQLクエリは、 ベースのクラスとそのすべてのサブクラスのプロパティすべてを含まなければなりません。"

#: index.docbook:348
msgid "Parameters"
msgstr "パラメータ"

#: index.docbook:350
msgid "Native sql queries support positional as well as named parameters:"
msgstr "ネイティブSQLクエリは、以下のように、 名前付きパラメータ（:name）と同様に位置パラメータをサポートします。"

#: index.docbook:353
msgid ""
      "<![CDATA[Query query = sess.createSQLQuery(\"SELECT * FROM CATS WHERE NAME like ?\").addEntity(Cat.class);\n"
      "List pusList = query.setString(0, \"Pus%\").list();\n"
      "     \n"
      "query = sess.createSQLQuery(\"SELECT * FROM CATS WHERE NAME like :name\").addEntity(Cat.class);\n"
      "List pusList = query.setString(\"name\", \"Pus%\").list();          ]]>"
msgstr ""
      "<![CDATA[Query query = sess.createSQLQuery(\"SELECT * FROM CATS WHERE NAME like ?\").addEntity(Cat.class);\n"
      "List pusList = query.setString(0, \"Pus%\").list();\n"
      "     \n"
      "query = sess.createSQLQuery(\"SELECT * FROM CATS WHERE NAME like :name\").addEntity(Cat.class);\n"
      "List pusList = query.setString(\"name\", \"Pus%\").list();          ]]>"

#: index.docbook:361
msgid "Named SQL queries"
msgstr "名前付きSQLクエリ"

#: index.docbook:363
msgid "Named SQL queries may be defined in the mapping document and called in exactly the same way as a named HQL query. In this case, we do <emphasis>not</emphasis> need to call <literal>addEntity()</literal>."
msgstr "名前付きSQLクエリはマッピングドキュメントで定義することができ、 名前付きHQLクエリと全く同じ方法で呼ぶことができます。 この場合、<literal>addEntity()</literal> を呼び出す必要は <emphasis>ない</emphasis> です。"

#: index.docbook:368
msgid ""
      "<![CDATA[<sql-query name=\"persons\">\n"
      "    <return alias=\"person\" class=\"eg.Person\"/>\n"
      "    SELECT person.NAME AS {person.name},\n"
      "           person.AGE AS {person.age},\n"
      "           person.SEX AS {person.sex}\n"
      "    FROM PERSON person\n"
      "    WHERE person.NAME LIKE :namePattern\n"
      "</sql-query>]]>"
msgstr ""
      "<![CDATA[<sql-query name=\"persons\">\n"
      "    <return alias=\"person\" class=\"eg.Person\"/>\n"
      "    SELECT person.NAME AS {person.name},\n"
      "           person.AGE AS {person.age},\n"
      "           person.SEX AS {person.sex}\n"
      "    FROM PERSON person\n"
      "    WHERE person.NAME LIKE :namePattern\n"
      "</sql-query>]]>"

#: index.docbook:370
msgid ""
      "<![CDATA[List people = sess.getNamedQuery(\"persons\")\n"
      "    .setString(\"namePattern\", namePattern)\n"
      "    .setMaxResults(50)\n"
      "    .list();]]>"
msgstr ""
      "<![CDATA[List people = sess.getNamedQuery(\"persons\")\n"
      "    .setString(\"namePattern\", namePattern)\n"
      "    .setMaxResults(50)\n"
      "    .list();]]>"

#: index.docbook:372
msgid "The <literal>&lt;return-join&gt;</literal> and <literal>&lt;load-collection&gt;</literal> elements are used to join associations and define queries which initialize collections, respectively."
msgstr "関連を結合するためとコレクションを初期化するクエリを定義するために、それぞれ <literal>&lt;return-join&gt;</literal> と <literal>&lt;load-collection&gt;</literal> 要素を使います。"

#: index.docbook:377
msgid ""
      "<![CDATA[<sql-query name=\"personsWith\">\n"
      "    <return alias=\"person\" class=\"eg.Person\"/>\n"
      "    <return-join alias=\"address\" property=\"person.mailingAddress\"/>\n"
      "    SELECT person.NAME AS {person.name},\n"
      "           person.AGE AS {person.age},\n"
      "           person.SEX AS {person.sex},\n"
      "           address.STREET AS {address.street},\n"
      "           address.CITY AS {address.city},\n"
      "           address.STATE AS {address.state},\n"
      "           address.ZIP AS {address.zip}\n"
      "    FROM PERSON person\n"
      "    JOIN ADDRESS address\n"
      "        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'\n"
      "    WHERE person.NAME LIKE :namePattern\n"
      "</sql-query>]]>"
msgstr ""
      "<![CDATA[<sql-query name=\"personsWith\">\n"
      "    <return alias=\"person\" class=\"eg.Person\"/>\n"
      "    <return-join alias=\"address\" property=\"person.mailingAddress\"/>\n"
      "    SELECT person.NAME AS {person.name},\n"
      "           person.AGE AS {person.age},\n"
      "           person.SEX AS {person.sex},\n"
      "           address.STREET AS {address.street},\n"
      "           address.CITY AS {address.city},\n"
      "           address.STATE AS {address.state},\n"
      "           address.ZIP AS {address.zip}\n"
      "    FROM PERSON person\n"
      "    JOIN ADDRESS address\n"
      "        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'\n"
      "    WHERE person.NAME LIKE :namePattern\n"
      "</sql-query>]]>"

#: index.docbook:379
msgid "A named SQL query may return a scalar value. You must declare the column alias and Hibernate type using the <literal>&lt;return-scalar&gt;</literal> element:"
msgstr "名前付きSQLクエリはスカラ値を返すこともできます。 <literal>&lt;return-scalar&gt;</literal> 要素を使って、 列の別名とHibernateの型を宣言しなければなりません。"

#: index.docbook:383
msgid ""
      "<![CDATA[<sql-query name=\"mySqlQuery\">\n"
      "    <return-scalar column=\"name\" type=\"string\"/>\n"
      "    <return-scalar column=\"age\" type=\"long\"/>\n"
      "    SELECT p.NAME AS name,\n"
      "           p.AGE AS age,\n"
      "    FROM PERSON p WHERE p.NAME LIKE 'Hiber%'\n"
      "</sql-query>]]>"
msgstr ""
      "<![CDATA[<sql-query name=\"mySqlQuery\">\n"
      "    <return-scalar column=\"name\" type=\"string\"/>\n"
      "    <return-scalar column=\"age\" type=\"long\"/>\n"
      "    SELECT p.NAME AS name,\n"
      "           p.AGE AS age,\n"
      "    FROM PERSON p WHERE p.NAME LIKE 'Hiber%'\n"
      "</sql-query>]]>"

#: index.docbook:385
msgid "You can externalize the resultset mapping informations in a <literal>&lt;resultset&gt;</literal> element to either reuse them accross several named queries or through the <literal>setResultSetMapping()</literal> API."
msgstr "リザルトセットのマッピング情報を <literal>&lt;resultset&gt;</literal> に外出しすることができます。 複数の名前付きクエリで再利用したり、<literal>setResultSetMapping()</literal> APIを通して再利用したりできます。"

#: index.docbook:390
msgid ""
      "<![CDATA[<resultset name=\"personAddress\">\n"
      "    <return alias=\"person\" class=\"eg.Person\"/>\n"
      "    <return-join alias=\"address\" property=\"person.mailingAddress\"/>\n"
      "</resultset>\n"
      "\n"
      "<sql-query name=\"personsWith\" resultset-ref=\"personAddress\">\n"
      "    SELECT person.NAME AS {person.name},\n"
      "           person.AGE AS {person.age},\n"
      "           person.SEX AS {person.sex},\n"
      "           address.STREET AS {address.street},\n"
      "           address.CITY AS {address.city},\n"
      "           address.STATE AS {address.state},\n"
      "           address.ZIP AS {address.zip}\n"
      "    FROM PERSON person\n"
      "    JOIN ADDRESS address\n"
      "        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'\n"
      "    WHERE person.NAME LIKE :namePattern\n"
      "</sql-query>]]>"
msgstr ""
      "<![CDATA[<resultset name=\"personAddress\">\n"
      "    <return alias=\"person\" class=\"eg.Person\"/>\n"
      "    <return-join alias=\"address\" property=\"person.mailingAddress\"/>\n"
      "</resultset>\n"
      "\n"
      "<sql-query name=\"personsWith\" resultset-ref=\"personAddress\">\n"
      "    SELECT person.NAME AS {person.name},\n"
      "           person.AGE AS {person.age},\n"
      "           person.SEX AS {person.sex},\n"
      "           address.STREET AS {address.street},\n"
      "           address.CITY AS {address.city},\n"
      "           address.STATE AS {address.state},\n"
      "           address.ZIP AS {address.zip}\n"
      "    FROM PERSON person\n"
      "    JOIN ADDRESS address\n"
      "        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'\n"
      "    WHERE person.NAME LIKE :namePattern\n"
      "</sql-query>]]>"

#: index.docbook:392
msgid "You can alternatively use the resultset mapping information in your hbm files directly in java code."
msgstr "代わりに、hbmファイル内のリザルトセットのマッピング情報を 直接Javaコードの中で使用できます。"

#: index.docbook:395
msgid ""
      "<![CDATA[List cats = sess.createSQLQuery(\n"
      "        \"select {cat.*}, {kitten.*} from cats cat, cats kitten where kitten.mother = cat.id\"\n"
      "    )\n"
      "    .setResultSetMapping(\"catAndKitten\")\n"
      "    .list();]]>"
msgstr ""
      "<![CDATA[List cats = sess.createSQLQuery(\n"
      "        \"select {cat.*}, {kitten.*} from cats cat, cats kitten where kitten.mother = cat.id\"\n"
      "    )\n"
      "    .setResultSetMapping(\"catAndKitten\")\n"
      "    .list();]]>"

#: index.docbook:398
msgid "Using return-property to explicitly specify column/alias names"
msgstr "列と列の別名を明示的に指定するために return-property を使う"

#: index.docbook:401
msgid "With <literal>&lt;return-property&gt;</literal> you can explicitly tell Hibernate what column aliases to use, instead of using the <literal>{}</literal>-syntax to let Hibernate inject its own aliases."
msgstr "別名を挿入するために <literal>{}</literal> 構文を使う代わりに、 <literal>&lt;return-property&gt;</literal> を使い、 どの列の別名を使うのかを明示できます。"

#: index.docbook:406
msgid ""
      "<![CDATA[<sql-query name=\"mySqlQuery\">\n"
      "    <return alias=\"person\" class=\"eg.Person\">\n"
      "        <return-property name=\"name\" column=\"myName\"/>\n"
      "        <return-property name=\"age\" column=\"myAge\"/>\n"
      "        <return-property name=\"sex\" column=\"mySex\"/>\n"
      "    </return>\n"
      "    SELECT person.NAME AS myName,\n"
      "           person.AGE AS myAge,\n"
      "           person.SEX AS mySex,\n"
      "    FROM PERSON person WHERE person.NAME LIKE :name\n"
      "</sql-query>\n"
      "]]>"
msgstr ""
      "<![CDATA[<sql-query name=\"mySqlQuery\">\n"
      "    <return alias=\"person\" class=\"eg.Person\">\n"
      "        <return-property name=\"name\" column=\"myName\"/>\n"
      "        <return-property name=\"age\" column=\"myAge\"/>\n"
      "        <return-property name=\"sex\" column=\"mySex\"/>\n"
      "    </return>\n"
      "    SELECT person.NAME AS myName,\n"
      "           person.AGE AS myAge,\n"
      "           person.SEX AS mySex,\n"
      "    FROM PERSON person WHERE person.NAME LIKE :name\n"
      "</sql-query>\n"
      "]]>"

#: index.docbook:408
msgid "<literal>&lt;return-property&gt;</literal> also works with multiple columns. This solves a limitation with the <literal>{}</literal>-syntax which can not allow fine grained control of multi-column properties."
msgstr "<literal>&lt;return-property&gt;</literal> は複数の列も扱えます。 これは、複数列のプロパティをきめ細かく制御できないという、 <literal>{}</literal> 構文の制限を解決します。"

#: index.docbook:413
msgid ""
      "<![CDATA[<sql-query name=\"organizationCurrentEmployments\">\n"
      "    <return alias=\"emp\" class=\"Employment\">\n"
      "        <return-property name=\"salary\">\n"
      "            <return-column name=\"VALUE\"/>\n"
      "            <return-column name=\"CURRENCY\"/>\n"
      "        </return-property>\n"
      "        <return-property name=\"endDate\" column=\"myEndDate\"/>\n"
      "    </return>\n"
      "        SELECT EMPLOYEE AS {emp.employee}, EMPLOYER AS {emp.employer},\n"
      "        STARTDATE AS {emp.startDate}, ENDDATE AS {emp.endDate},\n"
      "        REGIONCODE as {emp.regionCode}, EID AS {emp.id}, VALUE, CURRENCY\n"
      "        FROM EMPLOYMENT\n"
      "        WHERE EMPLOYER = :id AND ENDDATE IS NULL\n"
      "        ORDER BY STARTDATE ASC\n"
      "</sql-query>]]>"
msgstr ""
      "<![CDATA[<sql-query name=\"organizationCurrentEmployments\">\n"
      "    <return alias=\"emp\" class=\"Employment\">\n"
      "        <return-property name=\"salary\">\n"
      "            <return-column name=\"VALUE\"/>\n"
      "            <return-column name=\"CURRENCY\"/>\n"
      "        </return-property>\n"
      "        <return-property name=\"endDate\" column=\"myEndDate\"/>\n"
      "    </return>\n"
      "        SELECT EMPLOYEE AS {emp.employee}, EMPLOYER AS {emp.employer},\n"
      "        STARTDATE AS {emp.startDate}, ENDDATE AS {emp.endDate},\n"
      "        REGIONCODE as {emp.regionCode}, EID AS {emp.id}, VALUE, CURRENCY\n"
      "        FROM EMPLOYMENT\n"
      "        WHERE EMPLOYER = :id AND ENDDATE IS NULL\n"
      "        ORDER BY STARTDATE ASC\n"
      "</sql-query>]]>"

#: index.docbook:415
msgid "Notice that in this example we used <literal>&lt;return-property&gt;</literal> in combination with the <literal>{}</literal>-syntax for injection. Allowing users to choose how they want to refer column and properties."
msgstr "この例では、挿入のための <literal>{}</literal> 構文といっしょに、 <literal>&lt;return-property&gt;</literal> を使っていることに注意してください。 列とプロパティをどのように参照するかを選べます。"

#: index.docbook:420
msgid "If your mapping has a discriminator you must use <literal>&lt;return-discriminator&gt;</literal> to specify the discriminator column."
msgstr "マッピングに discriminator が含まれている場合、 discriminator の列を指定するために、&lt;return-discriminator&gt; を使わなければなりません。"

#: index.docbook:426
msgid "Using stored procedures for querying"
msgstr "問い合わせするためにストアドプロシージャを使う"

#: index.docbook:428
msgid "Hibernate 3 introduces support for queries via stored procedures and functions. Most of the following documentation is equivalent for both. The stored procedure/function must return a resultset as the first out-parameter to be able to work with Hibernate. An example of such a stored function in Oracle 9 and higher is as follows:"
msgstr "Hibernateはバージョン3から、ストアドプロシージャとストアド関数経由の問い合わせが サポートされました。 以降の文書の多くは、両方に当てはまります。 ストアドプロシージャやストアド関数をHibernateで使うためには、 1番目の出力パラメータとしてリザルトセットを返さなければなりません。 Oracle 9（もしくはそれ以上のバージョン）のストアドプロシージャの例を以下に示します。"

#: index.docbook:434
msgid ""
      "<![CDATA[CREATE OR REPLACE FUNCTION selectAllEmployments\n"
      "    RETURN SYS_REFCURSOR\n"
      "AS\n"
      "    st_cursor SYS_REFCURSOR;\n"
      "BEGIN\n"
      "    OPEN st_cursor FOR\n"
      " SELECT EMPLOYEE, EMPLOYER,\n"
      " STARTDATE, ENDDATE,\n"
      " REGIONCODE, EID, VALUE, CURRENCY\n"
      " FROM EMPLOYMENT;\n"
      "      RETURN  st_cursor;\n"
      " END;]]>"
msgstr ""
      "<![CDATA[CREATE OR REPLACE FUNCTION selectAllEmployments\n"
      "    RETURN SYS_REFCURSOR\n"
      "AS\n"
      "    st_cursor SYS_REFCURSOR;\n"
      "BEGIN\n"
      "    OPEN st_cursor FOR\n"
      " SELECT EMPLOYEE, EMPLOYER,\n"
      " STARTDATE, ENDDATE,\n"
      " REGIONCODE, EID, VALUE, CURRENCY\n"
      " FROM EMPLOYMENT;\n"
      "      RETURN  st_cursor;\n"
      " END;]]>"

#: index.docbook:436
msgid "To use this query in Hibernate you need to map it via a named query."
msgstr "Hibernateでこのクエリを使うためには、 名前付きクエリでマッピングする必要があります。"

#: index.docbook:439
msgid ""
      "<![CDATA[<sql-query name=\"selectAllEmployees_SP\" callable=\"true\">\n"
      "    <return alias=\"emp\" class=\"Employment\">\n"
      "        <return-property name=\"employee\" column=\"EMPLOYEE\"/>\n"
      "        <return-property name=\"employer\" column=\"EMPLOYER\"/>\n"
      "        <return-property name=\"startDate\" column=\"STARTDATE\"/>\n"
      "        <return-property name=\"endDate\" column=\"ENDDATE\"/>\n"
      "        <return-property name=\"regionCode\" column=\"REGIONCODE\"/>\n"
      "        <return-property name=\"id\" column=\"EID\"/>\n"
      "        <return-property name=\"salary\">\n"
      "            <return-column name=\"VALUE\"/>\n"
      "            <return-column name=\"CURRENCY\"/>\n"
      "        </return-property>\n"
      "    </return>\n"
      "    { ? = call selectAllEmployments() }\n"
      "</sql-query>]]>"
msgstr ""
      "<![CDATA[<sql-query name=\"selectAllEmployees_SP\" callable=\"true\">\n"
      "    <return alias=\"emp\" class=\"Employment\">\n"
      "        <return-property name=\"employee\" column=\"EMPLOYEE\"/>\n"
      "        <return-property name=\"employer\" column=\"EMPLOYER\"/>\n"
      "        <return-property name=\"startDate\" column=\"STARTDATE\"/>\n"
      "        <return-property name=\"endDate\" column=\"ENDDATE\"/>\n"
      "        <return-property name=\"regionCode\" column=\"REGIONCODE\"/>\n"
      "        <return-property name=\"id\" column=\"EID\"/>\n"
      "        <return-property name=\"salary\">\n"
      "            <return-column name=\"VALUE\"/>\n"
      "            <return-column name=\"CURRENCY\"/>\n"
      "        </return-property>\n"
      "    </return>\n"
      "    { ? = call selectAllEmployments() }\n"
      "</sql-query>]]>"

#: index.docbook:441
msgid "Notice stored procedures currently only return scalars and entities. <literal>&lt;return-join&gt;</literal> and <literal>&lt;load-collection&gt;</literal> are not supported."
msgstr "注意：今のところ、ストアドプロシージャはスカラとエンティティを返すのみです。 <literal>&lt;return-join&gt;</literal> と <literal>&lt;load-collection&gt;</literal> はサポートされていません。"

#: index.docbook:446
msgid "Rules/limitations for using stored procedures"
msgstr "ストアドプロシージャを使う上でのルールと制限"

#: index.docbook:448
msgid "To use stored procedures with Hibernate the procedures/functions have to follow some rules. If they do not follow those rules they are not usable with Hibernate. If you still want to use these procedures you have to execute them via <literal>session.connection()</literal>. The rules are different for each database, since database vendors have different stored procedure semantics/syntax."
msgstr "Hibernateでストアドプロシージャや関数を使うためには、 そのプロシージャはいくつかのルールに準拠する必要があります。 ルールに準拠していないプロシージャは、Hibernateで使うことはできません。 それでも、準拠していないプロシージャを使いたいのであれば、 <literal>session.connection()</literal> を通じて実行しなければなりません。 ルールはデータベースごとに異なります。 ストアドプロシージャのセマンティックスとシンタックスは、 データベースベンダごとに異なるためです。"

#: index.docbook:455
msgid "Stored procedure queries can't be paged with <literal>setFirstResult()/setMaxResults()</literal>."
msgstr "<literal>setFirstResult()/setMaxResults()</literal> を使って、 ストアドプロシージャクエリをページ分けすることはできません。"

#: index.docbook:458
msgid "Recommended call form is standard SQL92: <literal>{ ? = call functionName(&lt;parameters&gt;) }</literal> or <literal>{ ? = call procedureName(&lt;parameters&gt;}</literal>. Native call syntax is not supported."
msgstr "推奨する呼び出し方は、標準であるSQL92に従うことです。 <literal>{ ? = call functionName(&lt;parameters&gt;) }</literal> や <literal>{ ? = call procedureName(&lt;parameters&gt;) }</literal> です。 ネイティブな呼び出し構文はサポートされていません。"

#: index.docbook:463
msgid "For Oracle the following rules apply:"
msgstr "Oracleには下記のルールが適用されます。"

#: index.docbook:467
msgid "A function must return a result set. The first parameter of a procedure must be an <literal>OUT</literal> that returns a result set. This is done by using a <literal>SYS_REFCURSOR</literal> type in Oracle 9 or 10. In Oracle you need to define a <literal>REF CURSOR</literal> type, see Oracle literature."
msgstr "関数はリザルトセットを返さなければなりません。 プロシージャの第一引数はリザルトセットを返すため、 <literal>OUT</literal> でなければなりません。 Oracle 9と10では、<literal>SYS_REFCURSOR</literal> を使うことによってできます。 Oracleでは <literal>REF CURSOR</literal> 型を定義する必要があります。 Oracleの文献を参照してください。"

#: index.docbook:476
msgid "For Sybase or MS SQL server the following rules apply:"
msgstr "SybaseとMS SQLサーバーに適用されるルールを下記に示します。"

#: index.docbook:480
msgid "The procedure must return a result set. Note that since these servers can/will return multiple result sets and update counts, Hibernate will iterate the results and take the first result that is a result set as its return value. Everything else will be discarded."
msgstr "プロシージャはリザルトセットを返さなければなりません。 サーバーは複数のリザルトセットと更新カウントを返しますが、 Hibernateは1つ目のリザルトセットだけを返すことに注意してください。 その他はすべて捨てられます。"

#: index.docbook:488
msgid "If you can enable <literal>SET NOCOUNT ON</literal> in your procedure it will probably be more efficient, but this is not a requirement."
msgstr "プロシージャの中で <literal>SET NOCOUNT ON</literal> を有効にできれば、 おそらく効率がよくなるでしょう。 しかし、これは必要条件ではありません。"

#: index.docbook:498
msgid "Custom SQL for create, update and delete"
msgstr "作成、更新、削除のためのカスタムSQL"

#: index.docbook:500
msgid "Hibernate3 can use custom SQL statements for create, update, and delete operations. The class and collection persisters in Hibernate already contain a set of configuration time generated strings (insertsql, deletesql, updatesql etc.). The mapping tags <literal>&lt;sql-insert&gt;</literal>, <literal>&lt;sql-delete&gt;</literal>, and <literal>&lt;sql-update&gt;</literal> override these strings:"
msgstr "Hibernate3は作成、更新、削除処理のためのカスタムSQL文を使用できます。 クラスとコレクションの永続化機構は、コンフィグレーション時に生成された文字列 （insertsql、deletesql、updatesqlなど）のセットをすでに保持しています。 これらの文字列より、 <literal>&lt;sql-insert&gt;</literal>、 <literal>&lt;sql-delete&gt;</literal>、 <literal>&lt;sql-update&gt;</literal> というマッピングタグが優先されます。"

#: index.docbook:508
msgid ""
      "<![CDATA[<class name=\"Person\">\n"
      "    <id name=\"id\">\n"
      "        <generator class=\"increment\"/>\n"
      "    </id>\n"
      "    <property name=\"name\" not-null=\"true\"/>\n"
      "    <sql-insert>INSERT INTO PERSON (NAME, ID) VALUES ( UPPER(?), ? )</sql-insert>\n"
      "    <sql-update>UPDATE PERSON SET NAME=UPPER(?) WHERE ID=?</sql-update>\n"
      "    <sql-delete>DELETE FROM PERSON WHERE ID=?</sql-delete>\n"
      "</class>]]>"
msgstr ""
      "<![CDATA[<class name=\"Person\">\n"
      "    <id name=\"id\">\n"
      "        <generator class=\"increment\"/>\n"
      "    </id>\n"
      "    <property name=\"name\" not-null=\"true\"/>\n"
      "    <sql-insert>INSERT INTO PERSON (NAME, ID) VALUES ( UPPER(?), ? )</sql-insert>\n"
      "    <sql-update>UPDATE PERSON SET NAME=UPPER(?) WHERE ID=?</sql-update>\n"
      "    <sql-delete>DELETE FROM PERSON WHERE ID=?</sql-delete>\n"
      "</class>]]>"

#: index.docbook:510
msgid "The SQL is directly executed in your database, so you are free to use any dialect you like. This will of course reduce the portability of your mapping if you use database specific SQL."
msgstr "SQLを直接データベースで実行するため、好みの方言を自由に使用できます。 データベース独自のSQLを使えば、当然マッピングのポータビリティが下がります。"

#: index.docbook:514
msgid "Stored procedures are supported if the <literal>callable</literal> attribute is set:"
msgstr "<literal>callable</literal> 属性をセットすれば、 ストアドプロシージャを使用できます。"

#: index.docbook:517
msgid ""
      "<![CDATA[<class name=\"Person\">\n"
      "    <id name=\"id\">\n"
      "        <generator class=\"increment\"/>\n"
      "    </id>\n"
      "    <property name=\"name\" not-null=\"true\"/>\n"
      "    <sql-insert callable=\"true\">{call createPerson (?, ?)}</sql-insert>\n"
      "    <sql-delete callable=\"true\">{? = call deletePerson (?)}</sql-delete>\n"
      "    <sql-update callable=\"true\">{? = call updatePerson (?, ?)}</sql-update>\n"
      "</class>]]>"
msgstr ""
      "<![CDATA[<class name=\"Person\">\n"
      "    <id name=\"id\">\n"
      "        <generator class=\"increment\"/>\n"
      "    </id>\n"
      "    <property name=\"name\" not-null=\"true\"/>\n"
      "    <sql-insert callable=\"true\">{call createPerson (?, ?)}</sql-insert>\n"
      "    <sql-delete callable=\"true\">{? = call deletePerson (?)}</sql-delete>\n"
      "    <sql-update callable=\"true\">{? = call updatePerson (?, ?)}</sql-update>\n"
      "</class>]]>"

#: index.docbook:519
msgid "The order of the positional parameters are currently vital, as they must be in the same sequence as Hibernate expects them."
msgstr "今のところ、位置パラメータの順番はとても重要です。 すなわち、Hibernateが期待する順序でなければなりません。"

#: index.docbook:522
msgid "You can see the expected order by enabling debug logging for the <literal>org.hibernate.persister.entity</literal> level. With this level enabled Hibernate will print out the static SQL that is used to create, update, delete etc. entities. (To see the expected sequence, remember to not include your custom SQL in the mapping files as that will override the Hibernate generated static sql.)"
msgstr "<literal>org.hiberante.persister.entity</literal> レベルのデバッグログを 有効にすることによって、期待される順番を確かめられます。 このレベルを有効にすることにより、エンティティの作成、更新、削除などで 使用される静的なSQLが出力されます。 （期待される順序を確認するためには、Hibernateが生成する静的なSQLをオーバーライドする カスタムSQLをマッピングファイルに含めないことを忘れないでください。）"

#: index.docbook:529
msgid "The stored procedures are in most cases (read: better do it than not) required to return the number of rows inserted/updated/deleted, as Hibernate has some runtime checks for the success of the statement. Hibernate always registers the first statement parameter as a numeric output parameter for the CUD operations:"
msgstr "ストアドプロシージャは挿入/更新/削除された行数を返す必要があります （読み込みの場合は、返さないよりは返す方がよいです）。 実行時にHibernateがSQL文の成功をチェックするからです。 Hibernateは、CUD処理のための数値の出力パラメータとして、 SQL文の最初のパラメータをいつも記録します。"

#: index.docbook:535
msgid ""
      "<![CDATA[CREATE OR REPLACE FUNCTION updatePerson (uid IN NUMBER, uname IN VARCHAR2)\n"
      "    RETURN NUMBER IS\n"
      "BEGIN\n"
      "\n"
      "    update PERSON\n"
      "    set\n"
      "        NAME = uname,\n"
      "    where\n"
      "        ID = uid;\n"
      "\n"
      "    return SQL%ROWCOUNT;\n"
      "\n"
      "END updatePerson;]]>"
msgstr ""
      "<![CDATA[CREATE OR REPLACE FUNCTION updatePerson (uid IN NUMBER, uname IN VARCHAR2)\n"
      "    RETURN NUMBER IS\n"
      "BEGIN\n"
      "\n"
      "    update PERSON\n"
      "    set\n"
      "        NAME = uname,\n"
      "    where\n"
      "        ID = uid;\n"
      "\n"
      "    return SQL%ROWCOUNT;\n"
      "\n"
      "END updatePerson;]]>"

#: index.docbook:539
msgid "Custom SQL for loading"
msgstr "ロードのためのカスタムSQL"

#: index.docbook:541
msgid "You may also declare your own SQL (or HQL) queries for entity loading:"
msgstr "エンティティを読み込むための独自のSQL（もしくはHQL）クエリも宣言できます。"

#: index.docbook:544
msgid ""
      "<![CDATA[<sql-query name=\"person\">\n"
      "    <return alias=\"pers\" class=\"Person\" lock-mode=\"upgrade\"/>\n"
      "    SELECT NAME AS {pers.name}, ID AS {pers.id}\n"
      "    FROM PERSON\n"
      "    WHERE ID=?\n"
      "    FOR UPDATE\n"
      "</sql-query>]]>"
msgstr ""
      "<![CDATA[<sql-query name=\"person\">\n"
      "    <return alias=\"pers\" class=\"Person\" lock-mode=\"upgrade\"/>\n"
      "    SELECT NAME AS {pers.name}, ID AS {pers.id}\n"
      "    FROM PERSON\n"
      "    WHERE ID=?\n"
      "    FOR UPDATE\n"
      "</sql-query>]]>"

#: index.docbook:546
msgid "This is just a named query declaration, as discussed earlier. You may reference this named query in a class mapping:"
msgstr "これは、まさに（以前議論した）名前付きクエリの宣言です。 この名前付きクエリをクラスのマッピングから参照できます。"

#: index.docbook:549
msgid ""
      "<![CDATA[<class name=\"Person\">\n"
      "    <id name=\"id\">\n"
      "        <generator class=\"increment\"/>\n"
      "    </id>\n"
      "    <property name=\"name\" not-null=\"true\"/>\n"
      "    <loader query-ref=\"person\"/>\n"
      "</class>]]>"
msgstr ""
      "<![CDATA[<class name=\"Person\">\n"
      "    <id name=\"id\">\n"
      "        <generator class=\"increment\"/>\n"
      "    </id>\n"
      "    <property name=\"name\" not-null=\"true\"/>\n"
      "    <loader query-ref=\"person\"/>\n"
      "</class>]]>"

#: index.docbook:551
msgid "This even works with stored procedures."
msgstr "これはストアドプロシージャでさえも動作します。"

#: index.docbook:553
msgid "You may even define a query for collection loading:"
msgstr "次のように、コレクションをロードするためのクエリさえ定義してよいです。"

#: index.docbook:555
msgid ""
      "<![CDATA[<set name=\"employments\" inverse=\"true\">\n"
      "    <key/>\n"
      "    <one-to-many class=\"Employment\"/>\n"
      "    <loader query-ref=\"employments\"/>\n"
      "</set>]]>"
msgstr ""
      "<![CDATA[<set name=\"employments\" inverse=\"true\">\n"
      "    <key/>\n"
      "    <one-to-many class=\"Employment\"/>\n"
      "    <loader query-ref=\"employments\"/>\n"
      "</set>]]>"

#: index.docbook:557
msgid ""
      "<![CDATA[<sql-query name=\"employments\">\n"
      "    <load-collection alias=\"emp\" role=\"Person.employments\"/>\n"
      "    SELECT {emp.*}\n"
      "    FROM EMPLOYMENT emp\n"
      "    WHERE EMPLOYER = :id\n"
      "    ORDER BY STARTDATE ASC, EMPLOYEE ASC\n"
      "</sql-query>]]>"
msgstr ""
      "<![CDATA[<sql-query name=\"employments\">\n"
      "    <load-collection alias=\"emp\" role=\"Person.employments\"/>\n"
      "    SELECT {emp.*}\n"
      "    FROM EMPLOYMENT emp\n"
      "    WHERE EMPLOYER = :id\n"
      "    ORDER BY STARTDATE ASC, EMPLOYEE ASC\n"
      "</sql-query>]]>"

#: index.docbook:559
msgid "You could even define an entity loader that loads a collection by join fetching:"
msgstr "次のように、結合フェッチによりコレクションをロードする エンティティローダーを定義できます。"

#: index.docbook:562
msgid ""
      "<![CDATA[<sql-query name=\"person\">\n"
      "    <return alias=\"pers\" class=\"Person\"/>\n"
      "    <return-join alias=\"emp\" property=\"pers.employments\"/>\n"
      "    SELECT NAME AS {pers.*}, {emp.*}\n"
      "    FROM PERSON pers\n"
      "    LEFT OUTER JOIN EMPLOYMENT emp\n"
      "        ON pers.ID = emp.PERSON_ID\n"
      "    WHERE ID=?\n"
      "</sql-query>]]>"
msgstr ""
      "<![CDATA[<sql-query name=\"person\">\n"
      "    <return alias=\"pers\" class=\"Person\"/>\n"
      "    <return-join alias=\"emp\" property=\"pers.employments\"/>\n"
      "    SELECT NAME AS {pers.*}, {emp.*}\n"
      "    FROM PERSON pers\n"
      "    LEFT OUTER JOIN EMPLOYMENT emp\n"
      "        ON pers.ID = emp.PERSON_ID\n"
      "    WHERE ID=?\n"
      "</sql-query>]]>"

msgid "ROLES_OF_TRANSLATORS"
msgstr "<!--TRANS:ROLES_OF_TRANSLATORS-->"

msgid "CREDIT_FOR_TRANSLATORS"
msgstr "<!--TRANS:CREDIT_FOR_TRANSLATORS-->"

