#, fuzzy
msgid ""
msgstr ""
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Content-Type: text/plain; charset=utf-8\n"
#: index.docbook:5
msgid "Example: Parent/Child"
msgstr "例：親/子供"

#: index.docbook:7
msgid "One of the very first things that new users try to do with Hibernate is to model a parent / child type relationship. There are two different approaches to this. For various reasons the most convenient approach, especially for new users, is to model both <literal>Parent</literal> and <literal>Child</literal> as entity classes with a <literal>&lt;one-to-many&gt;</literal> association from <literal>Parent</literal> to <literal>Child</literal>. (The alternative approach is to declare the <literal>Child</literal> as a <literal>&lt;composite-element&gt;</literal>.) Now, it turns out that default semantics of a one to many association (in Hibernate) are much less close to the usual semantics of a parent / child relationship than those of a composite element mapping. We will explain how to use a <emphasis>bidirectional one to many association with cascades</emphasis> to model a parent / child relationship efficiently and elegantly. It's not at all difficult!"
msgstr "新規ユーザがHibernateを使ってまず最初に扱うモデルの一つに、親子型のモデル化があります。 このモデル化には二つのアプローチが存在します。とりわけ新規ユーザにとって、 さまざまな理由から最も便利だと思われるアプローチは、<literal>親</literal> から <literal>子供</literal> への <literal>&lt;one-to-many&gt;</literal> 関連により <literal>親</literal> と <literal>子供</literal> の両方をエンティティクラスとしてモデリングする方法です （もう一つの方法は、<literal>子供</literal> を <literal>&lt;composite-element&gt;</literal> として定義するものです）。 これで（Hibernateにおける）一対多関連のデフォルトのセマンティクスが、通常の複合要素のマッピングよりも、 親子関係のセマンティクスから遠いことがわかります。 それでは親子関係を効率的かつエレガントにモデリングするために、 <emphasis>カスケード操作を使った双方向一対多関連</emphasis> の扱い方を説明します。これはまったく難しいものではありません。"

#: index.docbook:21
msgid "A note about collections"
msgstr "コレクションに関する注意"

#: index.docbook:23
msgid "Hibernate collections are considered to be a logical part of their owning entity; never of the contained entities. This is a crucial distinction! It has the following consequences:"
msgstr "Hibernateのコレクションは自身のエンティティの論理的な部分と考えられ、 決して包含するエンティティのものではありません。これは致命的な違いです！ これは以下のような結果になります："

#: index.docbook:30
msgid "When we remove / add an object from / to a collection, the version number of the collection owner is incremented."
msgstr "オブジェクトをコレクションから削除、またはコレクションに追加するとき、 コレクションのオーナーのバージョン番号はインクリメントされます。"

#: index.docbook:36
msgid "If an object that was removed from a collection is an instance of a value type (eg, a composite element), that object will cease to be persistent and its state will be completely removed from the database. Likewise, adding a value type instance to the collection will cause its state to be immediately persistent."
msgstr "もしコレクションから削除されたオブジェクトが値型のインスタンス （例えばコンポジットエレメント)だったならば、そのオブジェクトは永続的ではなくなり、 その状態はデータベースから完全に削除されます。 同じように、値型のインスタンスをコレクションに追加すると、その状態はすぐに永続的になります。"

#: index.docbook:44
msgid "On the other hand, if an entity is removed from a collection (a one-to-many or many-to-many association), it will not be deleted, by default. This behaviour is completely consistent - a change to the internal state of another entity should not cause the associated entity to vanish! Likewise, adding an entity to a collection does not cause that entity to become persistent, by default."
msgstr "一方、もしエンティティがコレクション（一対多または多対多関連)から削除されても、 デフォルトではそれは削除されません。この動作は完全に一貫しています。 すなわち、他のエンティティの内部状態を変更しても、関連するエンティティが消滅すべきではないということです。 同様に、エンティティがコレクションに追加されても、デフォルトではそのエンティティは永続的にはなりません。"

#: index.docbook:54
msgid "Instead, the default behaviour is that adding an entity to a collection merely creates a link between the two entities, while removing it removes the link. This is very appropriate for all sorts of cases. Where it is not appropriate at all is the case of a parent / child relationship, where the life of the child is bound to the life cycle of the parent."
msgstr "その代わりに、デフォルトの動作では、エンティティをコレクションに追加すると単に二つのエンティティ間のリンクを作成し、 一方エンティティを削除するとリンクも削除します。これはすべてのケースにおいて非常に適切です。 これが適切でないのは親/子関係の場合です。この場合子供の生存は親のライフサイクルに制限されるからです。"

#: index.docbook:64
msgid "Bidirectional one-to-many"
msgstr "双方向一対多"

#: index.docbook:66
msgid "Suppose we start with a simple <literal>&lt;one-to-many&gt;</literal> association from <literal>Parent</literal> to <literal>Child</literal>."
msgstr "<literal>Parent</literal> から <literal>Child</literal> への単純な <literal>&lt;one-to-many&gt;</literal> 関連から始めるとします。"

#: index.docbook:71
msgid ""
      "<![CDATA[<set name=\"children\">\n"
      "    <key column=\"parent_id\"/>\n"
      "    <one-to-many class=\"Child\"/>\n"
      "</set>]]>"
msgstr ""
      "<![CDATA[<set name=\"children\">\n"
      "    <key column=\"parent_id\"/>\n"
      "    <one-to-many class=\"Child\"/>\n"
      "</set>]]>"

#: index.docbook:73
msgid "If we were to execute the following code"
msgstr "以下のコードを実行すると、"

#: index.docbook:77
msgid ""
      "<![CDATA[Parent p = .....;\n"
      "Child c = new Child();\n"
      "p.getChildren().add(c);\n"
      "session.save(c);\n"
      "session.flush();]]>"
msgstr ""
      "<![CDATA[Parent p = .....;\n"
      "Child c = new Child();\n"
      "p.getChildren().add(c);\n"
      "session.save(c);\n"
      "session.flush();]]>"

#: index.docbook:79
msgid "Hibernate would issue two SQL statements:"
msgstr "Hibernateは二つのSQL文を発行します:"

#: index.docbook:85
msgid "an <literal>INSERT</literal> to create the record for <literal>c</literal>"
msgstr "<literal>c</literal>に対するレコードを生成する<literal>INSERT</literal>"

#: index.docbook:88
msgid "an <literal>UPDATE</literal> to create the link from <literal>p</literal> to <literal>c</literal>"
msgstr "<literal>p</literal>から<literal>c</literal>へのリンクを作成する<literal>UPDATE</literal>"

#: index.docbook:95
msgid "This is not only inefficient, but also violates any <literal>NOT NULL</literal> constraint on the <literal>parent_id</literal> column. We can fix the nullability constraint violation by specifying <literal>not-null=\"true\"</literal> in the collection mapping:"
msgstr "これは非効率的なだけではなく、<literal>parent_id</literal> カラムにおいて <literal>NOT NULL</literal> 制約に違反します。 コレクションのマッピングで <literal>not-null=\"true\"</literal> と指定することで、null制約違反を解決することができます:"

#: index.docbook:101
msgid ""
      "<![CDATA[<set name=\"children\">\n"
      "    <key column=\"parent_id\" not-null=\"true\"/>\n"
      "    <one-to-many class=\"Child\"/>\n"
      "</set>]]>"
msgstr ""
      "<![CDATA[<set name=\"children\">\n"
      "    <key column=\"parent_id\" not-null=\"true\"/>\n"
      "    <one-to-many class=\"Child\"/>\n"
      "</set>]]>"

#: index.docbook:103
msgid "However, this is not the recommended solution."
msgstr "しかしこの解決策は推奨できません。"

#: index.docbook:106
msgid "The underlying cause of this behaviour is that the link (the foreign key <literal>parent_id</literal>) from <literal>p</literal> to <literal>c</literal> is not considered part of the state of the <literal>Child</literal> object and is therefore not created in the <literal>INSERT</literal>. So the solution is to make the link part of the <literal>Child</literal> mapping."
msgstr "この動作の根本的な原因は、<literal>p</literal> から <literal>c</literal> へのリンク （外部キー <literal>parent_id</literal>)は <literal>Child</literal> オブジェクトの状態の一部とは考えられず、 そのため <literal>INSERT</literal> によってリンクが生成されないことです。 ですから、解決策はリンクをChildマッピングの一部にすることです。"

#: index.docbook:113
msgid "<![CDATA[<many-to-one name=\"parent\" column=\"parent_id\" not-null=\"true\"/>]]>"
msgstr "<![CDATA[<many-to-one name=\"parent\" column=\"parent_id\" not-null=\"true\"/>]]>"

#: index.docbook:115
msgid "(We also need to add the <literal>parent</literal> property to the <literal>Child</literal> class.)"
msgstr "(また <literal>Child</literal> クラスに <literal>parent</literal> プロパティを追加する必要があります。)"

#: index.docbook:119
msgid "Now that the <literal>Child</literal> entity is managing the state of the link, we tell the collection not to update the link. We use the <literal>inverse</literal> attribute."
msgstr "それでは <literal>Child</literal> エンティティがリンクの状態を制御するようになったので、 コレクションがリンクを更新しないようにしましょう。それには <literal>inverse</literal> 属性を使います。"

#: index.docbook:124
msgid ""
      "<![CDATA[<set name=\"children\" inverse=\"true\">\n"
      "    <key column=\"parent_id\"/>\n"
      "    <one-to-many class=\"Child\"/>\n"
      "</set>]]>"
msgstr ""
      "<![CDATA[<set name=\"children\" inverse=\"true\">\n"
      "    <key column=\"parent_id\"/>\n"
      "    <one-to-many class=\"Child\"/>\n"
      "</set>]]>"

#: index.docbook:126
msgid "The following code would be used to add a new <literal>Child</literal>"
msgstr "以下のコードを使えば、新しい <literal>Child</literal> を追加することができます。"

#: index.docbook:130
msgid ""
      "<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
      "Child c = new Child();\n"
      "c.setParent(p);\n"
      "p.getChildren().add(c);\n"
      "session.save(c);\n"
      "session.flush();]]>"
msgstr ""
      "<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
      "Child c = new Child();\n"
      "c.setParent(p);\n"
      "p.getChildren().add(c);\n"
      "session.save(c);\n"
      "session.flush();]]>"

#: index.docbook:132
msgid "And now, only one SQL <literal>INSERT</literal> would be issued!"
msgstr "これにより、SQLの <literal>INSERT</literal> 文が一つだけが発行されるようになりました！"

#: index.docbook:136
msgid "To tighten things up a bit, we could create an <literal>addChild()</literal> method of <literal>Parent</literal>."
msgstr "もう少し強化するには、<literal>Parent</literal> の <literal>addChild()</literal> メソッドを作成します。"

#: index.docbook:141
msgid ""
      "<![CDATA[public void addChild(Child c) {\n"
      "    c.setParent(this);\n"
      "    children.add(c);\n"
      "}]]>"
msgstr ""
      "<![CDATA[public void addChild(Child c) {\n"
      "    c.setParent(this);\n"
      "    children.add(c);\n"
      "}]]>"

#: index.docbook:143
msgid "Now, the code to add a <literal>Child</literal> looks like"
msgstr "<literal>Child</literal> を追加するコードはこのようになります。"

#: index.docbook:147
msgid ""
      "<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
      "Child c = new Child();\n"
      "p.addChild(c);\n"
      "session.save(c);\n"
      "session.flush();]]>"
msgstr ""
      "<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
      "Child c = new Child();\n"
      "p.addChild(c);\n"
      "session.save(c);\n"
      "session.flush();]]>"

#: index.docbook:152
msgid "Cascading life cycle"
msgstr "ライフサイクルのカスケード"

#: index.docbook:154
msgid "The explicit call to <literal>save()</literal> is still annoying. We will address this by using cascades."
msgstr "明示的に <literal>save()</literal> をコールするのはまだ煩わしいものです。これをカスケードを使って対処します。"

#: index.docbook:159
msgid ""
      "<![CDATA[<set name=\"children\" inverse=\"true\" cascade=\"all\">\n"
      "    <key column=\"parent_id\"/>\n"
      "    <one-to-many class=\"Child\"/>\n"
      "</set>]]>"
msgstr ""
      "<![CDATA[<set name=\"children\" inverse=\"true\" cascade=\"all\">\n"
      "    <key column=\"parent_id\"/>\n"
      "    <one-to-many class=\"Child\"/>\n"
      "</set>]]>"

#: index.docbook:161
msgid "This simplifies the code above to"
msgstr "これにより先ほどのコードをこのように単純化します"

#: index.docbook:165
msgid ""
      "<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
      "Child c = new Child();\n"
      "p.addChild(c);\n"
      "session.flush();]]>"
msgstr ""
      "<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
      "Child c = new Child();\n"
      "p.addChild(c);\n"
      "session.flush();]]>"

#: index.docbook:167
msgid "Similarly, we don't need to iterate over the children when saving or deleting a <literal>Parent</literal>. The following removes <literal>p</literal> and all its children from the database."
msgstr "同様に <literal>Parent</literal> を保存または削除するときに、子供を一つ一つ取り出して扱う必要はありません。 以下のコードは <literal>p</literal> を削除し、そしてデータベースからその子供をすべて削除します。"

#: index.docbook:172
msgid ""
      "<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
      "session.delete(p);\n"
      "session.flush();]]>"
msgstr ""
      "<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
      "session.delete(p);\n"
      "session.flush();]]>"

#: index.docbook:174
msgid "However, this code"
msgstr "しかしこのコードは"

#: index.docbook:178
msgid ""
      "<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
      "Child c = (Child) p.getChildren().iterator().next();\n"
      "p.getChildren().remove(c);\n"
      "c.setParent(null);\n"
      "session.flush();]]>"
msgstr ""
      "<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
      "Child c = (Child) p.getChildren().iterator().next();\n"
      "p.getChildren().remove(c);\n"
      "c.setParent(null);\n"
      "session.flush();]]>"

#: index.docbook:180
msgid "will not remove <literal>c</literal> from the database; it will ony remove the link to <literal>p</literal> (and cause a <literal>NOT NULL</literal> constraint violation, in this case). You need to explicitly <literal>delete()</literal> the <literal>Child</literal>."
msgstr "データベースから <literal>c</literal> を削除しません。<literal>p</literal> へのリンクを削除する （そしてこのケースでは <literal>NOT NULL</literal> 制約違反を引き起こす）だけです。 <literal>Child</literal> の <literal>delete()</literal> を明示する必要があります。"

#: index.docbook:186
msgid ""
      "<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
      "Child c = (Child) p.getChildren().iterator().next();\n"
      "p.getChildren().remove(c);\n"
      "session.delete(c);\n"
      "session.flush();]]>"
msgstr ""
      "<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
      "Child c = (Child) p.getChildren().iterator().next();\n"
      "p.getChildren().remove(c);\n"
      "session.delete(c);\n"
      "session.flush();]]>"

#: index.docbook:188
msgid "Now, in our case, a <literal>Child</literal> can't really exist without its parent. So if we remove a <literal>Child</literal> from the collection, we really do want it to be deleted. For this, we must use <literal>cascade=\"all-delete-orphan\"</literal>."
msgstr "今このケースでは実際に <literal>Child</literal> が親なしでは存在できないようになりました。 そのため、もしコレクションから <literal>Child</literal> を取り除く場合、これも削除したいです。 そのためには <literal>cascade=\"all-delete-orphan\"</literal> を使わなければなりません。"

#: index.docbook:194
msgid ""
      "<![CDATA[<set name=\"children\" inverse=\"true\" cascade=\"all-delete-orphan\">\n"
      "    <key column=\"parent_id\"/>\n"
      "    <one-to-many class=\"Child\"/>\n"
      "</set>]]>"
msgstr ""
      "<![CDATA[<set name=\"children\" inverse=\"true\" cascade=\"all-delete-orphan\">\n"
      "    <key column=\"parent_id\"/>\n"
      "    <one-to-many class=\"Child\"/>\n"
      "</set>]]>"

#: index.docbook:196
msgid "Note: even though the collection mapping specifies <literal>inverse=\"true\"</literal>, cascades are still processed by iterating the collection elements. So if you require that an object be saved, deleted or updated by cascade, you must add it to the collection. It is not enough to simply call <literal>setParent()</literal>."
msgstr "注意：コレクションのマッピングで <literal>inverse=\"true\"</literal> と指定しても、 コレクションの要素のイテレーションによって、依然カスケードが実行されます。 そのためもしカスケードでオブジェクトをセーブ、削除、更新する必要があるなら、 それをコレクションに追加しなければなりません。単に <literal>setParent()</literal> を呼ぶだけでは不十分です。"

#: index.docbook:206
msgid "Cascades and <literal>unsaved-value</literal>"
msgstr "カスケードと <literal>unsaved-value</literal>"

#: index.docbook:208
msgid "Suppose we loaded up a <literal>Parent</literal> in one <literal>Session</literal>, made some changes in a UI action and wish to persist these changes in a new session by calling <literal>update()</literal>. The <literal>Parent</literal> will contain a collection of childen and, since cascading update is enabled, Hibernate needs to know which children are newly instantiated and which represent existing rows in the database. Lets assume that both <literal>Parent</literal> and <literal>Child</literal> have genenerated identifier properties of type <literal>Long</literal>. Hibernate will use the identifier and version/timestamp property value to determine which of the children are new. (See <xref linkend=\"objectstate-saveorupdate\"/>.) <emphasis>In Hibernate3, it is no longer necessary to specify an <literal>unsaved-value</literal> explicitly.</emphasis>"
msgstr "<literal>Parent</literal> が、ある <literal>Session</literal> でロードされ、UIのアクションで変更が加えられ、 <literal>update()</literal> を呼んでこの変更を新しいセッションで永続化したいとします。 <literal>Parent</literal> が子供のコレクションを持ち、カスケード更新が有効になっているため、 Hibernateはどの子供が新しくインスタンス化されたか、どれがデータベースの既存の行に相当するのかを知る必要があります。 <literal>Parent</literal> と <literal>Child</literal> の両方が <literal>java.lang.Long</literal> 型の識別プロパティを生成したとしましょう。 Hibernateはどの子供が新しいものかを決定するために識別プロパティの値を使います(versionやtimestampプロパティも使えます。 <xref linkend=\"manipulatingdata-updating-detached\"/> 参照)。Hibernate3になって、 明示的に <literal>unsaved-value</literal> を指定する必要はなくなりました。"

#: index.docbook:220
msgid "The following code will update <literal>parent</literal> and <literal>child</literal> and insert <literal>newChild</literal>."
msgstr "以下のコードは <literal>parent</literal> と <literal>child</literal> を更新し、<literal>newChild</literal> を挿入します。"

#: index.docbook:225
msgid ""
      "<![CDATA[//parent and child were both loaded in a previous session\n"
      "parent.addChild(child);\n"
      "Child newChild = new Child();\n"
      "parent.addChild(newChild);\n"
      "session.update(parent);\n"
      "session.flush();]]>"
msgstr ""
      "<![CDATA[//parent and child were both loaded in a previous session\n"
      "//parentとchildは両方とも、以前のSessionでロードされています\n"
      "parent.addChild(child);\n"
      "Child newChild = new Child();\n"
      "parent.addChild(newChild);\n"
      "session.update(parent);\n"
      "session.flush();]]>"

#: index.docbook:227
msgid "Well, that's all very well for the case of a generated identifier, but what about assigned identifiers and composite identifiers? This is more difficult, since Hibernate can't use the identifier property to distinguish between a newly instantiated object (with an identifier assigned by the user) and an object loaded in a previous session. In this case, Hibernate will either use the timestamp or version property, or will actually query the second-level cache or, worst case, the database, to see if the row exists."
msgstr "これらは生成された識別子の場合には非常に良いのですが、割り当てられた識別子と複合識別子の場合はどうでしょうか？ これはHibernateが、（ユーザにより割り当てられた識別子を持つ）新しくインスタンス化されたオブジェクトと、 以前のSessionでロードされたオブジェクトを区別できないため、より難しいです。 この場合、Hibernateはタイムスタンプかバージョンのプロパティのどちらかを使うか、二次キャッシュに問い合わせます。 最悪の場合、行が存在するかどうかデータベースを見ます。"

#: index.docbook:260
msgid "Conclusion"
msgstr "<title>結論</title>"

#: index.docbook:262
msgid "There is quite a bit to digest here and it might look confusing first time around. However, in practice, it all works out very nicely. Most Hibernate applications use the parent / child pattern in many places."
msgstr "ここではかなりの量を要約したので、最初の頃は混乱しているように思われるかもしれません。 しかし実際は、すべて非常に良く動作します。ほとんどのHibernateアプリケーションでは、多くの場面で親子パターンを使用します。"

#: index.docbook:267
msgid "We mentioned an alternative in the first paragraph. None of the above issues exist in the case of <literal>&lt;composite-element&gt;</literal> mappings, which have exactly the semantics of a parent / child relationship. Unfortunately, there are two big limitations to composite element classes: composite elements may not own collections, and they should not be the child of any entity other than the unique parent."
msgstr "最初の段落で代替方法について触れました。上記のような問題は <literal>&lt;composite-element&gt;</literal> マッピングの場合は存在せず、 にもかかわらずそれは確かに親子関係のセマンティクスを持ちます。 しかし残念ながら、複合要素クラスには二つの大きな制限があります： 1つは複合要素はコレクションを持つことができないことです。もうひとつは、 ユニークな親ではないエンティティの子供となるべきではないということです"

msgid "ROLES_OF_TRANSLATORS"
msgstr "<!--TRANS:ROLES_OF_TRANSLATORS-->"

msgid "CREDIT_FOR_TRANSLATORS"
msgstr "<!--TRANS:CREDIT_FOR_TRANSLATORS-->"

