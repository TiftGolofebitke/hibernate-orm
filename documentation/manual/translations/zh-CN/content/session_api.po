#, fuzzy
msgid ""
msgstr ""
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Content-Type: text/plain; charset=utf-8\n"
#: index.docbook:5
msgid "Working with objects"
msgstr ""

#: index.docbook:7
msgid "Hibernate is a full object/relational mapping solution that not only shields the developer from the details of the underlying database management system, but also offers <emphasis>state management</emphasis> of objects. This is, contrary to the management of SQL <literal>statements</literal> in common JDBC/SQL persistence layers, a very natural object-oriented view of persistence in Java applications."
msgstr ""

#: index.docbook:16
msgid "In other words, Hibernate application developers should always think about the <emphasis>state</emphasis> of their objects, and not necessarily about the execution of SQL statements. This part is taken care of by Hibernate and is only relevant for the application developer when tuning the performance of the system."
msgstr ""

#: index.docbook:24
msgid "Hibernate object states"
msgstr ""

#: index.docbook:26
msgid "Hibernate defines and supports the following object states:"
msgstr ""

#: index.docbook:32
msgid "<emphasis>Transient</emphasis> - an object is transient if it has just been instantiated using the <literal>new</literal> operator, and it is not associated with a Hibernate <literal>Session</literal>. It has no persistent representation in the database and no identifier value has been assigned. Transient instances will be destroyed by the garbage collector if the application doesn't hold a reference anymore. Use the Hibernate <literal>Session</literal> to make an object persistent (and let Hibernate take care of the SQL statements that need to be executed for this transition)."
msgstr ""

#: index.docbook:44
msgid "<emphasis>Persistent</emphasis> - a persistent instance has a representation in the database and an identifier value. It might just have been saved or loaded, however, it is by definition in the scope of a <literal>Session</literal>. Hibernate will detect any changes made to an object in persistent state and synchronize the state with the database when the unit of work completes. Developers don't execute manual <literal>UPDATE</literal> statements, or <literal>DELETE</literal> statements when an object should be made transient."
msgstr ""

#: index.docbook:55
msgid "<emphasis>Detached</emphasis> - a detached instance is an object that has been persistent, but its <literal>Session</literal> has been closed. The reference to the object is still valid, of course, and the detached instance might even be modified in this state. A detached instance can be reattached to a new <literal>Session</literal> at a later point in time, making it (and all the modifications) persistent again. This feature enables a programming model for long running units of work that require user think-time. We call them <emphasis>application transactions</emphasis>, i.e. a unit of work from the point of view of the user."
msgstr ""

#: index.docbook:69
msgid "We'll now discuss the states and state transitions (and the Hibernate methods that trigger a transition) in more detail."
msgstr ""

#: index.docbook:77
msgid "Making objects persistent"
msgstr ""

#: index.docbook:79
msgid "Newly instantiated instances of a a persistent class are considered <emphasis>transient</emphasis> by Hibernate. We can make a transient instance <emphasis>persistent</emphasis> by associating it with a session:"
msgstr ""

#: index.docbook:86
msgid ""
      "<![CDATA[DomesticCat fritz = new DomesticCat();\n"
      "fritz.setColor(Color.GINGER);\n"
      "fritz.setSex('M');\n"
      "fritz.setName(\"Fritz\");\n"
      "Long generatedId = (Long) sess.save(fritz);]]>"
msgstr ""

#: index.docbook:88
msgid "If <literal>Cat</literal> has a generated identifier, the identifier is generated and assigned to the <literal>cat</literal> when <literal>save()</literal> is called. If <literal>Cat</literal> has an <literal>assigned</literal> identifier, or a composite key, the identifier should be assigned to the <literal>cat</literal> instance before calling <literal>save()</literal>. You may also use <literal>persist()</literal> instead of <literal>save()</literal>, with the semantics defined in the EJB3 early draft."
msgstr ""

#: index.docbook:100
msgid "<literal>persist()</literal> makes a transient instance persistent. However, it doesn't guarantee that the identifier value will be assigned to the persistent instance immediately, the assignment might happen at flush time. <literal>persist()</literal> also guarantees that it will not execute an <literal>INSERT</literal> statement if it is called outside of transaction boundaries. This is useful in long-running conversations with an extended Session/persistence context."
msgstr ""

#: index.docbook:111
msgid "<literal>save()</literal> does guarantee to return an identifier. If an INSERT has to be executed to get the identifier ( e.g. \"identity\" generator, not \"sequence\"), this INSERT happens immediately, no matter if you are inside or outside of a transaction. This is problematic in a long-running conversation with an extended Session/persistence context."
msgstr ""

#: index.docbook:121
msgid "Alternatively, you may assign the identifier using an overloaded version of <literal>save()</literal>."
msgstr ""

#: index.docbook:126
msgid ""
      "<![CDATA[DomesticCat pk = new DomesticCat();\n"
      "pk.setColor(Color.TABBY);\n"
      "pk.setSex('F');\n"
      "pk.setName(\"PK\");\n"
      "pk.setKittens( new HashSet() );\n"
      "pk.addKitten(fritz);\n"
      "sess.save( pk, new Long(1234) );]]>"
msgstr ""

#: index.docbook:128
msgid "If the object you make persistent has associated objects (e.g. the <literal>kittens</literal> collection in the previous example), these objects may be made persistent in any order you like unless you have a <literal>NOT NULL</literal> constraint upon a foreign key column. There is never a risk of violating foreign key constraints. However, you might violate a <literal>NOT NULL</literal> constraint if you <literal>save()</literal> the objects in the wrong order."
msgstr ""

#: index.docbook:138
msgid "Usually you don't bother with this detail, as you'll very likely use Hibernate's <emphasis>transitive persistence</emphasis> feature to save the associated objects automatically. Then, even <literal>NOT NULL</literal> constraint violations don't occur - Hibernate will take care of everything. Transitive persistence is discussed later in this chapter."
msgstr ""

#: index.docbook:149
msgid "Loading an object"
msgstr ""

#: index.docbook:151
msgid "The <literal>load()</literal> methods of <literal>Session</literal> gives you a way to retrieve a persistent instance if you already know its identifier. <literal>load()</literal> takes a class object and will load the state into a newly instantiated instance of that class, in persistent state."
msgstr ""

#: index.docbook:158
msgid "<![CDATA[Cat fritz = (Cat) sess.load(Cat.class, generatedId);]]>"
msgstr ""

#: index.docbook:160
msgid ""
      "<![CDATA[// you need to wrap primitive identifiers\n"
      "long id = 1234;\n"
      "DomesticCat pk = (DomesticCat) sess.load( DomesticCat.class, new Long(id) );]]>"
msgstr ""

#: index.docbook:162
msgid "Alternatively, you can load state into a given instance:"
msgstr ""

#: index.docbook:166
msgid ""
      "<![CDATA[Cat cat = new DomesticCat();\n"
      "// load pk's state into cat\n"
      "sess.load( cat, new Long(pkId) );\n"
      "Set kittens = cat.getKittens();]]>"
msgstr ""

#: index.docbook:168
msgid "Note that <literal>load()</literal> will throw an unrecoverable exception if there is no matching database row. If the class is mapped with a proxy, <literal>load()</literal> just returns an uninitialized proxy and does not actually hit the database until you invoke a method of the proxy. This behaviour is very useful if you wish to create an association to an object without actually loading it from the database. It also allows multiple instances to be loaded as a batch if <literal>batch-size</literal> is defined for the class mapping."
msgstr ""

#: index.docbook:179
msgid "If you are not certain that a matching row exists, you should use the <literal>get()</literal> method, which hits the database immediately and returns null if there is no matching row."
msgstr ""

#: index.docbook:185
msgid ""
      "<![CDATA[Cat cat = (Cat) sess.get(Cat.class, id);\n"
      "if (cat==null) {\n"
      "    cat = new Cat();\n"
      "    sess.save(cat, id);\n"
      "}\n"
      "return cat;]]>"
msgstr ""

#: index.docbook:187
msgid "You may even load an object using an SQL <literal>SELECT ... FOR UPDATE</literal>, using a <literal>LockMode</literal>. See the API documentation for more information."
msgstr ""

#: index.docbook:192
msgid "<![CDATA[Cat cat = (Cat) sess.get(Cat.class, id, LockMode.UPGRADE);]]>"
msgstr ""

#: index.docbook:194
msgid "Note that any associated instances or contained collections are <emphasis>not</emphasis> selected <literal>FOR UPDATE</literal>, unless you decide to specify <literal>lock</literal> or <literal>all</literal> as a cascade style for the association."
msgstr ""

#: index.docbook:201
msgid "It is possible to re-load an object and all its collections at any time, using the <literal>refresh()</literal> method. This is useful when database triggers are used to initialize some of the properties of the object."
msgstr ""

#: index.docbook:207
msgid ""
      "<![CDATA[sess.save(cat);\n"
      "sess.flush(); //force the SQL INSERT\n"
      "sess.refresh(cat); //re-read the state (after the trigger executes)]]>"
msgstr ""

#: index.docbook:209
msgid "An important question usually appears at this point: How much does Hibernate load from the database and how many SQL <literal>SELECT</literal>s will it use? This depends on the <emphasis>fetching strategy</emphasis> and is explained in <xref linkend=\"performance-fetching\"/>."
msgstr ""

#: index.docbook:219
msgid "Querying"
msgstr ""

#: index.docbook:221
msgid "If you don't know the identifiers of the objects you are looking for, you need a query. Hibernate supports an easy-to-use but powerful object oriented query language (HQL). For programmatic query creation, Hibernate supports a sophisticated Criteria and Example query feature (QBC and QBE). You may also express your query in the native SQL of your database, with optional support from Hibernate for result set conversion into objects."
msgstr ""

#: index.docbook:231
msgid "Executing queries"
msgstr ""

#: index.docbook:233
msgid "HQL and native SQL queries are represented with an instance of <literal>org.hibernate.Query</literal>. This interface offers methods for parameter binding, result set handling, and for the execution of the actual query. You always obtain a <literal>Query</literal> using the current <literal>Session</literal>:"
msgstr ""

#: index.docbook:240
msgid ""
      "<![CDATA[List cats = session.createQuery(\n"
      "    \"from Cat as cat where cat.birthdate < ?\")\n"
      "    .setDate(0, date)\n"
      "    .list();\n"
      "\n"
      "List mothers = session.createQuery(\n"
      "    \"select mother from Cat as cat join cat.mother as mother where cat.name = ?\")\n"
      "    .setString(0, name)\n"
      "    .list();\n"
      "\n"
      "List kittens = session.createQuery(\n"
      "    \"from Cat as cat where cat.mother = ?\")\n"
      "    .setEntity(0, pk)\n"
      "    .list();\n"
      "\n"
      "Cat mother = (Cat) session.createQuery(\n"
      "    \"select cat.mother from Cat as cat where cat = ?\")\n"
      "    .setEntity(0, izi)\n"
      "    .uniqueResult();]]\n"
      "\n"
      "Query mothersWithKittens = (Cat) session.createQuery(\n"
      "    \"select mother from Cat as mother left join fetch mother.kittens\");\n"
      "Set uniqueMothers = new HashSet(mothersWithKittens.list());]]>"
msgstr ""

#: index.docbook:242
msgid "A query is usually executed by invoking <literal>list()</literal>, the result of the query will be loaded completely into a collection in memory. Entity instances retrieved by a query are in persistent state. The <literal>uniqueResult()</literal> method offers a shortcut if you know your query will only return a single object. Note that queries that make use of eager fetching of collections usually return duplicates of the root objects (but with their collections initialized). You can filter these duplicates simply through a <literal>Set</literal>."
msgstr ""

#: index.docbook:254
msgid "Iterating results"
msgstr ""

#: index.docbook:256
msgid "Occasionally, you might be able to achieve better performance by executing the query using the <literal>iterate()</literal> method. This will only usually be the case if you expect that the actual entity instances returned by the query will already be in the session or second-level cache. If they are not already cached, <literal>iterate()</literal> will be slower than <literal>list()</literal> and might require many database hits for a simple query, usually <emphasis>1</emphasis> for the initial select which only returns identifiers, and <emphasis>n</emphasis> additional selects to initialize the actual instances."
msgstr ""

#: index.docbook:268
msgid ""
      "<![CDATA[// fetch ids\n"
      "Iterator iter = sess.createQuery(\"from eg.Qux q order by q.likeliness\").iterate();\n"
      "while ( iter.hasNext() ) {\n"
      "    Qux qux = (Qux) iter.next();  // fetch the object\n"
      "    // something we couldnt express in the query\n"
      "    if ( qux.calculateComplicatedAlgorithm() ) {\n"
      "        // delete the current instance\n"
      "        iter.remove();\n"
      "        // dont need to process the rest\n"
      "        break;\n"
      "    }\n"
      "}]]>"
msgstr ""

#: index.docbook:272
msgid "Queries that return tuples"
msgstr ""

#: index.docbook:274
msgid "Hibernate queries sometimes return tuples of objects, in which case each tuple is returned as an array:"
msgstr ""

#: index.docbook:279
msgid ""
      "<![CDATA[Iterator kittensAndMothers = sess.createQuery(\n"
      "            \"select kitten, mother from Cat kitten join kitten.mother mother\")\n"
      "            .list()\n"
      "            .iterator();\n"
      "\n"
      "while ( kittensAndMothers.hasNext() ) {\n"
      "    Object[] tuple = (Object[]) kittensAndMothers.next();\n"
      "    Cat kitten = (Cat) tuple[0];\n"
      "    Cat mother = (Cat) tuple[1];\n"
      "    ....\n"
      "}]]>"
msgstr ""

#: index.docbook:284
msgid "Scalar results"
msgstr ""

#: index.docbook:286
msgid "Queries may specify a property of a class in the <literal>select</literal> clause. They may even call SQL aggregate functions. Properties or aggregates are considered \"scalar\" results (and not entities in persistent state)."
msgstr ""

#: index.docbook:292
msgid ""
      "<![CDATA[Iterator results = sess.createQuery(\n"
      "        \"select cat.color, min(cat.birthdate), count(cat) from Cat cat \" +\n"
      "        \"group by cat.color\")\n"
      "        .list()\n"
      "        .iterator();\n"
      "\n"
      "while ( results.hasNext() ) {\n"
      "    Object[] row = (Object[]) results.next();\n"
      "    Color type = (Color) row[0];\n"
      "    Date oldest = (Date) row[1];\n"
      "    Integer count = (Integer) row[2];\n"
      "    .....\n"
      "}]]>"
msgstr ""

#: index.docbook:297
msgid "Bind parameters"
msgstr ""

#: index.docbook:299
msgid "Methods on <literal>Query</literal> are provided for binding values to named parameters or JDBC-style <literal>?</literal> parameters. <emphasis>Contrary to JDBC, Hibernate numbers parameters from zero.</emphasis> Named parameters are identifiers of the form <literal>:name</literal> in the query string. The advantages of named parameters are:"
msgstr ""

#: index.docbook:309
msgid "named parameters are insensitive to the order they occur in the query string"
msgstr ""

#: index.docbook:315
msgid "they may occur multiple times in the same query"
msgstr ""

#: index.docbook:320
msgid "they are self-documenting"
msgstr ""

#: index.docbook:326
msgid ""
      "<![CDATA[//named parameter (preferred)\n"
      "Query q = sess.createQuery(\"from DomesticCat cat where cat.name = :name\");\n"
      "q.setString(\"name\", \"Fritz\");\n"
      "Iterator cats = q.iterate();]]>"
msgstr ""

#: index.docbook:328
msgid ""
      "<![CDATA[//positional parameter\n"
      "Query q = sess.createQuery(\"from DomesticCat cat where cat.name = ?\");\n"
      "q.setString(0, \"Izi\");\n"
      "Iterator cats = q.iterate();]]>"
msgstr ""

#: index.docbook:330
msgid ""
      "<![CDATA[//named parameter list\n"
      "List names = new ArrayList();\n"
      "names.add(\"Izi\");\n"
      "names.add(\"Fritz\");\n"
      "Query q = sess.createQuery(\"from DomesticCat cat where cat.name in (:namesList)\");\n"
      "q.setParameterList(\"namesList\", names);\n"
      "List cats = q.list();]]>"
msgstr ""

#: index.docbook:335
msgid "Pagination"
msgstr ""

#: index.docbook:337
msgid "If you need to specify bounds upon your result set (the maximum number of rows you want to retrieve and / or the first row you want to retrieve) you should use methods of the <literal>Query</literal> interface:"
msgstr ""

#: index.docbook:343
msgid ""
      "<![CDATA[Query q = sess.createQuery(\"from DomesticCat cat\");\n"
      "q.setFirstResult(20);\n"
      "q.setMaxResults(10);\n"
      "List cats = q.list();]]>"
msgstr ""

#: index.docbook:345
msgid "Hibernate knows how to translate this limit query into the native SQL of your DBMS."
msgstr ""

#: index.docbook:353
msgid "Scrollable iteration"
msgstr ""

#: index.docbook:355
msgid "If your JDBC driver supports scrollable <literal>ResultSet</literal>s, the <literal>Query</literal> interface may be used to obtain a <literal>ScrollableResults</literal> object, which allows flexible navigation of the query results."
msgstr ""

#: index.docbook:362
msgid ""
      "<![CDATA[Query q = sess.createQuery(\"select cat.name, cat from DomesticCat cat \" +\n"
      "                            \"order by cat.name\");\n"
      "ScrollableResults cats = q.scroll();\n"
      "if ( cats.first() ) {\n"
      "\n"
      "    // find the first name on each page of an alphabetical list of cats by name\n"
      "    firstNamesOfPages = new ArrayList();\n"
      "    do {\n"
      "        String name = cats.getString(0);\n"
      "        firstNamesOfPages.add(name);\n"
      "    }\n"
      "    while ( cats.scroll(PAGE_SIZE) );\n"
      "\n"
      "    // Now get the first page of cats\n"
      "    pageOfCats = new ArrayList();\n"
      "    cats.beforeFirst();\n"
      "    int i=0;\n"
      "    while( ( PAGE_SIZE > i++ ) && cats.next() ) pageOfCats.add( cats.get(1) );\n"
      "\n"
      "}\n"
      "cats.close()]]>"
msgstr ""

#: index.docbook:364
msgid "Note that an open database connection (and cursor) is required for this functionality, use <literal>setMaxResult()</literal>/<literal>setFirstResult()</literal> if you need offline pagination functionality."
msgstr ""

#: index.docbook:373
msgid "Externalizing named queries"
msgstr ""

#: index.docbook:375
msgid "You may also define named queries in the mapping document. (Remember to use a <literal>CDATA</literal> section if your query contains characters that could be interpreted as markup.)"
msgstr ""

#: index.docbook:381
msgid ""
      "<![CDATA[<query name=\"ByNameAndMaximumWeight\"><![CDATA[\n"
      "    from eg.DomesticCat as cat\n"
      "        where cat.name = ?\n"
      "        and cat.weight > ?\n"
      "] ]></query>]]>"
msgstr ""

#: index.docbook:383
msgid "Parameter binding and executing is done programatically:"
msgstr ""

#: index.docbook:387
msgid ""
      "<![CDATA[Query q = sess.getNamedQuery(\"ByNameAndMaximumWeight\");\n"
      "q.setString(0, name);\n"
      "q.setInt(1, minWeight);\n"
      "List cats = q.list();]]>"
msgstr ""

#: index.docbook:389
msgid "Note that the actual program code is independent of the query language that is used, you may also define native SQL queries in metadata, or migrate existing queries to Hibernate by placing them in mapping files."
msgstr ""

#: index.docbook:395
msgid "Also note that a query declaration inside a <literal>&lt;hibernate-mapping&gt;</literal> element requires a global unique name for the query, while a query declaration inside a <literal>&lt;class&gt;</literal> element is made unique automatically by prepending the fully qualified name of the class, for example <literal>eg.Cat.ByNameAndMaximumWeight</literal>."
msgstr ""

#: index.docbook:408
msgid "Filtering collections"
msgstr ""

#: index.docbook:409
msgid "A collection <emphasis>filter</emphasis> is a special type of query that may be applied to a persistent collection or array. The query string may refer to <literal>this</literal>, meaning the current collection element."
msgstr ""

#: index.docbook:415
msgid ""
      "<![CDATA[Collection blackKittens = session.createFilter(\n"
      "    pk.getKittens(), \n"
      "    \"where this.color = ?\")\n"
      "    .setParameter( Color.BLACK, Hibernate.custom(ColorUserType.class) )\n"
      "    .list()\n"
      ");]]>"
msgstr ""

#: index.docbook:417
msgid "The returned collection is considered a bag, and it's a copy of the given collection. The original collection is not modified (this is contrary to the implication of the name \"filter\", but consistent with expected behavior)."
msgstr ""

#: index.docbook:423
msgid "Observe that filters do not require a <literal>from</literal> clause (though they may have one if required). Filters are not limited to returning the collection elements themselves."
msgstr ""

#: index.docbook:428
msgid ""
      "<![CDATA[Collection blackKittenMates = session.createFilter(\n"
      "    pk.getKittens(), \n"
      "    \"select this.mate where this.color = eg.Color.BLACK.intValue\")\n"
      "    .list();]]>"
msgstr ""

#: index.docbook:430
msgid "Even an empty filter query is useful, e.g. to load a subset of elements in a huge collection:"
msgstr ""

#: index.docbook:435
msgid ""
      "<![CDATA[Collection tenKittens = session.createFilter(\n"
      "    mother.getKittens(), \"\")\n"
      "    .setFirstResult(0).setMaxResults(10)\n"
      "    .list();]]>"
msgstr ""

#: index.docbook:440
msgid "Criteria queries"
msgstr ""

#: index.docbook:442
msgid "HQL is extremely powerful but some developers prefer to build queries dynamically, using an object-oriented API, rather than building query strings. Hibernate provides an intuitive <literal>Criteria</literal> query API for these cases:"
msgstr ""

#: index.docbook:448
msgid ""
      "<![CDATA[Criteria crit = session.createCriteria(Cat.class);\n"
      "crit.add( Restrictions.eq( \"color\", eg.Color.BLACK ) );\n"
      "crit.setMaxResults(10);\n"
      "List cats = crit.list();]]>"
msgstr ""

#: index.docbook:450
msgid "The <literal>Criteria</literal> and the associated <literal>Example</literal> API are discussed in more detail in <xref linkend=\"querycriteria\"/>."
msgstr ""

#: index.docbook:458
msgid "Queries in native SQL"
msgstr ""

#: index.docbook:460
msgid "You may express a query in SQL, using <literal>createSQLQuery()</literal> and let Hibernate take care of the mapping from result sets to objects. Note that you may at any time call <literal>session.connection()</literal> and use the JDBC <literal>Connection</literal> directly. If you chose to use the Hibernate API, you must enclose SQL aliases in braces:"
msgstr ""

#: index.docbook:468
msgid ""
      "<![CDATA[List cats = session.createSQLQuery(\"SELECT {cat.*} FROM CAT {cat} WHERE ROWNUM<10\")\n"
      "    .addEntity(\"cat\", Cat.class)\n"
      ".list();]]>"
msgstr ""

#: index.docbook:470
msgid ""
      "<![CDATA[List cats = session.createSQLQuery(\n"
      "    \"SELECT {cat}.ID AS {cat.id}, {cat}.SEX AS {cat.sex}, \" +\n"
      "           \"{cat}.MATE AS {cat.mate}, {cat}.SUBCLASS AS {cat.class}, ... \" +\n"
      "    \"FROM CAT {cat} WHERE ROWNUM<10\")\n"
      "    .addEntity(\"cat\", Cat.class)\n"
      ".list()]]>"
msgstr ""

#: index.docbook:472
msgid "SQL queries may contain named and positional parameters, just like Hibernate queries. More information about native SQL queries in Hibernate can be found in <xref linkend=\"querysql\"/>."
msgstr ""

#: index.docbook:483
msgid "Modifying persistent objects"
msgstr ""

#: index.docbook:485
msgid "<emphasis>Transactional persistent instances</emphasis> (ie. objects loaded, saved, created or queried by the <literal>Session</literal>) may be manipulated by the application and any changes to persistent state will be persisted when the <literal>Session</literal> is <emphasis>flushed</emphasis> (discussed later in this chapter). There is no need to call a particular method (like <literal>update()</literal>, which has a different purpose) to make your modifications persistent. So the most straightforward way to update the state of an object is to <literal>load()</literal> it, and then manipulate it directly, while the <literal>Session</literal> is open:"
msgstr ""

#: index.docbook:496
msgid ""
      "<![CDATA[DomesticCat cat = (DomesticCat) sess.load( Cat.class, new Long(69) );\n"
      "cat.setName(\"PK\");\n"
      "sess.flush();  // changes to cat are automatically detected and persisted]]>"
msgstr ""

#: index.docbook:498
msgid "Sometimes this programming model is inefficient since it would require both an SQL <literal>SELECT</literal> (to load an object) and an SQL <literal>UPDATE</literal> (to persist its updated state) in the same session. Therefore Hibernate offers an alternate approach, using detached instances."
msgstr ""

#: index.docbook:506
msgid "Note that Hibernate does not offer its own API for direct execution of <literal>UPDATE</literal> or <literal>DELETE</literal> statements. Hibernate is a <emphasis>state management</emphasis> service, you don't have to think in <emphasis>statements</emphasis> to use it. JDBC is a perfect API for executing SQL statements, you can get a JDBC <literal>Connection</literal> at any time by calling <literal>session.connection()</literal>. Furthermore, the notion of mass operations conflicts with object/relational mapping for online transaction processing-oriented applications. Future versions of Hibernate may however provide special mass operation functions. See <xref linkend=\"batch\"/> for some possible batch operation tricks."
msgstr ""

#: index.docbook:521
msgid "Modifying detached objects"
msgstr ""

#: index.docbook:523
msgid "Many applications need to retrieve an object in one transaction, send it to the UI layer for manipulation, then save the changes in a new transaction. Applications that use this kind of approach in a high-concurrency environment usually use versioned data to ensure isolation for the \"long\" unit of work."
msgstr ""

#: index.docbook:530
msgid "Hibernate supports this model by providing for reattachment of detached instances using the <literal>Session.update()</literal> or <literal>Session.merge()</literal> methods:"
msgstr ""

#: index.docbook:536
msgid ""
      "<![CDATA[// in the first session\n"
      "Cat cat = (Cat) firstSession.load(Cat.class, catId);\n"
      "Cat potentialMate = new Cat();\n"
      "firstSession.save(potentialMate);\n"
      "\n"
      "// in a higher layer of the application\n"
      "cat.setMate(potentialMate);\n"
      "\n"
      "// later, in a new session\n"
      "secondSession.update(cat);  // update cat\n"
      "secondSession.update(mate); // update mate]]>"
msgstr ""

#: index.docbook:538
msgid "If the <literal>Cat</literal> with identifier <literal>catId</literal> had already been loaded by <literal>secondSession</literal> when the application tried to reattach it, an exception would have been thrown."
msgstr ""

#: index.docbook:544
msgid "Use <literal>update()</literal> if you are sure that the session does not contain an already persistent instance with the same identifier, and <literal>merge()</literal> if you want to merge your modifications at any time without consideration of the state of the session. In other words, <literal>update()</literal> is usually the first method you would call in a fresh session, ensuring that reattachment of your detached instances is the first operation that is executed."
msgstr ""

#: index.docbook:553
msgid "The application should individually <literal>update()</literal> detached instances reachable from the given detached instance if and <emphasis>only</emphasis> if it wants their state also updated. This can be automated of course, using <emphasis>transitive persistence</emphasis>, see <xref linkend=\"objectstate-transitive\"/>."
msgstr ""

#: index.docbook:560
msgid "The <literal>lock()</literal> method also allows an application to reassociate an object with a new session. However, the detached instance has to be unmodified!"
msgstr ""

#: index.docbook:565
msgid ""
      "<![CDATA[//just reassociate:\n"
      "sess.lock(fritz, LockMode.NONE);\n"
      "//do a version check, then reassociate:\n"
      "sess.lock(izi, LockMode.READ);\n"
      "//do a version check, using SELECT ... FOR UPDATE, then reassociate:\n"
      "sess.lock(pk, LockMode.UPGRADE);]]>"
msgstr ""

#: index.docbook:567
msgid "Note that <literal>lock()</literal> can be used with various <literal>LockMode</literal>s, see the API documentation and the chapter on transaction handling for more information. Reattachment is not the only usecase for <literal>lock()</literal>."
msgstr ""

#: index.docbook:574
msgid "Other models for long units of work are discussed in <xref linkend=\"transactions-optimistic\"/>."
msgstr ""

#: index.docbook:581
msgid "Automatic state detection"
msgstr ""

#: index.docbook:583
msgid "Hibernate users have requested a general purpose method that either saves a transient instance by generating a new identifier or updates/reattaches the detached instances associated with its current identifier. The <literal>saveOrUpdate()</literal> method implements this functionality."
msgstr ""

#: index.docbook:590
msgid ""
      "<![CDATA[// in the first session\n"
      "Cat cat = (Cat) firstSession.load(Cat.class, catID);\n"
      "\n"
      "// in a higher tier of the application\n"
      "Cat mate = new Cat();\n"
      "cat.setMate(mate);\n"
      "\n"
      "// later, in a new session\n"
      "secondSession.saveOrUpdate(cat);   // update existing state (cat has a non-null id)\n"
      "secondSession.saveOrUpdate(mate);  // save the new instance (mate has a null id)]]>"
msgstr ""

#: index.docbook:592
msgid "The usage and semantics of <literal>saveOrUpdate()</literal> seems to be confusing for new users. Firstly, so long as you are not trying to use instances from one session in another new session, you should not need to use <literal>update()</literal>, <literal>saveOrUpdate()</literal>, or <literal>merge()</literal>. Some whole applications will never use either of these methods."
msgstr ""

#: index.docbook:600
msgid "Usually <literal>update()</literal> or <literal>saveOrUpdate()</literal> are used in the following scenario:"
msgstr ""

#: index.docbook:607
msgid "the application loads an object in the first session"
msgstr ""

#: index.docbook:612
msgid "the object is passed up to the UI tier"
msgstr ""

#: index.docbook:617
msgid "some modifications are made to the object"
msgstr ""

#: index.docbook:622
msgid "the object is passed back down to the business logic tier"
msgstr ""

#: index.docbook:627
msgid "the application persists these modifications by calling <literal>update()</literal> in a second session"
msgstr ""

#: index.docbook:634
msgid "<literal>saveOrUpdate()</literal> does the following:"
msgstr ""

#: index.docbook:640
msgid "if the object is already persistent in this session, do nothing"
msgstr ""

#: index.docbook:645
msgid "if another object associated with the session has the same identifier, throw an exception"
msgstr ""

#: index.docbook:651
msgid "if the object has no identifier property, <literal>save()</literal> it"
msgstr ""

#: index.docbook:656
msgid "if the object's identifier has the value assigned to a newly instantiated object, <literal>save()</literal> it"
msgstr ""

#: index.docbook:662
msgid "if the object is versioned (by a <literal>&lt;version&gt;</literal> or <literal>&lt;timestamp&gt;</literal>), and the version property value is the same value assigned to a newly instantiated object, <literal>save()</literal> it"
msgstr ""

#: index.docbook:670
msgid "otherwise <literal>update()</literal> the object"
msgstr ""

#: index.docbook:676
msgid "and <literal>merge()</literal> is very different:"
msgstr ""

#: index.docbook:682
msgid "if there is a persistent instance with the same identifier currently associated with the session, copy the state of the given object onto the persistent instance"
msgstr ""

#: index.docbook:689
msgid "if there is no persistent instance currently associated with the session, try to load it from the database, or create a new persistent instance"
msgstr ""

#: index.docbook:695
msgid "the persistent instance is returned"
msgstr ""

#: index.docbook:700
msgid "the given instance does not become associated with the session, it remains detached"
msgstr ""

#: index.docbook:710
msgid "Deleting persistent objects"
msgstr ""

#: index.docbook:712
msgid "<literal>Session.delete()</literal> will remove an object's state from the database. Of course, your application might still hold a reference to a deleted object. It's best to think of <literal>delete()</literal> as making a persistent instance transient."
msgstr ""

#: index.docbook:719
msgid "<![CDATA[sess.delete(cat);]]>"
msgstr ""

#: index.docbook:721
msgid "You may delete objects in any order you like, without risk of foreign key constraint violations. It is still possible to violate a <literal>NOT NULL</literal> constraint on a foreign key column by deleting objects in the wrong order, e.g. if you delete the parent, but forget to delete the children."
msgstr ""

#: index.docbook:732
msgid "Replicating object between two different datastores"
msgstr ""

#: index.docbook:734
msgid "It is occasionally useful to be able to take a graph of persistent instances and make them persistent in a different datastore, without regenerating identifier values."
msgstr ""

#: index.docbook:740
msgid ""
      "<![CDATA[//retrieve a cat from one database\n"
      "Session session1 = factory1.openSession();\n"
      "Transaction tx1 = session1.beginTransaction();\n"
      "Cat cat = session1.get(Cat.class, catId);\n"
      "tx1.commit();\n"
      "session1.close();\n"
      "\n"
      "//reconcile with a second database\n"
      "Session session2 = factory2.openSession();\n"
      "Transaction tx2 = session2.beginTransaction();\n"
      "session2.replicate(cat, ReplicationMode.LATEST_VERSION);\n"
      "tx2.commit();\n"
      "session2.close();]]>"
msgstr ""

#: index.docbook:742
msgid "The <literal>ReplicationMode</literal> determines how <literal>replicate()</literal> will deal with conflicts with existing rows in the database."
msgstr ""

#: index.docbook:749
msgid "<literal>ReplicationMode.IGNORE</literal> - ignore the object when there is an existing database row with the same identifier"
msgstr ""

#: index.docbook:755
msgid "<literal>ReplicationMode.OVERWRITE</literal> - overwrite any existing database row with the same identifier"
msgstr ""

#: index.docbook:761
msgid "<literal>ReplicationMode.EXCEPTION</literal> - throw an exception if there is an existing database row with the same identifier"
msgstr ""

#: index.docbook:767
msgid "<literal>ReplicationMode.LATEST_VERSION</literal> - overwrite the row if its version number is earlier than the version number of the object, or ignore the object otherwise"
msgstr ""

#: index.docbook:775
msgid "Usecases for this feature include reconciling data entered into different database instances, upgrading system configuration information during product upgrades, rolling back changes made during non-ACID transactions and more."
msgstr ""

#: index.docbook:784
msgid "Flushing the Session"
msgstr ""

#: index.docbook:786
msgid "From time to time the <literal>Session</literal> will execute the SQL statements needed to synchronize the JDBC connection's state with the state of objects held in memory. This process, <emphasis>flush</emphasis>, occurs by default at the following points"
msgstr ""

#: index.docbook:795
msgid "before some query executions"
msgstr ""

#: index.docbook:800
msgid "from <literal>org.hibernate.Transaction.commit()</literal>"
msgstr ""

#: index.docbook:805
msgid "from <literal>Session.flush()</literal>"
msgstr ""

#: index.docbook:811
msgid "The SQL statements are issued in the following order"
msgstr ""

#: index.docbook:817
msgid "all entity insertions, in the same order the corresponding objects were saved using <literal>Session.save()</literal>"
msgstr ""

#: index.docbook:823
msgid "all entity updates"
msgstr ""

#: index.docbook:828
msgid "all collection deletions"
msgstr ""

#: index.docbook:833
msgid "all collection element deletions, updates and insertions"
msgstr ""

#: index.docbook:838
msgid "all collection insertions"
msgstr ""

#: index.docbook:843
msgid "all entity deletions, in the same order the corresponding objects were deleted using <literal>Session.delete()</literal>"
msgstr ""

#: index.docbook:850
msgid "(An exception is that objects using <literal>native</literal> ID generation are inserted when they are saved.)"
msgstr ""

#: index.docbook:855
msgid "Except when you explicity <literal>flush()</literal>, there are absolutely no guarantees about <emphasis>when</emphasis> the <literal>Session</literal> executes the JDBC calls, only the <emphasis>order</emphasis> in which they are executed. However, Hibernate does guarantee that the <literal>Query.list(..)</literal> will never return stale data; nor will they return the wrong data."
msgstr ""

#: index.docbook:863
msgid "It is possible to change the default behavior so that flush occurs less frequently. The <literal>FlushMode</literal> class defines three different modes: only flush at commit time (and only when the Hibernate <literal>Transaction</literal> API is used), flush automatically using the explained routine, or never flush unless <literal>flush()</literal> is called explicitly. The last mode is useful for long running units of work, where a <literal>Session</literal> is kept open and disconnected for a long time (see <xref linkend=\"transactions-optimistic-longsession\"/>)."
msgstr ""

#: index.docbook:873
msgid ""
      "<![CDATA[sess = sf.openSession();\n"
      "Transaction tx = sess.beginTransaction();\n"
      "sess.setFlushMode(FlushMode.COMMIT); // allow queries to return stale state\n"
      "\n"
      "Cat izi = (Cat) sess.load(Cat.class, id);\n"
      "izi.setName(iznizi);\n"
      "\n"
      "// might return stale data\n"
      "sess.find(\"from Cat as cat left outer join cat.kittens kitten\");\n"
      "\n"
      "// change to izi is not flushed!\n"
      "...\n"
      "tx.commit(); // flush occurs\n"
      "sess.close();]]>"
msgstr ""

#: index.docbook:875
msgid "During flush, an exception might occur (e.g. if a DML operation violates a constraint). Since handling exceptions involves some understanding of Hibernate's transactional behavior, we discuss it in <xref linkend=\"transactions\"/>."
msgstr ""

#: index.docbook:884
msgid "Transitive persistence"
msgstr ""

#: index.docbook:886
msgid "It is quite cumbersome to save, delete, or reattach individual objects, especially if you deal with a graph of associated objects. A common case is a parent/child relationship. Consider the following example:"
msgstr ""

#: index.docbook:892
msgid "If the children in a parent/child relationship would be value typed (e.g. a collection of addresses or strings), their life cycle would depend on the parent and no further action would be required for convenient \"cascading\" of state changes. When the parent is saved, the value-typed child objects are saved as well, when the parent is deleted, the children will be deleted, etc. This even works for operations such as the removal of a child from the collection; Hibernate will detect this and, since value-typed objects can't have shared references, delete the child from the database."
msgstr ""

#: index.docbook:903
msgid "Now consider the same scenario with parent and child objects being entities, not value-types (e.g. categories and items, or parent and child cats). Entities have their own life cycle, support shared references (so removing an entity from the collection does not mean it can be deleted), and there is by default no cascading of state from one entity to any other associated entities. Hibernate does not implement <emphasis>persistence by reachability</emphasis> by default."
msgstr ""

#: index.docbook:912
msgid "For each basic operation of the Hibernate session - including <literal>persist(), merge(), saveOrUpdate(), delete(), lock(), refresh(), evict(), replicate()</literal> - there is a corresponding cascade style. Respectively, the cascade styles are named <literal>create, merge, save-update, delete, lock, refresh, evict, replicate</literal>. If you want an operation to be cascaded along an association, you must indicate that in the mapping document. For example:"
msgstr ""

#: index.docbook:921
msgid "<![CDATA[<one-to-one name=\"person\" cascade=\"persist\"/>]]>"
msgstr ""

#: index.docbook:923
msgid "Cascade styles my be combined:"
msgstr ""

#: index.docbook:927
msgid "<![CDATA[<one-to-one name=\"person\" cascade=\"persist,delete,lock\"/>]]>"
msgstr ""

#: index.docbook:929
msgid "You may even use <literal>cascade=\"all\"</literal> to specify that <emphasis>all</emphasis> operations should be cascaded along the association. The default <literal>cascade=\"none\"</literal> specifies that no operations are to be cascaded."
msgstr ""

#: index.docbook:935
msgid "A special cascade style, <literal>delete-orphan</literal>, applies only to one-to-many associations, and indicates that the <literal>delete()</literal> operation should be applied to any child object that is removed from the association."
msgstr ""

#: index.docbook:942
msgid "Recommendations:"
msgstr ""

#: index.docbook:948
msgid "It doesn't usually make sense to enable cascade on a <literal>&lt;many-to-one&gt;</literal> or <literal>&lt;many-to-many&gt;</literal> association. Cascade is often useful for <literal>&lt;one-to-one&gt;</literal> and <literal>&lt;one-to-many&gt;</literal> associations."
msgstr ""

#: index.docbook:956
msgid "If the child object's lifespan is bounded by the lifespan of the parent object, make it a <emphasis>life cycle object</emphasis> by specifying <literal>cascade=\"all,delete-orphan\"</literal>."
msgstr ""

#: index.docbook:963
msgid "Otherwise, you might not need cascade at all. But if you think that you will often be working with the parent and children together in the same transaction, and you want to save yourself some typing, consider using <literal>cascade=\"persist,merge,save-update\"</literal>."
msgstr ""

#: index.docbook:971
msgid "Mapping an association (either a single valued association, or a collection) with <literal>cascade=\"all\"</literal> marks the association as a <emphasis>parent/child</emphasis> style relationship where save/update/delete of the parent results in save/update/delete of the child or children."
msgstr ""

#: index.docbook:977
msgid "Futhermore, a mere reference to a child from a persistent parent will result in save/update of the child. This metaphor is incomplete, however. A child which becomes unreferenced by its parent is <emphasis>not</emphasis> automatically deleted, except in the case of a <literal>&lt;one-to-many&gt;</literal> association mapped with <literal>cascade=\"delete-orphan\"</literal>. The precise semantics of cascading operations for a parent/child relationship are as follows:"
msgstr ""

#: index.docbook:988
msgid "If a parent is passed to <literal>persist()</literal>, all children are passed to <literal>persist()</literal>"
msgstr ""

#: index.docbook:994
msgid "If a parent is passed to <literal>merge()</literal>, all children are passed to <literal>merge()</literal>"
msgstr ""

#: index.docbook:1000
msgid "If a parent is passed to <literal>save()</literal>, <literal>update()</literal> or <literal>saveOrUpdate()</literal>, all children are passed to <literal>saveOrUpdate()</literal>"
msgstr ""

#: index.docbook:1006
msgid "If a transient or detached child becomes referenced by a persistent parent, it is passed to <literal>saveOrUpdate()</literal>"
msgstr ""

#: index.docbook:1012
msgid "If a parent is deleted, all children are passed to <literal>delete()</literal>"
msgstr ""

#: index.docbook:1017
msgid "If a child is dereferenced by a persistent parent, <emphasis>nothing special happens</emphasis> - the application should explicitly delete the child if necessary - unless <literal>cascade=\"delete-orphan\"</literal>, in which case the \"orphaned\" child is deleted."
msgstr ""

#: index.docbook:1026
msgid "Finally, note that cascading of operations can be applied to an object graph at <emphasis>call time</emphasis> or at <emphasis>flush time</emphasis>. All operations, if enabled, are cascaded to associated entities reachable when the operation is executed. However, <literal>save-upate</literal> and <literal>delete-orphan</literal> are transitive for all associated entities reachable during flush of the <literal>Session</literal>."
msgstr ""

#: index.docbook:1038
msgid "Using metadata"
msgstr ""

#: index.docbook:1040
msgid "Hibernate requires a very rich meta-level model of all entity and value types. From time to time, this model is very useful to the application itself. For example, the application might use Hibernate's metadata to implement a \"smart\" deep-copy algorithm that understands which objects should be copied (eg. mutable value types) and which should not (eg. immutable value types and, possibly, associated entities)."
msgstr ""

#: index.docbook:1047
msgid "Hibernate exposes metadata via the <literal>ClassMetadata</literal> and <literal>CollectionMetadata</literal> interfaces and the <literal>Type</literal> hierarchy. Instances of the metadata interfaces may be obtained from the <literal>SessionFactory</literal>."
msgstr ""

#: index.docbook:1054
msgid ""
      "<![CDATA[Cat fritz = ......;\n"
      "ClassMetadata catMeta = sessionfactory.getClassMetadata(Cat.class);\n"
      "\n"
      "Object[] propertyValues = catMeta.getPropertyValues(fritz);\n"
      "String[] propertyNames = catMeta.getPropertyNames();\n"
      "Type[] propertyTypes = catMeta.getPropertyTypes();\n"
      "\n"
      "// get a Map of all properties which are not collections or associations\n"
      "Map namedValues = new HashMap();\n"
      "for ( int i=0; i<propertyNames.length; i++ ) {\n"
      "    if ( !propertyTypes[i].isEntityType() && !propertyTypes[i].isCollectionType() ) {\n"
      "        namedValues.put( propertyNames[i], propertyValues[i] );\n"
      "    }\n"
      "}]]>"
msgstr ""

msgid "ROLES_OF_TRANSLATORS"
msgstr "<!--TRANS:ROLES_OF_TRANSLATORS-->"

msgid "CREDIT_FOR_TRANSLATORS"
msgstr "<!--TRANS:CREDIT_FOR_TRANSLATORS-->"

