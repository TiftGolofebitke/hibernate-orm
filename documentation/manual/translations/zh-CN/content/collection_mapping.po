#, fuzzy
msgid ""
msgstr ""
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Content-Type: text/plain; charset=utf-8\n"
#: index.docbook:5
msgid "Collection Mapping"
msgstr ""

#: index.docbook:8
msgid "Persistent collections"
msgstr ""

#: index.docbook:10
msgid "Hibernate requires that persistent collection-valued fields be declared as an interface type, for example:"
msgstr ""

#: index.docbook:15
msgid ""
      "<![CDATA[public class Product {\n"
      "    private String serialNumber;\n"
      "    private Set parts = new HashSet();\n"
      "    \n"
      "    public Set getParts() { return parts; }\n"
      "    void setParts(Set parts) { this.parts = parts; }\n"
      "    public String getSerialNumber() { return serialNumber; }\n"
      "    void setSerialNumber(String sn) { serialNumber = sn; }\n"
      "}]]>"
msgstr ""

#: index.docbook:17
msgid "The actual interface might be <literal>java.util.Set</literal>, <literal>java.util.Collection</literal>, <literal>java.util.List</literal>, <literal>java.util.Map</literal>, <literal>java.util.SortedSet</literal>, <literal>java.util.SortedMap</literal> or ... anything you like! (Where \"anything you like\" means you will have to write an implementation of <literal>org.hibernate.usertype.UserCollectionType</literal>.)"
msgstr ""

#: index.docbook:26
msgid "Notice how we initialized the instance variable with an instance of <literal>HashSet</literal>. This is the best way to initialize collection valued properties of newly instantiated (non-persistent) instances. When you make the instance persistent - by calling <literal>persist()</literal>, for example - Hibernate will actually replace the <literal>HashSet</literal> with an instance of Hibernate's own implementation of <literal>Set</literal>. Watch out for errors like this:"
msgstr ""

#: index.docbook:36
msgid ""
      "<![CDATA[Cat cat = new DomesticCat();\n"
      "Cat kitten = new DomesticCat();\n"
      "....\n"
      "Set kittens = new HashSet();\n"
      "kittens.add(kitten);\n"
      "cat.setKittens(kittens);\n"
      "session.persist(cat);\n"
      "kittens = cat.getKittens(); // Okay, kittens collection is a Set\n"
      "(HashSet) cat.getKittens(); // Error!]]>"
msgstr ""

#: index.docbook:38
msgid "The persistent collections injected by Hibernate behave like <literal>HashMap</literal>, <literal>HashSet</literal>, <literal>TreeMap</literal>, <literal>TreeSet</literal> or <literal>ArrayList</literal>, depending upon the interface type."
msgstr ""

#: index.docbook:45
msgid "Collections instances have the usual behavior of value types. They are automatically persisted when referenced by a persistent object and automatically deleted when unreferenced. If a collection is passed from one persistent object to another, its elements might be moved from one table to another. Two entities may not share a reference to the same collection instance. Due to the underlying relational model, collection-valued properties do not support null value semantics; Hibernate does not distinguish between a null collection reference and an empty collection."
msgstr ""

#: index.docbook:56
msgid "You shouldn't have to worry much about any of this. Use persistent collections the same way you use ordinary Java collections. Just make sure you understand the semantics of bidirectional associations (discussed later)."
msgstr ""

#: index.docbook:65
msgid "Collection mappings"
msgstr ""

#: index.docbook:67
msgid "The Hibernate mapping element used for mapping a collection depends upon the type of the interface. For example, a <literal>&lt;set&gt;</literal> element is used for mapping properties of type <literal>Set</literal>."
msgstr ""

#: index.docbook:73
msgid ""
      "<![CDATA[<class name=\"Product\">\n"
      "    <id name=\"serialNumber\" column=\"productSerialNumber\"/>\n"
      "    <set name=\"parts\">\n"
      "        <key column=\"productSerialNumber\" not-null=\"true\"/>\n"
      "        <one-to-many class=\"Part\"/>\n"
      "    </set>\n"
      "</class>]]>"
msgstr ""

#: index.docbook:75
msgid "Apart from <literal>&lt;set&gt;</literal>, there is also <literal>&lt;list&gt;</literal>, <literal>&lt;map&gt;</literal>, <literal>&lt;bag&gt;</literal>, <literal>&lt;array&gt;</literal> and <literal>&lt;primitive-array&gt;</literal> mapping elements. The <literal>&lt;map&gt;</literal> element is representative:"
msgstr ""

#: index.docbook:100
msgid ""
      "<![CDATA[<map\n"
      "    name=\"propertyName\"\n"
      "    table=\"table_name\"\n"
      "    schema=\"schema_name\"\n"
      "    lazy=\"true|extra|false\"\n"
      "    inverse=\"true|false\"\n"
      "    cascade=\"all|none|save-update|delete|all-delete-orphan|delete-orphan\"\n"
      "    sort=\"unsorted|natural|comparatorClass\"\n"
      "    order-by=\"column_name asc|desc\"\n"
      "    where=\"arbitrary sql where condition\"\n"
      "    fetch=\"join|select|subselect\"\n"
      "    batch-size=\"N\"\n"
      "    access=\"field|property|ClassName\"\n"
      "    optimistic-lock=\"true|false\"\n"
      "    mutable=\"true|false\"\n"
      "    node=\"element-name|.\"\n"
      "    embed-xml=\"true|false\"\n"
      ">\n"
      "\n"
      "    <key .... />\n"
      "    <map-key .... />\n"
      "    <element .... />\n"
      "</map>]]>"
msgstr ""

#: index.docbook:103
msgid "<literal>name</literal> the collection property name"
msgstr ""

#: index.docbook:108
msgid "<literal>table</literal> (optional - defaults to property name) the name of the collection table (not used for one-to-many associations)"
msgstr ""

#: index.docbook:114
msgid "<literal>schema</literal> (optional) the name of a table schema to override the schema declared on the root element"
msgstr ""

#: index.docbook:120
msgid "<literal>lazy</literal> (optional - defaults to <literal>true</literal>) may be used to disable lazy fetching and specify that the association is always eagerly fetched, or to enable \"extra-lazy\" fetching where most operations do not initialize the collection (suitable for very large collections)"
msgstr ""

#: index.docbook:129
msgid "<literal>inverse</literal> (optional - defaults to <literal>false</literal>) mark this collection as the \"inverse\" end of a bidirectional association"
msgstr ""

#: index.docbook:135
msgid "<literal>cascade</literal> (optional - defaults to <literal>none</literal>) enable operations to cascade to child entities"
msgstr ""

#: index.docbook:141
msgid "<literal>sort</literal> (optional) specify a sorted collection with <literal>natural</literal> sort order, or a given comparator class"
msgstr ""

#: index.docbook:147
msgid "<literal>order-by</literal> (optional, JDK1.4 only) specify a table column (or columns) that define the iteration order of the <literal>Map</literal>, <literal>Set</literal> or bag, together with an optional <literal>asc</literal> or <literal>desc</literal>"
msgstr ""

#: index.docbook:154
msgid "<literal>where</literal> (optional) specify an arbitrary SQL <literal>WHERE</literal> condition to be used when retrieving or removing the collection (useful if the collection should contain only a subset of the available data)"
msgstr ""

#: index.docbook:161
msgid "<literal>fetch</literal> (optional, defaults to <literal>select</literal>) Choose between outer-join fetching, fetching by sequential select, and fetching by sequential subselect."
msgstr ""

#: index.docbook:168
msgid "<literal>batch-size</literal> (optional, defaults to <literal>1</literal>) specify a \"batch size\" for lazily fetching instances of this collection."
msgstr ""

#: index.docbook:174
msgid "<literal>access</literal> (optional - defaults to <literal>property</literal>): The strategy Hibernate should use for accessing the collection property value."
msgstr ""

#: index.docbook:180
msgid "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>): Species that changes to the state of the collection results in increment of the owning entity's version. (For one to many associations, it is often reasonable to disable this setting.)"
msgstr ""

#: index.docbook:188
msgid "<literal>mutable</literal> (optional - defaults to <literal>true</literal>): A value of <literal>false</literal> specifies that the elements of the collection never change (a minor performance optimization in some cases)."
msgstr ""

#: index.docbook:198
msgid "Collection foreign keys"
msgstr ""

#: index.docbook:200
msgid "Collection instances are distinguished in the database by the foreign key of the entity that owns the collection. This foreign key is referred to as the <emphasis>collection key column</emphasis> (or columns) of the collection table. The collection key column is mapped by the <literal>&lt;key&gt;</literal> element."
msgstr ""

#: index.docbook:208
msgid "There may be a nullability constraint on the foreign key column. For most collections, this is implied. For unidirectional one to many associations, the foreign key column is nullable by default, so you might need to specify <literal>not-null=\"true\"</literal>."
msgstr ""

#: index.docbook:215
msgid "<![CDATA[<key column=\"productSerialNumber\" not-null=\"true\"/>]]>"
msgstr ""

#: index.docbook:217
msgid "The foreign key constraint may use <literal>ON DELETE CASCADE</literal>."
msgstr ""

#: index.docbook:221
msgid "<![CDATA[<key column=\"productSerialNumber\" on-delete=\"cascade\"/>]]>"
msgstr ""

#: index.docbook:223
msgid "See the previous chapter for a full definition of the <literal>&lt;key&gt;</literal> element."
msgstr ""

#: index.docbook:231
msgid "Collection elements"
msgstr ""

#: index.docbook:233
msgid "Collections may contain almost any other Hibernate type, including all basic types, custom types, components, and of course, references to other entities. This is an important distinction: an object in a collection might be handled with \"value\" semantics (its life cycle fully depends on the collection owner) or it might be a reference to another entity, with its own life cycle. In the latter case, only the \"link\" between the two objects is considered to be state held by the collection."
msgstr ""

#: index.docbook:242
msgid "The contained type is referred to as the <emphasis>collection element type</emphasis>. Collection elements are mapped by <literal>&lt;element&gt;</literal> or <literal>&lt;composite-element&gt;</literal>, or in the case of entity references, with <literal>&lt;one-to-many&gt;</literal> or <literal>&lt;many-to-many&gt;</literal>. The first two map elements with value semantics, the next two are used to map entity associations."
msgstr ""

#: index.docbook:254
msgid "Indexed collections"
msgstr ""

#: index.docbook:256
msgid "All collection mappings, except those with set and bag semantics, need an <emphasis>index column</emphasis> in the collection table - a column that maps to an array index, or <literal>List</literal> index, or <literal>Map</literal> key. The index of a <literal>Map</literal> may be of any basic type, mapped with <literal>&lt;map-key&gt;</literal>, it may be an entity reference mapped with <literal>&lt;map-key-many-to-many&gt;</literal>, or it may be a composite type, mapped with <literal>&lt;composite-map-key&gt;</literal>. The index of an array or list is always of type <literal>integer</literal> and is mapped using the <literal>&lt;list-index&gt;</literal> element. The mapped column contains sequential integers (numbered from zero, by default)."
msgstr ""

#: index.docbook:267
msgid ""
      "<programlistingco> <areaspec> <area id=\"index1\" coords=\"2 45\"/> <area id=\"index2\" coords=\"3 45\"/> </areaspec> <programlisting><![CDATA[<list-index \n"
      "        column=\"column_name\"\n"
      "        base=\"0|1|...\"/>]]></programlisting> <calloutlist> <callout arearefs=\"index1\"> <para> <literal>column_name</literal> (required): The name of the column holding the collection index values. </para> </callout> <callout arearefs=\"index1\"> <para> <literal>base</literal> (optional, defaults to <literal>0</literal>): The value of the index column that corresponds to the first element of the list or array. </para> </callout> </calloutlist> </programlistingco> <programlistingco> <areaspec> <area id=\"mapkey1\" coords=\"2 45\"/> <area id=\"mapkey2\" coords=\"3 45\"/> <area id=\"mapkey3\" coords=\"4 45\"/> </areaspec> <programlisting><![CDATA[<map-key \n"
      "        column=\"column_name\"\n"
      "        formula=\"any SQL expression\"\n"
      "        type=\"type_name\"\n"
      "        node=\"@attribute-name\"\n"
      "        length=\"N\"/>]]></programlisting> <calloutlist> <callout arearefs=\"mapkey1\"> <para> <literal>column</literal> (optional): The name of the column holding the collection index values. </para> </callout> <callout arearefs=\"mapkey2\"> <para> <literal>formula</literal> (optional): A SQL formula used to evaluate the key of the map. </para> </callout> <callout arearefs=\"mapkey3\"> <para> <literal>type</literal> (reguired): The type of the map keys. </para> </callout> </calloutlist> </programlistingco> <programlistingco> <areaspec> <area id=\"indexmanytomany1\" coords=\"2 45\"/> <area id=\"indexmanytomany2\" coords=\"3 45\"/> <area id=\"indexmanytomany3\" coords=\"3 45\"/> </areaspec> <programlisting><![CDATA[<map-key-many-to-many\n"
      "        column=\"column_name\"\n"
      "        formula=\"any SQL expression\"\n"
      "        class=\"ClassName\"\n"
      "/>]]></programlisting> <calloutlist> <callout arearefs=\"indexmanytomany1\"> <para> <literal>column</literal> (optional): The name of the foreign key column for the collection index values. </para> </callout> <callout arearefs=\"indexmanytomany2\"> <para> <literal>formula</literal> (optional): A SQL formula used to evaluate the foreign key of the map key. </para> </callout> <callout arearefs=\"indexmanytomany3\"> <para> <literal>class</literal> (required): The entity class used as the map key. </para> </callout> </calloutlist> </programlistingco>"
msgstr ""

#: index.docbook:348
msgid "If your table doesn't have an index column, and you still wish to use <literal>List</literal> as the property type, you should map the property as a Hibernate <emphasis>&lt;bag&gt;</emphasis>. A bag does not retain its order when it is retrieved from the database, but it may be optionally sorted or ordered."
msgstr ""

#: index.docbook:357
msgid "There are quite a range of mappings that can be generated for collections, covering many common relational models. We suggest you experiment with the schema generation tool to get a feeling for how various mapping declarations translate to database tables."
msgstr ""

#: index.docbook:364
msgid "Collections of values and many-to-many associations"
msgstr ""

#: index.docbook:366
msgid "Any collection of values or many-to-many association requires a dedicated <emphasis>collection table</emphasis> with a foreign key column or columns, <emphasis>collection element column</emphasis> or columns and possibly an index column or columns."
msgstr ""

#: index.docbook:373
msgid "For a collection of values, we use the <literal>&lt;element&gt;</literal> tag."
msgstr ""

#: index.docbook:375
msgid ""
      "<programlistingco> <areaspec> <area id=\"element1b\" coords=\"2 50\"/> <area id=\"element2b\" coords=\"3 50\"/> <area id=\"element3b\" coords=\"4 50\"/> </areaspec> <programlisting><![CDATA[<element\n"
      "        column=\"column_name\"\n"
      "        formula=\"any SQL expression\"\n"
      "        type=\"typename\"\n"
      "        length=\"L\"\n"
      "        precision=\"P\"\n"
      "        scale=\"S\"\n"
      "        not-null=\"true|false\"\n"
      "        unique=\"true|false\"\n"
      "        node=\"element-name\"\n"
      "/>]]></programlisting> <calloutlist> <callout arearefs=\"element1b\"> <para> <literal>column</literal> (optional): The name of the column holding the collection element values. </para> </callout> <callout arearefs=\"element2b\"> <para> <literal>formula</literal> (optional): An SQL formula used to evaluate the element. </para> </callout> <callout arearefs=\"element3b\"> <para> <literal>type</literal> (required): The type of the collection element. </para> </callout> </calloutlist> </programlistingco> <para> A <emphasis>many-to-many association</emphasis> is specified using the <literal>&lt;many-to-many&gt;</literal> element. </para> <programlistingco> <areaspec> <area id=\"manytomany1\" coords=\"2 60\"/> <area id=\"manytomany2\" coords=\"3 60\"/> <area id=\"manytomany3\" coords=\"4 60\"/> <area id=\"manytomany4\" coords=\"5 60\"/> <area id=\"manytomany5\" coords=\"6 60\"/> <area id=\"manytomany6\" coords=\"7 60\"/> <area id=\"manytomany7\" coords=\"8 60\"/> <area id=\"manytomany8\" coords=\"9 60\"/> </areaspec> <programlisting><![CDATA[<many-to-many\n"
      "        column=\"column_name\"\n"
      "        formula=\"any SQL expression\"\n"
      "        class=\"ClassName\"\n"
      "        fetch=\"select|join\"\n"
      "        unique=\"true|false\"\n"
      "        not-found=\"ignore|exception\"\n"
      "        entity-name=\"EntityName\"\n"
      "        property-ref=\"propertyNameFromAssociatedClass\"\n"
      "        node=\"element-name\"\n"
      "        embed-xml=\"true|false\"\n"
      "    />]]></programlisting> <calloutlist> <callout arearefs=\"manytomany1\"> <para> <literal>column</literal> (optional): The name of the element foreign key column. </para> </callout> <callout arearefs=\"manytomany2\"> <para> <literal>formula</literal> (optional): An SQL formula used to evaluate the element foreign key value. </para> </callout> <callout arearefs=\"manytomany3\"> <para> <literal>class</literal> (required): The name of the associated class. </para> </callout> <callout arearefs=\"manytomany4\"> <para> <literal>fetch</literal> (optional - defaults to <literal>join</literal>): enables outer-join or sequential select fetching for this association. This is a special case; for full eager fetching (in a single <literal>SELECT</literal>) of an entity and its many-to-many relationships to other entities, you would enable <literal>join</literal> fetching not only of the collection itself, but also with this attribute on the <literal>&lt;many-to-many&gt;</literal> nested element. </para> </callout> <callout arearefs=\"manytomany5\"> <para> <literal>unique</literal> (optional): Enable the DDL generation of a unique constraint for the foreign-key column. This makes the association multiplicity effectively one to many. </para> </callout> <callout arearefs=\"manytomany6\"> <para> <literal>not-found</literal> (optional - defaults to <literal>exception</literal>): Specifies how foreign keys that reference missing rows will be handled: <literal>ignore</literal> will treat a missing row as a null association. </para> </callout> <callout arearefs=\"manytomany7\"> <para> <literal>entity-name</literal> (optional): The entity name of the associated class, as an alternative to <literal>class</literal>. </para> </callout> <callout arearefs=\"manytomany8\"> <para> <literal>property-ref</literal>: (optional) The name of a property of the associated class that is joined to this foreign key. If not specified, the primary key of the associated class is used. </para> </callout> </calloutlist> </programlistingco>"
msgstr ""

#: index.docbook:480
msgid "Some examples, first, a set of strings:"
msgstr ""

#: index.docbook:484
msgid ""
      "<![CDATA[<set name=\"names\" table=\"person_names\">\n"
      "    <key column=\"person_id\"/>\n"
      "    <element column=\"person_name\" type=\"string\"/>\n"
      "</set>]]>"
msgstr ""

#: index.docbook:486
msgid "A bag containing integers (with an iteration order determined by the <literal>order-by</literal> attribute):"
msgstr ""

#: index.docbook:491
msgid ""
      "<![CDATA[<bag name=\"sizes\" \n"
      "        table=\"item_sizes\" \n"
      "        order-by=\"size asc\">\n"
      "    <key column=\"item_id\"/>\n"
      "    <element column=\"size\" type=\"integer\"/>\n"
      "</bag>]]>"
msgstr ""

#: index.docbook:493
msgid "An array of entities - in this case, a many to many association:"
msgstr ""

#: index.docbook:497
msgid ""
      "<![CDATA[<array name=\"addresses\" \n"
      "        table=\"PersonAddress\" \n"
      "        cascade=\"persist\">\n"
      "    <key column=\"personId\"/>\n"
      "    <list-index column=\"sortOrder\"/>\n"
      "    <many-to-many column=\"addressId\" class=\"Address\"/>\n"
      "</array>]]>"
msgstr ""

#: index.docbook:499
msgid "A map from string indices to dates:"
msgstr ""

#: index.docbook:503
msgid ""
      "<![CDATA[<map name=\"holidays\" \n"
      "        table=\"holidays\" \n"
      "        schema=\"dbo\" \n"
      "        order-by=\"hol_name asc\">\n"
      "    <key column=\"id\"/>\n"
      "    <map-key column=\"hol_name\" type=\"string\"/>\n"
      "    <element column=\"hol_date\" type=\"date\"/>\n"
      "</map>]]>"
msgstr ""

#: index.docbook:505
msgid "A list of components (discussed in the next chapter):"
msgstr ""

#: index.docbook:509
msgid ""
      "<![CDATA[<list name=\"carComponents\" \n"
      "        table=\"CarComponents\">\n"
      "    <key column=\"carId\"/>\n"
      "    <list-index column=\"sortOrder\"/>\n"
      "    <composite-element class=\"CarComponent\">\n"
      "        <property name=\"price\"/>\n"
      "        <property name=\"type\"/>\n"
      "        <property name=\"serialNumber\" column=\"serialNum\"/>\n"
      "    </composite-element>\n"
      "</list>]]>"
msgstr ""

#: index.docbook:514
msgid "One-to-many associations"
msgstr ""

#: index.docbook:516
msgid "A <emphasis>one to many association</emphasis> links the tables of two classes via a foreign key, with no intervening collection table. This mapping loses certain semantics of normal Java collections:"
msgstr ""

#: index.docbook:524
msgid "An instance of the contained entity class may not belong to more than one instance of the collection"
msgstr ""

#: index.docbook:530
msgid "An instance of the contained entity class may not appear at more than one value of the collection index"
msgstr ""

#: index.docbook:537
msgid "An association from <literal>Product</literal> to <literal>Part</literal> requires existence of a foreign key column and possibly an index column to the <literal>Part</literal> table. A <literal>&lt;one-to-many&gt;</literal> tag indicates that this is a one to many association."
msgstr ""

#: index.docbook:550
msgid ""
      "<![CDATA[<one-to-many \n"
      "        class=\"ClassName\"\n"
      "        not-found=\"ignore|exception\"\n"
      "        entity-name=\"EntityName\"\n"
      "        node=\"element-name\"\n"
      "        embed-xml=\"true|false\"\n"
      "    />]]>"
msgstr ""

#: index.docbook:553
msgid "<literal>class</literal> (required): The name of the associated class."
msgstr ""

#: index.docbook:558
msgid "<literal>not-found</literal> (optional - defaults to <literal>exception</literal>): Specifies how cached identifiers that reference missing rows will be handled: <literal>ignore</literal> will treat a missing row as a null association."
msgstr ""

#: index.docbook:565
msgid "<literal>entity-name</literal> (optional): The entity name of the associated class, as an alternative to <literal>class</literal>."
msgstr ""

#: index.docbook:573
msgid "Notice that the <literal>&lt;one-to-many&gt;</literal> element does not need to declare any columns. Nor is it necessary to specify the <literal>table</literal> name anywhere."
msgstr ""

#: index.docbook:579
msgid "<emphasis>Very important note:</emphasis> If the foreign key column of a <literal>&lt;one-to-many&gt;</literal> association is declared <literal>NOT NULL</literal>, you must declare the <literal>&lt;key&gt;</literal> mapping <literal>not-null=\"true\"</literal> or <emphasis>use a bidirectional association</emphasis> with the collection mapping marked <literal>inverse=\"true\"</literal>. See the discussion of bidirectional associations later in this chapter."
msgstr ""

#: index.docbook:588
msgid "This example shows a map of <literal>Part</literal> entities by name (where <literal>partName</literal> is a persistent property of <literal>Part</literal>). Notice the use of a formula-based index."
msgstr ""

#: index.docbook:594
msgid ""
      "<![CDATA[<map name=\"parts\"\n"
      "        cascade=\"all\">\n"
      "    <key column=\"productId\" not-null=\"true\"/>\n"
      "    <map-key formula=\"partName\"/>\n"
      "    <one-to-many class=\"Part\"/>\n"
      "</map>]]>"
msgstr ""

#: index.docbook:600
msgid "Advanced collection mappings"
msgstr ""

#: index.docbook:603
msgid "Sorted collections"
msgstr ""

#: index.docbook:605
msgid "Hibernate supports collections implementing <literal>java.util.SortedMap</literal> and <literal>java.util.SortedSet</literal>. You must specify a comparator in the mapping file:"
msgstr ""

#: index.docbook:610
msgid ""
      "<![CDATA[<set name=\"aliases\" \n"
      "            table=\"person_aliases\" \n"
      "            sort=\"natural\">\n"
      "    <key column=\"person\"/>\n"
      "    <element column=\"name\" type=\"string\"/>\n"
      "</set>\n"
      "\n"
      "<map name=\"holidays\" sort=\"my.custom.HolidayComparator\">\n"
      "    <key column=\"year_id\"/>\n"
      "    <map-key column=\"hol_name\" type=\"string\"/>\n"
      "    <element column=\"hol_date\" type=\"date\"/>\n"
      "</map>]]>"
msgstr ""

#: index.docbook:612
msgid "Allowed values of the <literal>sort</literal> attribute are <literal>unsorted</literal>, <literal>natural</literal> and the name of a class implementing <literal>java.util.Comparator</literal>."
msgstr ""

#: index.docbook:618
msgid "Sorted collections actually behave like <literal>java.util.TreeSet</literal> or <literal>java.util.TreeMap</literal>."
msgstr ""

#: index.docbook:623
msgid "If you want the database itself to order the collection elements use the <literal>order-by</literal> attribute of <literal>set</literal>, <literal>bag</literal> or <literal>map</literal> mappings. This solution is only available under JDK 1.4 or higher (it is implemented using <literal>LinkedHashSet</literal> or <literal>LinkedHashMap</literal>). This performs the ordering in the SQL query, not in memory."
msgstr ""

#: index.docbook:632
msgid ""
      "<![CDATA[<set name=\"aliases\" table=\"person_aliases\" order-by=\"lower(name) asc\">\n"
      "    <key column=\"person\"/>\n"
      "    <element column=\"name\" type=\"string\"/>\n"
      "</set>\n"
      "\n"
      "<map name=\"holidays\" order-by=\"hol_date, hol_name\">\n"
      "    <key column=\"year_id\"/>\n"
      "    <map-key column=\"hol_name\" type=\"string\"/>\n"
      "    <element column=\"hol_date type=\"date\"/>\n"
      "</map>]]>"
msgstr ""

#: index.docbook:634
msgid "Note that the value of the <literal>order-by</literal> attribute is an SQL ordering, not a HQL ordering!"
msgstr ""

#: index.docbook:639
msgid "Associations may even be sorted by some arbitrary criteria at runtime using a collection <literal>filter()</literal>."
msgstr ""

#: index.docbook:644
msgid "<![CDATA[sortedUsers = s.createFilter( group.getUsers(), \"order by this.name\" ).list();]]>"
msgstr ""

#: index.docbook:649
msgid "Bidirectional associations"
msgstr ""

#: index.docbook:651
msgid "A <emphasis>bidirectional association</emphasis> allows navigation from both \"ends\" of the association. Two kinds of bidirectional association are supported:"
msgstr ""

#: index.docbook:658
msgid "one-to-many"
msgstr ""

#: index.docbook:660
msgid "set or bag valued at one end, single-valued at the other"
msgstr ""

#: index.docbook:666
msgid "many-to-many"
msgstr ""

#: index.docbook:668
msgid "set or bag valued at both ends"
msgstr ""

#: index.docbook:677
msgid "You may specify a bidirectional many-to-many association simply by mapping two many-to-many associations to the same database table and declaring one end as <emphasis>inverse</emphasis> (which one is your choice, but it can not be an indexed collection)."
msgstr ""

#: index.docbook:684
msgid "Here's an example of a bidirectional many-to-many association; each category can have many items and each item can be in many categories:"
msgstr ""

#: index.docbook:689
msgid ""
      "<![CDATA[<class name=\"Category\">\n"
      "    <id name=\"id\" column=\"CATEGORY_ID\"/>\n"
      "    ...\n"
      "    <bag name=\"items\" table=\"CATEGORY_ITEM\">\n"
      "        <key column=\"CATEGORY_ID\"/>\n"
      "        <many-to-many class=\"Item\" column=\"ITEM_ID\"/>\n"
      "    </bag>\n"
      "</class>\n"
      "\n"
      "<class name=\"Item\">\n"
      "    <id name=\"id\" column=\"ITEM_ID\"/>\n"
      "    ...\n"
      "\n"
      "    <!-- inverse end -->\n"
      "    <bag name=\"categories\" table=\"CATEGORY_ITEM\" inverse=\"true\">\n"
      "        <key column=\"ITEM_ID\"/>\n"
      "        <many-to-many class=\"Category\" column=\"CATEGORY_ID\"/>\n"
      "    </bag>\n"
      "</class>]]>"
msgstr ""

#: index.docbook:691
msgid "Changes made only to the inverse end of the association are <emphasis>not</emphasis> persisted. This means that Hibernate has two representations in memory for every bidirectional association, one link from A to B and another link from B to A. This is easier to understand if you think about the Java object model and how we create a many-to-many relationship in Java:"
msgstr ""

#: index.docbook:699
msgid ""
      "<![CDATA[\n"
      "category.getItems().add(item);          // The category now \"knows\" about the relationship\n"
      "item.getCategories().add(category);     // The item now \"knows\" about the relationship\n"
      "\n"
      "session.persist(item);                   // The relationship won't be saved!\n"
      "session.persist(category);               // The relationship will be saved]]>"
msgstr ""

#: index.docbook:701
msgid "The non-inverse side is used to save the in-memory representation to the database."
msgstr ""

#: index.docbook:705
msgid "You may define a bidirectional one-to-many association by mapping a one-to-many association to the same table column(s) as a many-to-one association and declaring the many-valued end <literal>inverse=\"true\"</literal>."
msgstr ""

#: index.docbook:711
msgid ""
      "<![CDATA[<class name=\"Parent\">\n"
      "    <id name=\"id\" column=\"parent_id\"/>\n"
      "    ....\n"
      "    <set name=\"children\" inverse=\"true\">\n"
      "        <key column=\"parent_id\"/>\n"
      "        <one-to-many class=\"Child\"/>\n"
      "    </set>\n"
      "</class>\n"
      "\n"
      "<class name=\"Child\">\n"
      "    <id name=\"id\" column=\"child_id\"/>\n"
      "    ....\n"
      "    <many-to-one name=\"parent\" \n"
      "        class=\"Parent\" \n"
      "        column=\"parent_id\"\n"
      "        not-null=\"true\"/>\n"
      "</class>]]>"
msgstr ""

#: index.docbook:713
msgid "Mapping one end of an association with <literal>inverse=\"true\"</literal> doesn't affect the operation of cascades, these are orthogonal concepts!"
msgstr ""

#: index.docbook:721
msgid "Bidirectional associations with indexed collections"
msgstr ""

#: index.docbook:722
msgid "A bidirectional association where one end is represented as a <literal>&lt;list&gt;</literal> or <literal>&lt;map&gt;</literal> requires special consideration. If there is a property of the child class which maps to the index column, no problem, we can continue using <literal>inverse=\"true\"</literal> on the collection mapping:"
msgstr ""

#: index.docbook:729
msgid ""
      "<![CDATA[<class name=\"Parent\">\n"
      "    <id name=\"id\" column=\"parent_id\"/>\n"
      "    ....\n"
      "    <map name=\"children\" inverse=\"true\">\n"
      "        <key column=\"parent_id\"/>\n"
      "        <map-key column=\"name\" \n"
      "            type=\"string\"/>\n"
      "        <one-to-many class=\"Child\"/>\n"
      "    </map>\n"
      "</class>\n"
      "\n"
      "<class name=\"Child\">\n"
      "    <id name=\"id\" column=\"child_id\"/>\n"
      "    ....\n"
      "    <property name=\"name\" \n"
      "        not-null=\"true\"/>\n"
      "    <many-to-one name=\"parent\" \n"
      "        class=\"Parent\" \n"
      "        column=\"parent_id\"\n"
      "        not-null=\"true\"/>\n"
      "</class>]]>"
msgstr ""

#: index.docbook:731
msgid "But, if there is no such property on the child class, we can't think of the association as truly bidirectional (there is information available at one end of the association that is not available at the other end). In this case, we can't map the collection <literal>inverse=\"true\"</literal>. Instead, we could use the following mapping:"
msgstr ""

#: index.docbook:738
msgid ""
      "<![CDATA[<class name=\"Parent\">\n"
      "    <id name=\"id\" column=\"parent_id\"/>\n"
      "    ....\n"
      "    <map name=\"children\">\n"
      "        <key column=\"parent_id\"\n"
      "            not-null=\"true\"/>\n"
      "        <map-key column=\"name\" \n"
      "            type=\"string\"/>\n"
      "        <one-to-many class=\"Child\"/>\n"
      "    </map>\n"
      "</class>\n"
      "\n"
      "<class name=\"Child\">\n"
      "    <id name=\"id\" column=\"child_id\"/>\n"
      "    ....\n"
      "    <many-to-one name=\"parent\" \n"
      "        class=\"Parent\" \n"
      "        column=\"parent_id\"\n"
      "        insert=\"false\"\n"
      "        update=\"false\"\n"
      "        not-null=\"true\"/>\n"
      "</class>]]>"
msgstr ""

#: index.docbook:740
msgid "Note that in this mapping, the collection-valued end of the association is responsible for updates to the foreign key. TODO: Does this really result in some unnecessary update statements?"
msgstr ""

#: index.docbook:748
msgid "Ternary associations"
msgstr ""

#: index.docbook:750
msgid "There are three possible approaches to mapping a ternary association. One is to use a <literal>Map</literal> with an association as its index:"
msgstr ""

#: index.docbook:755
msgid ""
      "<![CDATA[<map name=\"contracts\">\n"
      "    <key column=\"employer_id\" not-null=\"true\"/>\n"
      "    <map-key-many-to-many column=\"employee_id\" class=\"Employee\"/>\n"
      "    <one-to-many class=\"Contract\"/>\n"
      "</map>]]>"
msgstr ""

#: index.docbook:757
msgid ""
      "<![CDATA[<map name=\"connections\">\n"
      "    <key column=\"incoming_node_id\"/>\n"
      "    <map-key-many-to-many column=\"outgoing_node_id\" class=\"Node\"/>\n"
      "    <many-to-many column=\"connection_id\" class=\"Connection\"/>\n"
      "</map>]]>"
msgstr ""

#: index.docbook:759
msgid "A second approach is to simply remodel the association as an entity class. This is the approach we use most commonly."
msgstr ""

#: index.docbook:764
msgid "A final alternative is to use composite elements, which we will discuss later."
msgstr ""

#: index.docbook:771
msgid "Using an &lt;idbag&gt;"
msgstr ""

#: index.docbook:773
msgid "If you've fully embraced our view that composite keys are a bad thing and that entities should have synthetic identifiers (surrogate keys), then you might find it a bit odd that the many to many associations and collections of values that we've shown so far all map to tables with composite keys! Now, this point is quite arguable; a pure association table doesn't seem to benefit much from a surrogate key (though a collection of composite values <emphasis>might</emphasis>). Nevertheless, Hibernate provides a feature that allows you to map many to many associations and collections of values to a table with a surrogate key."
msgstr ""

#: index.docbook:784
msgid "The <literal>&lt;idbag&gt;</literal> element lets you map a <literal>List</literal> (or <literal>Collection</literal>) with bag semantics."
msgstr ""

#: index.docbook:789
msgid ""
      "<![CDATA[<idbag name=\"lovers\" table=\"LOVERS\">\n"
      "    <collection-id column=\"ID\" type=\"long\">\n"
      "        <generator class=\"sequence\"/>\n"
      "    </collection-id>\n"
      "    <key column=\"PERSON1\"/>\n"
      "    <many-to-many column=\"PERSON2\" class=\"Person\" fetch=\"join\"/>\n"
      "</idbag>]]>"
msgstr ""

#: index.docbook:791
msgid "As you can see, an <literal>&lt;idbag&gt;</literal> has a synthetic id generator, just like an entity class! A different surrogate key is assigned to each collection row. Hibernate does not provide any mechanism to discover the surrogate key value of a particular row, however."
msgstr ""

#: index.docbook:798
msgid "Note that the update performance of an <literal>&lt;idbag&gt;</literal> is <emphasis>much</emphasis> better than a regular <literal>&lt;bag&gt;</literal>! Hibernate can locate individual rows efficiently and update or delete them individually, just like a list, map or set."
msgstr ""

#: index.docbook:805
msgid "In the current implementation, the <literal>native</literal> identifier generation strategy is not supported for <literal>&lt;idbag&gt;</literal> collection identifiers."
msgstr ""

#: index.docbook:829
msgid "Collection examples"
msgstr ""

#: index.docbook:831
msgid "The previous sections are pretty confusing. So lets look at an example. This class:"
msgstr ""

#: index.docbook:836
msgid ""
      "<![CDATA[package eg;\n"
      "import java.util.Set;\n"
      "\n"
      "public class Parent {\n"
      "    private long id;\n"
      "    private Set children;\n"
      "\n"
      "    public long getId() { return id; }\n"
      "    private void setId(long id) { this.id=id; }\n"
      "\n"
      "    private Set getChildren() { return children; }\n"
      "    private void setChildren(Set children) { this.children=children; }\n"
      "\n"
      "    ....\n"
      "    ....\n"
      "}]]>"
msgstr ""

#: index.docbook:838
msgid "has a collection of <literal>Child</literal> instances. If each child has at most one parent, the most natural mapping is a one-to-many association:"
msgstr ""

#: index.docbook:844
msgid ""
      "<![CDATA[<hibernate-mapping>\n"
      "\n"
      "    <class name=\"Parent\">\n"
      "        <id name=\"id\">\n"
      "            <generator class=\"sequence\"/>\n"
      "        </id>\n"
      "        <set name=\"children\">\n"
      "            <key column=\"parent_id\"/>\n"
      "            <one-to-many class=\"Child\"/>\n"
      "        </set>\n"
      "    </class>\n"
      "\n"
      "    <class name=\"Child\">\n"
      "        <id name=\"id\">\n"
      "            <generator class=\"sequence\"/>\n"
      "        </id>\n"
      "        <property name=\"name\"/>\n"
      "    </class>\n"
      "\n"
      "</hibernate-mapping>]]>"
msgstr ""

#: index.docbook:846
msgid "This maps to the following table definitions:"
msgstr ""

#: index.docbook:850
msgid ""
      "<![CDATA[create table parent ( id bigint not null primary key )\n"
      "create table child ( id bigint not null primary key, name varchar(255), parent_id bigint )\n"
      "alter table child add constraint childfk0 (parent_id) references parent]]>"
msgstr ""

#: index.docbook:852
msgid "If the parent is <emphasis>required</emphasis>, use a bidirectional one-to-many association:"
msgstr ""

#: index.docbook:857
msgid ""
      "<![CDATA[<hibernate-mapping>\n"
      "\n"
      "    <class name=\"Parent\">\n"
      "        <id name=\"id\">\n"
      "            <generator class=\"sequence\"/>\n"
      "        </id>\n"
      "        <set name=\"children\" inverse=\"true\">\n"
      "            <key column=\"parent_id\"/>\n"
      "            <one-to-many class=\"Child\"/>\n"
      "        </set>\n"
      "    </class>\n"
      "\n"
      "    <class name=\"Child\">\n"
      "        <id name=\"id\">\n"
      "            <generator class=\"sequence\"/>\n"
      "        </id>\n"
      "        <property name=\"name\"/>\n"
      "        <many-to-one name=\"parent\" class=\"Parent\" column=\"parent_id\" not-null=\"true\"/>\n"
      "    </class>\n"
      "\n"
      "</hibernate-mapping>]]>"
msgstr ""

#: index.docbook:859
msgid "Notice the <literal>NOT NULL</literal> constraint:"
msgstr ""

#: index.docbook:863
msgid ""
      "<![CDATA[create table parent ( id bigint not null primary key )\n"
      "create table child ( id bigint not null\n"
      "                     primary key,\n"
      "                     name varchar(255),\n"
      "                     parent_id bigint not null )\n"
      "alter table child add constraint childfk0 (parent_id) references parent]]>"
msgstr ""

#: index.docbook:865
msgid "Alternatively, if you absolutely insist that this association should be unidirectional, you can declare the <literal>NOT NULL</literal> constraint on the <literal>&lt;key&gt;</literal> mapping:"
msgstr ""

#: index.docbook:871
msgid ""
      "<![CDATA[<hibernate-mapping>\n"
      "\n"
      "    <class name=\"Parent\">\n"
      "        <id name=\"id\">\n"
      "            <generator class=\"sequence\"/>\n"
      "        </id>\n"
      "        <set name=\"children\">\n"
      "            <key column=\"parent_id\" not-null=\"true\"/>\n"
      "            <one-to-many class=\"Child\"/>\n"
      "        </set>\n"
      "    </class>\n"
      "\n"
      "    <class name=\"Child\">\n"
      "        <id name=\"id\">\n"
      "            <generator class=\"sequence\"/>\n"
      "        </id>\n"
      "        <property name=\"name\"/>\n"
      "    </class>\n"
      "\n"
      "</hibernate-mapping>]]>"
msgstr ""

#: index.docbook:873
msgid "On the other hand, if a child might have multiple parents, a many-to-many association is appropriate:"
msgstr ""

#: index.docbook:878
msgid ""
      "<![CDATA[<hibernate-mapping>\n"
      "\n"
      "    <class name=\"Parent\">\n"
      "        <id name=\"id\">\n"
      "            <generator class=\"sequence\"/>\n"
      "        </id>\n"
      "        <set name=\"children\" table=\"childset\">\n"
      "            <key column=\"parent_id\"/>\n"
      "            <many-to-many class=\"Child\" column=\"child_id\"/>\n"
      "        </set>\n"
      "    </class>\n"
      "\n"
      "    <class name=\"Child\">\n"
      "        <id name=\"id\">\n"
      "            <generator class=\"sequence\"/>\n"
      "        </id>\n"
      "        <property name=\"name\"/>\n"
      "    </class>\n"
      "\n"
      "</hibernate-mapping>]]>"
msgstr ""

#: index.docbook:880
msgid "Table definitions:"
msgstr ""

#: index.docbook:884
msgid ""
      "<![CDATA[create table parent ( id bigint not null primary key )\n"
      "create table child ( id bigint not null primary key, name varchar(255) )\n"
      "create table childset ( parent_id bigint not null,\n"
      "                        child_id bigint not null,\n"
      "                        primary key ( parent_id, child_id ) )\n"
      "alter table childset add constraint childsetfk0 (parent_id) references parent\n"
      "alter table childset add constraint childsetfk1 (child_id) references child]]>"
msgstr ""

#: index.docbook:886
msgid "For more examples and a complete walk-through a parent/child relationship mapping, see <xref linkend=\"example-parentchild\"/>."
msgstr ""

#: index.docbook:891
msgid "Even more exotic association mappings are possible, we will catalog all possibilities in the next chapter."
msgstr ""

msgid "ROLES_OF_TRANSLATORS"
msgstr "<!--TRANS:ROLES_OF_TRANSLATORS-->"

msgid "CREDIT_FOR_TRANSLATORS"
msgstr "<!--TRANS:CREDIT_FOR_TRANSLATORS-->"

