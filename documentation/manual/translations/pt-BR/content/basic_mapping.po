#, fuzzy
msgid ""
msgstr ""
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Content-Type: text/plain; charset=utf-8\n"
#: index.docbook:5
msgid "Basic O/R Mapping"
msgstr ""

#: index.docbook:8
msgid "Mapping declaration"
msgstr ""

#: index.docbook:10
msgid "Object/relational mappings are usually defined in an XML document. The mapping document is designed to be readable and hand-editable. The mapping language is Java-centric, meaning that mappings are constructed around persistent class declarations, not table declarations."
msgstr ""

#: index.docbook:17
msgid "Note that, even though many Hibernate users choose to write the XML by hand, a number of tools exist to generate the mapping document, including XDoclet, Middlegen and AndroMDA."
msgstr ""

#: index.docbook:23
msgid "Lets kick off with an example mapping:"
msgstr ""

#: index.docbook:27
msgid ""
      "<![CDATA[<?xml version=\"1.0\"?>\n"
      "<!DOCTYPE hibernate-mapping PUBLIC\n"
      "      \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
      "          \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\">\n"
      "\n"
      "<hibernate-mapping package=\"eg\">\n"
      "\n"
      "        <class name=\"Cat\"\n"
      "            table=\"cats\"\n"
      "            discriminator-value=\"C\">\n"
      "\n"
      "                <id name=\"id\">\n"
      "                        <generator class=\"native\"/>\n"
      "                </id>\n"
      "\n"
      "                <discriminator column=\"subclass\"\n"
      "                     type=\"character\"/>\n"
      "\n"
      "                <property name=\"weight\"/>\n"
      "\n"
      "                <property name=\"birthdate\"\n"
      "                    type=\"date\"\n"
      "                    not-null=\"true\"\n"
      "                    update=\"false\"/>\n"
      "\n"
      "                <property name=\"color\"\n"
      "                    type=\"eg.types.ColorUserType\"\n"
      "                    not-null=\"true\"\n"
      "                    update=\"false\"/>\n"
      "\n"
      "                <property name=\"sex\"\n"
      "                    not-null=\"true\"\n"
      "                    update=\"false\"/>\n"
      "\n"
      "                <property name=\"litterId\"\n"
      "                    column=\"litterId\"\n"
      "                    update=\"false\"/>\n"
      "\n"
      "                <many-to-one name=\"mother\"\n"
      "                    column=\"mother_id\"\n"
      "                    update=\"false\"/>\n"
      "\n"
      "                <set name=\"kittens\"\n"
      "                    inverse=\"true\"\n"
      "                    order-by=\"litter_id\">\n"
      "                        <key column=\"mother_id\"/>\n"
      "                        <one-to-many class=\"Cat\"/>\n"
      "                </set>\n"
      "\n"
      "                <subclass name=\"DomesticCat\"\n"
      "                    discriminator-value=\"D\">\n"
      "\n"
      "                        <property name=\"name\"\n"
      "                            type=\"string\"/>\n"
      "\n"
      "                </subclass>\n"
      "\n"
      "        </class>\n"
      "\n"
      "        <class name=\"Dog\">\n"
      "                <!-- mapping for Dog could go here -->\n"
      "        </class>\n"
      "\n"
      "</hibernate-mapping>]]>"
msgstr ""

#: index.docbook:29
msgid "We will now discuss the content of the mapping document. We will only describe the document elements and attributes that are used by Hibernate at runtime. The mapping document also contains some extra optional attributes and elements that affect the database schemas exported by the schema export tool. (For example the <literal> not-null</literal> attribute.)"
msgstr ""

#: index.docbook:40
msgid "Doctype"
msgstr ""

#: index.docbook:42
msgid "All XML mappings should declare the doctype shown. The actual DTD may be found at the URL above, in the directory <literal>hibernate-x.x.x/src/org/hibernate </literal> or in <literal>hibernate3.jar</literal>. Hibernate will always look for the DTD in its classpath first. If you experience lookups of the DTD using an Internet connection, check your DTD declaration against the contents of your claspath."
msgstr ""

#: index.docbook:52
msgid "EntityResolver"
msgstr ""

#: index.docbook:53
msgid "As mentioned previously, Hibernate will first attempt to resolve DTDs in its classpath. The manner in which it does this is by registering a custom <literal>org.xml.sax.EntityResolver</literal> implementation with the SAXReader it uses to read in the xml files. This custom <literal>EntityResolver</literal> recognizes two different systemId namespaces."
msgstr ""

#: index.docbook:61
msgid "a <literal>hibernate namespace</literal> is recognized whenever the resolver encounteres a systemId starting with <literal>http://hibernate.sourceforge.net/</literal>; the resolver attempts to resolve these entities via the classlaoder which loaded the Hibernate classes."
msgstr ""

#: index.docbook:70
msgid "a <literal>user namespace</literal> is recognized whenever the resolver encounteres a systemId using a <literal>classpath://</literal> URL protocol; the resolver will attempt to resolve these entities via (1) the current thread context classloader and (2) the classloader which loaded the Hibernate classes."
msgstr ""

#: index.docbook:79
msgid "An example of utilizing user namespacing:"
msgstr ""

#: index.docbook:82
msgid ""
      "<![CDATA[<?xml version=\"1.0\"?>\n"
      "<!DOCTYPE hibernate-mapping PUBLIC\n"
      "        \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
      "        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\" [\n"
      "    <!ENTITY types SYSTEM \"classpath://your/domain/types.xml\">\n"
      "]>\n"
      "\n"
      "<hibernate-mapping package=\"your.domain\">\n"
      "    <class name=\"MyEntity\">\n"
      "        <id name=\"id\" type=\"my-custom-id-type\">\n"
      "            ...\n"
      "        </id>\n"
      "    <class>\n"
      "    &types;\n"
      "</hibernate-mapping>]]>"
msgstr ""

#: index.docbook:83
msgid "Where <literal>types.xml</literal> is a resource in the <literal>your.domain</literal> package and contains a custom <xref linkend=\"mapping-types-custom\"/>typedef."
msgstr ""

#: index.docbook:91
msgid "hibernate-mapping"
msgstr ""

#: index.docbook:93
msgid "This element has several optional attributes. The <literal>schema</literal> and <literal>catalog</literal> attributes specify that tables referred to in this mapping belong to the named schema and/or catalog. If specified, tablenames will be qualified by the given schema and catalog names. If missing, tablenames will be unqualified. The <literal>default-cascade</literal> attribute specifies what cascade style should be assumed for properties and collections which do not specify a <literal>cascade</literal> attribute. The <literal>auto-import</literal> attribute lets us use unqualified class names in the query language, by default."
msgstr ""

#: index.docbook:114
msgid ""
      "<![CDATA[<hibernate-mapping\n"
      "         schema=\"schemaName\"\n"
      "         catalog=\"catalogName\"\n"
      "         default-cascade=\"cascade_style\"\n"
      "         default-access=\"field|property|ClassName\"\n"
      "         default-lazy=\"true|false\"\n"
      "         auto-import=\"true|false\"\n"
      "         package=\"package.name\"\n"
      " />]]>"
msgstr ""

#: index.docbook:117
msgid "<literal>schema</literal> (optional): The name of a database schema."
msgstr ""

#: index.docbook:122
msgid "<literal>catalog</literal> (optional): The name of a database catalog."
msgstr ""

#: index.docbook:127
msgid "<literal>default-cascade</literal> (optional - defaults to <literal>none</literal>): A default cascade style."
msgstr ""

#: index.docbook:133
msgid "<literal>default-access</literal> (optional - defaults to <literal>property</literal>): The strategy Hibernate should use for accessing all properties. Can be a custom implementation of <literal>PropertyAccessor</literal>."
msgstr ""

#: index.docbook:140
msgid "<literal>default-lazy</literal> (optional - defaults to <literal>true</literal>): The default value for unspecifed <literal>lazy</literal> attributes of class and collection mappings."
msgstr ""

#: index.docbook:147
msgid "<literal>auto-import</literal> (optional - defaults to <literal>true</literal>): Specifies whether we can use unqualified class names (of classes in this mapping) in the query language."
msgstr ""

#: index.docbook:154
msgid "<literal>package</literal> (optional): Specifies a package prefix to assume for unqualified class names in the mapping document."
msgstr ""

#: index.docbook:162
msgid "If you have two persistent classes with the same (unqualified) name, you should set <literal>auto-import=\"false\"</literal>. Hibernate will throw an exception if you attempt to assign two classes to the same \"imported\" name."
msgstr ""

#: index.docbook:168
msgid "Note that the <literal>hibernate-mapping</literal> element allows you to nest several persistent <literal>&lt;class&gt;</literal> mappings, as shown above. It is however good practice (and expected by some tools) to map only a single persistent class (or a single class hierarchy) in one mapping file and name it after the persistent superclass, e.g. <literal>Cat.hbm.xml</literal>, <literal>Dog.hbm.xml</literal>, or if using inheritance, <literal>Animal.hbm.xml</literal>."
msgstr ""

#: index.docbook:181
msgid "<title>class</title>"
msgstr ""

#: index.docbook:183
msgid "You may declare a persistent class using the <literal>class</literal> element:"
msgstr ""

#: index.docbook:211
msgid ""
      "<![CDATA[<class\n"
      "        name=\"ClassName\"\n"
      "        table=\"tableName\"\n"
      "        discriminator-value=\"discriminator_value\"\n"
      "        mutable=\"true|false\"\n"
      "        schema=\"owner\"\n"
      "        catalog=\"catalog\"\n"
      "        proxy=\"ProxyInterface\"\n"
      "        dynamic-update=\"true|false\"\n"
      "        dynamic-insert=\"true|false\"\n"
      "        select-before-update=\"true|false\"\n"
      "        polymorphism=\"implicit|explicit\"\n"
      "        where=\"arbitrary sql where condition\"\n"
      "        persister=\"PersisterClass\"\n"
      "        batch-size=\"N\"\n"
      "        optimistic-lock=\"none|version|dirty|all\"\n"
      "        lazy=\"true|false\"\n"
      "        entity-name=\"EntityName\"\n"
      "        check=\"arbitrary sql check condition\"\n"
      "        rowid=\"rowid\"\n"
      "        subselect=\"SQL expression\"\n"
      "        abstract=\"true|false\"\n"
      "        node=\"element-name\"\n"
      "/>]]>"
msgstr ""

#: index.docbook:214
msgid "<literal>name</literal> (optional): The fully qualified Java class name of the persistent class (or interface). If this attribute is missing, it is assumed that the mapping is for a non-POJO entity."
msgstr ""

#: index.docbook:221
msgid "<literal>table</literal> (optional - defaults to the unqualified class name): The name of its database table."
msgstr ""

#: index.docbook:227
msgid "<literal>discriminator-value</literal> (optional - defaults to the class name): A value that distiguishes individual subclasses, used for polymorphic behaviour. Acceptable values include <literal>null</literal> and <literal>not null</literal>."
msgstr ""

#: index.docbook:234
msgid "<literal>mutable</literal> (optional, defaults to <literal>true</literal>): Specifies that instances of the class are (not) mutable."
msgstr ""

#: index.docbook:240, index.docbook:2204
msgid "<literal>schema</literal> (optional): Override the schema name specified by the root <literal>&lt;hibernate-mapping&gt;</literal> element."
msgstr ""

#: index.docbook:246, index.docbook:2210
msgid "<literal>catalog</literal> (optional): Override the catalog name specified by the root <literal>&lt;hibernate-mapping&gt;</literal> element."
msgstr ""

#: index.docbook:252
msgid "<literal>proxy</literal> (optional): Specifies an interface to use for lazy initializing proxies. You may specify the name of the class itself."
msgstr ""

#: index.docbook:258
msgid "<literal>dynamic-update</literal> (optional, defaults to <literal>false</literal>): Specifies that <literal>UPDATE</literal> SQL should be generated at runtime and contain only those columns whose values have changed."
msgstr ""

#: index.docbook:265
msgid "<literal>dynamic-insert</literal> (optional, defaults to <literal>false</literal>): Specifies that <literal>INSERT</literal> SQL should be generated at runtime and contain only the columns whose values are not null."
msgstr ""

#: index.docbook:272
msgid "<literal>select-before-update</literal> (optional, defaults to <literal>false</literal>): Specifies that Hibernate should <emphasis>never</emphasis> perform an SQL <literal>UPDATE</literal> unless it is certain that an object is actually modified. In certain cases (actually, only when a transient object has been associated with a new session using <literal>update()</literal>), this means that Hibernate will perform an extra SQL <literal>SELECT</literal> to determine if an <literal>UPDATE</literal> is actually required."
msgstr ""

#: index.docbook:282
msgid "<literal>polymorphism</literal> (optional, defaults to <literal>implicit</literal>): Determines whether implicit or explicit query polymorphism is used."
msgstr ""

#: index.docbook:288
msgid "<literal>where</literal> (optional) specify an arbitrary SQL <literal>WHERE</literal> condition to be used when retrieving objects of this class"
msgstr ""

#: index.docbook:294
msgid "<literal>persister</literal> (optional): Specifies a custom <literal>ClassPersister</literal>."
msgstr ""

#: index.docbook:299
msgid "<literal>batch-size</literal> (optional, defaults to <literal>1</literal>) specify a \"batch size\" for fetching instances of this class by identifier."
msgstr ""

#: index.docbook:305
msgid "<literal>optimistic-lock</literal> (optional, defaults to <literal>version</literal>): Determines the optimistic locking strategy."
msgstr ""

#: index.docbook:311
msgid "<literal>lazy</literal> (optional): Lazy fetching may be completely disabled by setting <literal>lazy=\"false\"</literal>."
msgstr ""

#: index.docbook:317
msgid "<literal>entity-name</literal> (optional, defaults to the class name): Hibernate3 allows a class to be mapped multiple times (to different tables, potentially), and allows entity mappings that are represented by Maps or XML at the Java level. In these cases, you should provide an explicit arbitrary name for the entity. See <xref linkend=\"persistent-classes-dynamicmodels\"/> and <xref linkend=\"xml\"/> for more information."
msgstr ""

#: index.docbook:327
msgid "<literal>check</literal> (optional): A SQL expression used to generate a multi-row <emphasis>check</emphasis> constraint for automatic schema generation."
msgstr ""

#: index.docbook:333
msgid "<literal>rowid</literal> (optional): Hibernate can use so called ROWIDs on databases which support. E.g. on Oracle, Hibernate can use the <literal>rowid</literal> extra column for fast updates if you set this option to <literal>rowid</literal>. A ROWID is an implementation detail and represents the physical location of a stored tuple."
msgstr ""

#: index.docbook:341
msgid "<literal>subselect</literal> (optional): Maps an immutable and read-only entity to a database subselect. Useful if you want to have a view instead of a base table, but don't. See below for more information."
msgstr ""

#: index.docbook:348
msgid "<literal>abstract</literal> (optional): Used to mark abstract superclasses in <literal>&lt;union-subclass&gt;</literal> hierarchies."
msgstr ""

#: index.docbook:356
msgid "It is perfectly acceptable for the named persistent class to be an interface. You would then declare implementing classes of that interface using the <literal>&lt;subclass&gt;</literal> element. You may persist any <emphasis>static</emphasis> inner class. You should specify the class name using the standard form ie. <literal>eg.Foo$Bar</literal>."
msgstr ""

#: index.docbook:363
msgid "Immutable classes, <literal>mutable=\"false\"</literal>, may not be updated or deleted by the application. This allows Hibernate to make some minor performance optimizations."
msgstr ""

#: index.docbook:368
msgid "The optional <literal>proxy</literal> attribute enables lazy initialization of persistent instances of the class. Hibernate will initially return CGLIB proxies which implement the named interface. The actual persistent object will be loaded when a method of the proxy is invoked. See \"Initializing collections and proxies\" below."
msgstr ""

#: index.docbook:375
msgid "<emphasis>Implicit</emphasis> polymorphism means that instances of the class will be returned by a query that names any superclass or implemented interface or the class and that instances of any subclass of the class will be returned by a query that names the class itself. <emphasis>Explicit</emphasis> polymorphism means that class instances will be returned only by queries that explicitly name that class and that queries that name the class will return only instances of subclasses mapped inside this <literal>&lt;class&gt;</literal> declaration as a <literal>&lt;subclass&gt;</literal> or <literal>&lt;joined-subclass&gt;</literal>. For most purposes the default, <literal>polymorphism=\"implicit\"</literal>, is appropriate. Explicit polymorphism is useful when two different classes are mapped to the same table (this allows a \"lightweight\" class that contains a subset of the table columns)."
msgstr ""

#: index.docbook:387
msgid "The <literal>persister</literal> attribute lets you customize the persistence strategy used for the class. You may, for example, specify your own subclass of <literal>org.hibernate.persister.EntityPersister</literal> or you might even provide a completely new implementation of the interface <literal>org.hibernate.persister.ClassPersister</literal> that implements persistence via, for example, stored procedure calls, serialization to flat files or LDAP. See <literal>org.hibernate.test.CustomPersister</literal> for a simple example (of \"persistence\" to a <literal>Hashtable</literal>)."
msgstr ""

#: index.docbook:398
msgid "Note that the <literal>dynamic-update</literal> and <literal>dynamic-insert</literal> settings are not inherited by subclasses and so may also be specified on the <literal>&lt;subclass&gt;</literal> or <literal>&lt;joined-subclass&gt;</literal> elements. These settings may increase performance in some cases, but might actually decrease performance in others. Use judiciously."
msgstr ""

#: index.docbook:406
msgid "Use of <literal>select-before-update</literal> will usually decrease performance. It is very useful to prevent a database update trigger being called unnecessarily if you reattach a graph of detached instances to a <literal>Session</literal>."
msgstr ""

#: index.docbook:412
msgid "If you enable <literal>dynamic-update</literal>, you will have a choice of optimistic locking strategies:"
msgstr ""

#: index.docbook:418
msgid "<literal>version</literal> check the version/timestamp columns"
msgstr ""

#: index.docbook:423
msgid "<literal>all</literal> check all columns"
msgstr ""

#: index.docbook:428
msgid "<literal>dirty</literal> check the changed columns, allowing some concurrent updates"
msgstr ""

#: index.docbook:433
msgid "<literal>none</literal> do not use optimistic locking"
msgstr ""

#: index.docbook:438
msgid "We <emphasis>very</emphasis> strongly recommend that you use version/timestamp columns for optimistic locking with Hibernate. This is the optimal strategy with respect to performance and is the only strategy that correctly handles modifications made to detached instances (ie. when <literal>Session.merge()</literal> is used)."
msgstr ""

#: index.docbook:445
msgid "There is no difference between a view and a base table for a Hibernate mapping, as expected this is transparent at the database level (note that some DBMS don't support views properly, especially with updates). Sometimes you want to use a view, but can't create one in the database (ie. with a legacy schema). In this case, you can map an immutable and read-only entity to a given SQL subselect expression:"
msgstr ""

#: index.docbook:453
msgid ""
      "<![CDATA[<class name=\"Summary\">\n"
      "    <subselect>\n"
      "        select item.name, max(bid.amount), count(*)\n"
      "        from item\n"
      "        join bid on bid.item_id = item.id\n"
      "        group by item.name\n"
      "    </subselect>\n"
      "    <synchronize table=\"item\"/>\n"
      "    <synchronize table=\"bid\"/>\n"
      "    <id name=\"name\"/>\n"
      "    ...\n"
      "</class>]]>"
msgstr ""

#: index.docbook:455
msgid "Declare the tables to synchronize this entity with, ensuring that auto-flush happens correctly, and that queries against the derived entity do not return stale data. The <literal>&lt;subselect&gt;</literal> is available as both as an attribute and a nested mapping element."
msgstr ""

#: index.docbook:465
msgid "<title>id</title>"
msgstr ""

#: index.docbook:467
msgid "Mapped classes <emphasis>must</emphasis> declare the primary key column of the database table. Most classes will also have a JavaBeans-style property holding the unique identifier of an instance. The <literal>&lt;id&gt;</literal> element defines the mapping from that property to the primary key column."
msgstr ""

#: index.docbook:482
msgid ""
      "<![CDATA[<id\n"
      "        name=\"propertyName\"\n"
      "        type=\"typename\"\n"
      "        column=\"column_name\"\n"
      "        unsaved-value=\"null|any|none|undefined|id_value\"\n"
      "        access=\"field|property|ClassName\">\n"
      "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
      "\n"
      "        <generator class=\"generatorClass\"/>\n"
      "</id>]]>"
msgstr ""

#: index.docbook:485
msgid "<literal>name</literal> (optional): The name of the identifier property."
msgstr ""

#: index.docbook:490
msgid "<literal>type</literal> (optional): A name that indicates the Hibernate type."
msgstr ""

#: index.docbook:495
msgid "<literal>column</literal> (optional - defaults to the property name): The name of the primary key column."
msgstr ""

#: index.docbook:501
msgid "<literal>unsaved-value</literal> (optional - defaults to a \"sensible\" value): An identifier property value that indicates that an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session."
msgstr ""

#: index.docbook:509, index.docbook:1017, index.docbook:1156, index.docbook:1238, index.docbook:1345, index.docbook:1534, index.docbook:1708, index.docbook:1878, index.docbook:2457
msgid "<literal>access</literal> (optional - defaults to <literal>property</literal>): The strategy Hibernate should use for accessing the property value."
msgstr ""

#: index.docbook:517
msgid "If the <literal>name</literal> attribute is missing, it is assumed that the class has no identifier property."
msgstr ""

#: index.docbook:522
msgid "The <literal>unsaved-value</literal> attribute is almost never needed in Hibernate3."
msgstr ""

#: index.docbook:526
msgid "There is an alternative <literal>&lt;composite-id&gt;</literal> declaration to allow access to legacy data with composite keys. We strongly discourage its use for anything else."
msgstr ""

#: index.docbook:532
msgid "Generator"
msgstr ""

#: index.docbook:534
msgid "The optional <literal>&lt;generator&gt;</literal> child element names a Java class used to generate unique identifiers for instances of the persistent class. If any parameters are required to configure or initialize the generator instance, they are passed using the <literal>&lt;param&gt;</literal> element."
msgstr ""

#: index.docbook:541
msgid ""
      "<![CDATA[<id name=\"id\" type=\"long\" column=\"cat_id\">\n"
      "        <generator class=\"org.hibernate.id.TableHiLoGenerator\">\n"
      "                <param name=\"table\">uid_table</param>\n"
      "                <param name=\"column\">next_hi_value_column</param>\n"
      "        </generator>\n"
      "</id>]]>"
msgstr ""

#: index.docbook:543
msgid "All generators implement the interface <literal>org.hibernate.id.IdentifierGenerator</literal>. This is a very simple interface; some applications may choose to provide their own specialized implementations. However, Hibernate provides a range of built-in implementations. There are shortcut names for the built-in generators:"
msgstr ""

#: index.docbook:551
msgid "increment"
msgstr ""

#: index.docbook:553
msgid "generates identifiers of type <literal>long</literal>, <literal>short</literal> or <literal>int</literal> that are unique only when no other process is inserting data into the same table. <emphasis>Do not use in a cluster.</emphasis>"
msgstr ""

#: index.docbook:562
msgid "identity"
msgstr ""

#: index.docbook:564
msgid "supports identity columns in DB2, MySQL, MS SQL Server, Sybase and HypersonicSQL. The returned identifier is of type <literal>long</literal>, <literal>short</literal> or <literal>int</literal>."
msgstr ""

#: index.docbook:572
msgid "sequence"
msgstr ""

#: index.docbook:574
msgid "uses a sequence in DB2, PostgreSQL, Oracle, SAP DB, McKoi or a generator in Interbase. The returned identifier is of type <literal>long</literal>, <literal>short</literal> or <literal>int</literal>"
msgstr ""

#: index.docbook:582
msgid "hilo"
msgstr ""

#: index.docbook:584
msgid "uses a hi/lo algorithm to efficiently generate identifiers of type <literal>long</literal>, <literal>short</literal> or <literal>int</literal>, given a table and column (by default <literal>hibernate_unique_key</literal> and <literal>next_hi</literal> respectively) as a source of hi values. The hi/lo algorithm generates identifiers that are unique only for a particular database."
msgstr ""

#: index.docbook:594
msgid "seqhilo"
msgstr ""

#: index.docbook:596
msgid "uses a hi/lo algorithm to efficiently generate identifiers of type <literal>long</literal>, <literal>short</literal> or <literal>int</literal>, given a named database sequence."
msgstr ""

#: index.docbook:604
msgid "uuid"
msgstr ""

#: index.docbook:606
msgid "uses a 128-bit UUID algorithm to generate identifiers of type string, unique within a network (the IP address is used). The UUID is encoded as a string of hexadecimal digits of length 32."
msgstr ""

#: index.docbook:614
msgid "guid"
msgstr ""

#: index.docbook:616
msgid "uses a database-generated GUID string on MS SQL Server and MySQL."
msgstr ""

#: index.docbook:622
msgid "native"
msgstr ""

#: index.docbook:624
msgid "picks <literal>identity</literal>, <literal>sequence</literal> or <literal>hilo</literal> depending upon the capabilities of the underlying database."
msgstr ""

#: index.docbook:632
msgid "assigned"
msgstr ""

#: index.docbook:634
msgid "lets the application to assign an identifier to the object before <literal>save()</literal> is called. This is the default strategy if no <literal>&lt;generator&gt;</literal> element is specified."
msgstr ""

#: index.docbook:642
msgid "select"
msgstr ""

#: index.docbook:644
msgid "retrieves a primary key assigned by a database trigger by selecting the row by some unique key and retrieving the primary key value."
msgstr ""

#: index.docbook:651
msgid "foreign"
msgstr ""

#: index.docbook:653
msgid "uses the identifier of another associated object. Usually used in conjunction with a <literal>&lt;one-to-one&gt;</literal> primary key association."
msgstr ""

#: index.docbook:660
msgid "sequence-identity"
msgstr ""

#: index.docbook:662
msgid "a specialized sequence generation strategy which utilizes a database sequence for the actual value generation, but combines this with JDBC3 getGeneratedKeys to actually return the generated identifier value as part of the insert statement execution. This strategy is only known to be supported on Oracle 10g drivers targetted for JDK 1.4. Note comments on these insert statements are disabled due to a bug in the Oracle drivers."
msgstr ""

#: index.docbook:679
msgid "Hi/lo algorithm"
msgstr ""

#: index.docbook:680
msgid "The <literal>hilo</literal> and <literal>seqhilo</literal> generators provide two alternate implementations of the hi/lo algorithm, a favorite approach to identifier generation. The first implementation requires a \"special\" database table to hold the next available \"hi\" value. The second uses an Oracle-style sequence (where supported)."
msgstr ""

#: index.docbook:687
msgid ""
      "<![CDATA[<id name=\"id\" type=\"long\" column=\"cat_id\">\n"
      "        <generator class=\"hilo\">\n"
      "                <param name=\"table\">hi_value</param>\n"
      "                <param name=\"column\">next_value</param>\n"
      "                <param name=\"max_lo\">100</param>\n"
      "        </generator>\n"
      "</id>]]>"
msgstr ""

#: index.docbook:689
msgid ""
      "<![CDATA[<id name=\"id\" type=\"long\" column=\"cat_id\">\n"
      "        <generator class=\"seqhilo\">\n"
      "                <param name=\"sequence\">hi_value</param>\n"
      "                <param name=\"max_lo\">100</param>\n"
      "        </generator>\n"
      "</id>]]>"
msgstr ""

#: index.docbook:691
msgid "Unfortunately, you can't use <literal>hilo</literal> when supplying your own <literal>Connection</literal> to Hibernate. When Hibernate is using an application server datasource to obtain connections enlisted with JTA, you must properly configure the <literal>hibernate.transaction.manager_lookup_class</literal>."
msgstr ""

#: index.docbook:700
msgid "UUID algorithm"
msgstr ""

#: index.docbook:701
msgid "The UUID contains: IP address, startup time of the JVM (accurate to a quarter second), system time and a counter value (unique within the JVM). It's not possible to obtain a MAC address or memory address from Java code, so this is the best we can do without using JNI."
msgstr ""

#: index.docbook:710
msgid "Identity columns and sequences"
msgstr ""

#: index.docbook:711
msgid "For databases which support identity columns (DB2, MySQL, Sybase, MS SQL), you may use <literal>identity</literal> key generation. For databases that support sequences (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) you may use <literal>sequence</literal> style key generation. Both these strategies require two SQL queries to insert a new object."
msgstr ""

#: index.docbook:719
msgid ""
      "<![CDATA[<id name=\"id\" type=\"long\" column=\"person_id\">\n"
      "        <generator class=\"sequence\">\n"
      "                <param name=\"sequence\">person_id_sequence</param>\n"
      "        </generator>\n"
      "</id>]]>"
msgstr ""

#: index.docbook:721
msgid ""
      "<![CDATA[<id name=\"id\" type=\"long\" column=\"person_id\" unsaved-value=\"0\">\n"
      "        <generator class=\"identity\"/>\n"
      "</id>]]>"
msgstr ""

#: index.docbook:723
msgid "For cross-platform development, the <literal>native</literal> strategy will choose from the <literal>identity</literal>, <literal>sequence</literal> and <literal>hilo</literal> strategies, dependant upon the capabilities of the underlying database."
msgstr ""

#: index.docbook:732
msgid "Assigned identifiers"
msgstr ""

#: index.docbook:733
msgid "If you want the application to assign identifiers (as opposed to having Hibernate generate them), you may use the <literal>assigned</literal> generator. This special generator will use the identifier value already assigned to the object's identifier property. This generator is used when the primary key is a natural key instead of a surrogate key. This is the default behavior if you do no specify a <literal>&lt;generator&gt;</literal> element."
msgstr ""

#: index.docbook:742
msgid "Choosing the <literal>assigned</literal> generator makes Hibernate use <literal>unsaved-value=\"undefined\"</literal>, forcing Hibernate to go to the database to determine if an instance is transient or detached, unless there is a version or timestamp property, or you define <literal>Interceptor.isUnsaved()</literal>."
msgstr ""

#: index.docbook:752
msgid "Primary keys assigned by triggers"
msgstr ""

#: index.docbook:753
msgid "For legacy schemas only (Hibernate does not generate DDL with triggers)."
msgstr ""

#: index.docbook:757
msgid ""
      "<![CDATA[<id name=\"id\" type=\"long\" column=\"person_id\">\n"
      "        <generator class=\"select\">\n"
      "                <param name=\"key\">socialSecurityNumber</param>\n"
      "        </generator>\n"
      "</id>]]>"
msgstr ""

#: index.docbook:759
msgid "In the above example, there is a unique valued property named <literal>socialSecurityNumber</literal> defined by the class, as a natural key, and a surrogate key named <literal>person_id</literal> whose value is generated by a trigger."
msgstr ""

#: index.docbook:771
msgid "Enhanced identifier generators"
msgstr ""

#: index.docbook:773
msgid "Starting with release 3.2.3, there are 2 new generators which represent a re-thinking of 2 different aspects of identifier generation. The first aspect is database portability; the second is optimization (not having to query the database for every request for a new identifier value). These two new generators are intended to take the place of some of the named generators described above (starting in 3.3.x); however, they are included in the current releases and can be referenced by FQN."
msgstr ""

#: index.docbook:781
msgid "The first of these new generators is <literal>org.hibernate.id.enhanced.SequenceStyleGenerator</literal> which is intended firstly as a replacement for the <literal>sequence</literal> generator and secondly as a better portability generator than <literal>native</literal> (because <literal>native</literal> (generally) chooses between <literal>identity</literal> and <literal>sequence</literal> which have largely different semantics which can cause subtle isssues in applications eyeing portability). <literal>org.hibernate.id.enhanced.SequenceStyleGenerator</literal> however achieves portability in a different manner. It chooses between using a table or a sequence in the database to store its incrementing values depending on the capabilities of the dialect being used. The difference between this and <literal>native</literal> is that table-based and sequence-based storage have the same exact semantic (in fact sequences are exactly what Hibernate tries to emmulate with its table-based generators). This generator has a number of configuration parameters:"
msgstr ""

#: index.docbook:795
msgid "<literal>sequence_name</literal> (optional, defaults to <literal>hibernate_sequence</literal>): The name of the sequence (or table) to be used."
msgstr ""

#: index.docbook:801
msgid "<literal>initial_value</literal> (optional, defaults to <literal>1</literal>): The initial value to be retrieved from the sequence/table. In sequence creation terms, this is analogous to the clause typical named \"STARTS WITH\"."
msgstr ""

#: index.docbook:808
msgid "<literal>increment_size</literal> (optional, defaults to <literal>1</literal>): The value by which subsequent calls to the sequence/table should differ. In sequence creation terms, this is analogous to the clause typical named \"INCREMENT BY\"."
msgstr ""

#: index.docbook:815
msgid "<literal>force_table_use</literal> (optional, defaults to <literal>false</literal>): Should we force the use of a table as the backing structure even though the dialect might support sequence?"
msgstr ""

#: index.docbook:822
msgid "<literal>value_column</literal> (optional, defaults to <literal>next_val</literal>): Only relevant for table structures! The name of the column on the table which is used to hold the value."
msgstr ""

#: index.docbook:829
msgid "<literal>optimizer</literal> (optional, defaults to <literal>none</literal>): See"
msgstr ""

#: index.docbook:836
msgid "The second of these new generators is <literal>org.hibernate.id.enhanced.TableGenerator</literal> which is intended firstly as a replacement for the <literal>table</literal> generator (although it actually functions much more like <literal>org.hibernate.id.MultipleHiLoPerTableGenerator</literal>) and secondly as a re-implementation of <literal>org.hibernate.id.MultipleHiLoPerTableGenerator</literal> utilizing the notion of pluggable optimiziers. Essentially this generator defines a table capable of holding a number of different increment values simultaneously by using multiple distinctly keyed rows. This generator has a number of configuration parameters:"
msgstr ""

#: index.docbook:846
msgid "<literal>table_name</literal> (optional, defaults to <literal>hibernate_sequences</literal>): The name of the table to be used."
msgstr ""

#: index.docbook:852
msgid "<literal>value_column_name</literal> (optional, defaults to <literal>next_val</literal>): The name of the column on the table which is used to hold the value."
msgstr ""

#: index.docbook:858
msgid "<literal>segment_column_name</literal> (optional, defaults to <literal>sequence_name</literal>): The name of the column on the table which is used to hold the \"segement key\". This is the value which distinctly identifies which increment value to use."
msgstr ""

#: index.docbook:865
msgid "<literal>segment_value</literal> (optional, defaults to <literal>default</literal>): The \"segment key\" value for the segment from which we want to pull increment values for this generator."
msgstr ""

#: index.docbook:872
msgid "<literal>segment_value_length</literal> (optional, defaults to <literal>255</literal>): Used for schema generation; the column size to create this segment key column."
msgstr ""

#: index.docbook:878
msgid "<literal>initial_value</literal> (optional, defaults to <literal>1</literal>): The initial value to be retrieved from the table."
msgstr ""

#: index.docbook:884
msgid "<literal>increment_size</literal> (optional, defaults to <literal>1</literal>): The value by which subsequent calls to the table should differ."
msgstr ""

#: index.docbook:890
msgid "<literal>optimizer</literal> (optional, defaults to <literal></literal>): See"
msgstr ""

#: index.docbook:900
msgid "Identifier generator optimization"
msgstr ""

#: index.docbook:901
msgid "For identifier generators which store values in the database, it is inefficient for them to hit the database on each and every call to generate a new identifier value. Instead, you'd ideally want to group a bunch of them in memory and only hit the database when you have exhausted your in-memory value group. This is the role of the pluggable optimizers. Currently only the two enhanced generators (<xref linkend=\"mapping-declaration-id-enhanced\"/> support this notion."
msgstr ""

#: index.docbook:909
msgid "<literal>none</literal> (generally this is the default if no optimizer was specified): This says to not perform any optimizations, and hit the database each and every request."
msgstr ""

#: index.docbook:915
msgid "<literal>hilo</literal>: applies a hi/lo algorithm around the database retrieved values. The values from the database for this optimizer are expected to be sequential. The values retrieved from the database structure for this optimizer indicates the \"group number\"; the <literal>increment_size</literal> is multiplied by that value in memory to define a group \"hi value\"."
msgstr ""

#: index.docbook:924
msgid "<literal>pooled</literal>: like was discussed for <literal>hilo</literal>, this optimizers attempts to minimize the number of hits to the database. Here, however, we simply store the starting value for the \"next group\" into the database structure rather than a sequential value in combination with an in-memory grouping algorithm. <literal>increment_size</literal> here refers to the values coming from the database."
msgstr ""

#: index.docbook:937
msgid "composite-id"
msgstr ""

#: index.docbook:939
msgid ""
      "<![CDATA[<composite-id\n"
      "        name=\"propertyName\"\n"
      "        class=\"ClassName\"\n"
      "        mapped=\"true|false\"\n"
      "        access=\"field|property|ClassName\">\n"
      "        node=\"element-name|.\"\n"
      "\n"
      "        <key-property name=\"propertyName\" type=\"typename\" column=\"column_name\"/>\n"
      "        <key-many-to-one name=\"propertyName class=\"ClassName\" column=\"column_name\"/>\n"
      "        ......\n"
      "</composite-id>]]>"
msgstr ""

#: index.docbook:941
msgid "For a table with a composite key, you may map multiple properties of the class as identifier properties. The <literal>&lt;composite-id&gt;</literal> element accepts <literal>&lt;key-property&gt;</literal> property mappings and <literal>&lt;key-many-to-one&gt;</literal> mappings as child elements."
msgstr ""

#: index.docbook:948
msgid ""
      "<![CDATA[<composite-id>\n"
      "        <key-property name=\"medicareNumber\"/>\n"
      "        <key-property name=\"dependent\"/>\n"
      "</composite-id>]]>"
msgstr ""

#: index.docbook:950
msgid "Your persistent class <emphasis>must</emphasis> override <literal>equals()</literal> and <literal>hashCode()</literal> to implement composite identifier equality. It must also implements <literal>Serializable</literal>."
msgstr ""

#: index.docbook:956
msgid "Unfortunately, this approach to composite identifiers means that a persistent object is its own identifier. There is no convenient \"handle\" other than the object itself. You must instantiate an instance of the persistent class itself and populate its identifier properties before you can <literal>load()</literal> the persistent state associated with a composite key. We call this approach an <emphasis>embedded</emphasis> composite identifier, and discourage it for serious applications."
msgstr ""

#: index.docbook:965
msgid "A second approach is what we call a <emphasis>mapped</emphasis> composite identifier, where the identifier properties named inside the <literal>&lt;composite-id&gt;</literal> element are duplicated on both the persistent class and a separate identifier class."
msgstr ""

#: index.docbook:971
msgid ""
      "<![CDATA[<composite-id class=\"MedicareId\" mapped=\"true\">\n"
      "        <key-property name=\"medicareNumber\"/>\n"
      "        <key-property name=\"dependent\"/>\n"
      "</composite-id>]]>"
msgstr ""

#: index.docbook:973
msgid "In this example, both the composite identifier class, <literal>MedicareId</literal>, and the entity class itself have properties named <literal>medicareNumber</literal> and <literal>dependent</literal>. The identifier class must override <literal>equals()</literal> and <literal>hashCode()</literal> and implement. <literal>Serializable</literal>. The disadvantage of this approach is quite obvious&mdash;code duplication."
msgstr ""

#: index.docbook:982
msgid "The following attributes are used to specify a mapped composite identifier:"
msgstr ""

#: index.docbook:988
msgid "<literal>mapped</literal> (optional, defaults to <literal>false</literal>): indicates that a mapped composite identifier is used, and that the contained property mappings refer to both the entity class and the composite identifier class."
msgstr ""

#: index.docbook:996
msgid "<literal>class</literal> (optional, but required for a mapped composite identifier): The class used as a composite identifier."
msgstr ""

#: index.docbook:1003
msgid "We will describe a third, even more convenient approach where the composite identifier is implemented as a component class in <xref linkend=\"components-compositeid\"/>. The attributes described below apply only to this alternative approach:"
msgstr ""

#: index.docbook:1011
msgid "<literal>name</literal> (optional, required for this approach): A property of component type that holds the composite identifier (see chapter 9)."
msgstr ""

#: index.docbook:1023
msgid "<literal>class</literal> (optional - defaults to the property type determined by reflection): The component class used as a composite identifier (see next section)."
msgstr ""

#: index.docbook:1030
msgid "This third approach, an <emphasis>identifier component</emphasis> is the one we recommend for almost all applications."
msgstr ""

#: index.docbook:1038
msgid "discriminator"
msgstr ""

#: index.docbook:1040
msgid "The <literal>&lt;discriminator&gt;</literal> element is required for polymorphic persistence using the table-per-class-hierarchy mapping strategy and declares a discriminator column of the table. The discriminator column contains marker values that tell the persistence layer what subclass to instantiate for a particular row. A restricted set of types may be used: <literal>string</literal>, <literal>character</literal>, <literal>integer</literal>, <literal>byte</literal>, <literal>short</literal>, <literal>boolean</literal>, <literal>yes_no</literal>, <literal>true_false</literal>."
msgstr ""

#: index.docbook:1058
msgid ""
      "<![CDATA[<discriminator\n"
      "        column=\"discriminator_column\"\n"
      "        type=\"discriminator_type\"\n"
      "        force=\"true|false\"\n"
      "        insert=\"true|false\"\n"
      "        formula=\"arbitrary sql expression\"\n"
      "/>]]>"
msgstr ""

#: index.docbook:1061
msgid "<literal>column</literal> (optional - defaults to <literal>class</literal>) the name of the discriminator column."
msgstr ""

#: index.docbook:1067
msgid "<literal>type</literal> (optional - defaults to <literal>string</literal>) a name that indicates the Hibernate type"
msgstr ""

#: index.docbook:1073
msgid "<literal>force</literal> (optional - defaults to <literal>false</literal>) \"force\" Hibernate to specify allowed discriminator values even when retrieving all instances of the root class."
msgstr ""

#: index.docbook:1080
msgid "<literal>insert</literal> (optional - defaults to <literal>true</literal>) set this to <literal>false</literal> if your discriminator column is also part of a mapped composite identifier. (Tells Hibernate to not include the column in SQL <literal>INSERT</literal>s.)"
msgstr ""

#: index.docbook:1088
msgid "<literal>formula</literal> (optional) an arbitrary SQL expression that is executed when a type has to be evaluated. Allows content-based discrimination."
msgstr ""

#: index.docbook:1096
msgid "Actual values of the discriminator column are specified by the <literal>discriminator-value</literal> attribute of the <literal>&lt;class&gt;</literal> and <literal>&lt;subclass&gt;</literal> elements."
msgstr ""

#: index.docbook:1102
msgid "The <literal>force</literal> attribute is (only) useful if the table contains rows with \"extra\" discriminator values that are not mapped to a persistent class. This will not usually be the case."
msgstr ""

#: index.docbook:1108
msgid "Using the <literal>formula</literal> attribute you can declare an arbitrary SQL expression that will be used to evaluate the type of a row:"
msgstr ""

#: index.docbook:1113
msgid ""
      "<![CDATA[<discriminator\n"
      "    formula=\"case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end\"\n"
      "    type=\"integer\"/>]]>"
msgstr ""

#: index.docbook:1118
msgid "version (optional)"
msgstr ""

#: index.docbook:1120
msgid "The <literal>&lt;version&gt;</literal> element is optional and indicates that the table contains versioned data. This is particularly useful if you plan to use <emphasis>long transactions</emphasis> (see below)."
msgstr ""

#: index.docbook:1136
msgid ""
      "<![CDATA[<version\n"
      "        column=\"version_column\"\n"
      "        name=\"propertyName\"\n"
      "        type=\"typename\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        unsaved-value=\"null|negative|undefined\"\n"
      "        generated=\"never|always\"\n"
      "        insert=\"true|false\"\n"
      "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
      "/>]]>"
msgstr ""

#: index.docbook:1139
msgid "<literal>column</literal> (optional - defaults to the property name): The name of the column holding the version number."
msgstr ""

#: index.docbook:1145
msgid "<literal>name</literal>: The name of a property of the persistent class."
msgstr ""

#: index.docbook:1150
msgid "<literal>type</literal> (optional - defaults to <literal>integer</literal>): The type of the version number."
msgstr ""

#: index.docbook:1162
msgid "<literal>unsaved-value</literal> (optional - defaults to <literal>undefined</literal>): A version property value that indicates that an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. (<literal>undefined</literal> specifies that the identifier property value should be used.)"
msgstr ""

#: index.docbook:1171
msgid "<literal>generated</literal> (optional - defaults to <literal>never</literal>): Specifies that this version property value is actually generated by the database. See the discussion of <xref linkend=\"mapping-generated\"/>generated properties."
msgstr ""

#: index.docbook:1178
msgid "<literal>insert</literal> (optional - defaults to <literal>true</literal>): Specifies whether the version column should be included in SQL insert statements. May be set to <literal>false</literal> if and only if the database column is defined with a default value of <literal>0</literal>."
msgstr ""

#: index.docbook:1188
msgid "Version numbers may be of Hibernate type <literal>long</literal>, <literal>integer</literal>, <literal>short</literal>, <literal>timestamp</literal> or <literal>calendar</literal>."
msgstr ""

#: index.docbook:1193
msgid "A version or timestamp property should never be null for a detached instance, so Hibernate will detect any instance with a null version or timestamp as transient, no matter what other <literal>unsaved-value</literal> strategies are specified. <emphasis>Declaring a nullable version or timestamp property is an easy way to avoid any problems with transitive reattachment in Hibernate, especially useful for people using assigned identifiers or composite keys!</emphasis>"
msgstr ""

#: index.docbook:1204
msgid "timestamp (optional)"
msgstr ""

#: index.docbook:1206
msgid "The optional <literal>&lt;timestamp&gt;</literal> element indicates that the table contains timestamped data. This is intended as an alternative to versioning. Timestamps are by nature a less safe implementation of optimistic locking. However, sometimes the application might use the timestamps in other ways."
msgstr ""

#: index.docbook:1222
msgid ""
      "<![CDATA[<timestamp\n"
      "        column=\"timestamp_column\"\n"
      "        name=\"propertyName\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        unsaved-value=\"null|undefined\"\n"
      "        source=\"vm|db\"\n"
      "        generated=\"never|always\"\n"
      "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
      "/>]]>"
msgstr ""

#: index.docbook:1225
msgid "<literal>column</literal> (optional - defaults to the property name): The name of a column holding the timestamp."
msgstr ""

#: index.docbook:1231
msgid "<literal>name</literal>: The name of a JavaBeans style property of Java type <literal>Date</literal> or <literal>Timestamp</literal> of the persistent class."
msgstr ""

#: index.docbook:1244
msgid "<literal>unsaved-value</literal> (optional - defaults to <literal>null</literal>): A version property value that indicates that an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. (<literal>undefined</literal> specifies that the identifier property value should be used.)"
msgstr ""

#: index.docbook:1253
msgid "<literal>source</literal> (optional - defaults to <literal>vm</literal>): From where should Hibernate retrieve the timestamp value? From the database, or from the current JVM? Database-based timestamps incur an overhead because Hibernate must hit the database in order to determine the \"next value\", but will be safer for use in clustered environments. Note also, that not all <literal>Dialect</literal>s are known to support retrieving of the database's current timestamp, while others might be unsafe for usage in locking due to lack of precision (Oracle 8 for example)."
msgstr ""

#: index.docbook:1265
msgid "<literal>generated</literal> (optional - defaults to <literal>never</literal>): Specifies that this timestamp property value is actually generated by the database. See the discussion of <xref linkend=\"mapping-generated\"/>generated properties."
msgstr ""

#: index.docbook:1274
msgid "Note that <literal>&lt;timestamp&gt;</literal> is equivalent to <literal>&lt;version type=\"timestamp\"&gt;</literal>. And <literal>&lt;timestamp source=\"db\"&gt;</literal> is equivalent to <literal>&lt;version type=\"dbtimestamp\"&gt;</literal>"
msgstr ""

#: index.docbook:1284
msgid "property"
msgstr ""

#: index.docbook:1286
msgid "The <literal>&lt;property&gt;</literal> element declares a persistent, JavaBean style property of the class."
msgstr ""

#: index.docbook:1308
msgid ""
      "<![CDATA[<property\n"
      "        name=\"propertyName\"\n"
      "        column=\"column_name\"\n"
      "        type=\"typename\"\n"
      "        update=\"true|false\"\n"
      "        insert=\"true|false\"\n"
      "        formula=\"arbitrary SQL expression\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        lazy=\"true|false\"\n"
      "        unique=\"true|false\"\n"
      "        not-null=\"true|false\"\n"
      "        optimistic-lock=\"true|false\"\n"
      "        generated=\"never|insert|always\"\n"
      "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
      "        index=\"index_name\"\n"
      "        unique_key=\"unique_key_id\"\n"
      "        length=\"L\"\n"
      "        precision=\"P\"\n"
      "        scale=\"S\"\n"
      "/>]]>"
msgstr ""

#: index.docbook:1311
msgid "<literal>name</literal>: the name of the property, with an initial lowercase letter."
msgstr ""

#: index.docbook:1317
msgid "<literal>column</literal> (optional - defaults to the property name): the name of the mapped database table column. This may also be specified by nested <literal>&lt;column&gt;</literal> element(s)."
msgstr ""

#: index.docbook:1324
msgid "<literal>type</literal> (optional): a name that indicates the Hibernate type."
msgstr ""

#: index.docbook:1329
msgid "<literal>update, insert</literal> (optional - defaults to <literal>true</literal>) : specifies that the mapped columns should be included in SQL <literal>UPDATE</literal> and/or <literal>INSERT</literal> statements. Setting both to <literal>false</literal> allows a pure \"derived\" property whose value is initialized from some other property that maps to the same colum(s) or by a trigger or other application."
msgstr ""

#: index.docbook:1338
msgid "<literal>formula</literal> (optional): an SQL expression that defines the value for a <emphasis>computed</emphasis> property. Computed properties do not have a column mapping of their own."
msgstr ""

#: index.docbook:1351
msgid "<literal>lazy</literal> (optional - defaults to <literal>false</literal>): Specifies that this property should be fetched lazily when the instance variable is first accessed (requires build-time bytecode instrumentation)."
msgstr ""

#: index.docbook:1358
msgid "<literal>unique</literal> (optional): Enable the DDL generation of a unique constraint for the columns. Also, allow this to be the target of a <literal>property-ref</literal>."
msgstr ""

#: index.docbook:1365
msgid "<literal>not-null</literal> (optional): Enable the DDL generation of a nullability constraint for the columns."
msgstr ""

#: index.docbook:1371
msgid "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>): Specifies that updates to this property do or do not require acquisition of the optimistic lock. In other words, determines if a version increment should occur when this property is dirty."
msgstr ""

#: index.docbook:1379
msgid "<literal>generated</literal> (optional - defaults to <literal>never</literal>): Specifies that this property value is actually generated by the database. See the discussion of <xref linkend=\"mapping-generated\"/>generated properties."
msgstr ""

#: index.docbook:1388
msgid "<emphasis>typename</emphasis> could be:"
msgstr ""

#: index.docbook:1394
msgid "The name of a Hibernate basic type (eg. <literal>integer, string, character, date, timestamp, float, binary, serializable, object, blob</literal>)."
msgstr ""

#: index.docbook:1400
msgid "The name of a Java class with a default basic type (eg. <literal>int, float, char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</literal>)."
msgstr ""

#: index.docbook:1406
msgid "The name of a serializable Java class."
msgstr ""

#: index.docbook:1411
msgid "The class name of a custom type (eg. <literal>com.illflow.type.MyCustomType</literal>)."
msgstr ""

#: index.docbook:1417
msgid "If you do not specify a type, Hibernate will use reflection upon the named property to take a guess at the correct Hibernate type. Hibernate will try to interpret the name of the return class of the property getter using rules 2, 3, 4 in that order. However, this is not always enough. In certain cases you will still need the <literal>type</literal> attribute. (For example, to distinguish between <literal>Hibernate.DATE</literal> and <literal>Hibernate.TIMESTAMP</literal>, or to specify a custom type.)"
msgstr ""

#: index.docbook:1427
msgid "The <literal>access</literal> attribute lets you control how Hibernate will access the property at runtime. By default, Hibernate will call the property get/set pair. If you specify <literal>access=\"field\"</literal>, Hibernate will bypass the get/set pair and access the field directly, using reflection. You may specify your own strategy for property access by naming a class that implements the interface <literal>org.hibernate.property.PropertyAccessor</literal>."
msgstr ""

#: index.docbook:1436
msgid "An especially powerful feature are derived properties. These properties are by definition read-only, the property value is computed at load time. You declare the computation as a SQL expression, this translates to a <literal>SELECT</literal> clause subquery in the SQL query that loads an instance:"
msgstr ""

#: index.docbook:1443
msgid ""
      "<![CDATA[\n"
      "<property name=\"totalPrice\"\n"
      "    formula=\"( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product p\n"
      "                WHERE li.productId = p.productId\n"
      "                AND li.customerId = customerId\n"
      "                AND li.orderNumber = orderNumber )\"/>]]>"
msgstr ""

#: index.docbook:1445
msgid "Note that you can reference the entities own table by not declaring an alias on a particular column (<literal>customerId</literal> in the given example). Also note that you can use the nested <literal>&lt;formula&gt;</literal> mapping element if you don't like to use the attribute."
msgstr ""

#: index.docbook:1455
msgid "many-to-one"
msgstr ""

#: index.docbook:1457
msgid "An ordinary association to another persistent class is declared using a <literal>many-to-one</literal> element. The relational model is a many-to-one association: a foreign key in one table is referencing the primary key column(s) of the target table."
msgstr ""

#: index.docbook:1485
msgid ""
      "<![CDATA[<many-to-one\n"
      "        name=\"propertyName\"\n"
      "        column=\"column_name\"\n"
      "        class=\"ClassName\"\n"
      "        cascade=\"cascade_style\"\n"
      "        fetch=\"join|select\"\n"
      "        update=\"true|false\"\n"
      "        insert=\"true|false\"\n"
      "        property-ref=\"propertyNameFromAssociatedClass\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        unique=\"true|false\"\n"
      "        not-null=\"true|false\"\n"
      "        optimistic-lock=\"true|false\"\n"
      "        lazy=\"proxy|no-proxy|false\"\n"
      "        not-found=\"ignore|exception\"\n"
      "        entity-name=\"EntityName\"\n"
      "        formula=\"arbitrary SQL expression\"\n"
      "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
      "        embed-xml=\"true|false\"\n"
      "        index=\"index_name\"\n"
      "        unique_key=\"unique_key_id\"\n"
      "        foreign-key=\"foreign_key_name\"\n"
      "/>]]>"
msgstr ""

#: index.docbook:1488, index.docbook:1669, index.docbook:1855
msgid "<literal>name</literal>: The name of the property."
msgstr ""

#: index.docbook:1493, index.docbook:2284
msgid "<literal>column</literal> (optional): The name of the foreign key column. This may also be specified by nested <literal>&lt;column&gt;</literal> element(s)."
msgstr ""

#: index.docbook:1500, index.docbook:1674
msgid "<literal>class</literal> (optional - defaults to the property type determined by reflection): The name of the associated class."
msgstr ""

#: index.docbook:1506
msgid "<literal>cascade</literal> (optional): Specifies which operations should be cascaded from the parent object to the associated object."
msgstr ""

#: index.docbook:1512, index.docbook:1695
msgid "<literal>fetch</literal> (optional - defaults to <literal>select</literal>): Chooses between outer-join fetching or sequential select fetching."
msgstr ""

#: index.docbook:1518
msgid "<literal>update, insert</literal> (optional - defaults to <literal>true</literal>) specifies that the mapped columns should be included in SQL <literal>UPDATE</literal> and/or <literal>INSERT</literal> statements. Setting both to <literal>false</literal> allows a pure \"derived\" association whose value is initialized from some other property that maps to the same colum(s) or by a trigger or other application."
msgstr ""

#: index.docbook:1527
msgid "<literal>property-ref</literal>: (optional) The name of a property of the associated class that is joined to this foreign key. If not specified, the primary key of the associated class is used."
msgstr ""

#: index.docbook:1540
msgid "<literal>unique</literal> (optional): Enable the DDL generation of a unique constraint for the foreign-key column. Also, allow this to be the target of a <literal>property-ref</literal>. This makes the association multiplicity effectively one to one."
msgstr ""

#: index.docbook:1548
msgid "<literal>not-null</literal> (optional): Enable the DDL generation of a nullability constraint for the foreign key columns."
msgstr ""

#: index.docbook:1554
msgid "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>): Specifies that updates to this property do or do not require acquisition of the optimistic lock. In other words, dertermines if a version increment should occur when this property is dirty."
msgstr ""

#: index.docbook:1562
msgid "<literal>lazy</literal> (optional - defaults to <literal>proxy</literal>): By default, single point associations are proxied. <literal>lazy=\"no-proxy\"</literal> specifies that the property should be fetched lazily when the instance variable is first accessed (requires build-time bytecode instrumentation). <literal>lazy=\"false\"</literal> specifies that the association will always be eagerly fetched."
msgstr ""

#: index.docbook:1572
msgid "<literal>not-found</literal> (optional - defaults to <literal>exception</literal>): Specifies how foreign keys that reference missing rows will be handled: <literal>ignore</literal> will treat a missing row as a null association."
msgstr ""

#: index.docbook:1579, index.docbook:1733
msgid "<literal>entity-name</literal> (optional): The entity name of the associated class."
msgstr ""

#: index.docbook:1585
msgid "<literal>formula</literal> (optional): an SQL expression that defines the value for a <emphasis>computed</emphasis> foreign key."
msgstr ""

#: index.docbook:1592
msgid "Setting a value of the <literal>cascade</literal> attribute to any meaningful value other than <literal>none</literal> will propagate certain operations to the associated object. The meaningful values are the names of Hibernate's basic operations, <literal>persist, merge, delete, save-update, evict, replicate, lock, refresh</literal>, as well as the special values <literal>delete-orphan</literal> and <literal>all</literal> and comma-separated combinations of operation names, for example, <literal>cascade=\"persist,merge,evict\"</literal> or <literal>cascade=\"all,delete-orphan\"</literal>. See <xref linkend=\"objectstate-transitive\"/> for a full explanation. Note that single valued associations (many-to-one and one-to-one associations) do not support orphan delete."
msgstr ""

#: index.docbook:1605
msgid "A typical <literal>many-to-one</literal> declaration looks as simple as this:"
msgstr ""

#: index.docbook:1609
msgid "<![CDATA[<many-to-one name=\"product\" class=\"Product\" column=\"PRODUCT_ID\"/>]]>"
msgstr ""

#: index.docbook:1611
msgid "The <literal>property-ref</literal> attribute should only be used for mapping legacy data where a foreign key refers to a unique key of the associated table other than the primary key. This is an ugly relational model. For example, suppose the <literal>Product</literal> class had a unique serial number, that is not the primary key. (The <literal>unique</literal> attribute controls Hibernate's DDL generation with the SchemaExport tool.)"
msgstr ""

#: index.docbook:1620
msgid "<![CDATA[<property name=\"serialNumber\" unique=\"true\" type=\"string\" column=\"SERIAL_NUMBER\"/>]]>"
msgstr ""

#: index.docbook:1622
msgid "Then the mapping for <literal>OrderItem</literal> might use:"
msgstr ""

#: index.docbook:1626
msgid "<![CDATA[<many-to-one name=\"product\" property-ref=\"serialNumber\" column=\"PRODUCT_SERIAL_NUMBER\"/>]]>"
msgstr ""

#: index.docbook:1628
msgid "This is certainly not encouraged, however."
msgstr ""

#: index.docbook:1632
msgid "If the referenced unique key comprises multiple properties of the associated entity, you should map the referenced properties inside a named <literal>&lt;properties&gt;</literal> element."
msgstr ""

#: index.docbook:1637
msgid "If the referenced unique key is the property of a component, you may specify a property path:"
msgstr ""

#: index.docbook:1641
msgid "<![CDATA[<many-to-one name=\"owner\" property-ref=\"identity.ssn\" column=\"OWNER_SSN\"/>]]>"
msgstr ""

#: index.docbook:1646
msgid "one-to-one"
msgstr ""

#: index.docbook:1648
msgid "A one-to-one association to another persistent class is declared using a <literal>one-to-one</literal> element."
msgstr ""

#: index.docbook:1666
msgid ""
      "<![CDATA[<one-to-one\n"
      "        name=\"propertyName\"\n"
      "        class=\"ClassName\"\n"
      "        cascade=\"cascade_style\"\n"
      "        constrained=\"true|false\"\n"
      "        fetch=\"join|select\"\n"
      "        property-ref=\"propertyNameFromAssociatedClass\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        formula=\"any SQL expression\"\n"
      "        lazy=\"proxy|no-proxy|false\"\n"
      "        entity-name=\"EntityName\"\n"
      "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
      "        embed-xml=\"true|false\"\n"
      "        foreign-key=\"foreign_key_name\"\n"
      "/>]]>"
msgstr ""

#: index.docbook:1680
msgid "<literal>cascade</literal> (optional) specifies which operations should be cascaded from the parent object to the associated object."
msgstr ""

#: index.docbook:1686
msgid "<literal>constrained</literal> (optional) specifies that a foreign key constraint on the primary key of the mapped table references the table of the associated class. This option affects the order in which <literal>save()</literal> and <literal>delete()</literal> are cascaded, and determines whether the association may be proxied (it is also used by the schema export tool)."
msgstr ""

#: index.docbook:1701
msgid "<literal>property-ref</literal>: (optional) The name of a property of the associated class that is joined to the primary key of this class. If not specified, the primary key of the associated class is used."
msgstr ""

#: index.docbook:1714
msgid "<literal>formula</literal> (optional): Almost all one to one associations map to the primary key of the owning entity. In the rare case that this is not the case, you may specify a some other column, columns or expression to join on using an SQL formula. (See <literal>org.hibernate.test.onetooneformula</literal> for an example.)"
msgstr ""

#: index.docbook:1722
msgid "<literal>lazy</literal> (optional - defaults to <literal>proxy</literal>): By default, single point associations are proxied. <literal>lazy=\"no-proxy\"</literal> specifies that the property should be fetched lazily when the instance variable is first accessed (requires build-time bytecode instrumentation). <literal>lazy=\"false\"</literal> specifies that the association will always be eagerly fetched. <emphasis>Note that if <literal>constrained=\"false\"</literal>, proxying is impossible and Hibernate will eager fetch the association!</emphasis>"
msgstr ""

#: index.docbook:1740
msgid "There are two varieties of one-to-one association:"
msgstr ""

#: index.docbook:1744
msgid "primary key associations"
msgstr ""

#: index.docbook:1747
msgid "unique foreign key associations"
msgstr ""

#: index.docbook:1752
msgid "Primary key associations don't need an extra table column; if two rows are related by the association then the two table rows share the same primary key value. So if you want two objects to be related by a primary key association, you must make sure that they are assigned the same identifier value!"
msgstr ""

#: index.docbook:1759
msgid "For a primary key association, add the following mappings to <literal>Employee</literal> and <literal>Person</literal>, respectively."
msgstr ""

#: index.docbook:1764
msgid "<![CDATA[<one-to-one name=\"person\" class=\"Person\"/>]]>"
msgstr ""

#: index.docbook:1765
msgid "<![CDATA[<one-to-one name=\"employee\" class=\"Employee\" constrained=\"true\"/>]]>"
msgstr ""

#: index.docbook:1767
msgid "Now we must ensure that the primary keys of related rows in the PERSON and EMPLOYEE tables are equal. We use a special Hibernate identifier generation strategy called <literal>foreign</literal>:"
msgstr ""

#: index.docbook:1773
msgid ""
      "<![CDATA[<class name=\"person\" table=\"PERSON\">\n"
      "    <id name=\"id\" column=\"PERSON_ID\">\n"
      "        <generator class=\"foreign\">\n"
      "            <param name=\"property\">employee</param>\n"
      "        </generator>\n"
      "    </id>\n"
      "    ...\n"
      "    <one-to-one name=\"employee\"\n"
      "        class=\"Employee\"\n"
      "        constrained=\"true\"/>\n"
      "</class>]]>"
msgstr ""

#: index.docbook:1775
msgid "A newly saved instance of <literal>Person</literal> is then assigned the same primary key value as the <literal>Employee</literal> instance refered with the <literal>employee</literal> property of that <literal>Person</literal>."
msgstr ""

#: index.docbook:1781
msgid "Alternatively, a foreign key with a unique constraint, from <literal>Employee</literal> to <literal>Person</literal>, may be expressed as:"
msgstr ""

#: index.docbook:1786
msgid "<![CDATA[<many-to-one name=\"person\" class=\"Person\" column=\"PERSON_ID\" unique=\"true\"/>]]>"
msgstr ""

#: index.docbook:1788
msgid "And this association may be made bidirectional by adding the following to the <literal>Person</literal> mapping:"
msgstr ""

#: index.docbook:1793
msgid "<![CDATA[<one-to-one name=\"employee\" class=\"Employee\" property-ref=\"person\"/>]]>"
msgstr ""

#: index.docbook:1798
msgid "natural-id"
msgstr ""

#: index.docbook:1800
msgid ""
      "<![CDATA[<natural-id mutable=\"true|false\"/>\n"
      "        <property ... />\n"
      "        <many-to-one ... />\n"
      "        ......\n"
      "</natural-id>]]>"
msgstr ""

#: index.docbook:1802
msgid "Even though we recommend the use of surrogate keys as primary keys, you should still try to identify natural keys for all entities. A natural key is a property or combination of properties that is unique and non-null. If it is also immutable, even better. Map the properties of the natural key inside the <literal>&lt;natural-id&gt;</literal> element. Hibernate will generate the necessary unique key and nullability constraints, and your mapping will be more self-documenting."
msgstr ""

#: index.docbook:1811
msgid "We strongly recommend that you implement <literal>equals()</literal> and <literal>hashCode()</literal> to compare the natural key properties of the entity."
msgstr ""

#: index.docbook:1816
msgid "This mapping is not intended for use with entities with natural primary keys."
msgstr ""

#: index.docbook:1822
msgid "<literal>mutable</literal> (optional, defaults to <literal>false</literal>): By default, natural identifier properties as assumed to be immutable (constant)."
msgstr ""

#: index.docbook:1832
msgid "component, dynamic-component"
msgstr ""

#: index.docbook:1834
msgid "The <literal>&lt;component&gt;</literal> element maps properties of a child object to columns of the table of a parent class. Components may, in turn, declare their own properties, components or collections. See \"Components\" below."
msgstr ""

#: index.docbook:1852
msgid ""
      "<![CDATA[<component\n"
      "        name=\"propertyName\"\n"
      "        class=\"className\"\n"
      "        insert=\"true|false\"\n"
      "        update=\"true|false\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        lazy=\"true|false\"\n"
      "        optimistic-lock=\"true|false\"\n"
      "        unique=\"true|false\"\n"
      "        node=\"element-name|.\"\n"
      ">\n"
      "\n"
      "        <property ...../>\n"
      "        <many-to-one .... />\n"
      "        ........\n"
      "</component>]]>"
msgstr ""

#: index.docbook:1860
msgid "<literal>class</literal> (optional - defaults to the property type determined by reflection): The name of the component (child) class."
msgstr ""

#: index.docbook:1866, index.docbook:1955
msgid "<literal>insert</literal>: Do the mapped columns appear in SQL <literal>INSERT</literal>s?"
msgstr ""

#: index.docbook:1872, index.docbook:1961
msgid "<literal>update</literal>: Do the mapped columns appear in SQL <literal>UPDATE</literal>s?"
msgstr ""

#: index.docbook:1884
msgid "<literal>lazy</literal> (optional - defaults to <literal>false</literal>): Specifies that this component should be fetched lazily when the instance variable is first accessed (requires build-time bytecode instrumentation)."
msgstr ""

#: index.docbook:1891
msgid "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>): Specifies that updates to this component do or do not require acquisition of the optimistic lock. In other words, determines if a version increment should occur when this property is dirty."
msgstr ""

#: index.docbook:1899, index.docbook:1975
msgid "<literal>unique</literal> (optional - defaults to <literal>false</literal>): Specifies that a unique constraint exists upon all mapped columns of the component."
msgstr ""

#: index.docbook:1908
msgid "The child <literal>&lt;property&gt;</literal> tags map properties of the child class to table columns."
msgstr ""

#: index.docbook:1913
msgid "The <literal>&lt;component&gt;</literal> element allows a <literal>&lt;parent&gt;</literal> subelement that maps a property of the component class as a reference back to the containing entity."
msgstr ""

#: index.docbook:1919
msgid "The <literal>&lt;dynamic-component&gt;</literal> element allows a <literal>Map</literal> to be mapped as a component, where the property names refer to keys of the map, see <xref linkend=\"components-dynamic\"/>."
msgstr ""

#: index.docbook:1928
msgid "properties"
msgstr ""

#: index.docbook:1930
msgid "The <literal>&lt;properties&gt;</literal> element allows the definition of a named, logical grouping of properties of a class. The most important use of the construct is that it allows a combination of properties to be the target of a <literal>property-ref</literal>. It is also a convenient way to define a multi-column unique constraint."
msgstr ""

#: index.docbook:1946
msgid ""
      "<![CDATA[<properties\n"
      "        name=\"logicalName\"\n"
      "        insert=\"true|false\"\n"
      "        update=\"true|false\"\n"
      "        optimistic-lock=\"true|false\"\n"
      "        unique=\"true|false\"\n"
      ">\n"
      "\n"
      "        <property ...../>\n"
      "        <many-to-one .... />\n"
      "        ........\n"
      "</properties>]]>"
msgstr ""

#: index.docbook:1949
msgid "<literal>name</literal>: The logical name of the grouping - <emphasis>not</emphasis> an actual property name."
msgstr ""

#: index.docbook:1967
msgid "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>): Specifies that updates to these properties do or do not require acquisition of the optimistic lock. In other words, determines if a version increment should occur when these properties are dirty."
msgstr ""

#: index.docbook:1984
msgid "For example, if we have the following <literal>&lt;properties&gt;</literal> mapping:"
msgstr ""

#: index.docbook:1988
msgid ""
      "<![CDATA[<class name=\"Person\">\n"
      "    <id name=\"personNumber\"/>\n"
      "    ...\n"
      "    <properties name=\"name\"\n"
      "            unique=\"true\" update=\"false\">\n"
      "        <property name=\"firstName\"/>\n"
      "        <property name=\"initial\"/>\n"
      "        <property name=\"lastName\"/>\n"
      "    </properties>\n"
      "</class>]]>"
msgstr ""

#: index.docbook:1990
msgid "Then we might have some legacy data association which refers to this unique key of the <literal>Person</literal> table, instead of to the primary key:"
msgstr ""

#: index.docbook:1995
msgid ""
      "<![CDATA[<many-to-one name=\"person\"\n"
      "         class=\"Person\" property-ref=\"name\">\n"
      "    <column name=\"firstName\"/>\n"
      "    <column name=\"initial\"/>\n"
      "    <column name=\"lastName\"/>\n"
      "</many-to-one>]]>"
msgstr ""

#: index.docbook:1997
msgid "We don't recommend the use of this kind of thing outside the context of mapping legacy data."
msgstr ""

#: index.docbook:2005
msgid "subclass"
msgstr ""

#: index.docbook:2007
msgid "Finally, polymorphic persistence requires the declaration of each subclass of the root persistent class. For the table-per-class-hierarchy mapping strategy, the <literal>&lt;subclass&gt;</literal> declaration is used."
msgstr ""

#: index.docbook:2020
msgid ""
      "<![CDATA[<subclass\n"
      "        name=\"ClassName\"\n"
      "        discriminator-value=\"discriminator_value\"\n"
      "        proxy=\"ProxyInterface\"\n"
      "        lazy=\"true|false\"\n"
      "        dynamic-update=\"true|false\"\n"
      "        dynamic-insert=\"true|false\"\n"
      "        entity-name=\"EntityName\"\n"
      "        node=\"element-name\"\n"
      "        extends=\"SuperclassName\">\n"
      "\n"
      "        <property .... />\n"
      "        .....\n"
      "</subclass>]]>"
msgstr ""

#: index.docbook:2023, index.docbook:2081, index.docbook:2144
msgid "<literal>name</literal>: The fully qualified class name of the subclass."
msgstr ""

#: index.docbook:2028
msgid "<literal>discriminator-value</literal> (optional - defaults to the class name): A value that distiguishes individual subclasses."
msgstr ""

#: index.docbook:2034, index.docbook:2091, index.docbook:2154
msgid "<literal>proxy</literal> (optional): Specifies a class or interface to use for lazy initializing proxies."
msgstr ""

#: index.docbook:2040, index.docbook:2097, index.docbook:2160
msgid "<literal>lazy</literal> (optional, defaults to <literal>true</literal>): Setting <literal>lazy=\"false\"</literal> disables the use of lazy fetching."
msgstr ""

#: index.docbook:2048
msgid "Each subclass should declare its own persistent properties and subclasses. <literal>&lt;version&gt;</literal> and <literal>&lt;id&gt;</literal> properties are assumed to be inherited from the root class. Each subclass in a heirarchy must define a unique <literal>discriminator-value</literal>. If none is specified, the fully qualified Java class name is used."
msgstr ""

#: index.docbook:2056, index.docbook:2114, index.docbook:2172
msgid "For information about inheritance mappings, see <xref linkend=\"inheritance\"/>."
msgstr ""

#: index.docbook:2063
msgid "joined-subclass"
msgstr ""

#: index.docbook:2065
msgid "Alternatively, each subclass may be mapped to its own table (table-per-subclass mapping strategy). Inherited state is retrieved by joining with the table of the superclass. We use the <literal>&lt;joined-subclass&gt;</literal> element."
msgstr ""

#: index.docbook:2078
msgid ""
      "<![CDATA[<joined-subclass\n"
      "        name=\"ClassName\"\n"
      "        table=\"tablename\"\n"
      "        proxy=\"ProxyInterface\"\n"
      "        lazy=\"true|false\"\n"
      "        dynamic-update=\"true|false\"\n"
      "        dynamic-insert=\"true|false\"\n"
      "        schema=\"schema\"\n"
      "        catalog=\"catalog\"\n"
      "        extends=\"SuperclassName\"\n"
      "        persister=\"ClassName\"\n"
      "        subselect=\"SQL expression\"\n"
      "        entity-name=\"EntityName\"\n"
      "        node=\"element-name\">\n"
      "\n"
      "        <key .... >\n"
      "\n"
      "        <property .... />\n"
      "        .....\n"
      "</joined-subclass>]]>"
msgstr ""

#: index.docbook:2086, index.docbook:2149
msgid "<literal>table</literal>: The name of the subclass table."
msgstr ""

#: index.docbook:2105
msgid "No discriminator column is required for this mapping strategy. Each subclass must, however, declare a table column holding the object identifier using the <literal>&lt;key&gt;</literal> element. The mapping at the start of the chapter would be re-written as:"
msgstr ""

#: index.docbook:2112
msgid ""
      "<![CDATA[<?xml version=\"1.0\"?>\n"
      "<!DOCTYPE hibernate-mapping PUBLIC\n"
      "        \"-//Hibernate/Hibernate Mapping DTD//EN\"\n"
      "        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\">\n"
      "\n"
      "<hibernate-mapping package=\"eg\">\n"
      "\n"
      "        <class name=\"Cat\" table=\"CATS\">\n"
      "                <id name=\"id\" column=\"uid\" type=\"long\">\n"
      "                        <generator class=\"hilo\"/>\n"
      "                </id>\n"
      "                <property name=\"birthdate\" type=\"date\"/>\n"
      "                <property name=\"color\" not-null=\"true\"/>\n"
      "                <property name=\"sex\" not-null=\"true\"/>\n"
      "                <property name=\"weight\"/>\n"
      "                <many-to-one name=\"mate\"/>\n"
      "                <set name=\"kittens\">\n"
      "                        <key column=\"MOTHER\"/>\n"
      "                        <one-to-many class=\"Cat\"/>\n"
      "                </set>\n"
      "                <joined-subclass name=\"DomesticCat\" table=\"DOMESTIC_CATS\">\n"
      "                    <key column=\"CAT\"/>\n"
      "                    <property name=\"name\" type=\"string\"/>\n"
      "                </joined-subclass>\n"
      "        </class>\n"
      "\n"
      "        <class name=\"eg.Dog\">\n"
      "                <!-- mapping for Dog could go here -->\n"
      "        </class>\n"
      "\n"
      "</hibernate-mapping>]]>"
msgstr ""

#: index.docbook:2121
msgid "union-subclass"
msgstr ""

#: index.docbook:2123
msgid "A third option is to map only the concrete classes of an inheritance hierarchy to tables, (the table-per-concrete-class strategy) where each table defines all persistent state of the class, including inherited state. In Hibernate, it is not absolutely necessary to explicitly map such inheritance hierarchies. You can simply map each class with a separate <literal>&lt;class&gt;</literal> declaration. However, if you wish use polymorphic associations (e.g. an association to the superclass of your hierarchy), you need to use the <literal>&lt;union-subclass&gt;</literal> mapping."
msgstr ""

#: index.docbook:2141
msgid ""
      "<![CDATA[<union-subclass\n"
      "        name=\"ClassName\"\n"
      "        table=\"tablename\"\n"
      "        proxy=\"ProxyInterface\"\n"
      "        lazy=\"true|false\"\n"
      "        dynamic-update=\"true|false\"\n"
      "        dynamic-insert=\"true|false\"\n"
      "        schema=\"schema\"\n"
      "        catalog=\"catalog\"\n"
      "        extends=\"SuperclassName\"\n"
      "        abstract=\"true|false\"\n"
      "        persister=\"ClassName\"\n"
      "        subselect=\"SQL expression\"\n"
      "        entity-name=\"EntityName\"\n"
      "        node=\"element-name\">\n"
      "\n"
      "        <property .... />\n"
      "        .....\n"
      "</union-subclass>]]>"
msgstr ""

#: index.docbook:2168
msgid "No discriminator column or key column is required for this mapping strategy."
msgstr ""

#: index.docbook:2179
msgid "join"
msgstr ""

#: index.docbook:2181
msgid "Using the <literal>&lt;join&gt;</literal> element, it is possible to map properties of one class to several tables, when there's a 1-to-1 relationship between the tables."
msgstr ""

#: index.docbook:2195
msgid ""
      "<![CDATA[<join\n"
      "        table=\"tablename\"\n"
      "        schema=\"owner\"\n"
      "        catalog=\"catalog\"\n"
      "        fetch=\"join|select\"\n"
      "        inverse=\"true|false\"\n"
      "        optional=\"true|false\">\n"
      "\n"
      "        <key ... />\n"
      "\n"
      "        <property ... />\n"
      "        ...\n"
      "</join>]]>"
msgstr ""

#: index.docbook:2199
msgid "<literal>table</literal>: The name of the joined table."
msgstr ""

#: index.docbook:2216
msgid "<literal>fetch</literal> (optional - defaults to <literal>join</literal>): If set to <literal>join</literal>, the default, Hibernate will use an inner join to retrieve a <literal>&lt;join&gt;</literal> defined by a class or its superclasses and an outer join for a <literal>&lt;join&gt;</literal> defined by a subclass. If set to <literal>select</literal> then Hibernate will use a sequential select for a <literal>&lt;join&gt;</literal> defined on a subclass, which will be issued only if a row turns out to represent an instance of the subclass. Inner joins will still be used to retrieve a <literal>&lt;join&gt;</literal> defined by the class and its superclasses."
msgstr ""

#: index.docbook:2229
msgid "<literal>inverse</literal> (optional - defaults to <literal>false</literal>): If enabled, Hibernate will not try to insert or update the properties defined by this join."
msgstr ""

#: index.docbook:2236
msgid "<literal>optional</literal> (optional - defaults to <literal>false</literal>): If enabled, Hibernate will insert a row only if the properties defined by this join are non-null and will always use an outer join to retrieve the properties."
msgstr ""

#: index.docbook:2245
msgid "For example, the address information for a person can be mapped to a separate table (while preserving value type semantics for all properties):"
msgstr ""

#: index.docbook:2250
msgid ""
      "<![CDATA[<class name=\"Person\"\n"
      "    table=\"PERSON\">\n"
      "\n"
      "    <id name=\"id\" column=\"PERSON_ID\">...</id>\n"
      "\n"
      "    <join table=\"ADDRESS\">\n"
      "        <key column=\"ADDRESS_ID\"/>\n"
      "        <property name=\"address\"/>\n"
      "        <property name=\"zip\"/>\n"
      "        <property name=\"country\"/>\n"
      "    </join>\n"
      "    ...]]>"
msgstr ""

#: index.docbook:2252
msgid "This feature is often only useful for legacy data models, we recommend fewer tables than classes and a fine-grained domain model. However, it is useful for switching between inheritance mapping strategies in a single hierarchy, as explained later."
msgstr ""

#: index.docbook:2262
msgid "<title>key</title>"
msgstr ""

#: index.docbook:2264
msgid "We've seen the <literal>&lt;key&gt;</literal> element crop up a few times now. It appears anywhere the parent mapping element defines a join to a new table, and defines the foreign key in the joined table, that references the primary key of the original table."
msgstr ""

#: index.docbook:2280
msgid ""
      "<![CDATA[<key\n"
      "        column=\"columnname\"\n"
      "        on-delete=\"noaction|cascade\"\n"
      "        property-ref=\"propertyName\"\n"
      "        not-null=\"true|false\"\n"
      "        update=\"true|false\"\n"
      "        unique=\"true|false\"\n"
      "/>]]>"
msgstr ""

#: index.docbook:2291
msgid "<literal>on-delete</literal> (optional, defaults to <literal>noaction</literal>): Specifies whether the foreign key constraint has database-level cascade delete enabled."
msgstr ""

#: index.docbook:2298
msgid "<literal>property-ref</literal> (optional): Specifies that the foreign key refers to columns that are not the primary key of the orginal table. (Provided for legacy data.)"
msgstr ""

#: index.docbook:2305
msgid "<literal>not-null</literal> (optional): Specifies that the foreign key columns are not nullable (this is implied whenever the foreign key is also part of the primary key)."
msgstr ""

#: index.docbook:2312
msgid "<literal>update</literal> (optional): Specifies that the foreign key should never be updated (this is implied whenever the foreign key is also part of the primary key)."
msgstr ""

#: index.docbook:2319
msgid "<literal>unique</literal> (optional): Specifies that the foreign key should have a unique constraint (this is implied whenever the foreign key is also the primary key)."
msgstr ""

#: index.docbook:2327
msgid "We recommend that for systems where delete performance is important, all keys should be defined <literal>on-delete=\"cascade\"</literal>, and Hibernate will use a database-level <literal>ON CASCADE DELETE</literal> constraint, instead of many individual <literal>DELETE</literal> statements. Be aware that this feature bypasses Hibernate's usual optimistic locking strategy for versioned data."
msgstr ""

#: index.docbook:2335
msgid "The <literal>not-null</literal> and <literal>update</literal> attributes are useful when mapping a unidirectional one to many association. If you map a unidirectional one to many to a non-nullable foreign key, you <emphasis>must</emphasis> declare the key column using <literal>&lt;key not-null=\"true\"&gt;</literal>."
msgstr ""

#: index.docbook:2345
msgid "column and formula elements"
msgstr ""

#: index.docbook:2346
msgid "Any mapping element which accepts a <literal>column</literal> attribute will alternatively accept a <literal>&lt;column&gt;</literal> subelement. Likewise, <literal>&lt;formula&gt;</literal> is an alternative to the <literal>formula</literal> attribute."
msgstr ""

#: index.docbook:2352
msgid ""
      "<![CDATA[<column\n"
      "        name=\"column_name\"\n"
      "        length=\"N\"\n"
      "        precision=\"N\"\n"
      "        scale=\"N\"\n"
      "        not-null=\"true|false\"\n"
      "        unique=\"true|false\"\n"
      "        unique-key=\"multicolumn_unique_key_name\"\n"
      "        index=\"index_name\"\n"
      "        sql-type=\"sql_type_name\"\n"
      "        check=\"SQL expression\"\n"
      "        default=\"SQL expression\"/>]]>"
msgstr ""

#: index.docbook:2354
msgid "<![CDATA[<formula>SQL expression</formula>]]>"
msgstr ""

#: index.docbook:2356
msgid "<literal>column</literal> and <literal>formula</literal> attributes may even be combined within the same property or association mapping to express, for example, exotic join conditions."
msgstr ""

#: index.docbook:2362
msgid ""
      "<![CDATA[<many-to-one name=\"homeAddress\" class=\"Address\"\n"
      "        insert=\"false\" update=\"false\">\n"
      "    <column name=\"person_id\" not-null=\"true\" length=\"10\"/>\n"
      "    <formula>'MAILING'</formula>\n"
      "</many-to-one>]]>"
msgstr ""

#: index.docbook:2367
msgid "import"
msgstr ""

#: index.docbook:2369
msgid "Suppose your application has two persistent classes with the same name, and you don't want to specify the fully qualified (package) name in Hibernate queries. Classes may be \"imported\" explicitly, rather than relying upon <literal>auto-import=\"true\"</literal>. You may even import classes and interfaces that are not explicitly mapped."
msgstr ""

#: index.docbook:2376
msgid "<![CDATA[<import class=\"java.lang.Object\" rename=\"Universe\"/>]]>"
msgstr ""

#: index.docbook:2383
msgid ""
      "<![CDATA[<import\n"
      "        class=\"ClassName\"\n"
      "        rename=\"ShortName\"\n"
      "/>]]>"
msgstr ""

#: index.docbook:2386
msgid "<literal>class</literal>: The fully qualified class name of of any Java class."
msgstr ""

#: index.docbook:2391
msgid "<literal>rename</literal> (optional - defaults to the unqualified class name): A name that may be used in the query language."
msgstr ""

#: index.docbook:2402
msgid "<title>any</title>"
msgstr ""

#: index.docbook:2404
msgid "There is one further type of property mapping. The <literal>&lt;any&gt;</literal> mapping element defines a polymorphic association to classes from multiple tables. This type of mapping always requires more than one column. The first column holds the type of the associated entity. The remaining columns hold the identifier. It is impossible to specify a foreign key constraint for this kind of association, so this is most certainly not meant as the usual way of mapping (polymorphic) associations. You should use this only in very special cases (eg. audit logs, user session data, etc)."
msgstr ""

#: index.docbook:2414
msgid "The <literal>meta-type</literal> attribute lets the application specify a custom type that maps database column values to persistent classes which have identifier properties of the type specified by <literal>id-type</literal>. You must specify the mapping from values of the meta-type to class names."
msgstr ""

#: index.docbook:2421
msgid ""
      "<![CDATA[<any name=\"being\" id-type=\"long\" meta-type=\"string\">\n"
      "    <meta-value value=\"TBL_ANIMAL\" class=\"Animal\"/>\n"
      "    <meta-value value=\"TBL_HUMAN\" class=\"Human\"/>\n"
      "    <meta-value value=\"TBL_ALIEN\" class=\"Alien\"/>\n"
      "    <column name=\"table_name\"/>\n"
      "    <column name=\"id\"/>\n"
      "</any>]]>"
msgstr ""

#: index.docbook:2432
msgid ""
      "<![CDATA[<any\n"
      "        name=\"propertyName\"\n"
      "        id-type=\"idtypename\"\n"
      "        meta-type=\"metatypename\"\n"
      "        cascade=\"cascade_style\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        optimistic-lock=\"true|false\"\n"
      ">\n"
      "        <meta-value ... />\n"
      "        <meta-value ... />\n"
      "        .....\n"
      "        <column .... />\n"
      "        <column .... />\n"
      "        .....\n"
      "</any>]]>"
msgstr ""

#: index.docbook:2435
msgid "<literal>name</literal>: the property name."
msgstr ""

#: index.docbook:2440
msgid "<literal>id-type</literal>: the identifier type."
msgstr ""

#: index.docbook:2445
msgid "<literal>meta-type</literal> (optional - defaults to <literal>string</literal>): Any type that is allowed for a discriminator mapping."
msgstr ""

#: index.docbook:2451
msgid "<literal>cascade</literal> (optional- defaults to <literal>none</literal>): the cascade style."
msgstr ""

#: index.docbook:2463
msgid "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>): Specifies that updates to this property do or do not require acquisition of the optimistic lock. In other words, define if a version increment should occur if this property is dirty."
msgstr ""

#: index.docbook:2478
msgid "Hibernate Types"
msgstr ""

#: index.docbook:2481
msgid "Entities and values"
msgstr ""

#: index.docbook:2483
msgid "To understand the behaviour of various Java language-level objects with respect to the persistence service, we need to classify them into two groups:"
msgstr ""

#: index.docbook:2488
msgid "An <emphasis>entity</emphasis> exists independently of any other objects holding references to the entity. Contrast this with the usual Java model where an unreferenced object is garbage collected. Entities must be explicitly saved and deleted (except that saves and deletions may be <emphasis>cascaded</emphasis> from a parent entity to its children). This is different from the ODMG model of object persistence by reachablity - and corresponds more closely to how application objects are usually used in large systems. Entities support circular and shared references. They may also be versioned."
msgstr ""

#: index.docbook:2499
msgid "An entity's persistent state consists of references to other entities and instances of <emphasis>value</emphasis> types. Values are primitives, collections (not what's inside a collection), components and certain immutable objects. Unlike entities, values (in particular collections and components) <emphasis>are</emphasis> persisted and deleted by reachability. Since value objects (and primitives) are persisted and deleted along with their containing entity they may not be independently versioned. Values have no independent identity, so they cannot be shared by two entities or collections."
msgstr ""

#: index.docbook:2510
msgid "Up until now, we've been using the term \"persistent class\" to refer to entities. We will continue to do that. Strictly speaking, however, not all user-defined classes with persistent state are entities. A <emphasis>component</emphasis> is a user defined class with value semantics. A Java property of type <literal>java.lang.String</literal> also has value semantics. Given this definition, we can say that all types (classes) provided by the JDK have value type semantics in Java, while user-defined types may be mapped with entity or value type semantics. This decision is up to the application developer. A good hint for an entity class in a domain model are shared references to a single instance of that class, while composition or aggregation usually translates to a value type."
msgstr ""

#: index.docbook:2524
msgid "We'll revisit both concepts throughout the documentation."
msgstr ""

#: index.docbook:2528
msgid "The challenge is to map the Java type system (and the developers' definition of entities and value types) to the SQL/database type system. The bridge between both systems is provided by Hibernate: for entities we use <literal>&lt;class&gt;</literal>, <literal>&lt;subclass&gt;</literal> and so on. For value types we use <literal>&lt;property&gt;</literal>, <literal>&lt;component&gt;</literal>, etc, usually with a <literal>type</literal> attribute. The value of this attribute is the name of a Hibernate <emphasis>mapping type</emphasis>. Hibernate provides many mappings (for standard JDK value types) out of the box. You can write your own mapping types and implement your custom conversion strategies as well, as you'll see later."
msgstr ""

#: index.docbook:2541
msgid "All built-in Hibernate types except collections support null semantics."
msgstr ""

#: index.docbook:2548
msgid "Basic value types"
msgstr ""

#: index.docbook:2550
msgid "The built-in <emphasis>basic mapping types</emphasis> may be roughly categorized into"
msgstr ""

#: index.docbook:2555
msgid "integer, long, short, float, double, character, byte, boolean, yes_no, true_false"
msgstr ""

#: index.docbook:2558
msgid "Type mappings from Java primitives or wrapper classes to appropriate (vendor-specific) SQL column types. <literal>boolean, yes_no</literal> and <literal>true_false</literal> are all alternative encodings for a Java <literal>boolean</literal> or <literal>java.lang.Boolean</literal>."
msgstr ""

#: index.docbook:2567
msgid "string"
msgstr ""

#: index.docbook:2569
msgid "A type mapping from <literal>java.lang.String</literal> to <literal>VARCHAR</literal> (or Oracle <literal>VARCHAR2</literal>)."
msgstr ""

#: index.docbook:2576
msgid "date, time, timestamp"
msgstr ""

#: index.docbook:2578
msgid "Type mappings from <literal>java.util.Date</literal> and its subclasses to SQL types <literal>DATE</literal>, <literal>TIME</literal> and <literal>TIMESTAMP</literal> (or equivalent)."
msgstr ""

#: index.docbook:2586
msgid "calendar, calendar_date"
msgstr ""

#: index.docbook:2588
msgid "Type mappings from <literal>java.util.Calendar</literal> to SQL types <literal>TIMESTAMP</literal> and <literal>DATE</literal> (or equivalent)."
msgstr ""

#: index.docbook:2596
msgid "big_decimal, big_integer"
msgstr ""

#: index.docbook:2598
msgid "Type mappings from <literal>java.math.BigDecimal</literal> and <literal>java.math.BigInteger</literal> to <literal>NUMERIC</literal> (or Oracle <literal>NUMBER</literal>)."
msgstr ""

#: index.docbook:2606
msgid "locale, timezone, currency"
msgstr ""

#: index.docbook:2608
msgid "Type mappings from <literal>java.util.Locale</literal>, <literal>java.util.TimeZone</literal> and <literal>java.util.Currency</literal> to <literal>VARCHAR</literal> (or Oracle <literal>VARCHAR2</literal>). Instances of <literal>Locale</literal> and <literal>Currency</literal> are mapped to their ISO codes. Instances of <literal>TimeZone</literal> are mapped to their <literal>ID</literal>."
msgstr ""

#: index.docbook:2620
msgid "<literal>class</literal>"
msgstr ""

#: index.docbook:2622
msgid "A type mapping from <literal>java.lang.Class</literal> to <literal>VARCHAR</literal> (or Oracle <literal>VARCHAR2</literal>). A <literal>Class</literal> is mapped to its fully qualified name."
msgstr ""

#: index.docbook:2630
msgid "binary"
msgstr ""

#: index.docbook:2632
msgid "Maps byte arrays to an appropriate SQL binary type."
msgstr ""

#: index.docbook:2638
msgid "text"
msgstr ""

#: index.docbook:2640
msgid "Maps long Java strings to a SQL <literal>CLOB</literal> or <literal>TEXT</literal> type."
msgstr ""

#: index.docbook:2647
msgid "serializable"
msgstr ""

#: index.docbook:2649
msgid "Maps serializable Java types to an appropriate SQL binary type. You may also indicate the Hibernate type <literal>serializable</literal> with the name of a serializable Java class or interface that does not default to a basic type."
msgstr ""

#: index.docbook:2658
msgid "clob, blob"
msgstr ""

#: index.docbook:2660
msgid "Type mappings for the JDBC classes <literal>java.sql.Clob</literal> and <literal>java.sql.Blob</literal>. These types may be inconvenient for some applications, since the blob or clob object may not be reused outside of a transaction. (Furthermore, driver support is patchy and inconsistent.)"
msgstr ""

#: index.docbook:2670
msgid "imm_date, imm_time, imm_timestamp, imm_calendar, imm_calendar_date, imm_serializable, imm_binary"
msgstr ""

#: index.docbook:2674
msgid "Type mappings for what are usually considered mutable Java types, where Hibernate makes certain optimizations appropriate only for immutable Java types, and the application treats the object as immutable. For example, you should not call <literal>Date.setTime()</literal> for an instance mapped as <literal>imm_timestamp</literal>. To change the value of the property, and have that change made persistent, the application must assign a new (nonidentical) object to the property."
msgstr ""

#: index.docbook:2689
msgid "Unique identifiers of entities and collections may be of any basic type except <literal>binary</literal>, <literal>blob</literal> and <literal>clob</literal>. (Composite identifiers are also allowed, see below.)"
msgstr ""

#: index.docbook:2695
msgid "The basic value types have corresponding <literal>Type</literal> constants defined on <literal>org.hibernate.Hibernate</literal>. For example, <literal>Hibernate.STRING</literal> represents the <literal>string</literal> type."
msgstr ""

#: index.docbook:2704
msgid "Custom value types"
msgstr ""

#: index.docbook:2706
msgid "It is relatively easy for developers to create their own value types. For example, you might want to persist properties of type <literal>java.lang.BigInteger</literal> to <literal>VARCHAR</literal> columns. Hibernate does not provide a built-in type for this. But custom types are not limited to mapping a property (or collection element) to a single table column. So, for example, you might have a Java property <literal>getName()</literal>/<literal>setName()</literal> of type <literal>java.lang.String</literal> that is persisted to the columns <literal>FIRST_NAME</literal>, <literal>INITIAL</literal>, <literal>SURNAME</literal>."
msgstr ""

#: index.docbook:2717
msgid "To implement a custom type, implement either <literal>org.hibernate.UserType</literal> or <literal>org.hibernate.CompositeUserType</literal> and declare properties using the fully qualified classname of the type. Check out <literal>org.hibernate.test.DoubleStringType</literal> to see the kind of things that are possible."
msgstr ""

#: index.docbook:2725
msgid ""
      "<![CDATA[<property name=\"twoStrings\" type=\"org.hibernate.test.DoubleStringType\">\n"
      "    <column name=\"first_string\"/>\n"
      "    <column name=\"second_string\"/>\n"
      "</property>]]>"
msgstr ""

#: index.docbook:2727
msgid "Notice the use of <literal>&lt;column&gt;</literal> tags to map a property to multiple columns."
msgstr ""

#: index.docbook:2732
msgid "The <literal>CompositeUserType</literal>, <literal>EnhancedUserType</literal>, <literal>UserCollectionType</literal>, and <literal>UserVersionType</literal> interfaces provide support for more specialized uses."
msgstr ""

#: index.docbook:2738
msgid "You may even supply parameters to a <literal>UserType</literal> in the mapping file. To do this, your <literal>UserType</literal> must implement the <literal>org.hibernate.usertype.ParameterizedType</literal> interface. To supply parameters to your custom type, you can use the <literal>&lt;type&gt;</literal> element in your mapping files."
msgstr ""

#: index.docbook:2746
msgid ""
      "<![CDATA[<property name=\"priority\">\n"
      "    <type name=\"com.mycompany.usertypes.DefaultValueIntegerType\">\n"
      "        <param name=\"default\">0</param>\n"
      "    </type>\n"
      "</property>]]>"
msgstr ""

#: index.docbook:2748
msgid "The <literal>UserType</literal> can now retrieve the value for the parameter named <literal>default</literal> from the <literal>Properties</literal> object passed to it."
msgstr ""

#: index.docbook:2753
msgid "If you use a certain <literal>UserType</literal> very often, it may be useful to define a shorter name for it. You can do this using the <literal>&lt;typedef&gt;</literal> element. Typedefs assign a name to a custom type, and may also contain a list of default parameter values if the type is parameterized."
msgstr ""

#: index.docbook:2760
msgid ""
      "<![CDATA[<typedef class=\"com.mycompany.usertypes.DefaultValueIntegerType\" name=\"default_zero\">\n"
      "    <param name=\"default\">0</param>\n"
      "</typedef>]]>"
msgstr ""

#: index.docbook:2762
msgid "<![CDATA[<property name=\"priority\" type=\"default_zero\"/>]]>"
msgstr ""

#: index.docbook:2764
msgid "It is also possible to override the parameters supplied in a typedef on a case-by-case basis by using type parameters on the property mapping."
msgstr ""

#: index.docbook:2769
msgid "Even though Hibernate's rich range of built-in types and support for components means you will very rarely <emphasis>need</emphasis> to use a custom type, it is nevertheless considered good form to use custom types for (non-entity) classes that occur frequently in your application. For example, a <literal>MonetaryAmount</literal> class is a good candidate for a <literal>CompositeUserType</literal>, even though it could easily be mapped as a component. One motivation for this is abstraction. With a custom type, your mapping documents would be future-proofed against possible changes in your way of representing monetary values."
msgstr ""

#: index.docbook:2785
msgid "Mapping a class more than once"
msgstr ""

#: index.docbook:2786
msgid "It is possible to provide more than one mapping for a particular persistent class. In this case you must specify an <emphasis>entity name</emphasis> do disambiguate between instances of the two mapped entities. (By default, the entity name is the same as the class name.) Hibernate lets you specify the entity name when working with persistent objects, when writing queries, or when mapping associations to the named entity."
msgstr ""

#: index.docbook:2794
msgid ""
      "<![CDATA[<class name=\"Contract\" table=\"Contracts\"\n"
      "        entity-name=\"CurrentContract\">\n"
      "    ...\n"
      "    <set name=\"history\" inverse=\"true\"\n"
      "            order-by=\"effectiveEndDate desc\">\n"
      "        <key column=\"currentContractId\"/>\n"
      "        <one-to-many entity-name=\"HistoricalContract\"/>\n"
      "    </set>\n"
      "</class>\n"
      "\n"
      "<class name=\"Contract\" table=\"ContractHistory\"\n"
      "        entity-name=\"HistoricalContract\">\n"
      "    ...\n"
      "    <many-to-one name=\"currentContract\"\n"
      "            column=\"currentContractId\"\n"
      "            entity-name=\"CurrentContract\"/>\n"
      "</class>]]>"
msgstr ""

#: index.docbook:2796
msgid "Notice how associations are now specified using <literal>entity-name</literal> instead of <literal>class</literal>."
msgstr ""

#: index.docbook:2804
msgid "SQL quoted identifiers"
msgstr ""

#: index.docbook:2805
msgid "You may force Hibernate to quote an identifier in the generated SQL by enclosing the table or column name in backticks in the mapping document. Hibernate will use the correct quotation style for the SQL <literal>Dialect</literal> (usually double quotes, but brackets for SQL Server and backticks for MySQL)."
msgstr ""

#: index.docbook:2812
msgid ""
      "<![CDATA[<class name=\"LineItem\" table=\"`Line Item`\">\n"
      "    <id name=\"id\" column=\"`Item Id`\"/><generator class=\"assigned\"/></id>\n"
      "    <property name=\"itemNumber\" column=\"`Item #`\"/>\n"
      "    ...\n"
      "</class>]]>"
msgstr ""

#: index.docbook:2818
msgid "Metadata alternatives"
msgstr ""

#: index.docbook:2820
msgid "XML isn't for everyone, and so there are some alternative ways to define O/R mapping metadata in Hibernate."
msgstr ""

#: index.docbook:2825
msgid "Using XDoclet markup"
msgstr ""

#: index.docbook:2827
msgid "Many Hibernate users prefer to embed mapping information directly in sourcecode using XDoclet <literal>@hibernate.tags</literal>. We will not cover this approach in this document, since strictly it is considered part of XDoclet. However, we include the following example of the <literal>Cat</literal> class with XDoclet mappings."
msgstr ""

#: index.docbook:2834
msgid ""
      "<![CDATA[package eg;\n"
      "import java.util.Set;\n"
      "import java.util.Date;\n"
      "\n"
      "/**\n"
      " * @hibernate.class\n"
      " *  table=\"CATS\"\n"
      " */\n"
      "public class Cat {\n"
      "    private Long id; // identifier\n"
      "    private Date birthdate;\n"
      "    private Cat mother;\n"
      "    private Set kittens\n"
      "    private Color color;\n"
      "    private char sex;\n"
      "    private float weight;\n"
      "\n"
      "    /*\n"
      "     * @hibernate.id\n"
      "     *  generator-class=\"native\"\n"
      "     *  column=\"CAT_ID\"\n"
      "     */\n"
      "    public Long getId() {\n"
      "        return id;\n"
      "    }\n"
      "    private void setId(Long id) {\n"
      "        this.id=id;\n"
      "    }\n"
      "\n"
      "    /**\n"
      "     * @hibernate.many-to-one\n"
      "     *  column=\"PARENT_ID\"\n"
      "     */\n"
      "    public Cat getMother() {\n"
      "        return mother;\n"
      "    }\n"
      "    void setMother(Cat mother) {\n"
      "        this.mother = mother;\n"
      "    }\n"
      "\n"
      "    /**\n"
      "     * @hibernate.property\n"
      "     *  column=\"BIRTH_DATE\"\n"
      "     */\n"
      "    public Date getBirthdate() {\n"
      "        return birthdate;\n"
      "    }\n"
      "    void setBirthdate(Date date) {\n"
      "        birthdate = date;\n"
      "    }\n"
      "    /**\n"
      "     * @hibernate.property\n"
      "     *  column=\"WEIGHT\"\n"
      "     */\n"
      "    public float getWeight() {\n"
      "        return weight;\n"
      "    }\n"
      "    void setWeight(float weight) {\n"
      "        this.weight = weight;\n"
      "    }\n"
      "\n"
      "    /**\n"
      "     * @hibernate.property\n"
      "     *  column=\"COLOR\"\n"
      "     *  not-null=\"true\"\n"
      "     */\n"
      "    public Color getColor() {\n"
      "        return color;\n"
      "    }\n"
      "    void setColor(Color color) {\n"
      "        this.color = color;\n"
      "    }\n"
      "    /**\n"
      "     * @hibernate.set\n"
      "     *  inverse=\"true\"\n"
      "     *  order-by=\"BIRTH_DATE\"\n"
      "     * @hibernate.collection-key\n"
      "     *  column=\"PARENT_ID\"\n"
      "     * @hibernate.collection-one-to-many\n"
      "     */\n"
      "    public Set getKittens() {\n"
      "        return kittens;\n"
      "    }\n"
      "    void setKittens(Set kittens) {\n"
      "        this.kittens = kittens;\n"
      "    }\n"
      "    // addKitten not needed by Hibernate\n"
      "    public void addKitten(Cat kitten) {\n"
      "        kittens.add(kitten);\n"
      "    }\n"
      "\n"
      "    /**\n"
      "     * @hibernate.property\n"
      "     *  column=\"SEX\"\n"
      "     *  not-null=\"true\"\n"
      "     *  update=\"false\"\n"
      "     */\n"
      "    public char getSex() {\n"
      "        return sex;\n"
      "    }\n"
      "    void setSex(char sex) {\n"
      "        this.sex=sex;\n"
      "    }\n"
      "}]]>"
msgstr ""

#: index.docbook:2836
msgid "See the Hibernate web site for more examples of XDoclet and Hibernate."
msgstr ""

#: index.docbook:2843
msgid "Using JDK 5.0 Annotations"
msgstr ""

#: index.docbook:2845
msgid "JDK 5.0 introduced XDoclet-style annotations at the language level, type-safe and checked at compile time. This mechnism is more powerful than XDoclet annotations and better supported by tools and IDEs. IntelliJ IDEA, for example, supports auto-completion and syntax highlighting of JDK 5.0 annotations. The new revision of the EJB specification (JSR-220) uses JDK 5.0 annotations as the primary metadata mechanism for entity beans. Hibernate3 implements the <literal>EntityManager</literal> of JSR-220 (the persistence API), support for mapping metadata is available via the <emphasis>Hibernate Annotations</emphasis> package, as a separate download. Both EJB3 (JSR-220) and Hibernate3 metadata is supported."
msgstr ""

#: index.docbook:2856
msgid "This is an example of a POJO class annotated as an EJB entity bean:"
msgstr ""

#: index.docbook:2860
msgid ""
      "<![CDATA[@Entity(access = AccessType.FIELD)\n"
      "public class Customer implements Serializable {\n"
      "\n"
      "    @Id;\n"
      "    Long id;\n"
      "\n"
      "    String firstName;\n"
      "    String lastName;\n"
      "    Date birthday;\n"
      "\n"
      "    @Transient\n"
      "    Integer age;\n"
      "\n"
      "    @Embedded\n"
      "    private Address homeAddress;\n"
      "\n"
      "    @OneToMany(cascade=CascadeType.ALL)\n"
      "    @JoinColumn(name=\"CUSTOMER_ID\")\n"
      "    Set<Order> orders;\n"
      "\n"
      "    // Getter/setter and business methods\n"
      "}]]>"
msgstr ""

#: index.docbook:2862
msgid "Note that support for JDK 5.0 Annotations (and JSR-220) is still work in progress and not completed. Please refer to the Hibernate Annotations module for more details."
msgstr ""

#: index.docbook:2871
msgid "Generated Properties"
msgstr ""

#: index.docbook:2872
msgid "Generated properties are properties which have their values generated by the database. Typically, Hibernate applications needed to <literal>refresh</literal> objects which contain any properties for which the database was generating values. Marking properties as generated, however, lets the application delegate this responsibility to Hibernate. Essentially, whenever Hibernate issues an SQL INSERT or UPDATE for an entity which has defined generated properties, it immediately issues a select afterwards to retrieve the generated values."
msgstr ""

#: index.docbook:2881
msgid "Properties marked as generated must additionally be non-insertable and non-updateable. Only <xref linkend=\"mapping-declaration-version\"/>versions, <xref linkend=\"mapping-declaration-timestamp\"/>timestamps, and <xref linkend=\"mapping-declaration-property\"/>simple properties can be marked as generated."
msgstr ""

#: index.docbook:2888
msgid "<literal>never</literal> (the default) - means that the given property value is not generated within the database."
msgstr ""

#: index.docbook:2892
msgid "<literal>insert</literal> - states that the given property value is generated on insert, but is not regenerated on subsequent updates. Things like created-date would fall into this category. Note that even thought <xref linkend=\"mapping-declaration-version\"/>version and <xref linkend=\"mapping-declaration-timestamp\"/>timestamp properties can be marked as generated, this option is not available there..."
msgstr ""

#: index.docbook:2900
msgid "<literal>always</literal> - states that the property value is generated both on insert and on update."
msgstr ""

#: index.docbook:2907
msgid "Auxiliary Database Objects"
msgstr ""

#: index.docbook:2908
msgid "Allows CREATE and DROP of arbitrary database objects, in conjunction with Hibernate's schema evolution tools, to provide the ability to fully define a user schema within the Hibernate mapping files. Although designed specifically for creating and dropping things like triggers or stored procedures, really any SQL command that can be run via a <literal>java.sql.Statement.execute()</literal> method is valid here (ALTERs, INSERTS, etc). There are essentially two modes for defining auxiliary database objects..."
msgstr ""

#: index.docbook:2917
msgid "The first mode is to explicitly list the CREATE and DROP commands out in the mapping file:"
msgstr ""

#: index.docbook:2921
msgid ""
      "<![CDATA[<hibernate-mapping>\n"
      "    ...\n"
      "    <database-object>\n"
      "        <create>CREATE TRIGGER my_trigger ...</create>\n"
      "        <drop>DROP TRIGGER my_trigger</drop>\n"
      "    </database-object>\n"
      "</hibernate-mapping>]]>"
msgstr ""

#: index.docbook:2922
msgid "The second mode is to supply a custom class which knows how to construct the CREATE and DROP commands. This custom class must implement the <literal>org.hibernate.mapping.AuxiliaryDatabaseObject</literal> interface."
msgstr ""

#: index.docbook:2927
msgid ""
      "<![CDATA[<hibernate-mapping>\n"
      "    ...\n"
      "    <database-object>\n"
      "        <definition class=\"MyTriggerDefinition\"/>\n"
      "    </database-object>\n"
      "</hibernate-mapping>]]>"
msgstr ""

#: index.docbook:2928
msgid "Additionally, these database objects can be optionally scoped such that they only apply when certain dialects are used."
msgstr ""

#: index.docbook:2932
msgid ""
      "<![CDATA[<hibernate-mapping>\n"
      "    ...\n"
      "    <database-object>\n"
      "        <definition class=\"MyTriggerDefinition\"/>\n"
      "        <dialect-scope name=\"org.hibernate.dialect.Oracle9Dialect\"/>\n"
      "        <dialect-scope name=\"org.hibernate.dialect.OracleDialect\"/>\n"
      "    </database-object>\n"
      "</hibernate-mapping>]]>"
msgstr ""

msgid "ROLES_OF_TRANSLATORS"
msgstr "<!--TRANS:ROLES_OF_TRANSLATORS-->"

msgid "CREDIT_FOR_TRANSLATORS"
msgstr "<!--TRANS:CREDIT_FOR_TRANSLATORS-->"

