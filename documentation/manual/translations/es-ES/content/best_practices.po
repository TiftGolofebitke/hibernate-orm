msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2007-10-25 07:47+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: best_practices.xml:5
#, no-c-format
msgid "Best Practices"
msgstr "Mejores Prácticas"

#. Tag: term
#: best_practices.xml:9
#, no-c-format
msgid ""
"Write fine-grained classes and map them using <literal>&lt;component&gt;</"
"literal>."
msgstr ""
"Escribe clase finamente granularizadas y mapealas usando <literal>&lt;"
"component&gt;</literal>."

#. Tag: para
#: best_practices.xml:11
#, no-c-format
msgid ""
"Use an <literal>Address</literal> class to encapsulate <literal>street</"
"literal>, <literal>suburb</literal>, <literal>state</literal>, "
"<literal>postcode</literal>. This encourages code reuse and simplifies "
"refactoring."
msgstr ""
"Usa una clase <literal>Dirección</literal> para encapsular <literal>calle</"
"literal>, <literal>distrito</literal>, <literal>estado</literal>, "
"<literal>código postal</literal>. Esto alienta la reutilización de código y "
"simplifica el refactoring."

#. Tag: term
#: best_practices.xml:19
#, no-c-format
msgid "Declare identifier properties on persistent classes."
msgstr "Declara las propiedades identificadoras en clases persistentes."

#. Tag: para
#: best_practices.xml:21
#, no-c-format
msgid ""
"Hibernate makes identifier properties optional. There are all sorts of "
"reasons why you should use them. We recommend that identifiers be "
"'synthetic' (generated, with no business meaning)."
msgstr ""
"Hibernate hace opcionales las propiedades identificadoras. Existen todo tipo "
"de razones por las que debes usarlas. Recomendamos que los identificadores "
"sean 'sintéticos' (generados, sin ningún significado de negocio)."

#. Tag: term
#: best_practices.xml:29
#, no-c-format
msgid "Identify natural keys."
msgstr "Identifica las claves naturales."

#. Tag: para
#: best_practices.xml:31
#, no-c-format
msgid ""
"Identify natural keys for all entities, and map them using <literal>&lt;"
"natural-id&gt;</literal>. Implement <literal>equals()</literal> and "
"<literal>hashCode()</literal> to compare the properties that make up the "
"natural key."
msgstr ""
"Identifica las claves naturales de todas las entidades, y mapealas usando "
"<literal>&lt;natural-id&gt;</literal>. Implementa <literal>equals()</"
"literal> y <literal>hashCode()</literal> para comparar las propiedades que "
"componen la clave natural."

#. Tag: term
#: best_practices.xml:39
#, no-c-format
msgid "Place each class mapping in its own file."
msgstr "Coloca cada mapeo de clase en su propio fichero."

#. Tag: para
#: best_practices.xml:41
#, no-c-format
msgid ""
"Don't use a single monolithic mapping document. Map <literal>com.eg.Foo</"
"literal> in the file <literal>com/eg/Foo.hbm.xml</literal>. This makes "
"particularly good sense in a team environment."
msgstr ""
"No uses un solo documento monolítico de mapeo. Mapea <literal>com.eg.Foo</"
"literal> en el fichero <literal>com/eg/Foo.hbm.xml</literal>. Esto tiene "
"sentido particularmente en un ambiente de equipo."

#. Tag: term
#: best_practices.xml:49
#, no-c-format
msgid "Load mappings as resources."
msgstr "Carga los mapeos como recursos."

#. Tag: para
#: best_practices.xml:51
#, no-c-format
msgid "Deploy the mappings along with the classes they map."
msgstr "Despliega los mapeos junto a las clases que mapean."

#. Tag: term
#: best_practices.xml:57
#, no-c-format
msgid "Consider externalising query strings."
msgstr "Considera externalizar las cadenas de consulta."

#. Tag: para
#: best_practices.xml:59
#, no-c-format
msgid ""
"This is a good practice if your queries call non-ANSI-standard SQL "
"functions. Externalising the query strings to mapping files will make the "
"application more portable."
msgstr ""
"Esta es una buena práctica si tus consultas llaman a funciones SQL que no "
"son del estándar ANSI. Externalizar las cadenas de consulta a ficheros de "
"mapeo hará la aplicación más portable."

#. Tag: term
#: best_practices.xml:67
#, no-c-format
msgid "Use bind variables."
msgstr "Usa variables de ligado."

#. Tag: para
#: best_practices.xml:69
#, no-c-format
msgid ""
"As in JDBC, always replace non-constant values by \"?\". Never use string "
"manipulation to bind a non-constant value in a query! Even better, consider "
"using named parameters in queries."
msgstr ""
"Igual que en JDBC, siempre remplaza valores no constantes con \"?\". ¡Nunca "
"uses manipulación de cadenas para ligar un valor no constante en una "
"consulta! Incluso mejor, considera usar parámetros con nombre en las "
"consultas."

#. Tag: term
#: best_practices.xml:77
#, no-c-format
msgid "Don't manage your own JDBC connections."
msgstr "No manejes tus propias conexiones JDBC."

#. Tag: para
#: best_practices.xml:79
#, no-c-format
msgid ""
"Hibernate lets the application manage JDBC connections. This approach should "
"be considered a last-resort. If you can't use the built-in connections "
"providers, consider providing your own implementation of <literal>org."
"hibernate.connection.ConnectionProvider</literal>."
msgstr ""
"Hibernate deja a la aplicación administre las conexiones JDBC. Este enfoque "
"debe considerarse como último recurso. Si no puedes usar los provedores de "
"conexión prefabricados, considera prover tu propia implementación de "
"<literal>org.hibernate.connection.ConnectionProvider</literal>."

#. Tag: term
#: best_practices.xml:87
#, no-c-format
msgid "Consider using a custom type."
msgstr "Considera usar un tipo personalizado."

#. Tag: para
#: best_practices.xml:89
#, no-c-format
msgid ""
"Suppose you have a Java type, say from some library, that needs to be "
"persisted but doesn't provide the accessors needed to map it as a component. "
"You should consider implementing <literal>org.hibernate.UserType</literal>. "
"This approach frees the application code from implementing transformations "
"to / from a Hibernate type."
msgstr ""
"Supón que tienes un tipo Java, digamos de alguna biblioteca, que necesita "
"hacerse persistente pero no provee los métodos de acceso necesarios para "
"mapearlo como un componente. Debes considerar implementar <literal>org."
"hibernate.UserType</literal>. Este enfoque libera al código de aplicación de "
"implementar transformaciones a / desde un tipo Hibernate."

#. Tag: term
#: best_practices.xml:98
#, no-c-format
msgid "Use hand-coded JDBC in bottlenecks."
msgstr "Usa JDBC codificado a mano en cuellos de botella."

#. Tag: para
#: best_practices.xml:100
#, no-c-format
msgid ""
"In performance-critical areas of the system, some kinds of operations might "
"benefit from direct JDBC. But please, wait until you <emphasis>know</"
"emphasis> something is a bottleneck. And don't assume that direct JDBC is "
"necessarily faster. If you need to use direct JDBC, it might be worth "
"opening a Hibernate <literal>Session</literal> and using that JDBC "
"connection. That way you can still use the same transaction strategy and "
"underlying connection provider."
msgstr ""
"En áreas del sistema de rendimiento crítico, algunos tipos de operaciones "
"podrían beneficiarse del JDBC directo. Pero por favor, espero hasta que "
"<emphasis>sepas</emphasis> que algo es un cuello de botella. Y no asumas que "
"el JDBC directo es necesariamente más rápido. Si necesitas usar JDBC "
"directo, podría ser valioso abrir una <literal>Session</literal> de "
"Hibernate y usar esa conexión JDBC. De esta forma puedes usar aún la misma "
"estrategia de transacción y el mismo proveedor de conexiones subyacente."

#. Tag: term
#: best_practices.xml:110
#, no-c-format
msgid "Understand <literal>Session</literal> flushing."
msgstr "Comprende la limpieza (flushing) de <literal>Session</literal>."

#. Tag: para
#: best_practices.xml:112
#, no-c-format
msgid ""
"From time to time the Session synchronizes its persistent state with the "
"database. Performance will be affected if this process occurs too often. You "
"may sometimes minimize unnecessary flushing by disabling automatic flushing "
"or even by changing the order of queries and other operations within a "
"particular transaction."
msgstr ""
"De vez en cuando la sesión sincroniza su estado persistente con la base de "
"datos. El rendimiento se verá afectado si este proceso ocurre demasiado "
"frecuentemente. A veces puedes minimizar limpieza innecesaria deshabilitando "
"la limpieza automática o incluso cambiando el orden de las consultas u otras "
"operaciones en una transacción en particular."

#. Tag: term
#: best_practices.xml:121
#, no-c-format
msgid "In a three tiered architecture, consider using detached objects."
msgstr "En una aplicación en tres gradas, considera usar objetos separados."

#. Tag: para
#: best_practices.xml:123
#, no-c-format
msgid ""
"When using a servlet / session bean architecture, you could pass persistent "
"objects loaded in the session bean to and from the servlet / JSP layer. Use "
"a new session to service each request. Use <literal>Session.merge()</"
"literal> or <literal>Session.saveOrUpdate()</literal> to synchronize objects "
"with the database."
msgstr ""
"Al usar una arquitectura de servlet / sesión, puedes pasar objetos "
"persistentes en el bean de sesión hacia y desde la capa de servlet / JSP. "
"Usa una sesión nueva para atender el servicio de cada petición. Usa "
"<literal>Session.merge()</literal> o <literal>Session.saveOrUpdate()</"
"literal> para sincronizar los objetos con la base de datos."

#. Tag: term
#: best_practices.xml:132
#, no-c-format
msgid "In a two tiered architecture, consider using long persistence contexts."
msgstr ""
"En una arquitectura en dos gradas, considera usar contexto de persistencia "
"largos."

#. Tag: para
#: best_practices.xml:134
#, no-c-format
msgid ""
"Database Transactions have to be as short as possible for best scalability. "
"However, it is often neccessary to implement long running "
"<emphasis>application transactions</emphasis>, a single unit-of-work from "
"the point of view of a user. An application transaction might span several "
"client request/response cycles. It is common to use detached objects to "
"implement application transactions. An alternative, extremely appropriate in "
"two tiered architecture, is to maintain a single open persistence contact "
"(session) for the whole life cycle of the application transaction and simply "
"disconnect from the JDBC connection at the end of each request and reconnect "
"at the beginning of the subsequent request. Never share a single session "
"across more than one application transaction, or you will be working with "
"stale data."
msgstr ""
"Las transacciones de base de datos tienen que ser tan cortas como sea "
"posible. Sin embargo, frecuentemente es necesario implementar "
"<emphasis>transacciones de aplicación</emphasis> ejecutándose en largo, una "
"sola unidad de trabajo desde el punto de vista de un usuario. Una "
"transacción de aplicación puede abarcar muchos ciclos petición/respuesta del "
"cliente. Es común usar objetos separados para implementar transacciones de "
"aplicación. Una alternativa, extremadamente apropiada en arquitecturas en "
"dos gradas, es mantener un solo contacto de persistencia abierto (sesión) "
"para todo el ciclo de vida de la transacción de aplicación y simplemente "
"desconectar de la conexión JDBC al final de cada petición, y reconectar al "
"comienzo de la petición subsecuente. Nunca compartas una única sesión a "
"través de más de una transacción de aplicación, o estarás trabajando con "
"datos añejos."

#. Tag: term
#: best_practices.xml:148
#, no-c-format
msgid "Don't treat exceptions as recoverable."
msgstr "No trates la excepciones como recuperables."

#. Tag: para
#: best_practices.xml:150
#, no-c-format
msgid ""
"This is more of a necessary practice than a \"best\" practice. When an "
"exception occurs, roll back the <literal>Transaction</literal> and close the "
"<literal>Session</literal>. If you don't, Hibernate can't guarantee that in-"
"memory state accurately represents persistent state. As a special case of "
"this, do not use <literal>Session.load()</literal> to determine if an "
"instance with the given identifier exists on the database; use "
"<literal>Session.get()</literal> or a query instead."
msgstr ""
"Esto es más una práctica necesaria que una \"mejor\" práctica. Cuando ocurra "
"una excepción, deshaz (rollback) la <literal>Transaction</literal> y cierra "
"la <literal>Session</literal>. Si no lo haces, Hibernate no puede garantizar "
"que el estado en memoria representa con exactitud el estado persistente. "
"Como un caso especial de esto, no uses <literal>Session.load()</literal> "
"para determinar si una instancia con el identificador dado existe en la base "
"de datos. En cambio, usa <literal>Session.get()</literal> o una consulta."

#. Tag: term
#: best_practices.xml:160
#, no-c-format
msgid "Prefer lazy fetching for associations."
msgstr "Prefiere la recuperación perezosa para las asociaciones."

#. Tag: para
#: best_practices.xml:162
#, no-c-format
msgid ""
"Use eager fetching sparingly. Use proxies and lazy collections for most "
"associations to classes that are not likely to be completely held in the "
"second-level cache. For associations to cached classes, where there is an a "
"extremely high probability of a cache hit, explicitly disable eager fetching "
"using <literal>lazy=\"false\"</literal>. When an join fetching is "
"appropriate to a particular use case, use a query with a <literal>left join "
"fetch</literal>."
msgstr ""
"Usa escasamente la recuperación temprana. Usa proxies y colecciones "
"perezosas para la mayoría de asociaciones a clases probablemente no estén "
"mantenidas en el caché de segundo nivel. Para las asociaciones a clases en "
"caché, donde hay una probabilidad de acceso a caché extremadamente alta, "
"deshabilita explícitamente la recuperación temprana usando <literal>lazy="
"\"false\"</literal>. Cuando sea apropiada la recuperación por unión (join "
"fetching) para un caso de uso en particular, usa una consulta con un "
"<literal>left join fetch</literal>."

#. Tag: term
#: best_practices.xml:172
#, no-c-format
msgid ""
"Use the <emphasis>open session in view</emphasis> pattern, or a disciplined "
"<emphasis>assembly phase</emphasis> to avoid problems with unfetched data."
msgstr ""
"Usa el patrón <emphasis>sesión abierta en vista</emphasis>, o una "
"<emphasis>fase de ensamblado</emphasis> disciplinada para evitar problemas "
"con datos no recuperados."

#. Tag: para
#: best_practices.xml:177
#, no-c-format
msgid ""
"Hibernate frees the developer from writing tedious <emphasis>Data Transfer "
"Objects</emphasis> (DTO). In a traditional EJB architecture, DTOs serve dual "
"purposes: first, they work around the problem that entity beans are not "
"serializable; second, they implicitly define an assembly phase where all "
"data to be used by the view is fetched and marshalled into the DTOs before "
"returning control to the presentation tier. Hibernate eliminates the first "
"purpose. However, you will still need an assembly phase (think of your "
"business methods as having a strict contract with the presentation tier "
"about what data is available in the detached objects) unless you are "
"prepared to hold the persistence context (the session) open across the view "
"rendering process. This is not a limitation of Hibernate! It is a "
"fundamental requirement of safe transactional data access."
msgstr ""
"Hibernate liberal al desarrollador de escribir <emphasis>Objetos de "
"Transferencia de Datos (Data Transfer Objects)</emphasis> (DTO). En una "
"arquitectura tradicional de EJB, los DTOs tienen un propósito doble: "
"primero, atacan el problema que los beans de entidad no son serializables. "
"Segundo, definen implícitamente una fase de ensamblado cuando se recuperan y "
"se forman (marshalling) todos los datos a usar por la vista en los DTOs "
"antes de devolver el control a la grada de presentación. Hibernate elimina "
"el primer propósito. Sin embargo, aún necesitas una fase de ensamblado "
"(piensa en tus métodos de negocio como si tuviesen un contrato estricto con "
"la grada de presentación sobre qué datos están disponibles en los objetos "
"separados) a menos que estés preparado para tener el contexto de "
"persistencia (la sesión) abierto a través del proceso de renderización de la "
"vista. ¡Esta no es una limitación de Hibernate! Es un requerimiento "
"fundamental de acceso seguro a datos transaccionales."

#. Tag: term
#: best_practices.xml:191
#, no-c-format
msgid "Consider abstracting your business logic from Hibernate."
msgstr "Considera abstraer tu lógica de negocio de Hibernate"

#. Tag: para
#: best_practices.xml:193
#, no-c-format
msgid ""
"Hide (Hibernate) data-access code behind an interface. Combine the "
"<emphasis>DAO</emphasis> and <emphasis>Thread Local Session</emphasis> "
"patterns. You can even have some classes persisted by handcoded JDBC, "
"associated to Hibernate via a <literal>UserType</literal>. (This advice is "
"intended for \"sufficiently large\" applications; it is not appropriate for "
"an application with five tables!)"
msgstr ""
"Oculta el código de acceso a datos (Hibernate) detrás de una interface. "
"Combina los patrones <emphasis>DAO</emphasis> y <emphasis>Sesión de Hebra "
"Local</emphasis>. Incluso puedes tener algunas clases hechas persistentes "
"por JDBC escrito a mano, asociadas a Hibernate por medio de un "
"<literal>UserType</literal>. (Este consejo está pensado para aplicaciones "
"\"suficientemente grandes\"; ¡no es apropiado para una aplicación con cinco "
"tablas!)"

#. Tag: term
#: best_practices.xml:203
#, no-c-format
msgid "Don't use exotic association mappings."
msgstr "No uses mapeos de asociación exóticos."

#. Tag: para
#: best_practices.xml:205
#, no-c-format
msgid ""
"Good usecases for a real many-to-many associations are rare. Most of the "
"time you need additional information stored in the \"link table\". In this "
"case, it is much better to use two one-to-many associations to an "
"intermediate link class. In fact, we think that most associations are one-to-"
"many and many-to-one, you should be careful when using any other association "
"style and ask yourself if it is really neccessary."
msgstr ""
"Son raros los casos de uso de asociaciones reales muchos-a-muchos. La mayor "
"parte del tiempo necesitas información adicional almacenada en una \"tabla "
"de enlace\". En este caso, es mucho mejor usar dos asociaciones uno-a-muchos "
"a una clase de enlace intermedia. De hecho, pensamos que la mayoría de "
"asociaciones son uno-a-muchos y muchos-a-uno, debes ser cuidadoso al usr "
"cualquier otro estilo de asociación y preguntarte si es realmente necesario."

#. Tag: term
#: best_practices.xml:215
#, no-c-format
msgid "Prefer bidirectional associations."
msgstr "Prefiere las asociaciones bidireccionales."

#. Tag: para
#: best_practices.xml:217
#, no-c-format
msgid ""
"Unidirectional associations are more difficult to query. In a large "
"application, almost all associations must be navigable in both directions in "
"queries."
msgstr ""
"Las asociaciones unidireccionales son más difíciles de consultar. En una "
"aplicación grande, casi todas las asociaciones deben ser navegables en ambas "
"direcciones en consultas."
