#, fuzzy
msgid ""
msgstr ""
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Content-Type: text/plain; charset=utf-8\n"
#: index.docbook:5
msgid "Transactions And Concurrency"
msgstr "Transacciones y Concurrencia"

#: index.docbook:7
msgid "The most important point about Hibernate and concurrency control is that it is very easy to understand. Hibernate directly uses JDBC connections and JTA resources without adding any additional locking behavior. We highly recommend you spend some time with the JDBC, ANSI, and transaction isolation specification of your database management system."
msgstr "El punto m&#x00e1;s importante sobre Hibernate y el control de concurrencia es que muy f&#x00e1;cil de comprender. Hibernate usa directamente conexiones JDBC y recursos JTA sin agregar ning&#x00fa;n comportamiento de bloqueo adicional. Recomendamos altamente que gastes algo de tiempo con la especificaci&#x00f3;n de JDBC, ANSI, y el aislamiento de transacciones de tu sistema de gesti&#x00f3;n de base de datos. Hibernate s&#x00f3;lo a&#x00f1;ade versionado autom&#x00e1;tico pero no bloquea objetos en memoria ni cambia el nivel de aislamiento de tus transacciones de base de datos. B&#x00e1;sicamente, usa Hibernate como usar&#x00ed;as JDBC directo (o JTA/CMT) con tus recursos de base de datos."

#: index.docbook:14
msgid "Hibernate does not lock objects in memory. Your application can expect the behavior as defined by the isolation level of your database transactions. Note that thanks to the <literal>Session</literal>, which is also a transaction-scoped cache, Hibernate provides repeatable reads for lookup by identifier and entity queries (not reporting queries that return scalar values)."
msgstr "Sin embargo, adem&#x00e1;s del versionado autom&#x00e1;tico, Hibernate ofrece una API (menor) para bloqueo pesimista de filas, usando la sint&#x00e1;xis <literal>SELECT FOR UPDATE</literal>. Esta API se discute m&#x00e1;s adelante en este cap&#x00ed;tulo:"

#: index.docbook:22
msgid "In addition to versioning for automatic optimistic concurrency control, Hibernate also offers a (minor) API for pessimistic locking of rows, using the <literal>SELECT FOR UPDATE</literal> syntax. Optimistic concurrency control and this API are discussed later in this chapter."
msgstr "Comenzamos la discusi&#x00f3;n del control de concurrencia en Hibernate con la granularidad de <literal>Configuration</literal>, <literal>SessionFactory</literal>, y <literal>Session</literal>, as&#x00ed; como la base de datos y las transacciones de aplicaci&#x00f3;n largas."

#: index.docbook:29
msgid "We start the discussion of concurrency control in Hibernate with the granularity of <literal>Configuration</literal>, <literal>SessionFactory</literal>, and <literal>Session</literal>, as well as database transactions and long conversations."
msgstr "&#x00c1;mbitos de sesi&#x00f3;n y de transacci&#x00f3;n"

#: index.docbook:36
msgid "Session and transaction scopes"
msgstr "Una <literal>SessionFactory</literal> es un objeto seguro entre hebras caro-de-crear pensado para ser compartido por todas las hebras de la aplicaci&#x00f3;n. Es creado una sola vez, usualmente en el arranque de la aplicaci&#x00f3;n, a partir de una instancia de <literal>Configuration</literal>."

#: index.docbook:38
msgid "A <literal>SessionFactory</literal> is an expensive-to-create, threadsafe object intended to be shared by all application threads. It is created once, usually on application startup, from a <literal>Configuration</literal> instance."
msgstr "Una <literal>Session</literal> es un objeto barato, inseguro entre hebras que debe ser usado una sola vez, para un solo proceso de negocio, una sola unidad de trabajo, y luego descartado. Una <literal>Session</literal> no obtendr&#x00e1; una <literal>Connection</literal> JDBC (o un <literal>Datasource</literal>) a menos que sea necesario, de modo que puedas abrir y cerrar seguramente una <literal>Session</literal> incluso si no est&#x00e1;s seguro que se necesitar&#x00e1; acceso a los datos para servir una petici&#x00f3;n en particular. (Esto se vuelve importante en cuanto est&#x00e9;s implementando alguno de los siguientes patrones usando intercepci&#x00f3;n de peticiones)."

#: index.docbook:44
msgid "A <literal>Session</literal> is an inexpensive, non-threadsafe object that should be used once, for a single request, a conversation, single unit of work, and then discarded. A <literal>Session</literal> will not obtain a JDBC <literal>Connection</literal> (or a <literal>Datasource</literal>) unless it is needed, hence consume no resources until used."
msgstr "Para completar este cuadro tienes que pensar tambi&#x00e9;n en las transacciones de base de datos. Una transacci&#x00f3;n de base de datos tiene que ser tan corta como sea posible, para reducir la contenci&#x00f3;n de bloqueos en la base de datos. Las transacciones largas de base de datos prevendr&#x00e1;n a tu aplicaci&#x00f3;n de escalar a una carga altamente concurrente."

#: index.docbook:52
msgid "To complete this picture you also have to think about database transactions. A database transaction has to be as short as possible, to reduce lock contention in the database. Long database transactions will prevent your application from scaling to highly concurrent load. Hence, it is almost never good design to hold a database transaction open during user think time, until the unit of work is complete."
msgstr "&#x00bf;Qu&#x00e9; es el &#x00e1;mbito de una unidad de trabajo? &#x00bf;Puede una sola <literal>Session</literal> de Hibernate extenderse a trav&#x00e9;s de varias transacciones de base de datos o es &#x00e9;sta una relaci&#x00f3;n uno-a-uno de &#x00e1;mbitos? &#x00bf;Cu&#x00e1;ndo debes abrir y cerrar una <literal>Session</literal> y c&#x00f3;mo demarcas los l&#x00ed;mites de la transacci&#x00f3;n de base de datos?"

#: index.docbook:61
msgid "What is the scope of a unit of work? Can a single Hibernate <literal>Session</literal> span several database transactions or is this a one-to-one relationship of scopes? When should you open and close a <literal>Session</literal> and how do you demarcate the database transaction boundaries?"
msgstr "Unidad de trabajo"

#: index.docbook:69
msgid "Unit of work"
msgstr "Primero, no uses el antipatr&#x00f3;n <emphasis>sesi&#x00f3;n-por-operaci&#x00f3;n</emphasis>, esto es, &#x00a1;no abras y cierres una <literal>Session</literal> para cada simple llamada a la base de datos en una sola hebra! Por supuesto, lo mismo es verdad para transacciones de base de datos. Las llamadas a base de datos en una aplicaci&#x00f3;n se hacen usando una secuencia prevista, que est&#x00e1;n agrupadas dentro de unidades de trabajo at&#x00f3;micas. (Nota que esto tambi&#x00e9;n significa que el auto-commit despu&#x00e9;s de cada una de las sentencias SQL es in&#x00fa;til en una aplicaci&#x00f3;n, este modo est&#x00e1; pensado para trabajo ad-hoc de consola SQL. Hibernate deshabilita, o espera que el servidor de aplicaciones lo haga, el modo auto-commit inmediatamente.)"

#: index.docbook:71
msgid "First, don't use the <emphasis>session-per-operation</emphasis> antipattern, that is, don't open and close a <literal>Session</literal> for every simple database call in a single thread! Of course, the same is true for database transactions. Database calls in an application are made using a planned sequence, they are grouped into atomic units of work. (Note that this also means that auto-commit after every single SQL statement is useless in an application, this mode is intended for ad-hoc SQL console work. Hibernate disables, or expects the application server to do so, auto-commit mode immediately.) Database transactions are never optional, all communication with a database has to occur inside a transaction, no matter if you read or write data. As explained, auto-commit behavior for reading data should be avoided, as many small transactions are unlikely to perform better than one clearly defined unit of work. The latter is also much more maintainable and extensible."
msgstr "El patr&#x00f3;n m&#x00e1;s com&#x00fa;n en una aplicaci&#x00f3;n mutiusuario cliente/servidor es <emphasis>sesi&#x00f3;n-por-petici&#x00f3;n</emphasis>. En este modelo, una petici&#x00f3;n del cliente es enviada al servidor (en donde se ejecuta la capa de persistencia de Hibernate), se abre una nueva <literal>Session</literal> de Hibernate, y todas las operaciones de base de datos se ejecutan en esta unidad de trabajo. Una vez completado el trabajo (y se ha preparado la respuesta para el cliente) la sesi&#x00f3;n es limpiada y cerrada. Podr&#x00ed;as usar una sola transacci&#x00f3;n de base de datos para servir a petici&#x00f3;n del cliente, comenz&#x00e1;ndola y comprometi&#x00e9;ndola cuando abres y cierras la <literal>Session</literal>. La relaci&#x00f3;n entre las dos es uno-a-uno y este modelo es a la medida perfecta de muchas aplicaciones."

#: index.docbook:87
msgid "The most common pattern in a multi-user client/server application is <emphasis>session-per-request</emphasis>. In this model, a request from the client is send to the server (where the Hibernate persistence layer runs), a new Hibernate <literal>Session</literal> is opened, and all database operations are executed in this unit of work. Once the work has been completed (and the response for the client has been prepared), the session is flushed and closed. You would also use a single database transaction to serve the clients request, starting and committing it when you open and close the <literal>Session</literal>. The relationship between the two is one-to-one and this model is a perfect fit for many applications."
msgstr "El desaf&#x00ed;o yace en la implementaci&#x00f3;n: no s&#x00f3;lo tienen que comenzarse y terminarse correctamente la <literal>Session</literal> y la transacci&#x00f3;n, sino que adem&#x00e1;s tienen que estar accesibles para las operaciones de acceso a datos. La demarcaci&#x00f3;n de una unidad de trabajo se implementa idealmente usando un interceptor que se ejecuta cuando una petici&#x00f3;n llama al servidor y anter que la respuesta sea enviada (es decir, un <literal>ServletFilter</literal>). Recomendamos ligar la <literal>Session</literal> a la hebra que atiende la petici&#x00f3;n, usando una variable <literal>ThreadLocal</literal>. Esto permite un f&#x00e1;cil acceso (como acceder a una variable static) en t&#x00f3;do el c&#x00f3;digo que se ejecuta en esta hebra. Dependiendo del mecanismo de demarcaci&#x00f3;n de transacciones de base de datos que elijas, podr&#x00ed;as mantener tambi&#x00e9;n el contexto de la transacci&#x00f3;n en una variable <literal>ThreadLocal</literal>. Los patrones de implementaci&#x00f3;n para esto son conocidos como <emphasis>Sesi&#x00f3;n Local de Hebra (ThreadLocal Session)</emphasis> y <emphasis>Sesi&#x00f3;n Abierta en Vista (Open Session in View)</emphasis>. Puedes extender f&#x00e1;cilmente la clase de ayuda <literal>HibernateUtil</literal> mostrada anteriormente para encontrar una forma de implementar un interceptor e instalarlo en tu entorno. Ver el sitio web de Hibernate para consejos y ejemplos."

#: index.docbook:99
msgid "The challenge lies in the implementation. Hibernate provides built-in management of the \"current session\" to simplify this pattern. All you have to do is start a transaction when a server request has to be processed, and end the transaction before the response is send to the client. You can do this in any way you like, common solutions are <literal>ServletFilter</literal>, AOP interceptor with a pointcut on the service methods, or a proxy/interception container. An EJB container is a standardized way to implement cross-cutting aspects such as transaction demarcation on EJB session beans, declaratively with CMT. If you decide to use programmatic transaction demarcation, prefer the Hibernate <literal>Transaction</literal> API shown later in this chapter, for ease of use and code portability."
msgstr "Transacciones de aplicaci&#x00f3;n"

#: index.docbook:112
msgid "Your application code can access a \"current session\" to process the request by simply calling <literal>sessionFactory.getCurrentSession()</literal> anywhere and as often as needed. You will always get a <literal>Session</literal> scoped to the current database transaction. This has to be configured for either resource-local or JTA environments, see <xref linkend=\"architecture-current-session\"/>."
msgstr "El patr&#x00f3;n sesi&#x00f3;n-por-petici&#x00f3;n no es el &#x00fa;nico concepto &#x00fa;til que puedes usar para dise&#x00f1;ar unidades de trabajo. Muchos procesos de negocio requiere una serie completa de interacciones con el usuario intercaladas con accesos a base de datos. En aplicaciones web y de empresa no es aceptable que una transacci&#x00f3;n de base de datos se extienda a trav&#x00e9;s de la interacci&#x00f3;n de un usuario. Considera el siguiente ejemplo:"

#: index.docbook:120
msgid "Sometimes it is convenient to extend the scope of a <literal>Session</literal> and database transaction until the \"view has been rendered\". This is especially useful in servlet applications that utilize a separate rendering phase after the request has been processed. Extending the database transaction until view rendering is complete is easy to do if you implement your own interceptor. However, it is not easily doable if you rely on EJBs with container-managed transactions, as a transaction will be completed when an EJB method returns, before rendering of any view can start. See the Hibernate website and forum for tips and examples around this <emphasis>Open Session in View</emphasis> pattern."
msgstr "Se abre la primera pantalla de un di&#x00e1;logo, los datos vistos por el usuario han sido cargados en una <literal>Session</literal> y transacci&#x00f3;n de base de datos particular. El usuario es libre de modificar los objetos."

#: index.docbook:135
msgid "Long conversations"
msgstr "El usuario hace click en \"Salvar\" despu&#x00e9;s de 5 minutos y espera que sus modificaciones sean hechas persistentes. Tambi&#x00e9;n espera que &#x00e9;l sea la &#x00fa;nica persona editando esta informaci&#x00f3;n y que no puede ocurrir ninguna modificaci&#x00f3;n en conflicto."

#: index.docbook:137
msgid "The session-per-request pattern is not the only useful concept you can use to design units of work. Many business processes require a whole series of interactions with the user interleaved with database accesses. In web and enterprise applications it is not acceptable for a database transaction to span a user interaction. Consider the following example:"
msgstr "Llamamos a esto unidad de trabajo, desde el punto de vista del usuario, una larga <emphasis>transacci&#x00f3;n de aplicaci&#x00f3;n</emphasis> ejecut&#x00e1;ndose. Hay muchas formas en que puedes implementar esto en tu aplicaci&#x00f3;n."

#: index.docbook:147
msgid "The first screen of a dialog opens, the data seen by the user has been loaded in a particular <literal>Session</literal> and database transaction. The user is free to modify the objects."
msgstr "Una primera implementaci&#x00f3;n ingenua podr&#x00ed;a mantener abierta la <literal>Session</literal> y la transacci&#x00f3;n de base de datos durante el tiempo de pensar del usuario, con bloqueos tomados en la base de datos para prevenir la modificaci&#x00f3;n concurrente, y para garantizar aislamiento y atomicidad. Esto es, por supuesto, un antipatr&#x00f3;n, ya que la contenci&#x00f3;n de bloqueo no permitir&#x00ed;a a la aplicaci&#x00f3;n escalar con el n&#x00fa;mero de usuarios concurrentes."

#: index.docbook:154
msgid "The user clicks \"Save\" after 5 minutes and expects his modifications to be made persistent; he also expects that he was the only person editing this information and that no conflicting modification can occur."
msgstr "Claramente, tenemos que usar muchas transacciones de base de datos para implementar la transacci&#x00f3;n de aplicaci&#x00f3;n. En este caso, mantener el aislamiento de los procesos de negocio se vuelve una responsabilidad parcial de la capa de aplicaci&#x00f3;n. Una sola transacci&#x00f3;n de aplicaci&#x00f3;n usualmente abarca varias transacciones de base de datos. Ser&#x00e1; at&#x00f3;mica si s&#x00f3;lo una de estas transacciones de base de datos (la &#x00fa;ltima) almacena los datos actualizados, todas las otras simplemente leen datos (por ejemplo, en un di&#x00e1;logo estilo-asistente abarcando muchos ciclos petici&#x00f3;n/respuesta). Esto es m&#x00e1;s f&#x00e1;cil de implementar de lo que suena, especialmente si usas las funcionalidades de Hibernate:"

#: index.docbook:162
msgid "We call this unit of work, from the point of view of the user, a long running <emphasis>conversation</emphasis> (or <emphasis>application transaction</emphasis>). There are many ways how you can implement this in your application."
msgstr "<emphasis>Versionado Autom&#x00e1;tico</emphasis> - Hibernate puede llevar un control autom&#x00e1;tico de concurrencia optimista por ti, puede detectar autom&#x00e1;ticamente si una modificaci&#x00f3;n concurrente ha ocurrido durante el tiempo de pensar del usuario."

#: index.docbook:168
msgid "A first naive implementation might keep the <literal>Session</literal> and database transaction open during user think time, with locks held in the database to prevent concurrent modification, and to guarantee isolation and atomicity. This is of course an anti-pattern, since lock contention would not allow the application to scale with the number of concurrent users."
msgstr "<emphasis>Objetos Separados</emphasis> - Si decides usar el ya discutido patr&#x00f3;n de <emphasis>sesi&#x00f3;n-por-petici&#x00f3;n</emphasis>, todas las instancias cargadas estar&#x00e1;n en estado separado durante el tiempo de pensar del usuario. Hibernate te permite volver a unir los objetos y hacer persistentes las modificaciones. El patr&#x00f3;n se llama <emphasis>sesi&#x00f3;n-por-petici&#x00f3;n-con-objetos-separados</emphasis>. Se usa versionado autom&#x00e1;tico para aislar las modificaciones concurrentes."

#: index.docbook:176
msgid "Clearly, we have to use several database transactions to implement the converastion. In this case, maintaining isolation of business processes becomes the partial responsibility of the application tier. A single conversation usually spans several database transactions. It will be atomic if only one of these database transactions (the last one) stores the updated data, all others simply read data (e.g. in a wizard-style dialog spanning several request/response cycles). This is easier to implement than it might sound, especially if you use Hibernate's features:"
msgstr "<emphasis>Sesi&#x00f3;n Larga</emphasis> - La <literal>Session</literal> de Hibernate puede ser desconectada de la conexi&#x00f3;n JDBC subyacente despu&#x00e9;s que se haya sido comprometida la transacci&#x00f3;n de base de datos, y reconectada cuando ocurra una nueva petici&#x00f3;n del cliente. Este patr&#x00f3;n es conocido como <emphasis>sesi&#x00f3;n-por-transacci&#x00f3;n-de-aplicaci&#x00f3;n</emphasis> y hace la re-uni&#x00f3;n innecesaria. Para aislar las modificaciones concurrentes se usa el versionado autom&#x00e1;tico."

#: index.docbook:189
msgid "<emphasis>Automatic Versioning</emphasis> - Hibernate can do automatic optimistic concurrency control for you, it can automatically detect if a concurrent modification occured during user think time. Usually we only check at the end of the conversation."
msgstr "Tanto <emphasis>sesi&#x00f3;n-por-petici&#x00f3;n-con-objetos-separados</emphasis> como <emphasis>sesi&#x00f3;n-por-transacci&#x00f3;n-de-aplicaci&#x00f3;n</emphasis>, ambas tienen ventajas y desventajas, las discutimos m&#x00e1;s adelante en este cap&#x00ed;tulo en el contexto del control optimista de concurrencia."

#: index.docbook:197
msgid "<emphasis>Detached Objects</emphasis> - If you decide to use the already discussed <emphasis>session-per-request</emphasis> pattern, all loaded instances will be in detached state during user think time. Hibernate allows you to reattach the objects and persist the modifications, the pattern is called <emphasis>session-per-request-with-detached-objects</emphasis>. Automatic versioning is used to isolate concurrent modifications."
msgstr "Considerando la identidad del objeto"

#: index.docbook:207
msgid "<emphasis>Extended (or Long) Session</emphasis> - The Hibernate <literal>Session</literal> may be disconnected from the underlying JDBC connection after the database transaction has been committed, and reconnected when a new client request occurs. This pattern is known as <emphasis>session-per-conversation</emphasis> and makes even reattachment unnecessary. Automatic versioning is used to isolate concurrent modifications and the <literal>Session</literal> is usually not allowed to be flushed automatically, but explicitely."
msgstr "Una aplicaci&#x00f3;n puede acceder concurrentemente a el mismo estado persistente en dos <literal>Session</literal>s diferentes. Sin embargo, una instancia de una clase persistente nunca se comparte entre dos instancias de <literal>Session</literal>. Por lo tanto existen dos nociones diferentes de identidad:"

#: index.docbook:220
msgid "Both <emphasis>session-per-request-with-detached-objects</emphasis> and <emphasis>session-per-conversation</emphasis> have advantages and disadvantages, we discuss them later in this chapter in the context of optimistic concurrency control."
msgstr "Identidad de Base de Datos"

#: index.docbook:229
msgid "Considering object identity"
msgstr "foo.getId().equals( bar.getId() )"

#: index.docbook:231
msgid "An application may concurrently access the same persistent state in two different <literal>Session</literal>s. However, an instance of a persistent class is never shared between two <literal>Session</literal> instances. Hence there are two different notions of identity:"
msgstr "Identidad JVM"

#: index.docbook:240
msgid "Database Identity"
msgstr "foo==bar"

#: index.docbook:243
msgid "foo.getId().equals( bar.getId() )"
msgstr "Entonces para objetos unidos a una <literal>Session</literal> <emphasis>en particular</emphasis> (es decir en el &#x00e1;mbito de una <literal>Session</literal>) las dos nociones son equivalentes, y la identidad JVM para la identidad de base de datos est&#x00e1; garantizada por Hibernate. Sin embargo, mientras la aplicaci&#x00f3;n acceda concurrentemente al \"mismo\" (identidad persistente) objeto de negocio en dos sesiones diferentes, las dos instancias ser&#x00e1;n realmente \"diferentes\" (identidad JVM). Los conflictos se resuelven (con versionado autom&#x00e1;tico) en tiempo de limpieza (flush) usando un enfoque optimista."

#: index.docbook:248
msgid "JVM Identity"
msgstr "Este enfoque deja que Hibernate y la base de datos se preocupen sobre la concurrencia. Adem&#x00e1;s provee la mejor escalabilidad, ya que garantizando la identidad un unidades de trabajo monohebra no se necesitan bloqueos caros u otros medios de sincronizaci&#x00f3;n. La aplicaci&#x00f3;n nunca necesita sincronizar sobre ning&#x00fa;n objeto de negocio, siempre que se apegue a una sola hebra por <literal>Session</literal>. Dentro de una <literal>Session</literal> la aplicaci&#x00f3;n puede usar con seguridad <literal>==</literal> para comparar objetos."

#: index.docbook:251
msgid "foo==bar"
msgstr "Sin embargo, una aplicaci&#x00f3;n que usa <literal>==</literal> fuera de una <literal>Session</literal>, podr&#x00ed;a ver resultados inesperados. Esto podr&#x00ed;a ocurrir incluso en sitios algo inesperados, por ejemplo, si pones dos instancias separadas dentro del mismo <literal>Set</literal>. Ambas podr&#x00ed;an tener la misma identidad de base de datos (es decir, representar la misma fila), pero la identidad JVM, por definici&#x00f3;n, no est&#x00e1; garantizada para las instancias en estado separado. El desarrollador tiene que sobrescribir los m&#x00e9;todos <literal>equals()</literal> y <literal>hashCode()</literal> en las clases persistentes e implementar su propia noci&#x00f3;n de igualdad de objetos. Hay una advertencia: Nunca uses el identificador de base de datos para implementar la igualdad, usa una clave de negocio, una combinaci&#x00f3;n de atributos &#x00fa;nicos, usualmente inmutables. El identificador de base de datos cambiar&#x00e1; si un objeto transitorio es hecho persistente. Si la instancia transitoria (usualmente junta a instancias separadas) es mantenida en un <literal>Set</literal>, cambiar el c&#x00f3;digo hash rompe el contrato del <literal>Set</literal>. Los atributos para las claves de negocio no tienen que ser tan estables como las claves primarias de base de datos, s&#x00f3;lo tienes que garantizar estabilidad en tanto los objetos est&#x00e9;n en el mismo <literal>Set</literal>. Mira el sitio web de Hibernate para una discusi&#x00f3;n m&#x00e1;s cuidadosa de este tema. Nota tambi&#x00e9;n que &#x00e9;ste no es un tema de Hibernate, sino simplemente c&#x00f3;mo la identidad y la igualdad de los objetos Java tiene que ser implementada."

#: index.docbook:257
msgid "Then for objects attached to a <emphasis>particular</emphasis> <literal>Session</literal> (i.e. in the scope of a <literal>Session</literal>) the two notions are equivalent, and JVM identity for database identity is guaranteed by Hibernate. However, while the application might concurrently access the \"same\" (persistent identity) business object in two different sessions, the two instances will actually be \"different\" (JVM identity). Conflicts are resolved using (automatic versioning) at flush/commit time, using an optimistic approach."
msgstr "Temas comunes"

#: index.docbook:266
msgid "This approach leaves Hibernate and the database to worry about concurrency; it also provides the best scalability, since guaranteeing identity in single-threaded units of work only doesn't need expensive locking or other means of synchronization. The application never needs to synchronize on any business object, as long as it sticks to a single thread per <literal>Session</literal>. Within a <literal>Session</literal> the application may safely use <literal>==</literal> to compare objects."
msgstr "Nunca uses los antipatrones <emphasis>sesi&#x00f3;n-por-sesi&#x00f3;n-de-usuario</emphasis> o <emphasis>sesi&#x00f3;n-por-aplicaci&#x00f3;n</emphasis> (por supuesto, hay raras excepciones a esta regla). Nota que algunis de los siguientes temas podr&#x00ed;an tambi&#x00e9;n aparecer con los patrones recomendados. Aseg&#x00fa;rate que entiendes las implicaciones antes de tomar una decisi&#x00f3;n de dise&#x00f1;o:"

#: index.docbook:275
msgid "However, an application that uses <literal>==</literal> outside of a <literal>Session</literal>, might see unexpected results. This might occur even in some unexpected places, for example, if you put two detached instances into the same <literal>Set</literal>. Both might have the same database identity (i.e. they represent the same row), but JVM identity is by definition not guaranteed for instances in detached state. The developer has to override the <literal>equals()</literal> and <literal>hashCode()</literal> methods in persistent classes and implement his own notion of object equality. There is one caveat: Never use the database identifier to implement equality, use a business key, a combination of unique, usually immutable, attributes. The database identifier will change if a transient object is made persistent. If the transient instance (usually together with detached instances) is held in a <literal>Set</literal>, changing the hashcode breaks the contract of the <literal>Set</literal>. Attributes for business keys don't have to be as stable as database primary keys, you only have to guarantee stability as long as the objects are in the same <literal>Set</literal>. See the Hibernate website for a more thorough discussion of this issue. Also note that this is not a Hibernate issue, but simply how Java object identity and equality has to be implemented."
msgstr "Una <literal>Session</literal> no es segura entre hebras. Las cosas que se suponen que funcionan concurrentemente, como peticiones HTTP, beans de sesi&#x00f3;n, o workers de Swing, provocar&#x00e1;n condiciones de competencia si una instancia de <literal>Session</literal> fuese compartida. Si guardas tu <literal>Session</literal> de Hibernate en tu <literal>HttpSession</literal> (discutido m&#x00e1;s adelante), debes considerar sincronizar el acceso a tu sesi&#x00f3;n HTTP. De otro modo, un usuario que hace click lo suficientemente r&#x00e1;pido puede llegar a usar la misma <literal>Session</literal> en dos hebras ejecut&#x00e1;ndose concurrentemente."

#: index.docbook:296
msgid "Common issues"
msgstr "Una excepci&#x00f3;n lanzada por Hibernate significa que tienes que deshacer (rollback) tu transacci&#x00f3;n de base de datos y cerrar la <literal>Session</literal> inmediatamente (discutido en m&#x00e1;s detalle luego). Si tu <literal>Session</literal> est&#x00e1; ligada a la aplicaci&#x00f3;n, tienes que parar la aplicaci&#x00f3;n. Deshacer (rollback) la transacci&#x00f3;n de base de datos no pone a tus objetos de vuelta al estado en que estaban al comienzo de la transacci&#x00f3;n. Esto significa que el estado de la base de datos y los objetos de negocio quedan fuera de sincron&#x00ed;a. Usualmente esto no es un problema, pues las excepciones no son recuperables y tienes que volver a comenzar despu&#x00e9;s del rollback de todos modos."

#: index.docbook:298
msgid "Never use the anti-patterns <emphasis>session-per-user-session</emphasis> or <emphasis>session-per-application</emphasis> (of course, there are rare exceptions to this rule). Note that some of the following issues might also appear with the recommended patterns, make sure you understand the implications before making a design decision:"
msgstr "La <literal>Session</literal> pone en cach&#x00e9; todo objeto que est&#x00e9; en estado persistente (vigilado y chequeado por estado sucio por Hibernate). Esto significa que crece sin fin hasta que obtienes una OutOfMemoryException, si la mantienes abierta por un largo tiempo o simplemente cargas demasiados datos. Una soluci&#x00f3;n para esto es llamar a <literal>clear()</literal> y <literal>evict()</literal> para gestionar el cach&#x00e9; de la <literal>Session</literal>, pero probalemente debas considerar un procedimiento almacenado si necesitas operaciones de datos masivas. Se muestran algunas soluciones en <xref linkend=\"batch\"/>. Mantener una <literal>Session</literal> abierta por la duraci&#x00f3;n de una sesi&#x00f3;n de usuario significa tambi&#x00e9;n una alta probabilidad de datos a&#x00f1;ejos."

#: index.docbook:307
msgid "A <literal>Session</literal> is not thread-safe. Things which are supposed to work concurrently, like HTTP requests, session beans, or Swing workers, will cause race conditions if a <literal>Session</literal> instance would be shared. If you keep your Hibernate <literal>Session</literal> in your <literal>HttpSession</literal> (discussed later), you should consider synchronizing access to your Http session. Otherwise, a user that clicks reload fast enough may use the same <literal>Session</literal> in two concurrently running threads."
msgstr "Demarcaci&#x00f3;n de la transacci&#x00f3;n de base de datos"

#: index.docbook:318
msgid "An exception thrown by Hibernate means you have to rollback your database transaction and close the <literal>Session</literal> immediately (discussed later in more detail). If your <literal>Session</literal> is bound to the application, you have to stop the application. Rolling back the database transaction doesn't put your business objects back into the state they were at the start of the transaction. This means the database state and the business objects do get out of sync. Usually this is not a problem, because exceptions are not recoverable and you have to start over after rollback anyway."
msgstr "Los l&#x00ed;mites de las transacciones de base de datos (o sistema) son siempre necesarios. Ninguna comunicaci&#x00f3;n con la base de datos puede darse fuera de una transacci&#x00f3;n de base de datos (esto parece confundir muchos desarrolladores acostumbrados al modo auto-commit). Siempre usa l&#x00ed;mites de transacci&#x00f3;n claros, incluso para las operaciones de s&#x00f3;lo lectura. Dependiendo del nivel de aislamiento y las capacidades de base de datos, esto podr&#x00ed;a o no ser requerido, pero no hay un merma si siempre demarcas expl&#x00ed;citamente las transacciones."

#: index.docbook:330
msgid "The <literal>Session</literal> caches every object that is in persistent state (watched and checked for dirty state by Hibernate). This means it grows endlessly until you get an OutOfMemoryException, if you keep it open for a long time or simply load too much data. One solution for this is to call <literal>clear()</literal> and <literal>evict()</literal> to manage the <literal>Session</literal> cache, but you most likely should consider a Stored Procedure if you need mass data operations. Some solutions are shown in <xref linkend=\"batch\"/>. Keeping a <literal>Session</literal> open for the duration of a user session also means a high probability of stale data."
msgstr "Una aplicaci&#x00f3;n Hibernate puede ejecutarse en entornos no manejados (es decir, como independiente, Web simple, o aplicaciones Swing) y entornos manejados J2EE. En un entorno no manejado, Hibernate es usualmente responsable de su propio pool de conexiones de base de datos. El desarrollador de aplicaciones tiene que establecer manualmente los l&#x00ed;mites de transacci&#x00f3;n, en otras palabras, hacer begin, commit, o rollback las transacciones de base de datos por s&#x00ed; mismo. Un entorno manejado usualmente provee transacciones gestionadas por contenedor, con el ensamble de transacci&#x00f3;n definido declarativamente en descriptores de despliegue de beans de sesi&#x00f3;n EJB, por ejemplo. La demarcaci&#x00f3;n program&#x00e1;tica de transacciones no es m&#x00e1;s necesario, incluso limpiar (flush) la <literal>Session</literal> es hecho autom&#x00e1;ticamente."

#: index.docbook:348
msgid "Database transaction demarcation"
msgstr "Sin embargo, frecuentemente es deseable mantener portable tu capa de persistencia. Hibernate ofrece una API de envoltura llamada <literal>Transaction</literal> que se traduce al sistema de transacciones nativo de tu entorno de despliegue. Esta API es realmente opcional, pero recomendamos fuertemente su uso salvo que est&#x00e9;s en un bean de sesi&#x00f3;n CMT."

#: index.docbook:350
msgid "Datatabase (or system) transaction boundaries are always necessary. No communication with the database can occur outside of a database transaction (this seems to confuse many developers who are used to the auto-commit mode). Always use clear transaction boundaries, even for read-only operations. Depending on your isolation level and database capabilities this might not be required but there is no downside if you always demarcate transactions explicitly. Certainly, a single database transaction is going to perform better than many small transactions, even for reading data."
msgstr "Usualmente, finalizar una <literal>Session</literal> implica cuatro fases distintas:"

#: index.docbook:360
msgid "A Hibernate application can run in non-managed (i.e. standalone, simple Web- or Swing applications) and managed J2EE environments. In a non-managed environment, Hibernate is usually responsible for its own database connection pool. The application developer has to manually set transaction boundaries, in other words, begin, commit, or rollback database transactions himself. A managed environment usually provides container-managed transactions (CMT), with the transaction assembly defined declaratively in deployment descriptors of EJB session beans, for example. Programmatic transaction demarcation is then no longer necessary."
msgstr "limpiar (flush) la sesi&#x00f3;n"

#: index.docbook:370
msgid "However, it is often desirable to keep your persistence layer portable between non-managed resource-local environments, and systems that can rely on JTA but use BMT instead of CMT. In both cases you'd use programmatic transaction demaracation. Hibernate offers a wrapper API called <literal>Transaction</literal> that translates into the native transaction system of your deployment environment. This API is actually optional, but we strongly encourage its use unless you are in a CMT session bean."
msgstr "comprometer la transacci&#x00f3;n"

#: index.docbook:379
msgid "Usually, ending a <literal>Session</literal> involves four distinct phases:"
msgstr "cerrar la sesi&#x00f3;n"

#: index.docbook:385
msgid "flush the session"
msgstr "manejar excepciones"

#: index.docbook:390
msgid "commit the transaction"
msgstr "Limpiar la sesi&#x00f3;n ha sido discutido anteriormente, tendremos ahora una mirada m&#x00e1;s de cerca a la demarcaci&#x00f3;n de transacciones y manejo de excepciones en sendos entornos manejado y no manejados."

#: index.docbook:395
msgid "close the session"
msgstr "Entorno no manejado"

#: index.docbook:400
msgid "handle exceptions"
msgstr "Si una capa de persistencia Hibernate se ejecuta en un entorno no manejado, las conexiones de base de datos son manejadas usualmente por el mecanismo de pooling de Hibernate. El idioma manejo de sesi&#x00f3;n/transacci&#x00f3;n se ve as&#x00ed;:"

#: index.docbook:406
msgid "Flushing the session has been discussed earlier, we'll now have a closer look at transaction demarcation and exception handling in both managed- and non-managed environments."
msgstr ""
      "<![CDATA[//Non-managed environment idiom\n"
      "Session sess = factory.openSession();\n"
      "Transaction tx = null;\n"
      "try {\n"
      "    tx = sess.beginTransaction();\n"
      "\n"
      "    // do some work\n"
      "    ...\n"
      "\n"
      "    tx.commit();\n"
      "}\n"
      "catch (RuntimeException e) {\n"
      "    if (tx != null) tx.rollback();\n"
      "    throw e; // or display error message\n"
      "}\n"
      "finally {\n"
      "    sess.close();\n"
      "}]]>"

#: index.docbook:413
msgid "Non-managed environment"
msgstr "No tienes que limpiar con <literal>flush()</literal> la <literal>Session</literal> expl&#x00ed;citamente - la llamada a <literal>commit()</literal> autom&#x00e1;ticamente dispara la sincronizaci&#x00f3;n."

#: index.docbook:415
msgid "If a Hibernate persistence layer runs in a non-managed environment, database connections are usually handled by simple (i.e. non-DataSource) connection pools from which Hibernate obtains connections as needed. The session/transaction handling idiom looks like this:"
msgstr "Una llamada a <literal>close()</literal> marca el fin de una sesi&#x00f3;n. La principal implicaci&#x00f3;n de <literal>close()</literal> es que la conexi&#x00f3;n JDBC ser&#x00e1; abandonada por la sesi&#x00f3;n."

#: index.docbook:422
msgid ""
      "<![CDATA[// Non-managed environment idiom\n"
      "Session sess = factory.openSession();\n"
      "Transaction tx = null;\n"
      "try {\n"
      "    tx = sess.beginTransaction();\n"
      "\n"
      "    // do some work\n"
      "    ...\n"
      "\n"
      "    tx.commit();\n"
      "}\n"
      "catch (RuntimeException e) {\n"
      "    if (tx != null) tx.rollback();\n"
      "    throw e; // or display error message\n"
      "}\n"
      "finally {\n"
      "    sess.close();\n"
      "}]]>"
msgstr "Este c&#x00f3;digo Java es portable y se ejecuta tanto en entornos no manejados como en entornos JTA."

#: index.docbook:424
msgid "You don't have to <literal>flush()</literal> the <literal>Session</literal> explicitly - the call to <literal>commit()</literal> automatically triggers the synchronization (depending upon the <xref linkend=\"objectstate-flushing\"/>FlushMode for the session. A call to <literal>close()</literal> marks the end of a session. The main implication of <literal>close()</literal> is that the JDBC connection will be relinquished by the session. This Java code is portable and runs in both non-managed and JTA environments."
msgstr "Muy probablemente nunca veas este idioma en c&#x00f3;digo de negocio en una aplicaci&#x00f3;n normal; las excepciones fatales (sistema) deben siempre ser capturadas en la \"cima\". En otras palabras, el c&#x00f3;digo que ejecuta las llamadas de Hibernate (en la capa de persistencia) y el c&#x00f3;digo que maneja <literal>RuntimeException</literal> (y usualmente s&#x00f3;lo puede limpiar y salir) est&#x00e1;n en capas diferentes. Esto puede ser un desaf&#x00ed;o de dise&#x00f1;arlo t&#x00fa; mismo y debes usar los servicios de contenedor J2EE/EJB en cuanto estuviesen disponibles. El manejo de excepciones se dicute m&#x00e1;s adelante en este cap&#x00ed;tulo."

#: index.docbook:433
msgid "A much more flexible solution is Hibernate's built-in \"current session\" context management, as described earlier:"
msgstr "Nota que debes seleccionar <literal>org.hibernate.transaction.JDBCTransactionFactory</literal> (que es el por defecto)."

#: index.docbook:438
msgid ""
      "<![CDATA[// Non-managed environment idiom with getCurrentSession()\n"
      "try {\n"
      "    factory.getCurrentSession().beginTransaction();\n"
      "\n"
      "    // do some work\n"
      "    ...\n"
      "\n"
      "    factory.getCurrentSession().getTransaction().commit();\n"
      "}\n"
      "catch (RuntimeException e) {\n"
      "    factory.getCurrentSession().getTransaction().rollback();\n"
      "    throw e; // or display error message\n"
      "}]]>"
msgstr "Usando JTA"

#: index.docbook:440
msgid "You will very likely never see these code snippets in a regular application; fatal (system) exceptions should always be caught at the \"top\". In other words, the code that executes Hibernate calls (in the persistence layer) and the code that handles <literal>RuntimeException</literal> (and usually can only clean up and exit) are in different layers. The current context management by Hibernate can significantly simplify this design, as all you need is access to a <literal>SessionFactory</literal>. Exception handling is discussed later in this chapter."
msgstr "Si tu capa de persistencia se ejecuta en un servidor de aplicaciones (por ejemplo, detr&#x00e1;s de beans de sesi&#x00f3;n EJB), cada conexi&#x00f3;n de datasource obtenida por Hibernate ser&#x00e1; parte autom&#x00e1;ticamente de la transacci&#x00f3;n JTA global. Hibernate ofrece dos estrategias para esta integraci&#x00f3;n."

#: index.docbook:450
msgid "Note that you should select <literal>org.hibernate.transaction.JDBCTransactionFactory</literal> (which is the default), and for the second example <literal>\"thread\"</literal> as your <literal>hibernate.current_session_context_class</literal>."
msgstr "Si usas transacciones gestionadas-por-bean (BMT) Hibernate le dir&#x00e1; al servidor de aplicaciones que comience y finalice una transacci&#x00f3;n BMT si usas la API de <literal>Transaction</literal>. De modo que, el c&#x00f3;digo de gesti&#x00f3;n de la transacci&#x00f3;n es id&#x00e9;ntico al de un entorno no manejado."

#: index.docbook:459
msgid "Using JTA"
msgstr ""
      "<![CDATA[// BMT idiom\n"
      "Session sess = factory.openSession();\n"
      "Transaction tx = null;\n"
      "try {\n"
      "    tx = sess.beginTransaction();\n"
      "\n"
      "    // do some work\n"
      "    ...\n"
      "\n"
      "    tx.commit();\n"
      "}\n"
      "catch (RuntimeException e) {\n"
      "    if (tx != null) tx.rollback();\n"
      "    throw e; // or display error message\n"
      "}\n"
      "finally {\n"
      "    sess.close();\n"
      "}]]>"

#: index.docbook:461
msgid "If your persistence layer runs in an application server (e.g. behind EJB session beans), every datasource connection obtained by Hibernate will automatically be part of the global JTA transaction. You can also install a standalone JTA implementation and use it without EJB. Hibernate offers two strategies for JTA integration."
msgstr "Con CMT, la demarcaci&#x00f3;n de la transacci&#x00f3;n se hace en descriptores de despliegue de beans de sesi&#x00f3;n, no program&#x00e1;ticamente. Si no quieres limpiar (flush) y cerrar manualmente la <literal>Session</literal> por ti mismo, solamente establece <literal>hibernate.transaction.flush_before_completion</literal> a <literal>true</literal>, <literal>hibernate.connection.release_mode</literal> a <literal>after_statement</literal> o <literal>auto</literal> y <literal>hibernate.transaction.auto_close_session</literal> a <literal>true</literal>. Hibernate limpiar&#x00e1; y cerrar&#x00e1; entonces autom&#x00e1;ticamente la <literal>Session</literal> para ti. Lo &#x00fa;nico que resta es deshacer (rollback) la transacci&#x00f3;n cuando ocurra una excepci&#x00f3;n. Afortunadamente, en un bean CMT, incluso esto ocurre autom&#x00e1;ticamente, ya que una <literal>RuntimeException</literal> no manejada disparada por un m&#x00e9;todo de un bean de sesi&#x00f3;n le dice al contenedor que ponga a deshacer la transacci&#x00f3;n global. <emphasis>Esto significa que, en CMT, no necesitas usar en absoluto la API de <literal>Transaction</literal> de Hibernate.</emphasis>"

#: index.docbook:468
msgid "If you use bean-managed transactions (BMT) Hibernate will tell the application server to start and end a BMT transaction if you use the <literal>Transaction</literal> API. So, the transaction management code is identical to the non-managed environment."
msgstr "Nota que debes elegir <literal>org.hibernate.transaction.JTATransactionFactory</literal> en un bean de sesi&#x00f3;n BMT, y <literal>org.hibernate.transaction.CMTTransactionFactory</literal> en un bean de sesi&#x00f3;n CMT, cuando configures la f&#x00e1;brica de transacciones de Hibernate. Recuerda adem&#x00e1;s establecer <literal>org.hibernate.transaction.manager_lookup_class</literal>."

#: index.docbook:474
msgid ""
      "<![CDATA[// BMT idiom\n"
      "Session sess = factory.openSession();\n"
      "Transaction tx = null;\n"
      "try {\n"
      "    tx = sess.beginTransaction();\n"
      "\n"
      "    // do some work\n"
      "    ...\n"
      "\n"
      "    tx.commit();\n"
      "}\n"
      "catch (RuntimeException e) {\n"
      "    if (tx != null) tx.rollback();\n"
      "    throw e; // or display error message\n"
      "}\n"
      "finally {\n"
      "    sess.close();\n"
      "}]]>"
msgstr "Si trabajas en un entorno CMT, y usas limpieza (flushing) y cierre autom&#x00e1;ticos de la sesi&#x00f3;n, podr&#x00ed;as querer tambi&#x00e9;n usar la misma sesi&#x00f3;n en diferentes partes de tu c&#x00f3;digo. T&#x00ed;picamente, en un entorno no manejado, usar&#x00ed;as una variable <literal>ThreadLocal</literal> para tener la sesi&#x00f3;n, pero una sola petici&#x00f3;n de EJB puede ejecutarse en diferentes hebras (por ejemplo, un bean de sesi&#x00f3;n llamando a otro bean de sesi&#x00f3;n). Si no quieres molestarte en pasar tu <literal>Session</literal> por alrededor, la <literal>SessionFactory</literal> provee el m&#x00e9;todo <literal>getCurrentSession()</literal>, que devuelve una sesi&#x00f3;n que est&#x00e1; pegada al contexto de transacci&#x00f3;n JTA. &#x00a1;Esta es la forma m&#x00e1;s f&#x00e1;cil de integrar Hibernate en una aplicaci&#x00f3;n! La sesi&#x00f3;n \"actual\" siempre tiene habilitados limpieza, cierre y liberaci&#x00f3;n de conexi&#x00f3;n autom&#x00e1;ticos (sin importar la configuraci&#x00f3;n de las propiedades anteriores). Nuestra idioma de gesti&#x00f3;n de sesi&#x00f3;n/transacci&#x00f3;n se reduce a:"

#: index.docbook:476
msgid "If you want to use a transaction-bound <literal>Session</literal>, that is, the <literal>getCurrentSession()</literal> functionality for easy context propagation, you will have to use the JTA <literal>UserTransaction</literal> API directly:"
msgstr ""
      "<![CDATA[// CMT idiom\n"
      "Session sess = factory.getCurrentSession();\n"
      "\n"
      "// do some work\n"
      "...\n"
      "\n"
      "]]>"

#: index.docbook:482
msgid ""
      "<![CDATA[// BMT idiom with getCurrentSession()\n"
      "try {\n"
      "    UserTransaction tx = (UserTransaction)new InitialContext()\n"
      "                            .lookup(\"java:comp/UserTransaction\");\n"
      "\n"
      "    tx.begin();\n"
      "\n"
      "    // Do some work on Session bound to transaction\n"
      "    factory.getCurrentSession().load(...);\n"
      "    factory.getCurrentSession().persist(...);\n"
      "\n"
      "    tx.commit();\n"
      "}\n"
      "catch (RuntimeException e) {\n"
      "    tx.rollback();\n"
      "    throw e; // or display error message\n"
      "}]]>"
msgstr "En otras palabras, todo lo que tienes que hacer en un entorno manejado, es llamar a <literal>SessionFactory.getCurrentSession()</literal>, hacer tu trabajo de acceso a datos, y dejar el resto al contenedor. Los l&#x00ed;mites de transacci&#x00f3;n se establecen declarativamente en los descriptores de despliegue de tu bean de sesi&#x00f3;n. El ciclo de vida de la sesi&#x00f3;n es manejado completamente por Hibernate."

#: index.docbook:484
msgid "With CMT, transaction demarcation is done in session bean deployment descriptors, not programatically, hence, the code is reduced to:"
msgstr "Existe una advertencia al uso del modo de liberaci&#x00f3;n de conexi&#x00f3;n <literal>after_statement</literal>. Debido a una limitaci&#x00f3;n tonta de la especificaci&#x00f3;n de JTA, no es posible para Hibernate limpiar autom&#x00e1;ticamente ning&#x00fa;n <literal>ScrollableResults</literal> no cerrado ni instancias de <literal>Iterator</literal> devueltas por <literal>scroll()</literal> o <literal>iterate()</literal>. <emphasis>Debes</emphasis> liberar el cursor de base de datos subyacente llamando a <literal>ScrollableResults.close()</literal> o <literal>Hibernate.close(Iterator)</literal> expl&#x00ed;citamente desde un bloque <literal>finally</literal>. (Por supuesto, la mayor&#x00ed;a de las aplicaciones pueden evitarlo f&#x00e1;cilmente no usando en absoluto ning&#x00fa;n <literal>scroll()</literal> o <literal>iterate()</literal> desde el c&#x00f3;digo CMT.)"

#: index.docbook:489
msgid ""
      "<![CDATA[// CMT idiom\n"
      " Session sess = factory.getCurrentSession();\n"
      "\n"
      " // do some work\n"
      " ...\n"
      "]]>"
msgstr "Manejo de excepciones"

#: index.docbook:491
msgid "In a CMT/EJB even rollback happens automatically, since an unhandled <literal>RuntimeException</literal> thrown by a session bean method tells the container to set the global transaction to rollback. <emphasis>This means you do not need to use the Hibernate <literal>Transaction</literal> API at all with BMT or CMT, and you get automatic propagation of the \"current\" Session bound to the transaction.</emphasis>"
msgstr "Si la <literal>Session</literal> lanza una excepci&#x00f3;n (incluyendo cualquier <literal>SQLException</literal>), debes inmediatamente deshacer (rollback) la transacci&#x00f3;n de base de datos, llamar a <literal>Session.close()</literal> y descartar la instancia de <literal>Session</literal>. Ciertos m&#x00e9;todos de <literal>Session</literal> <emphasis>no</emphasis> dejar&#x00e1;n la sesi&#x00f3;n en un estado consistente. Ninguna excepci&#x00f3;n lanzada por Hibernate puede ser tratada como recuperable. Aseg&#x00fa;rate que la <literal>Session</literal> sea cerrada llamando a <literal>close()</literal> en un bloque <literal>finally</literal>."

#: index.docbook:499
msgid "Note that you should choose <literal>org.hibernate.transaction.JTATransactionFactory</literal> if you use JTA directly (BMT), and <literal>org.hibernate.transaction.CMTTransactionFactory</literal> in a CMT session bean, when you configure Hibernate's transaction factory. Remember to also set <literal>hibernate.transaction.manager_lookup_class</literal>. Furthermore, make sure that your <literal>hibernate.current_session_context_class</literal> is either unset (backwards compatiblity), or set to <literal>\"jta\"</literal>."
msgstr "La <literal>HibernateException</literal>, que envuelve la mayor&#x00ed;a de los errores que pueden ocurrir en la capa de persistencia de Hibernate, en una excepci&#x00f3;n no chequeada (no lo era en versiones anteriores de Hibernate). En nuestra opini&#x00f3;n, no debemos forzar al desarrollador de aplicaciones a capturar una excepci&#x00f3;n irrecuperable en una capa baja. En la mayor&#x00ed;a de los sistemas, las excepciones no chequeadas y fatales son manejadas en uno de los primeros cuadros de la pila de llamadas a m&#x00e9;todos (es decir, en las capas m&#x00e1;s altas) y se presenta un mensaje de error al usuario de la aplicaci&#x00f3;n (o se toma alguna otra acci&#x00f3;n apropiada). Nota que Hibernate podr&#x00ed;a tambi&#x00e9;n lanzar otras excepciones no chequeadas que no sean una <literal>HibernateException</literal>. Una vez m&#x00e1;s, no son recuperables y debe tomarse una acci&#x00f3;n apropiada."

#: index.docbook:508
msgid "The <literal>getCurrentSession()</literal> operation has one downside in a JTA environment. There is one caveat to the use of <literal>after_statement</literal> connection release mode, which is then used by default. Due to a silly limitation of the JTA spec, it is not possible for Hibernate to automatically clean up any unclosed <literal>ScrollableResults</literal> or <literal>Iterator</literal> instances returned by <literal>scroll()</literal> or <literal>iterate()</literal>. You <emphasis>must</emphasis> release the underlying database cursor by calling <literal>ScrollableResults.close()</literal> or <literal>Hibernate.close(Iterator)</literal> explicity from a <literal>finally</literal> block. (Of course, most applications can easily avoid using <literal>scroll()</literal> or <literal>iterate()</literal> at all from the JTA or CMT code.)"
msgstr "Hibernate envuelve <literal>SQLException</literal>s lanzadas mientras se interact&#x00fa;a con la base de datos en una <literal>JDBCException</literal>. De hecho, Hibernate intentar&#x00e1; convertir la excepci&#x00f3;n en una subclase de <literal>JDBCException</literal> m&#x00e1;s significativa. La <literal>SQLException</literal> est&#x00e1; siempre disponible v&#x00ed;a <literal>JDBCException.getCause()</literal>. Hibernate convierte la <literal>SQLException</literal> en una subclase de <literal>JDBCException</literal> apropiada usando el <literal>SQLExceptionConverter</literal> adjunto a la <literal>SessionFactory</literal>. Por defecto, el <literal>SQLExceptionConverter</literal> est&#x00e1; definido para el dialecto configurado; sin embargo, es tambi&#x00e9;n posible enchufar una implementaci&#x00f3;n personalizada (ver los javadocs de la clase <literal>SQLExceptionConverterFactory</literal> para los detalles). Los subtipos est&#x00e1;ndar de <literal>JDBCException</literal> son:"

#: index.docbook:524
msgid "Exception handling"
msgstr "<literal>JDBCConnectionException</literal> - indica un error con la comunicaci&#x00f3;n JDBC subyacente."

#: index.docbook:526
msgid "If the <literal>Session</literal> throws an exception (including any <literal>SQLException</literal>), you should immediately rollback the database transaction, call <literal>Session.close()</literal> and discard the <literal>Session</literal> instance. Certain methods of <literal>Session</literal> will <emphasis>not</emphasis> leave the session in a consistent state. No exception thrown by Hibernate can be treated as recoverable. Ensure that the <literal>Session</literal> will be closed by calling <literal>close()</literal> in a <literal>finally</literal> block."
msgstr "<literal>SQLGrammarException</literal> - indica un problema de gram&#x00e1;tica o sint&#x00e1;xis con el SQL publicado."

#: index.docbook:537
msgid "The <literal>HibernateException</literal>, which wraps most of the errors that can occur in a Hibernate persistence layer, is an unchecked exception (it wasn't in older versions of Hibernate). In our opinion, we shouldn't force the application developer to catch an unrecoverable exception at a low layer. In most systems, unchecked and fatal exceptions are handled in one of the first frames of the method call stack (i.e. in higher layers) and an error message is presented to the application user (or some other appropriate action is taken). Note that Hibernate might also throw other unchecked exceptions which are not a <literal>HibernateException</literal>. These are, again, not recoverable and appropriate action should be taken."
msgstr "<literal>ConstraintViolationException</literal> - indica alguna forma de violaci&#x00f3;n de restricci&#x00f3;n de integridad."

#: index.docbook:549
msgid "Hibernate wraps <literal>SQLException</literal>s thrown while interacting with the database in a <literal>JDBCException</literal>. In fact, Hibernate will attempt to convert the eexception into a more meningful subclass of <literal>JDBCException</literal>. The underlying <literal>SQLException</literal> is always available via <literal>JDBCException.getCause()</literal>. Hibernate converts the <literal>SQLException</literal> into an appropriate <literal>JDBCException</literal> subclass using the <literal>SQLExceptionConverter</literal> attached to the <literal>SessionFactory</literal>. By default, the <literal>SQLExceptionConverter</literal> is defined by the configured dialect; however, it is also possible to plug in a custom implementation (see the javadocs for the <literal>SQLExceptionConverterFactory</literal> class for details). The standard <literal>JDBCException</literal> subtypes are:"
msgstr "<literal>LockAcquisitionException</literal> - indica un error adquiriendo un nivel de bloqueo necesario para realizar una operaci&#x00f3;n solicitada."

#: index.docbook:565
msgid "<literal>JDBCConnectionException</literal> - indicates an error with the underlying JDBC communication."
msgstr "<literal>GenericJDBCException</literal> - una excepci&#x00f3;n gen&#x00e9;rica que no cay&#x00f3; en ninguna de las otras categor&#x00ed;as."

#: index.docbook:571
msgid "<literal>SQLGrammarException</literal> - indicates a grammar or syntax problem with the issued SQL."
msgstr "Control optimista de concurrencia"

#: index.docbook:577
msgid "<literal>ConstraintViolationException</literal> - indicates some form of integrity constraint violation."
msgstr "El &#x00fa;nico enfoque que es consistente con alta concurrencia y alta escalabilidad es el control optimista de concurrencia con versionamiento. El chuequeo de versi&#x00f3;n usa n&#x00fa;meros de versi&#x00f3;n, o timestamps, para detectar actualizaciones en conflicto (y para prevenir actualizaciones perdidas). Hibernate provee para tres enfoques posibles de escribir c&#x00f3;digo de aplicaci&#x00f3;n que use concurrencia optimista. Los casos de uso que hemos mostrado est&#x00e1;n en el contexto de transacciones de aplicaci&#x00f3;n largas pero el chequeo de versiones tiene adem&#x00e1;s el beneficio de prevenir actualizaciones perdidas en transacciones de base de datos solas."

#: index.docbook:583
msgid "<literal>LockAcquisitionException</literal> - indicates an error acquiring a lock level necessary to perform the requested operation."
msgstr "Chequeo de versiones de aplicaci&#x00f3;n"

#: index.docbook:589
msgid "<literal>GenericJDBCException</literal> - a generic exception which did not fall into any of the other categories."
msgstr "En una implementaci&#x00f3;n sin mucha ayuda de Hibernate, cada interacci&#x00f3;n con la base de datos ocurre en una nueva <literal>Session</literal> y el desarrollador es responsable de recargar todas las intancias persistentes desde la base de datos antes de manipularlas. Este enfoque fuerza a la aplicaci&#x00f3;n a realizar su propio chequeo de versiones para asegurar el aislamiento de transacciones de base de datos. Es el enfoque m&#x00e1;s similar a los EJBs de entidad."

#: index.docbook:599
msgid "Transaction timeout"
msgstr ""
      "<![CDATA[// foo is an instance loaded by a previous Session\n"
      "session = factory.openSession();\n"
      "Transaction t = session.beginTransaction();\n"
      "int oldVersion = foo.getVersion();\n"
      "session.load( foo, foo.getKey() ); // load the current state\n"
      "if ( oldVersion != foo.getVersion() ) throw new StaleObjectStateException();\n"
      "foo.setProperty(\"bar\");\n"
      "t.commit();\n"
      "session.close();]]>"

#: index.docbook:601
msgid "One extremely important feature provided by a managed environment like EJB that is never provided for non-managed code is transaction timeout. Transaction timeouts ensure that no misbehaving transaction can indefinitely tie up resources while returning no response to the user. Outside a managed (JTA) environment, Hibernate cannot fully provide this functionality. However, Hibernate can at least control data access operations, ensuring that database level deadlocks and queries with huge result sets are limited by a defined timeout. In a managed environment, Hibernate can delegate transaction timeout to JTA. This functioanlity is abstracted by the Hibernate <literal>Transaction</literal> object."
msgstr "La propiedad <literal>version</literal> se mapea usando <literal>&lt;version&gt;</literal>, e Hibernate la incrementar&#x00e1; autom&#x00e1;ticamente durante la limpieza si la entidad est&#x00e1; sucia."

#: index.docbook:614
msgid ""
      "<![CDATA[\n"
      "Session sess = factory.openSession();\n"
      "try {\n"
      "    //set transaction timeout to 3 seconds\n"
      "    sess.getTransaction().setTimeout(3);\n"
      "    sess.getTransaction().begin();\n"
      "\n"
      "    // do some work\n"
      "    ...\n"
      "\n"
      "    sess.getTransaction().commit()\n"
      "}\n"
      "catch (RuntimeException e) {\n"
      "    sess.getTransaction().rollback();\n"
      "    throw e; // or display error message\n"
      "}\n"
      "finally {\n"
      "    sess.close();\n"
      "}]]>"
msgstr "Por supuesto, si est&#x00e1;s operando un entorno de baja-concurrencia-de-datos y no requieres chequeo de versiones, puedes usar este enfoque y simplemente saltar el chequeo de versiones. En ese caso, <emphasis>el &#x00fa;ltimo compromiso (commit) gana</emphasis> ser&#x00e1; la estrategia por defecto para tus transacciones de aplicaci&#x00f3;n largas. Ten en mente que esto podr&#x00ed;a confundir a los usuarios de la aplicaci&#x00f3;n, pues podr&#x00ed;an experimentar actualizaciones perdidas sin mensajes de error ni chance de fusionar los cambios conflictivos."

#: index.docbook:616
msgid "Note that <literal>setTimeout()</literal> may not be called in a CMT bean, where transaction timeouts must be defined declaratively."
msgstr "Claramente, el chequeo manual de versiones es factible solamente en circunstancias muy triviales, y no es pr&#x00e1;ctico para la mayor&#x00ed;a de aplicaciones. Frecuentemente, no s&#x00f3;lo intancias solas, sino grafos completos de objetos modificados tienen que ser chequeados. Hibernate ofrece chequeo de versiones autom&#x00e1;tico con el paradigma de dise&#x00f1;o de <literal>Session</literal> larga o de instancias separadas."

#: index.docbook:626
msgid "Optimistic concurrency control"
msgstr "Sesi&#x00f3;n larga y versionado autom&#x00e1;tico"

#: index.docbook:628
msgid "The only approach that is consistent with high concurrency and high scalability is optimistic concurrency control with versioning. Version checking uses version numbers, or timestamps, to detect conflicting updates (and to prevent lost updates). Hibernate provides for three possible approaches to writing application code that uses optimistic concurrency. The use cases we show are in the context of long conversations, but version checking also has the benefit of preventing lost updates in single database transactions."
msgstr "Una sola instancia de <literal>Session</literal> y sus instancias persistentes son usadas para toda la transacci&#x00f3;n de aplicaci&#x00f3;n. Hibernate chequea las versiones de instancia en el momento de limpieza (flush), lanzando una excepci&#x00f3;n si se detecta una modificaci&#x00f3;n concurrente. Concierne al desarrollador capturar y manejar esta excepci&#x00f3;n (las opciones comunes son la oportunidad del usuario de fusionar los cambios, o recomenzar el proceso de negocio sin datos a&#x00f1;ejos)."

#: index.docbook:639
msgid "Application version checking"
msgstr "La <literal>Session</literal> se desconecta de cualquier conexi&#x00f3;n JDBC subyacente al esperar por una interacci&#x00f3;n del usuario. Este enfoque es el m&#x00e1;s eficiente en t&#x00e9;rminos de acceso a base de datos. La aplicaci&#x00f3;n no necesita tratar por s&#x00ed; misma con el chequeo de versiones, ni re-uniendo instancias separadas, ni tiene que recargar instancias en cada transacci&#x00f3;n de base de datos."

#: index.docbook:641
msgid "In an implementation without much help from Hibernate, each interaction with the database occurs in a new <literal>Session</literal> and the developer is responsible for reloading all persistent instances from the database before manipulating them. This approach forces the application to carry out its own version checking to ensure conversation transaction isolation. This approach is the least efficient in terms of database access. It is the approach most similar to entity EJBs."
msgstr ""
      "<![CDATA[// foo is an instance loaded earlier by the Session\n"
      "session.reconnect(); // Obtain a new JDBC connection\n"
      "Transaction t = session.beginTransaction();\n"
      "foo.setProperty(\"bar\");\n"
      "t.commit(); // End database transaction, flushing the change and checking the version\n"
      "session.disconnect(); // Return JDBC connection ]]>"

#: index.docbook:650
msgid ""
      "<![CDATA[// foo is an instance loaded by a previous Session\n"
      "session = factory.openSession();\n"
      "Transaction t = session.beginTransaction();\n"
      "\n"
      "int oldVersion = foo.getVersion();\n"
      "session.load( foo, foo.getKey() ); // load the current state\n"
      "if ( oldVersion != foo.getVersion() ) throw new StaleObjectStateException();\n"
      "foo.setProperty(\"bar\");\n"
      "\n"
      "t.commit();\n"
      "session.close();]]>"
msgstr "El objeto <literal>foo</literal> todav&#x00ed;a conoce en qu&#x00e9; <literal>Session</literal> fue cargado. <literal>Session.reconnect()</literal> obtiene una nueva conexi&#x00f3;n (o puedes proveer una) y reasume la sesi&#x00f3;n. El m&#x00e9;todo <literal>Session.disconnect()</literal> desconectar&#x00e1; la sesi&#x00f3;n de la conexi&#x00f3;n JDBC y la devolver&#x00e1; la conexi&#x00f3;n al pool (a menos que hayas provisto la conexi&#x00f3;n). Despu&#x00e9;s de la reconexi&#x00f3;n, para forzar un chequeo de versi&#x00f3;n en datos que no est&#x00e9;s actualizando, puedes llamar a <literal>Session.lock()</literal> con <literal>LockMode.READ</literal> sobre cualquier objeto que pudiese haber sido actualizado por otra transacci&#x00f3;n. No necesitas bloquear ning&#x00fa;n dato que <emphasis>s&#x00ed; est&#x00e9;s</emphasis> actualizando."

#: index.docbook:652
msgid "The <literal>version</literal> property is mapped using <literal>&lt;version&gt;</literal>, and Hibernate will automatically increment it during flush if the entity is dirty."
msgstr "Si las llamadas expl&#x00ed;citas a <literal>disconnect()</literal> y <literal>reconnect()</literal> son muy onerosas, puedes usar en cambio <literal>hibernate.connection.release_mode</literal>."

#: index.docbook:658
msgid "Of course, if you are operating in a low-data-concurrency environment and don't require version checking, you may use this approach and just skip the version check. In that case, <emphasis>last commit wins</emphasis> will be the default strategy for your long conversations. Keep in mind that this might confuse the users of the application, as they might experience lost updates without error messages or a chance to merge conflicting changes."
msgstr "Este patr&#x00f3;n es problem&#x00e1;tico si la <literal>Session</literal> es demasiado grande para ser almacenada durante el tiempo de pensar del usuario, por ejemplo, una <literal>HttpSession</literal> debe mantenerse tan peque&#x00f1;a como sea posible. Ya que la <literal>Session</literal> es tambi&#x00e9;n el cach&#x00e9; (obligatorio) de primer nivel y contiene todos los objetos cargados, podemos probablemente cargar esta estrategia s&#x00f3;lo para unos pocos ciclos petici&#x00f3;n/respuesta. Esto est&#x00e1; de hecho recomendado, ya que la <literal>Session</literal> tendr&#x00e1; pronto tambi&#x00e9;n datos a&#x00f1;ejos."

#: index.docbook:667
msgid "Clearly, manual version checking is only feasible in very trivial circumstances and not practical for most applications. Often not only single instances, but complete graphs of modified ojects have to be checked. Hibernate offers automatic version checking with either an extended <literal>Session</literal> or detached instances as the design paradigm."
msgstr "Nota tambi&#x00e9;n que debes mantener la <literal>Session</literal> desconectada pr&#x00f3;xima a la capa de persistencia. En otras palabras, usa una sesi&#x00f3;n de EJB con estado para tener la <literal>Session</literal> y no transferirla a la capa web para almacenarla en la <literal>HttpSession</literal> (ni incluso serializarla a una capa separada)."

#: index.docbook:678
msgid "Extended session and automatic versioning"
msgstr "Objetos separados y versionado autom&#x00e1;tico"

#: index.docbook:680
msgid "A single <literal>Session</literal> instance and its persistent instances are used for the whole conversation, known as <emphasis>session-per-conversation</emphasis>. Hibernate checks instance versions at flush time, throwing an exception if concurrent modification is detected. It's up to the developer to catch and handle this exception (common options are the opportunity for the user to merge changes or to restart the business conversation with non-stale data)."
msgstr "Cada interacci&#x00f3;n con el almac&#x00e9;n persistente ocurre en una nueva <literal>Session</literal>. Sin embargo, las mismas instancias persistentes son reusadas para cada interacci&#x00f3;n con la base de datos. La aplicaci&#x00f3;n manipula el estado de las instancias separadas originalmente cargadas en otra <literal>Session</literal> y luego las readjunta usando <literal>Session.update()</literal>, <literal>Session.saveOrUpdate()</literal>, o <literal>Session.merge()</literal>."

#: index.docbook:689
msgid "The <literal>Session</literal> is disconnected from any underlying JDBC connection when waiting for user interaction. This approach is the most efficient in terms of database access. The application need not concern itself with version checking or with reattaching detached instances, nor does it have to reload instances in every database transaction."
msgstr ""
      "<![CDATA[// foo is an instance loaded by a previous Session\n"
      "foo.setProperty(\"bar\");\n"
      "session = factory.openSession();\n"
      "Transaction t = session.beginTransaction();\n"
      "session.saveOrUpdate(foo); // Use merge() if \"foo\" might have been loaded already\n"
      "t.commit();\n"
      "session.close();]]>"

#: index.docbook:697
msgid ""
      "<![CDATA[// foo is an instance loaded earlier by the old session\n"
      "Transaction t = session.beginTransaction(); // Obtain a new JDBC connection, start transaction\n"
      "\n"
      "foo.setProperty(\"bar\");\n"
      "\n"
      "session.flush();    // Only for last transaction in conversation\n"
      "t.commit();         // Also return JDBC connection\n"
      "session.close();    // Only for last transaction in conversation]]>"
msgstr "De nuevo, Hibernate chequear&#x00e1; las versiones de instancia durante la limpieza (flush), lanzando una excepci&#x00f3;n si ocurrieron actualizaciones en conflicto."

#: index.docbook:698
msgid "The <literal>foo</literal> object still knows which <literal>Session</literal> it was loaded in. Beginning a new database transaction on an old session obtains a new connection and resumes the session. Committing a database transaction disconnects a session from the JDBC connection and returns the connection to the pool. After reconnection, to force a version check on data you aren't updating, you may call <literal>Session.lock()</literal> with <literal>LockMode.READ</literal> on any objects that might have been updated by another transaction. You don't need to lock any data that you <emphasis>are</emphasis> updating. Usually you would set <literal>FlushMode.MANUAL</literal> on an extended <literal>Session</literal>, so that only the last database transaction cycle is allowed to actually persist all modifications made in this conversation. Hence, only this last database transaction would include the <literal>flush()</literal> operation, and then also <literal>close()</literal> the session to end the conversation."
msgstr "Puedes tambi&#x00e9;n llamar a <literal>lock()</literal> en vez de <literal>update()</literal> y usar <literal>LockMode.READ</literal> (realizando un chequeo de versi&#x00f3;n, puenteando todos los cach&#x00e9;s) si est&#x00e1;s seguro que el objeto no ha sido modificado."

#: index.docbook:713
msgid "This pattern is problematic if the <literal>Session</literal> is too big to be stored during user think time, e.g. an <literal>HttpSession</literal> should be kept as small as possible. As the <literal>Session</literal> is also the (mandatory) first-level cache and contains all loaded objects, we can probably use this strategy only for a few request/response cycles. You should use a <literal>Session</literal> only for a single conversation, as it will soon also have stale data."
msgstr "Personalizando el versionado autom&#x00e1;tico"

#: index.docbook:723
msgid "(Note that earlier Hibernate versions required explicit disconnection and reconnection of a <literal>Session</literal>. These methods are deprecated, as beginning and ending a transaction has the same effect.)"
msgstr "Puedes deshabilitar el incremento de versi&#x00f3;n autom&#x00e1;tico de Hibernate para propiedades en particular y colecciones estableciendo el atributo de mapeo <literal>optimistic-lock</literal> a <literal>false</literal>. Hibernate entonces no incrementar&#x00e1; ya m&#x00e1;s las versiones si la propiedad est&#x00e1; sucia."

#: index.docbook:729
msgid "Also note that you should keep the disconnected <literal>Session</literal> close to the persistence layer. In other words, use an EJB stateful session bean to hold the <literal>Session</literal> in a three-tier environment, and don't transfer it to the web layer (or even serialize it to a separate tier) to store it in the <literal>HttpSession</literal>."
msgstr "Los esquemas de base de datos heredados son frecuentemente est&#x00e1;ticos y no pueden ser modificados. U otras aplicaciones podr&#x00ed;an tambi&#x00e9;n acceder la misma base de datos y no saber c&#x00f3;mo manejar los n&#x00fa;meros de versi&#x00f3;n ni incluso timestamps. En ambos casos, el versionado no puede confiarse a una columna en particular en una tabla. Para forzar un chequeo de versiones sin un mapeo de propiedad de versi&#x00f3;n o timestamp, con una comparaci&#x00f3;n del estado de todos los campos en una fila, activa <literal>optimistic-lock=\"all\"</literal> en el mapeo de <literal>&lt;class&gt;</literal>. Nota que esto conceptualmente funciona solamente si Hibernate puede comparar el estado viejo y nuevo, es decir, si usas una sola <literal>Session</literal> larga y no sesi&#x00f3;n-por-petici&#x00f3;n-con-instancias-separadas."

#: index.docbook:737
msgid "The extended session pattern, or <emphasis>session-per-conversation</emphasis>, is more difficult to implement with automatic current session context management. You need to supply your own implementation of the <literal>CurrentSessionContext</literal> for this, see the Hibernate Wiki for examples."
msgstr "A veces las modificaciones concurrentes pueden permitirse, en cuanto los cambios que hayan sido hechos no se traslapen. Si estableces <literal>optimistic-lock=\"dirty\"</literal> al mapear la <literal>&lt;class&gt;</literal>, Hibernate s&#x00f3;lo comparar&#x00e1; los campos sucios durante la limpieza."

#: index.docbook:747
msgid "Detached objects and automatic versioning"
msgstr "En ambos casos, con columnas de versi&#x00f3;n/timestamp dedicadas o con comparaci&#x00f3;n de campos completa/sucios, Hibernate usa una sola sentencia <literal>UPDATE</literal> (con una cl&#x00e1;usula <literal>WHERE</literal> apropiada) por entidad para ejecutar el chequeo de versiones y actualizar la informaci&#x00f3;n. Si usas persistencia transitiva para la re-uni&#x00f3;n en cascada de entidades asociadas, Hibernate podr&#x00ed;a ejecutar actualizaciones innecesarias. Esto usualmente no es un problema, pero podr&#x00ed;an ejecutarse disparadores (triggers) <emphasis>on update</emphasis> en la base de datos incluso cuando no se haya hecho ning&#x00fa;n cambio a las instancias separadas. Puedes personalizar este comportamiento estableciendo <literal>select-before-update=\"true\"</literal> en el mapeo de <literal>&lt;class&gt;</literal>, forzando a Hibernate a <literal>SELECT</literal> la instancia para asegurar que las actualizaciones realmente ocurran, antes de actualizar la fila."

#: index.docbook:749
msgid "Each interaction with the persistent store occurs in a new <literal>Session</literal>. However, the same persistent instances are reused for each interaction with the database. The application manipulates the state of detached instances originally loaded in another <literal>Session</literal> and then reattaches them using <literal>Session.update()</literal>, <literal>Session.saveOrUpdate()</literal>, or <literal>Session.merge()</literal>."
msgstr "Bloqueo pesimista"

#: index.docbook:757
msgid ""
      "<![CDATA[// foo is an instance loaded by a previous Session\n"
      "foo.setProperty(\"bar\");\n"
      "session = factory.openSession();\n"
      "Transaction t = session.beginTransaction();\n"
      "session.saveOrUpdate(foo); // Use merge() if \"foo\" might have been loaded already\n"
      "t.commit();\n"
      "session.close();]]>"
msgstr "No se pretende que los usuarios gasten mucho tiempo preocup&#x00e1;ndose de las estrategias de bloqueo. Usualmente es suficiente con especificar un nivel de aislamiento para las conexiones JDBC y entonces simplemente dejar que la base de datos haga todo el trabajo. Sin embargo, los usuarios avanzados pueden a veces obtener bloqueos exclusivos pesimistas, o reobtener bloqueos al comienzo de una nueva transacci&#x00f3;n."

#: index.docbook:759
msgid "Again, Hibernate will check instance versions during flush, throwing an exception if conflicting updates occured."
msgstr "&#x00a1;Hibernate siempre usar&#x00e1; el mecanismo de bloqueo de la base de datos, nunca bloqueo de objetos en memoria!"

#: index.docbook:764
msgid "You may also call <literal>lock()</literal> instead of <literal>update()</literal> and use <literal>LockMode.READ</literal> (performing a version check, bypassing all caches) if you are sure that the object has not been modified."
msgstr "La clase <literal>LockMode</literal> define los diferentes niveles de bloqueo que pueden ser adquiridos por Hibernate. Un bloqueo se obtiene por los siguientes mecanismos:"

#: index.docbook:773
msgid "Customizing automatic versioning"
msgstr "<literal>LockMode.WRITE</literal> se adquiere autom&#x00e1;ticamente cuando Hibernate actualiza o inserta una fila."

#: index.docbook:775
msgid "You may disable Hibernate's automatic version increment for particular properties and collections by setting the <literal>optimistic-lock</literal> mapping attribute to <literal>false</literal>. Hibernate will then no longer increment versions if the property is dirty."
msgstr "<literal>LockMode.UPGRADE</literal> puede ser adquirido bajo petici&#x00f3;n expl&#x00ed;cita del usuario usando <literal>SELECT ... FOR UPDATE</literal> en base de datos que soporten esa sint&#x00e1;xis."

#: index.docbook:782
msgid "Legacy database schemas are often static and can't be modified. Or, other applications might also access the same database and don't know how to handle version numbers or even timestamps. In both cases, versioning can't rely on a particular column in a table. To force a version check without a version or timestamp property mapping, with a comparison of the state of all fields in a row, turn on <literal>optimistic-lock=\"all\"</literal> in the <literal>&lt;class&gt;</literal> mapping. Note that this concepetually only works if Hibernate can compare the old and new state, i.e. if you use a single long <literal>Session</literal> and not session-per-request-with-detached-objects."
msgstr "<literal>LockMode.UPGRADE_NOWAIT</literal> puede ser adquirido bajo petici&#x00f3;n expl&#x00ed;cita del usuario usando un <literal>SELECT ... FOR UPDATE NOWAIT</literal> bajo Oracle."

#: index.docbook:793
msgid "Sometimes concurrent modification can be permitted as long as the changes that have been made don't overlap. If you set <literal>optimistic-lock=\"dirty\"</literal> when mapping the <literal>&lt;class&gt;</literal>, Hibernate will only compare dirty fields during flush."
msgstr "<literal>LockMode.READ</literal> es adquirido autom&#x00e1;ticamente cuando Hibernate lee datos bajo los niveles de aislamiento Repeatable Read o Serializable. Puede ser readquirido por pedido expl&#x00ed;cito del usuario."

#: index.docbook:799
msgid "In both cases, with dedicated version/timestamp columns or with full/dirty field comparison, Hibernate uses a single <literal>UPDATE</literal> statement (with an appropriate <literal>WHERE</literal> clause) per entity to execute the version check and update the information. If you use transitive persistence to cascade reattachment to associated entities, Hibernate might execute uneccessary updates. This is usually not a problem, but <emphasis>on update</emphasis> triggers in the database might be executed even when no changes have been made to detached instances. You can customize this behavior by setting <literal>select-before-update=\"true\"</literal> in the <literal>&lt;class&gt;</literal> mapping, forcing Hibernate to <literal>SELECT</literal> the instance to ensure that changes did actually occur, before updating the row."
msgstr "<literal>LockMode.NONE</literal> representa la ausencia de un bloqueo. Todos los objetos se pasan a este modo de bloqueo al final de una <literal>Transaction</literal>. Los objetos asociados con una sesi&#x00f3;n v&#x00ed;a una llamada a <literal>update()</literal> o <literal>saveOrUpdate()</literal> tambi&#x00e9;n comienzan en este modo de bloqueo."

#: index.docbook:817
msgid "Pessimistic Locking"
msgstr "La \"petici&#x00f3;n expl&#x00ed;cita del usuario\" se expresa en una de las siguientes formas:"

#: index.docbook:819
msgid "It is not intended that users spend much time worring about locking strategies. Its usually enough to specify an isolation level for the JDBC connections and then simply let the database do all the work. However, advanced users may sometimes wish to obtain exclusive pessimistic locks, or re-obtain locks at the start of a new transaction."
msgstr "Una llamada a <literal>Session.load()</literal>, especificando un <literal>LockMode</literal>."

#: index.docbook:826
msgid "Hibernate will always use the locking mechanism of the database, never lock objects in memory!"
msgstr "Una llamada a <literal>Session.lock()</literal>."

#: index.docbook:831
msgid "The <literal>LockMode</literal> class defines the different lock levels that may be acquired by Hibernate. A lock is obtained by the following mechanisms:"
msgstr "Una llamada a <literal>Query.setLockMode()</literal>."

#: index.docbook:838
msgid "<literal>LockMode.WRITE</literal> is acquired automatically when Hibernate updates or inserts a row."
msgstr "Si se llama a <literal>Session.load()</literal> con <literal>UPGRADE</literal> o <literal>UPGRADE_NOWAIT</literal>, y el objeto pedido no ha sido a&#x00fa;n cargado por la sesi&#x00f3;n, el objeto es cargado usando <literal>SELECT ... FOR UPDATE</literal>. Si se llama a <literal>load()</literal> para un objeto que ya est&#x00e9; cargado con un bloqueo menos restrictivo que el pedido, Hibernate llama a <literal>lock()</literal> para ese objeto."

#: index.docbook:844
msgid "<literal>LockMode.UPGRADE</literal> may be acquired upon explicit user request using <literal>SELECT ... FOR UPDATE</literal> on databases which support that syntax."
msgstr "<literal>Session.lock()</literal> realiza un chequeo de n&#x00fa;mero de versi&#x00f3;n si el modo de bloqueo especificado es <literal>READ</literal>, <literal>UPGRADE</literal> o <literal>UPGRADE_NOWAIT</literal>. (En el caso de <literal>UPGRADE</literal> o <literal>UPGRADE_NOWAIT</literal>, se usa <literal>SELECT ... FOR UPDATE</literal>.)"

#: index.docbook:850
msgid "<literal>LockMode.UPGRADE_NOWAIT</literal> may be acquired upon explicit user request using a <literal>SELECT ... FOR UPDATE NOWAIT</literal> under Oracle."
msgstr "Si la base de datos no soporta el modo de bloqueo solicitado, Hibernate usar&#x00e1; un modo alternativo apropiado (en vez de lanzar una excepci&#x00f3;n). Esto asegura que las aplicaciones ser&#x00e1;n portables."

#: index.docbook:856
msgid "<literal>LockMode.READ</literal> is acquired automatically when Hibernate reads data under Repeatable Read or Serializable isolation level. May be re-acquired by explicit user request."
msgstr ""

#: index.docbook:863
msgid "<literal>LockMode.NONE</literal> represents the absence of a lock. All objects switch to this lock mode at the end of a <literal>Transaction</literal>. Objects associated with the session via a call to <literal>update()</literal> or <literal>saveOrUpdate()</literal> also start out in this lock mode."
msgstr ""

#: index.docbook:872
msgid "The \"explicit user request\" is expressed in one of the following ways:"
msgstr ""

#: index.docbook:878
msgid "A call to <literal>Session.load()</literal>, specifying a <literal>LockMode</literal>."
msgstr ""

#: index.docbook:883
msgid "A call to <literal>Session.lock()</literal>."
msgstr ""

#: index.docbook:888
msgid "A call to <literal>Query.setLockMode()</literal>."
msgstr ""

#: index.docbook:894
msgid "If <literal>Session.load()</literal> is called with <literal>UPGRADE</literal> or <literal>UPGRADE_NOWAIT</literal>, and the requested object was not yet loaded by the session, the object is loaded using <literal>SELECT ... FOR UPDATE</literal>. If <literal>load()</literal> is called for an object that is already loaded with a less restrictive lock than the one requested, Hibernate calls <literal>lock()</literal> for that object."
msgstr ""

#: index.docbook:903
msgid "<literal>Session.lock()</literal> performs a version number check if the specified lock mode is <literal>READ</literal>, <literal>UPGRADE</literal> or <literal>UPGRADE_NOWAIT</literal>. (In the case of <literal>UPGRADE</literal> or <literal>UPGRADE_NOWAIT</literal>, <literal>SELECT ... FOR UPDATE</literal> is used.)"
msgstr ""

#: index.docbook:910
msgid "If the database does not support the requested lock mode, Hibernate will use an appropriate alternate mode (instead of throwing an exception). This ensures that applications will be portable."
msgstr ""

#: index.docbook:919
msgid "Connection Release Modes"
msgstr ""

#: index.docbook:921
msgid "The legacy (2.x) behavior of Hibernate in regards to JDBC connection management was that a <literal>Session</literal> would obtain a connection when it was first needed and then hold unto that connection until the session was closed. Hibernate 3.x introduced the notion of connection release modes to tell a session how to handle its JDBC connections. Note that the following discussion is pertinent only to connections provided through a configured <literal>ConnectionProvider</literal>; user-supplied connections are outside the breadth of this discussion. The different release modes are identified by the enumerated values of <literal>org.hibernate.ConnectionReleaseMode</literal>:"
msgstr ""

#: index.docbook:935
msgid "<literal>ON_CLOSE</literal> - is essentially the legacy behavior described above. The Hibernate session obatins a connection when it first needs to perform some JDBC access and holds unto that connection until the session is closed."
msgstr ""

#: index.docbook:942
msgid "<literal>AFTER_TRANSACTION</literal> - says to release connections after a <literal>org.hibernate.Transaction</literal> has completed."
msgstr ""

#: index.docbook:948
msgid "<literal>AFTER_STATEMENT</literal> (also referred to as aggressive release) - says to release connections after each and every statement execution. This aggressive releasing is skipped if that statement leaves open resources associated with the given session; currently the only situation where this occurs is through the use of <literal>org.hibernate.ScrollableResults</literal>."
msgstr ""

#: index.docbook:958
msgid "The configuration parameter <literal>hibernate.connection.release_mode</literal> is used to specify which release mode to use. The possible values:"
msgstr ""

#: index.docbook:965
msgid "<literal>auto</literal> (the default) - this choice delegates to the release mode returned by the <literal>org.hibernate.transaction.TransactionFactory.getDefaultReleaseMode()</literal> method. For JTATransactionFactory, this returns ConnectionReleaseMode.AFTER_STATEMENT; for JDBCTransactionFactory, this returns ConnectionReleaseMode.AFTER_TRANSACTION. It is rarely a good idea to change this default behavior as failures due to the value of this setting tend to indicate bugs and/or invalid assumptions in user code."
msgstr ""

#: index.docbook:975
msgid "<literal>on_close</literal> - says to use ConnectionReleaseMode.ON_CLOSE. This setting is left for backwards compatibility, but its use is highly discouraged."
msgstr ""

#: index.docbook:981
msgid "<literal>after_transaction</literal> - says to use ConnectionReleaseMode.AFTER_TRANSACTION. This setting should not be used in JTA environments. Also note that with ConnectionReleaseMode.AFTER_TRANSACTION, if a session is considered to be in auto-commit mode connections will be released as if the release mode were AFTER_STATEMENT."
msgstr ""

#: index.docbook:989
msgid "<literal>after_statement</literal> - says to use ConnectionReleaseMode.AFTER_STATEMENT. Additionally, the configured <literal>ConnectionProvider</literal> is consulted to see if it supports this setting (<literal>supportsAggressiveRelease()</literal>). If not, the release mode is reset to ConnectionReleaseMode.AFTER_TRANSACTION. This setting is only safe in environments where we can either re-acquire the same underlying JDBC connection each time we make a call into <literal>ConnectionProvider.getConnection()</literal> or in auto-commit environments where it does not matter whether we get back the same connection."
msgstr ""

msgid "ROLES_OF_TRANSLATORS"
msgstr "<!--TRANS:ROLES_OF_TRANSLATORS-->"

msgid "CREDIT_FOR_TRANSLATORS"
msgstr "<!--TRANS:CREDIT_FOR_TRANSLATORS-->"

