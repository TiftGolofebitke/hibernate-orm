#, fuzzy
msgid ""
msgstr ""
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Content-Type: text/plain; charset=utf-8\n"
#: index.docbook:5
msgid "Configuration"
msgstr "Configuraci&#x00f3;n"

#: index.docbook:7
msgid "Because Hibernate is designed to operate in many different environments, there are a large number of configuration parameters. Fortunately, most have sensible default values and Hibernate is distributed with an example <literal>hibernate.properties</literal> file in <literal>etc/</literal> that shows the various options. Just put the example file in your classpath and customize it."
msgstr "Debido a que Hibernate est&#x00e1; dise&#x00f1;ado para operar en muchos entornos diferentes, hay un gran n&#x00fa;mero de par&#x00e1;metros de configuraci&#x00f3;n. Afortunadamente, la mayor&#x00ed;a tiene valores por defecto sensibles e Hibernate se distribuye con un fichero <literal>hibernate.properties</literal> de ejemplo en <literal>etc/</literal> que muestra las diversas opciones. Tan s&#x00f3;lo pon el fichero de ejemplo en tu classpath y personal&#x00ed;zalo."

#: index.docbook:16
msgid "Programmatic configuration"
msgstr "Configuraci&#x00f3;n program&#x00e1;tica"

#: index.docbook:18
msgid "An instance of <literal>org.hibernate.cfg.Configuration</literal> represents an entire set of mappings of an application's Java types to an SQL database. The <literal>Configuration</literal> is used to build an (immutable) <literal>SessionFactory</literal>. The mappings are compiled from various XML mapping files."
msgstr "Una instancia de <literal>org.hibernate.cfg.Configuration</literal> representa un conjunto entero de mapeos de los tipos Java de una aplicaci&#x00f3;n a una base de datos SQL. La <literal>Configuration</literal> es usada para construir una <literal>SessionFactory</literal> (inmutable). Los mapeos se compilan de varios ficheros de mapeo XML."

#: index.docbook:26
msgid "You may obtain a <literal>Configuration</literal> instance by instantiating it directly and specifying XML mapping documents. If the mapping files are in the classpath, use <literal>addResource()</literal>:"
msgstr "Puedes obtener una instancia de <literal>Configuration</literal> instanci&#x00e1;ndola directamente y especificando documentos de mapeo XML. Si los ficheros de mapeo est&#x00e1;n en el classpath, usa <literal>addResource()</literal>:"

#: index.docbook:32
msgid ""
      "<![CDATA[Configuration cfg = new Configuration()\n"
      "    .addResource(\"Item.hbm.xml\")\n"
      "    .addResource(\"Bid.hbm.xml\");]]>"
msgstr ""
      "<![CDATA[Configuration cfg = new Configuration()\n"
      "    .addResource(\"Item.hbm.xml\")\n"
      "    .addResource(\"Bid.hbm.xml\");]]>"

#: index.docbook:34
msgid "An alternative (sometimes better) way is to specify the mapped class, and let Hibernate find the mapping document for you:"
msgstr "Una forma alternativa (a veces mejor) es especificar la clase mapeada, y dejar que Hibernate encuentre el documento de mapeo por ti:"

#: index.docbook:39
msgid ""
      "<![CDATA[Configuration cfg = new Configuration()\n"
      "    .addClass(org.hibernate.auction.Item.class)\n"
      "    .addClass(org.hibernate.auction.Bid.class);]]>"
msgstr ""
      "<![CDATA[Configuration cfg = new Configuration()\n"
      "    .addClass(org.hibernate.auction.Item.class)\n"
      "    .addClass(org.hibernate.auction.Bid.class);]]>"

#: index.docbook:41
msgid "Then Hibernate will look for mapping files named <literal>/org/hibernate/auction/Item.hbm.xml</literal> and <literal>/org/hibernate/auction/Bid.hbm.xml</literal> in the classpath. This approach eliminates any hardcoded filenames."
msgstr "Entonces Hibernate buscar&#x00e1; ficheros de mapeo llamados <literal>/org/hibernate/auction/Item.hbm.xml</literal> y <literal>/org/hibernate/auction/Bid.hbm.xml</literal> en el classpath. Este enfoque elimina cualquier nombre de fichero en el c&#x00f3;digo."

#: index.docbook:48
msgid "A <literal>Configuration</literal> also allows you to specify configuration properties:"
msgstr "Una <literal>Configuration</literal> tambi&#x00e9;n te permite especificar propiedades de configuraci&#x00f3;n:"

#: index.docbook:53
msgid ""
      "<![CDATA[Configuration cfg = new Configuration()\n"
      "    .addClass(org.hibernate.auction.Item.class)\n"
      "    .addClass(org.hibernate.auction.Bid.class)\n"
      "    .setProperty(\"hibernate.dialect\", \"org.hibernate.dialect.MySQLInnoDBDialect\")\n"
      "    .setProperty(\"hibernate.connection.datasource\", \"java:comp/env/jdbc/test\")\n"
      "    .setProperty(\"hibernate.order_updates\", \"true\");]]>"
msgstr ""
      "<![CDATA[Configuration cfg = new Configuration()\n"
      "    .addClass(org.hibernate.auction.Item.class)\n"
      "    .addClass(org.hibernate.auction.Bid.class)\n"
      "    .setProperty(\"hibernate.dialect\", \"org.hibernate.dialect.MySQLInnoDBDialect\")\n"
      "    .setProperty(\"hibernate.connection.datasource\", \"java:comp/env/jdbc/test\")\n"
      "    .setProperty(\"hibernate.order_updates\", \"true\");]]>"

#: index.docbook:55
msgid "This is not the only way to pass configuration properties to Hibernate. The various options include:"
msgstr "Esta no es la &#x00fa;nica forma de pasar propiedades de configuraci&#x00f3;n a Hibernate. La diversas opciones incluyen:"

#: index.docbook:62
msgid "Pass an instance of <literal>java.util.Properties</literal> to <literal>Configuration.setProperties()</literal>."
msgstr "Pasar una instancia de <literal>java.util.Properties</literal> a <literal>Configuration.setProperties()</literal>."

#: index.docbook:68
msgid "Place <literal>hibernate.properties</literal> in a root directory of the classpath."
msgstr "Colocar <literal>hibernate.properties</literal> en un directorio ra&#x00ed;z del classpath."

#: index.docbook:74
msgid "Set <literal>System</literal> properties using <literal>java -Dproperty=value</literal>."
msgstr "Establecer propiedades <literal>System</literal> usando <literal>java -Dproperty=value</literal>."

#: index.docbook:80
msgid "Include <literal>&lt;property&gt;</literal> elements in <literal>hibernate.cfg.xml</literal> (discussed later)."
msgstr "Incluir elementos <literal>&lt;property&gt;</literal> en <literal>hibernate.cfg.xml</literal> (discutido luego)."

#: index.docbook:87
msgid "<literal>hibernate.properties</literal> is the easiest approach if you want to get started quickly."
msgstr "<literal>hibernate.properties</literal> es el enfoque m&#x00e1;s f&#x00e1;cil si quieres comenzar r&#x00e1;pido."

#: index.docbook:92
msgid "The <literal>Configuration</literal> is intended as a startup-time object, to be discarded once a <literal>SessionFactory</literal> is created."
msgstr "La <literal>Configuration</literal> est&#x00e1; concebida como un objeto de tiempo de arranque, para ser descartado una vez que una <literal>SessionFactory</literal> es creada."

#: index.docbook:100
msgid "Obtaining a SessionFactory"
msgstr "Obteniendo una SessionFactory"

#: index.docbook:102
msgid "When all mappings have been parsed by the <literal>Configuration</literal>, the application must obtain a factory for <literal>Session</literal> instances. This factory is intended to be shared by all application threads:"
msgstr "Cuando todos los mapeos han sido parseados por la <literal>Configuration</literal>, la aplicaci&#x00f3;n debe obtener una f&#x00e1;brica de instancias de <literal>Session</literal>. Esta f&#x00e1;brica est&#x00e1; concebida para ser compartida por todas las hebras de aplicaci&#x00f3;n:"

#: index.docbook:108
msgid "<![CDATA[SessionFactory sessions = cfg.buildSessionFactory();]]>"
msgstr "<![CDATA[SessionFactory sessions = cfg.buildSessionFactory();]]>"

#: index.docbook:110
msgid "Hibernate does allow your application to instantiate more than one <literal>SessionFactory</literal>. This is useful if you are using more than one database."
msgstr "Hibernate permite que tu aplicaci&#x00f3;n instancie m&#x00e1;s de una <literal>SessionFactory</literal>. Esto es &#x00fa;til si est&#x00e1;s usando m&#x00e1;s de una base de datos."

#: index.docbook:119
msgid "JDBC connections"
msgstr "Conexiones JDBC"

#: index.docbook:121
msgid "Usually, you want to have the <literal>SessionFactory</literal> create and pool JDBC connections for you. If you take this approach, opening a <literal>Session</literal> is as simple as:"
msgstr "Usualmente, quieres que la <literal>SessionFactory</literal> cree y almacene en pool conexiones JDBC para ti. Si adoptas este enfoque, abrir una <literal>Session</literal> es tan simple como:"

#: index.docbook:127
msgid "<![CDATA[Session session = sessions.openSession(); // open a new Session]]>"
msgstr "<![CDATA[Session session = sessions.openSession(); // open a new Session]]>"

#: index.docbook:129
msgid "As soon as you do something that requires access to the database, a JDBC connection will be obtained from the pool."
msgstr "En cuanto hagas algo que requiera acceso a la base de datos, se obtendr&#x00e1; una conexi&#x00f3;n JDBC del pool."

#: index.docbook:134
msgid "For this to work, we need to pass some JDBC connection properties to Hibernate. All Hibernate property names and semantics are defined on the class <literal>org.hibernate.cfg.Environment</literal>. We will now describe the most important settings for JDBC connection configuration."
msgstr "Para que esto funcione, necesitamos pasar algunas propiedades de conexi&#x00f3;n JDBC a Hibernate. Todos los nombres de propiedades y su sem&#x00e1;ntica est&#x00e1;n definidas en la clase <literal>org.hibernate.cfg.Environment</literal>. Describiremos ahora las configuraciones m&#x00e1;s importantes para la conexi&#x00f3;n JDBC."

#: index.docbook:141
msgid "Hibernate will obtain (and pool) connections using <literal>java.sql.DriverManager</literal> if you set the following properties:"
msgstr "Hibernate obtendr&#x00e1; (y tendr&#x00e1; en pool) conexiones usando <literal>java.sql.DriverManager</literal> si configuras las siguientes propiedades:"

#: index.docbook:147
msgid "Hibernate JDBC Properties"
msgstr "Propiedades JDBC de Hibernate"

#: index.docbook:153, index.docbook:241, index.docbook:338, index.docbook:529, index.docbook:725, index.docbook:832, index.docbook:920
msgid "Property name"
msgstr "Nombre de propiedad"

#: index.docbook:154, index.docbook:242, index.docbook:339, index.docbook:530, index.docbook:726, index.docbook:833, index.docbook:921
msgid "Purpose"
msgstr "Prop&#x00f3;sito"

#: index.docbook:160
msgid "hibernate.connection.driver_class"
msgstr "hibernate.connection.driver_class"

#: index.docbook:163
msgid "JDBC driver class"
msgstr "clase del driver jdbc"

#: index.docbook:168
msgid "hibernate.connection.url"
msgstr "hibernate.connection.url"

#: index.docbook:171
msgid "JDBC URL"
msgstr "URL de jdbc"

#: index.docbook:176, index.docbook:272
msgid "hibernate.connection.username"
msgstr "hibernate.connection.username"

#: index.docbook:179
msgid "database user"
msgstr "usuario de base de datos"

#: index.docbook:184, index.docbook:280
msgid "hibernate.connection.password"
msgstr "hibernate.connection.password"

#: index.docbook:187
msgid "database user password"
msgstr "contrase&#x00f1;a del usuario de base de datos"

#: index.docbook:192
msgid "hibernate.connection.pool_size"
msgstr "hibernate.connection.pool_size"

#: index.docbook:195
msgid "maximum number of pooled connections"
msgstr "n&#x00fa;mero m&#x00e1;ximo de conexiones manejadas por pooling"

#: index.docbook:202
msgid "Hibernate's own connection pooling algorithm is however quite rudimentary. It is intended to help you get started and is <emphasis>not intended for use in a production system</emphasis> or even for performance testing. You should use a third party pool for best performance and stability. Just replace the <literal>hibernate.connection.pool_size</literal> property with connection pool specific settings. This will turn off Hibernate's internal pool. For example, you might like to use C3P0."
msgstr "El algoritmo de pooling de conexiones propio de Hibernate es sin embargo algo rudimentario. Est&#x00e1; concebido para ayudarte a comenzar y <emphasis>no est&#x00e1; concebido para usar en un sistema de producci&#x00f3;n</emphasis> ni siquiera para pruebas de rendimiento. Debes usar un pool de terceros para un mejor rendimiento y estabilidad. S&#x00f3;lo remplaza la propiedad <literal>hibernate.connection.pool_size</literal> con configuraciones espec&#x00ed;ficas del pool de conexiones. Esto desactivar&#x00e1; el pool interno de Hibernate. Por ejemplo, podr&#x00ed;as querer usar C3P0."

#: index.docbook:212
msgid "C3P0 is an open source JDBC connection pool distributed along with Hibernate in the <literal>lib</literal> directory. Hibernate will use its <literal>C3P0ConnectionProvider</literal> for connection pooling if you set <literal>hibernate.c3p0.*</literal> properties. If you'd like to use Proxool refer to the packaged <literal>hibernate.properties</literal> and the Hibernate web site for more information."
msgstr "C3P0 es un pool de conexiones JDBC de c&#x00f3;digo abierto distribuido junto a Hibernate en el directorio <literal>lib</literal>. Hibernate usar&#x00e1; su <literal>C3P0ConnectionProvider</literal> para pooling de conexiones si estableces propiedades <literal>hibernate.c3p0.*</literal>. Si quieres usar Proxool refi&#x00e9;rete al <literal>hibernate.properties</literal> empaquetado y al sitio web de Hibernate para m&#x00e1;s informaci&#x00f3;n."

#: index.docbook:221
msgid "Here is an example <literal>hibernate.properties</literal> file for C3P0:"
msgstr "Aqu&#x00ed; hay un fichero <literal>hibernate.properties</literal> de ejemplo para C3P0:"

#: index.docbook:225
msgid ""
      "<![CDATA[hibernate.connection.driver_class = org.postgresql.Driver\n"
      "hibernate.connection.url = jdbc:postgresql://localhost/mydatabase\n"
      "hibernate.connection.username = myuser\n"
      "hibernate.connection.password = secret\n"
      "hibernate.c3p0.min_size=5\n"
      "hibernate.c3p0.max_size=20\n"
      "hibernate.c3p0.timeout=1800\n"
      "hibernate.c3p0.max_statements=50\n"
      "hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect]]>"
msgstr ""
      "<![CDATA[hibernate.connection.driver_class = org.postgresql.Driver\n"
      "hibernate.connection.url = jdbc:postgresql://localhost/mydatabase\n"
      "hibernate.connection.username = myuser\n"
      "hibernate.connection.password = secret\n"
      "hibernate.c3p0.min_size=5\n"
      "hibernate.c3p0.max_size=20\n"
      "hibernate.c3p0.timeout=1800\n"
      "hibernate.c3p0.max_statements=50\n"
      "hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect]]>"

#: index.docbook:227
msgid "For use inside an application server, you should almost always configure Hibernate to obtain connections from an application server <literal>Datasource</literal> registered in JNDI. You'll need to set at least one of the following properties:"
msgstr "Para su uso en un servidor de aplicaciones, casi siempre debes configurar Hibernate para que obtenga conexiones de un <literal>Datasource</literal> del servidor de aplicaciones registrado en JNDI. Necesitar&#x00e1;s establecer al menos una de las siguientes propiedades:"

#: index.docbook:235
msgid "Hibernate Datasource Properties"
msgstr "Propiedades de Datasource de Hibernate"

#: index.docbook:248
msgid "hibernate.connection.datasource"
msgstr "hibernate.connection.datasource"

#: index.docbook:251
msgid "datasource JNDI name"
msgstr "nombre del datasource JNDI"

#: index.docbook:256
msgid "hibernate.jndi.url"
msgstr "hibernate.jndi.url"

#: index.docbook:258
msgid "<emphasis>URL of the JNDI provider</emphasis> (optional)"
msgstr "<emphasis>URL del provedor JNDI</emphasis> (optional)"

#: index.docbook:264
msgid "hibernate.jndi.class"
msgstr "hibernate.jndi.class"

#: index.docbook:266
msgid "<emphasis>class of the JNDI <literal>InitialContextFactory</literal></emphasis> (optional)"
msgstr "<emphasis>clase de la <literal>InitialContextFactory</literal> de JNDI</emphasis> (opcional)"

#: index.docbook:274
msgid "<emphasis>database user</emphasis> (optional)"
msgstr "<emphasis>usuario de base de datos</emphasis> (opcional)"

#: index.docbook:282
msgid "<emphasis>database user password</emphasis> (optional)"
msgstr "<emphasis>contrase&#x00f1;a del usuario de base de datos</emphasis> (opcional)"

#: index.docbook:290
msgid "Here's an example <literal>hibernate.properties</literal> file for an application server provided JNDI datasource:"
msgstr "He aqu&#x00ed; un fichero <literal>hibernate.properties</literal> de ejemplo para un un datasource JNDI provisto por un servidor de aplicaciones."

#: index.docbook:295
msgid ""
      "<![CDATA[hibernate.connection.datasource = java:/comp/env/jdbc/test\n"
      "hibernate.transaction.factory_class = \\\n"
      "    org.hibernate.transaction.JTATransactionFactory\n"
      "hibernate.transaction.manager_lookup_class = \\\n"
      "    org.hibernate.transaction.JBossTransactionManagerLookup\n"
      "hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect]]>"
msgstr ""
      "<![CDATA[hibernate.connection.datasource = java:/comp/env/jdbc/test\n"
      "hibernate.transaction.factory_class = \\\n"
      "    org.hibernate.transaction.JTATransactionFactory\n"
      "hibernate.transaction.manager_lookup_class = \\\n"
      "    org.hibernate.transaction.JBossTransactionManagerLookup\n"
      "hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect]]>"

#: index.docbook:297
msgid "JDBC connections obtained from a JNDI datasource will automatically participate in the container-managed transactions of the application server."
msgstr "Las conexiones JDBC obtenidas de un datasource JNDI participar&#x00e1;n autom&#x00e1;ticamente en las transacciones del servidor de aplicaciones manejadas por contenedor."

#: index.docbook:302
msgid "Arbitrary connection properties may be given by prepending \"<literal>hibernate.connection</literal>\" to the property name. For example, you may specify a <literal>charSet</literal> using <literal>hibernate.connection.charSet</literal>."
msgstr "Pueden darse propiedades de conexi&#x00f3;n arbitrarias anteponiendo \"<literal>hibernate.connnection</literal>\" al nombre de propiedad. Por ejemplo, puedes especificar un <literal>charSet</literal> usando <literal>hibernate.connection.charSet</literal>."

#: index.docbook:308
msgid "You may define your own plugin strategy for obtaining JDBC connections by implementing the interface <literal>org.hibernate.connection.ConnectionProvider</literal>. You may select a custom implementation by setting <literal>hibernate.connection.provider_class</literal>."
msgstr "Puedes definir tu propia estrategia de plugin para obtener conexiones JDBC implementando la interface <literal>org.hibernate.connection.ConnectionProvider</literal>. Puedes seleccionar una implementaci&#x00f3;n personalizada estableciendo <literal>hibernate.connection.provider_class</literal>."

#: index.docbook:317
msgid "Optional configuration properties"
msgstr "Par&#x00e1;metros de configuraci&#x00f3;n opcionales"

#: index.docbook:319
msgid "There are a number of other properties that control the behaviour of Hibernate at runtime. All are optional and have reasonable default values."
msgstr "Hay un n&#x00fa;mero de otras propiedades que controlan el comportamiento de Hibernate en tiempo de ejecuci&#x00f3;n. Todas son opcionales y tienen valores por defecto razonables."

#: index.docbook:324
msgid "<emphasis>Warning: some of these properties are \"system-level\" only.</emphasis> System-level properties can be set only via <literal>java -Dproperty=value</literal> or <literal>hibernate.properties</literal>. They may <emphasis>not</emphasis> be set by the other techniques described above."
msgstr "<emphasis>Advertencia: algunas de estas propiedades son de \"nivel-de-sistema\" solamente.</emphasis>. Las propiedades a nivel de sistema s&#x00f3;lo pueden ser establecidas por medio de <literal>java -Dproperty=value</literal> o <literal>hibernate.properties</literal>. <emphasis>No</emphasis> pueden establecerse por medio de las otras t&#x00e9;cnicas arriba descritas."

#: index.docbook:332
msgid "Hibernate Configuration Properties"
msgstr "Propiedades de Configuraci&#x00f3;n de Hibernate"

#: index.docbook:345
msgid "hibernate.dialect"
msgstr "hibernate.dialect"

#: index.docbook:347
msgid "The classname of a Hibernate <literal>Dialect</literal> which allows Hibernate to generate SQL optimized for a particular relational database."
msgstr "El nombre de clase de un <literal>Dialect</literal> de Hibernate que permite a Hibernate generar SQL optimizado para una base de datos relacional en particular."

#: index.docbook:351
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>full.classname.of.Dialect</literal>"
msgstr "<emphasis role=\"strong\">ej.</emphasis> <literal>full.classname.of.Dialect</literal>"

#: index.docbook:359
msgid "hibernate.show_sql"
msgstr "hibernate.show_sql"

#: index.docbook:361
msgid "Write all SQL statements to console. This is an alternative to setting the log category <literal>org.hibernate.SQL</literal> to <literal>debug</literal>."
msgstr "Escribe todas las sentencias SQL a la consola."

#: index.docbook:365, index.docbook:377, index.docbook:471, index.docbook:484, index.docbook:497, index.docbook:510, index.docbook:564, index.docbook:591, index.docbook:605, index.docbook:660, index.docbook:888, index.docbook:903, index.docbook:993
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>true</literal> | <literal>false</literal>"
msgstr "<emphasis role=\"strong\">ej.</emphasis> <literal>true</literal> | <literal>false</literal>"

#: index.docbook:373
msgid "hibernate.format_sql"
msgstr "hibernate.default_schema"

#: index.docbook:375
msgid "Pretty print the SQL in the log and console."
msgstr "Cualifica, en el SQL generado, los nombres de tabla sin cualificar con el esquema/tablespace dado."

#: index.docbook:385
msgid "hibernate.default_schema"
msgstr "hibernate.default_catalog"

#: index.docbook:387
msgid "Qualify unqualified table names with the given schema/tablespace in generated SQL."
msgstr "Cualifica, en el SQL generado, los nombres de tabla sin cualificar con el cat&#x00e1;logo dado."

#: index.docbook:390
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>SCHEMA_NAME</literal>"
msgstr "<emphasis role=\"strong\">ej.</emphasis> <literal>CATALOG_NAME</literal>"

#: index.docbook:398
msgid "hibernate.default_catalog"
msgstr "hibernate.session_factory_name"

#: index.docbook:400
msgid "Qualify unqualified table names with the given catalog in generated SQL."
msgstr "La <literal>SessionFactory</literal> ser&#x00e1; ligada a este nombre en JNDI autom&#x00e1;ticamente despu&#x00e9;s de ser creada."

#: index.docbook:403
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>CATALOG_NAME</literal>"
msgstr "<emphasis role=\"strong\">ej.</emphasis> <literal>jndi/composite/name</literal>"

#: index.docbook:411
msgid "hibernate.session_factory_name"
msgstr "hibernate.max_fetch_depth"

#: index.docbook:413
msgid "The <literal>SessionFactory</literal> will be automatically bound to this name in JNDI after it has been created."
msgstr "Establece una \"profundidad\" m&#x00e1;xima del &#x00e1;rbol de recuperaci&#x00f3;n por outer join para asociaciones de un extremo solo (uno-a-uno, muchos-a-uno). Un <literal>0</literal> deshabilita la recuperaci&#x00f3;n por outer join por defecto."

#: index.docbook:416, index.docbook:859
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>jndi/composite/name</literal>"
msgstr "<emphasis role=\"strong\">ej.</emphasis> valores recomendados entre <literal>0</literal> y <literal>3</literal>"

#: index.docbook:424
msgid "hibernate.max_fetch_depth"
msgstr "hibernate.default_batch_fetch_size"

#: index.docbook:426
msgid "Set a maximum \"depth\" for the outer join fetch tree for single-ended associations (one-to-one, many-to-one). A <literal>0</literal> disables default outer join fetching."
msgstr "Establece un tama&#x00f1;o por defecto para la recuperaci&#x00f3;n en lote de asociaciones de Hibernate."

#: index.docbook:430
msgid "<emphasis role=\"strong\">eg.</emphasis> recommended values between <literal>0</literal> and <literal>3</literal>"
msgstr "<emphasis role=\"strong\">ej.</emphasis> valores recomendados <literal>4</literal>, <literal>8</literal>, <literal>16</literal>"

#: index.docbook:439
msgid "hibernate.default_batch_fetch_size"
msgstr "hibernate.default_entity_mode"

#: index.docbook:441
msgid "Set a default size for Hibernate batch fetching of associations."
msgstr "Establece un modo por defecto de representaci&#x00f3;n de entidades para todas las sesiones abiertas por esta <literal>SessionFactory</literal>"

#: index.docbook:443
msgid "<emphasis role=\"strong\">eg.</emphasis> recommended values <literal>4</literal>, <literal>8</literal>, <literal>16</literal>"
msgstr "<literal>dynamic-map</literal>, <literal>dom4j</literal>, <literal>pojo</literal>"

#: index.docbook:452
msgid "hibernate.default_entity_mode"
msgstr "hibernate.order_updates"

#: index.docbook:454
msgid "Set a default mode for entity representation for all sessions opened from this <literal>SessionFactory</literal>"
msgstr "Fuerza a Hibernate a ordenar las actualizaciones SQL por el valor de la clave primaria de los items a actualizar. Esto resultar&#x00e1; en menos bloqueos muertos de transacci&#x00f3;n en sistemas altamente concurrentes."

#: index.docbook:457
msgid "<literal>dynamic-map</literal>, <literal>dom4j</literal>, <literal>pojo</literal>"
msgstr "<emphasis role=\"strong\">ej.</emphasis> <literal>true</literal> | <literal>false</literal>"

#: index.docbook:465
msgid "hibernate.order_updates"
msgstr "hibernate.generate_statistics"

#: index.docbook:467
msgid "Force Hibernate to order SQL updates by the primary key value of the items being updated. This will result in fewer transaction deadlocks in highly concurrent systems."
msgstr "De habilitarse, Hibernate colectar&#x00e1; estad&#x00ed;sticas &#x00fa;tiles para la afinaci&#x00f3;n de rendimiento."

#: index.docbook:479
msgid "hibernate.generate_statistics"
msgstr "hibernate.use_identifer_rollback"

#: index.docbook:481
msgid "If enabled, Hibernate will collect statistics useful for performance tuning."
msgstr "De habilitarse, las propiedades identificadoras generadas ser&#x00e1;n reseteadas a valores por defecto cuando los objetos sean borrados."

#: index.docbook:492
msgid "hibernate.use_identifier_rollback"
msgstr "hibernate.use_sql_comments"

#: index.docbook:494
msgid "If enabled, generated identifier properties will be reset to default values when objects are deleted."
msgstr "De activarse, Hibernate generar&#x00e1; comentarios dentro del SQL, para una m&#x00e1;s f&#x00e1;cil depuraci&#x00f3;n, por defecto a <literal>false</literal>."

#: index.docbook:505
msgid "hibernate.use_sql_comments"
msgstr "Propiedades de JDBC y Conexiones de Hibernate"

#: index.docbook:507
msgid "If turned on, Hibernate will generate comments inside the SQL, for easier debugging, defaults to <literal>false</literal>."
msgstr "Nombre de propiedad"

#: index.docbook:521
msgid "Hibernate JDBC and Connection Properties"
msgstr "hibernate.jdbc.fetch_size"

#: index.docbook:536
msgid "hibernate.jdbc.fetch_size"
msgstr "Un valor distinto de cero habilita el uso de actualizaciones en lote de JDBC2 por Hibernate."

#: index.docbook:538
msgid "A non-zero value determines the JDBC fetch size (calls <literal>Statement.setFetchSize()</literal>)."
msgstr "<emphasis role=\"strong\">ej.</emphasis> valores recomendados entre <literal>5</literal> y <literal>30</literal>"

#: index.docbook:545
msgid "hibernate.jdbc.batch_size"
msgstr "hibernate.jdbc.batch_versioned_data"

#: index.docbook:547
msgid "A non-zero value enables use of JDBC2 batch updates by Hibernate."
msgstr "Establece esta propiedad a <literal>true</literal> si tu driver JDBC devuelve cuentas correctas de filas desde <literal>executeBatch()</literal> (usualmente es seguro activar esta opci&#x00f3;n). Hibernate usar&#x00e1; DML en lote para versionar autom&#x00e1;ticamente los datos. Por defecto a <literal>false</literal>."

#: index.docbook:549
msgid "<emphasis role=\"strong\">eg.</emphasis> recommended values between <literal>5</literal> and <literal>30</literal>"
msgstr "<emphasis role=\"strong\">ej.</emphasis> <literal>true</literal> | <literal>false</literal>"

#: index.docbook:557
msgid "hibernate.jdbc.batch_versioned_data"
msgstr "hibernate.jdbc.factory_class"

#: index.docbook:559
msgid "Set this property to <literal>true</literal> if your JDBC driver returns correct row counts from <literal>executeBatch()</literal> (it is usually safe to turn this option on). Hibernate will then use batched DML for automatically versioned data. Defaults to <literal>false</literal>."
msgstr "Selecciona un <literal>Batcher</literal> personalizado. La mayor&#x00ed;a de las aplicaciones no necesitar&#x00e1;n esta propiedad de configuraci&#x00f3;n."

#: index.docbook:572
msgid "hibernate.jdbc.factory_class"
msgstr "hibernate.jdbc.use_scrollable_resultset"

#: index.docbook:574
msgid "Select a custom <literal>Batcher</literal>. Most applications will not need this configuration property."
msgstr "Habilita el uso de resultados scrollables de JDBC2 por Hibernate. Esta propiedad s&#x00f3;lo es necesaria cuando se usan conexiones JDBC provistas por el usuario, en caso contrario Hibernate usa los metadatos de conexi&#x00f3;n."

#: index.docbook:577
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>classname.of.BatcherFactory</literal>"
msgstr "<emphasis role=\"strong\">ej.</emphasis> <literal>true</literal> | <literal>false</literal>"

#: index.docbook:585
msgid "hibernate.jdbc.use_scrollable_resultset"
msgstr "hibernate.jdbc.use_streams_for_binary"

#: index.docbook:587
msgid "Enables use of JDBC2 scrollable resultsets by Hibernate. This property is only necessary when using user supplied JDBC connections, Hibernate uses connection metadata otherwise."
msgstr "Usa flujos (streams) al escribir/leer tipos <literal>binary</literal> o <literal>serializable</literal> a/desde JDBC (propiedad a nivel de sistema)."

#: index.docbook:599
msgid "hibernate.jdbc.use_streams_for_binary"
msgstr "hibernate.jdbc.use_get_generated_keys"

#: index.docbook:601
msgid "Use streams when writing/reading <literal>binary</literal> or <literal>serializable</literal> types to/from JDBC (system-level property)."
msgstr "Habilita el uso de <literal>PreparedStatement.getGeneratedKeys()</literal> de JDBC3 para traer claves generadas nativamente despu&#x00e9;s de insertar. Requiere un driver JDBC3+ y un JRE1.4+. Establ&#x00e9;cela a false si tu driver tiene problemas con los generadores de identificador de Hibernate. Por defecto, se intenta determinar las capacidades del driver usando los metadatos de conexi&#x00f3;n."

#: index.docbook:613
msgid "hibernate.jdbc.use_get_generated_keys"
msgstr "hibernate.connection.provider_class"

#: index.docbook:615
msgid "Enable use of JDBC3 <literal>PreparedStatement.getGeneratedKeys()</literal> to retrieve natively generated keys after insert. Requires JDBC3+ driver and JRE1.4+, set to false if your driver has problems with the Hibernate identifier generators. By default, tries to determine the driver capabilities using connection metadata."
msgstr "EL nombre de clase de un <literal>ConnectionProvider</literal> personalizado que provea conexiones JDBC a Hibernate."

#: index.docbook:621, index.docbook:751, index.docbook:763, index.docbook:777, index.docbook:815
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>true|false</literal>"
msgstr "<emphasis role=\"strong\">ej.</emphasis> <literal>classname.of.ConnectionProvider</literal>"

#: index.docbook:629
msgid "hibernate.connection.provider_class"
msgstr "hibernate.connection.isolation"

#: index.docbook:631
msgid "The classname of a custom <literal>ConnectionProvider</literal> which provides JDBC connections to Hibernate."
msgstr "Establece el nivel de aislamiento de transacci&#x00f3;n JDBC. Comprueba <literal>java.sql.Connection</literal> para valores significativos pero observa que la mayor&#x00ed;a de las bases de datos no soportan todos los niveles de aislamiento."

#: index.docbook:634
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>classname.of.ConnectionProvider</literal>"
msgstr "<emphasis role=\"strong\">eg.</emphasis> <literal>1, 2, 4, 8</literal>"

#: index.docbook:642
msgid "hibernate.connection.isolation"
msgstr "hibernate.connection.autocommit"

#: index.docbook:644
msgid "Set the JDBC transaction isolation level. Check <literal>java.sql.Connection</literal> for meaningful values but note that most databases do not support all isolation levels."
msgstr "Habilita compromiso autom&#x00e1;tico (autocommit) para las conexiones JDBC en pool (no recomendado)."

#: index.docbook:648
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>1, 2, 4, 8</literal>"
msgstr "<emphasis role=\"strong\">ej.</emphasis> <literal>true</literal> | <literal>false</literal>"

#: index.docbook:656
msgid "hibernate.connection.autocommit"
msgstr "hibernate.connection.release_mode"

#: index.docbook:658
msgid "Enables autocommit for JDBC pooled connections (not recommended)."
msgstr "Especifica cu&#x00e1;ndo Hibernate debe liberar las conexiones JDBC. Por defecto, una conexi&#x00f3;n JDBC es retenida hasta que la sesi&#x00f3;n es cerrada expl&#x00ed;citamente o desconectada. Para un datasource JTA del servidor de aplicaciones, debes usar <literal>after_statement</literal> para liberar agresivamente las conexiones despu&#x00e9;s de cada llamada JDBC. Para una conexi&#x00f3;n no JTA, frecuentemente tiene sentido liberar la conexi&#x00f3;n al final de cada transacci&#x00f3;n, usando <literal>after_transaction</literal>. <literal>auto</literal> eligir&#x00e1; <literal>after_statement</literal> para las estrategias JTA o CMT de transacci&#x00f3;n y <literal>after_transaction</literal> para la estrategia JDBC de transacci&#x00f3;n."

#: index.docbook:668
msgid "hibernate.connection.release_mode"
msgstr "hibernate.connection.<emphasis>&lt;propertyName&gt;</emphasis>"

#: index.docbook:670
msgid "Specify when Hibernate should release JDBC connections. By default, a JDBC connection is held until the session is explicitly closed or disconnected. For an application server JTA datasource, you should use <literal>after_statement</literal> to aggressively release connections after every JDBC call. For a non-JTA connection, it often makes sense to release the connection at the end of each transaction, by using <literal>after_transaction</literal>. <literal>auto</literal> will choose <literal>after_statement</literal> for the JTA and CMT transaction strategies and <literal>after_transaction</literal> for the JDBC transaction strategy."
msgstr "Pasa la propiedad JDBC <literal>propertyName</literal> a <literal>DriverManager.getConnection()</literal>."

#: index.docbook:681
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>auto</literal> (default) | <literal>on_close</literal> | <literal>after_transaction</literal> | <literal>after_statement</literal>"
msgstr "hibernate.jndi.<emphasis>&lt;propertyName&gt;</emphasis>"

#: index.docbook:686
msgid "Note that this setting only affects <literal>Session</literal>s returned from <literal>SessionFactory.openSession</literal>. For <literal>Session</literal>s obtained through <literal>SessionFactory.getCurrentSession</literal>, the <literal>CurrentSessionContext</literal> implementation configured for use controls the connection release mode for those <literal>Session</literal>s. See"
msgstr "Pasa la propiedad <literal>propertyName</literal> a <literal>InitialContextFactory</literal> de JNDI."

#: index.docbook:698
msgid "hibernate.connection.<emphasis>&lt;propertyName&gt;</emphasis>"
msgstr "Propiedades de Cach&#x00e9; de Hibernate"

#: index.docbook:700
msgid "Pass the JDBC property <literal>propertyName</literal> to <literal>DriverManager.getConnection()</literal>."
msgstr "Nombre de propiedad"

#: index.docbook:707
msgid "hibernate.jndi.<emphasis>&lt;propertyName&gt;</emphasis>"
msgstr "Prop&#x00f3;sito"

#: index.docbook:709
msgid "Pass the property <literal>propertyName</literal> to the JNDI <literal>InitialContextFactory</literal>."
msgstr "hibernate.cache.provider_class"

#: index.docbook:719
msgid "Hibernate Cache Properties"
msgstr "El nombre de clase de un <literal>CacheProvider</literal> personalizado."

#: index.docbook:732
msgid "hibernate.cache.provider_class"
msgstr "Optimiza la operaci&#x00f3;n del cach&#x00e9; de segundo nivel para minimizar escrituras, al costo de lecturas m&#x00e1;s frecuentes. Esto es m&#x00e1;s &#x00fa;til para cach&#x00e9;s en cluster y, en Hibernate3, est&#x00e1; habilitado por defecto para implementaciones de cach&#x00e9; en cluster."

#: index.docbook:734
msgid "The classname of a custom <literal>CacheProvider</literal>."
msgstr "<emphasis role=\"strong\">ej.</emphasis> <literal>true|false</literal>"

#: index.docbook:736
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>classname.of.CacheProvider</literal>"
msgstr "hibernate.cache.use_query_cache"

#: index.docbook:744
msgid "hibernate.cache.use_minimal_puts"
msgstr "Habilita el cach&#x00e9; de lectura, consultas individuales todav&#x00ed;a tienen que ponerse cachables."

#: index.docbook:746
msgid "Optimize second-level cache operation to minimize writes, at the cost of more frequent reads. This setting is most useful for clustered caches and, in Hibernate3, is enabled by default for clustered cache implementations."
msgstr "<emphasis role=\"strong\">ej.</emphasis> <literal>true|false</literal>"

#: index.docbook:759
msgid "hibernate.cache.use_query_cache"
msgstr "Puede ser usado para deshabilitar completamente el cach&#x00e9; de segundo nivel, que est&#x00e1; habilitado por defecto para clases que especifican un mapeo <literal>&lt;cache&gt;</literal>."

#: index.docbook:761
msgid "Enable the query cache, individual queries still have to be set cachable."
msgstr "<emphasis role=\"strong\">ej.</emphasis> <literal>true|false</literal>"

#: index.docbook:771
msgid "hibernate.cache.use_second_level_cache"
msgstr "El nombre de clase de una interface <literal>QueryCache</literal> personalizada, por defecto al <literal>StandardQueryCache</literal> prefabricado."

#: index.docbook:773
msgid "May be used to completely disable the second level cache, which is enabled by default for classes which specify a <literal>&lt;cache&gt;</literal> mapping."
msgstr "<emphasis role=\"strong\">ej.</emphasis> <literal>classname.of.QueryCache</literal>"

#: index.docbook:785
msgid "hibernate.cache.query_cache_factory"
msgstr "Un prefijo a usar para los nombres de regi&#x00f3;n del cach&#x00e9; de segundo nivel."

#: index.docbook:787
msgid "The classname of a custom <literal>QueryCache</literal> interface, defaults to the built-in <literal>StandardQueryCache</literal>."
msgstr "<emphasis role=\"strong\">ej.</emphasis> <literal>prefix</literal>"

#: index.docbook:790
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>classname.of.QueryCache</literal>"
msgstr "hibernate.cache.use_structured_entries"

#: index.docbook:798
msgid "hibernate.cache.region_prefix"
msgstr "Fuerza a Hibernate a almacenar los datos en el cach&#x00e9; de segundo nivel en un formato m&#x00e1;s amigable al humano."

#: index.docbook:800
msgid "A prefix to use for second-level cache region names."
msgstr "<emphasis role=\"strong\">ej.</emphasis> <literal>true|false</literal>"

#: index.docbook:802
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>prefix</literal>"
msgstr "Propiedades de Transacci&#x00f3;n de Hibernate"

#: index.docbook:810
msgid "hibernate.cache.use_structured_entries"
msgstr "Nombre de propiedad"

#: index.docbook:812
msgid "Forces Hibernate to store data in the second-level cache in a more human-friendly format."
msgstr "Prop&#x00f3;sito"

#: index.docbook:826
msgid "Hibernate Transaction Properties"
msgstr "El nombre de clase de un <literal>TransactionFactory</literal> a usar con la API de <literal>Transaction</literal> de Hibernate (por defectoa <literal>JDBCTransactionFactory</literal>)."

#: index.docbook:839
msgid "hibernate.transaction.factory_class"
msgstr "Un nombre JNDI usado por <literal>JTATransactionFactory</literal> para obtener la <literal>UserTransaction</literal> JTA del servidor de aplicaciones."

#: index.docbook:841
msgid "The classname of a <literal>TransactionFactory</literal> to use with Hibernate <literal>Transaction</literal> API (defaults to <literal>JDBCTransactionFactory</literal>)."
msgstr "<emphasis role=\"strong\">ej.</emphasis> <literal>jndi/composite/name</literal>"

#: index.docbook:845
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>classname.of.TransactionFactory</literal>"
msgstr "hibernate.transaction.manager_lookup_class"

#: index.docbook:853
msgid "jta.UserTransaction"
msgstr "El nombre de clase de un <literal>TransactionManagerLookup</literal> requerido cuando el chach&#x00e9; a nivel de JVM est&#x00e1; habilitado o cuando se usa un generador alto/bajo en un entorno JTA."

#: index.docbook:855
msgid "A JNDI name used by <literal>JTATransactionFactory</literal> to obtain the JTA <literal>UserTransaction</literal> from the application server."
msgstr "<emphasis role=\"strong\">ej.</emphasis> <literal>classname.of.TransactionManagerLookup</literal>"

#: index.docbook:867
msgid "hibernate.transaction.manager_lookup_class"
msgstr "De habilitarse, la sesi&#x00f3;n se limpiar&#x00e1; (flushed) autom&#x00e1;ticamente durante la fase previa a la compleci&#x00f3;n de la transacci&#x00f3;n. (Muy &#x00fa;til cuando se usa Hibernate con CMT)."

#: index.docbook:869
msgid "The classname of a <literal>TransactionManagerLookup</literal> - required when JVM-level caching is enabled or when using hilo generator in a JTA environment."
msgstr "<emphasis role=\"strong\">ej.</emphasis> <literal>true</literal> | <literal>false</literal>"

#: index.docbook:873
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>classname.of.TransactionManagerLookup</literal>"
msgstr "hibernate.transaction.auto_close_session"

#: index.docbook:881
msgid "hibernate.transaction.flush_before_completion"
msgstr "De habilitarse, la sesi&#x00f3;n ser&#x00e1; cerrada autom&#x00e1;ticamente durante la fase posterior a la compleci&#x00f3;n de la transacci&#x00f3;n. (Muy &#x00fa;til cuando se usa Hibernate con CMT)."

#: index.docbook:883
msgid "If enabled, the session will be automatically flushed during the before completion phase of the transaction. Built-in and automatic session context management is preferred, see <xref linkend=\"architecture-current-session\"/>."
msgstr "<emphasis role=\"strong\">ej.</emphasis> <literal>true</literal> | <literal>false</literal>"

#: index.docbook:896
msgid "hibernate.transaction.auto_close_session"
msgstr "Nombre de propiedad"

#: index.docbook:898
msgid "If enabled, the session will be automatically closed during the after completion phase of the transaction. Built-in and utomatic session context management is preferred, see <xref linkend=\"architecture-current-session\"/>."
msgstr "Prop&#x00f3;sito"

#: index.docbook:914
msgid "Miscellaneous Properties"
msgstr "Elige la implementaci&#x00f3;n de parser HQL."

#: index.docbook:927
msgid "hibernate.current_session_context_class"
msgstr "Mapeos de s&#x00ed;mbolos en consultas Hibernate a s&#x00ed;mbolos SQL. (los s&#x00ed;mbolos puedem ser nombres de funci&#x00f3;n o literales, por ejemplo)."

#: index.docbook:929
msgid "Supply a (custom) strategy for the scoping of the \"current\" <literal>Session</literal>. See <xref linkend=\"architecture-current-session\"/> for more information about the built-in strategies."
msgstr "<emphasis role=\"strong\">ej.</emphasis> <literal>hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</literal>"

#: index.docbook:934
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>jta</literal> | <literal>thread</literal> | <literal>managed</literal> | <literal>custom.Class</literal>"
msgstr "hibernate.hbm2ddl.auto"

#: index.docbook:943
msgid "hibernate.query.factory_class"
msgstr "Exporta autom&#x00e1;ticamente DDL de esquema cuando al crear la <literal>SessionFactory</literal>. Con <literal>create-drop</literal>, el esquema de base de datos ser&#x00e1; desechado cuando la <literal>SessionFactory</literal> se cierre expl&#x00ed;citamente."

#: index.docbook:945
msgid "Chooses the HQL parser implementation."
msgstr "<emphasis role=\"strong\">ej.</emphasis> <literal>update</literal> | <literal>create</literal> | <literal>create-drop</literal>"

#: index.docbook:947
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>org.hibernate.hql.ast.ASTQueryTranslatorFactory</literal> or <literal>org.hibernate.hql.classic.ClassicQueryTranslatorFactory</literal>"
msgstr "hibernate.cglib.use_reflection_optimizer"

#: index.docbook:956
msgid "hibernate.query.substitutions"
msgstr "Habilita el uso de CGLIB en vez de reflecc&#x00f3;n en tiempo de ejecuci&#x00f3;n (propiedad a nivel de sistema). La reflecci&#x00f3;n a veces puede ser &#x00fa;til ante la aparici&#x00f3;n de problemas. Observa que Hibernate siempre requiere CGLIB incluso si desactivas el optimizador. No puedes establecer esta propiedad en <literal>hibernate.cfg.xml</literal>."

#: index.docbook:958
msgid "Mapping from tokens in Hibernate queries to SQL tokens (tokens might be function or literal names, for example)."
msgstr "<emphasis role=\"strong\">ej.</emphasis> <literal>true</literal> | <literal>false</literal>"

#: index.docbook:961
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</literal>"
msgstr "SQL Dialects"

#: index.docbook:969
msgid "hibernate.hbm2ddl.auto"
msgstr "You should always set the <literal>hibernate.dialect</literal> property to the correct <literal>org.hibernate.dialect.Dialect</literal> subclass for your database. If you specify a dialect, Hibernate will use sensible defaults for some of the other properties listed above, saving you the effort of specifying them manually."

#: index.docbook:971
msgid "Automatically validate or export schema DDL to the database when the <literal>SessionFactory</literal> is created. With <literal>create-drop</literal>, the database schema will be dropped when the <literal>SessionFactory</literal> is closed explicitly."
msgstr "Dialectos SQL de Hibernate(<literal>hibernate.dialect</literal>)"

#: index.docbook:977
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>validate</literal> | <literal>update</literal> | <literal>create</literal> | <literal>create-drop</literal>"
msgstr "RDBMS"

#: index.docbook:986
msgid "hibernate.cglib.use_reflection_optimizer"
msgstr "Dialecto"

#: index.docbook:988
msgid "Enables use of CGLIB instead of runtime reflection (System-level property). Reflection can sometimes be useful when troubleshooting, note that Hibernate always requires CGLIB even if you turn off the optimizer. You can not set this property in <literal>hibernate.cfg.xml</literal>."
msgstr "<entry>DB2</entry>"

#: index.docbook:1004
msgid "SQL Dialects"
msgstr "DB2 AS/400"

#: index.docbook:1006
msgid "You should always set the <literal>hibernate.dialect</literal> property to the correct <literal>org.hibernate.dialect.Dialect</literal> subclass for your database. If you specify a dialect, Hibernate will use sensible defaults for some of the other properties listed above, saving you the effort of specifying them manually."
msgstr "org.hibernate.dialect.DB2400Dialect"

#: index.docbook:1014
msgid "Hibernate SQL Dialects (<literal>hibernate.dialect</literal>)"
msgstr "DB2 OS390"

#: index.docbook:1022
msgid "RDBMS"
msgstr "org.hibernate.dialect.DB2390Dialect"

#: index.docbook:1023
msgid "Dialect"
msgstr "PostgreSQL"

#: index.docbook:1028
msgid "<entry>DB2</entry>"
msgstr "org.hibernate.dialect.PostgreSQLDialect"

#: index.docbook:1028
msgid "org.hibernate.dialect.DB2Dialect"
msgstr "MySQL"

#: index.docbook:1031
msgid "DB2 AS/400"
msgstr "org.hibernate.dialect.MySQLDialect"

#: index.docbook:1031
msgid "org.hibernate.dialect.DB2400Dialect"
msgstr "MySQL con InnoDB"

#: index.docbook:1034
msgid "DB2 OS390"
msgstr "org.hibernate.dialect.MySQLInnoDBDialect"

#: index.docbook:1034
msgid "org.hibernate.dialect.DB2390Dialect"
msgstr "MySQL con MyISAM"

#: index.docbook:1037
msgid "PostgreSQL"
msgstr "org.hibernate.dialect.MySQLMyISAMDialect"

#: index.docbook:1037
msgid "org.hibernate.dialect.PostgreSQLDialect"
msgstr "Oracle (cualquier versi&#x00f3;n)"

#: index.docbook:1040
msgid "MySQL"
msgstr "org.hibernate.dialect.OracleDialect"

#: index.docbook:1040
msgid "org.hibernate.dialect.MySQLDialect"
msgstr "Oracle 9i/10g"

#: index.docbook:1043
msgid "MySQL with InnoDB"
msgstr "org.hibernate.dialect.Oracle9Dialect"

#: index.docbook:1043
msgid "org.hibernate.dialect.MySQLInnoDBDialect"
msgstr "Sybase"

#: index.docbook:1046
msgid "MySQL with MyISAM"
msgstr "org.hibernate.dialect.SybaseDialect"

#: index.docbook:1046
msgid "org.hibernate.dialect.MySQLMyISAMDialect"
msgstr "Sybase Anywhere"

#: index.docbook:1049
msgid "Oracle (any version)"
msgstr "org.hibernate.dialect.SybaseAnywhereDialect"

#: index.docbook:1049
msgid "org.hibernate.dialect.OracleDialect"
msgstr "Microsoft SQL Server"

#: index.docbook:1052
msgid "Oracle 9i/10g"
msgstr "org.hibernate.dialect.SQLServerDialect"

#: index.docbook:1052
msgid "org.hibernate.dialect.Oracle9Dialect"
msgstr "SAP DB"

#: index.docbook:1055
msgid "Sybase"
msgstr "org.hibernate.dialect.SAPDBDialect"

#: index.docbook:1055
msgid "org.hibernate.dialect.SybaseDialect"
msgstr "Informix"

#: index.docbook:1058
msgid "Sybase Anywhere"
msgstr "org.hibernate.dialect.InformixDialect"

#: index.docbook:1058
msgid "org.hibernate.dialect.SybaseAnywhereDialect"
msgstr "HypersonicSQL"

#: index.docbook:1061
msgid "Microsoft SQL Server"
msgstr "org.hibernate.dialect.HSQLDialect"

#: index.docbook:1061
msgid "org.hibernate.dialect.SQLServerDialect"
msgstr "Ingres"

#: index.docbook:1064
msgid "SAP DB"
msgstr "org.hibernate.dialect.IngresDialect"

#: index.docbook:1064
msgid "org.hibernate.dialect.SAPDBDialect"
msgstr "Progress"

#: index.docbook:1067
msgid "Informix"
msgstr "org.hibernate.dialect.ProgressDialect"

#: index.docbook:1067
msgid "org.hibernate.dialect.InformixDialect"
msgstr "Mckoi SQL"

#: index.docbook:1070
msgid "HypersonicSQL"
msgstr "org.hibernate.dialect.MckoiDialect"

#: index.docbook:1070
msgid "org.hibernate.dialect.HSQLDialect"
msgstr "Interbase"

#: index.docbook:1073
msgid "Ingres"
msgstr "org.hibernate.dialect.InterbaseDialect"

#: index.docbook:1073
msgid "org.hibernate.dialect.IngresDialect"
msgstr "Pointbase"

#: index.docbook:1076
msgid "Progress"
msgstr "org.hibernate.dialect.PointbaseDialect"

#: index.docbook:1076
msgid "org.hibernate.dialect.ProgressDialect"
msgstr "FrontBase"

#: index.docbook:1079
msgid "Mckoi SQL"
msgstr "org.hibernate.dialect.FrontbaseDialect"

#: index.docbook:1079
msgid "org.hibernate.dialect.MckoiDialect"
msgstr "Firebird"

#: index.docbook:1082
msgid "Interbase"
msgstr "org.hibernate.dialect.FirebirdDialect"

#: index.docbook:1082
msgid "org.hibernate.dialect.InterbaseDialect"
msgstr "Recuperaci&#x00f3;n por Uni&#x00f3;n Externa (Outer Join Fetching)"

#: index.docbook:1085
msgid "Pointbase"
msgstr "Si tu base de datos soporta uniones externas del estilo ANSI, Oracle o Sybase, la <emphasis>recuperaci&#x00f3;n por uni&#x00f3;n externa</emphasis> aumentar&#x00e1; frecuentemente el rendimiento limitando el n&#x00fa;mero de llamadas a la base de datos (al costo de m&#x00e1;s trabajo posiblemente realizado por la base de datos misma). La recuperaci&#x00f3;n por uni&#x00f3;n externa permite que un grafo completo de objetos conectados por asociaciones muchos-a-uno, uno-a-muchos, muchos-a-muchos y uno-a-uno sea tra&#x00ed;do en una sola <literal>SELECT</literal> SQL."

#: index.docbook:1085
msgid "org.hibernate.dialect.PointbaseDialect"
msgstr "La recuperaci&#x00f3;n por uni&#x00f3;n externa puede ser deshabilitada <emphasis>globalmente</emphasis> estableciendo la propiedad <literal>hibernate.max_fetch_depth</literal> a <literal>0</literal>. Un valor de <literal>1</literal> o mayor habilita la recuperaci&#x00f3;n por uni&#x00f3;n externa para asociaciones uno-a-uno y muchos-a-uno que hayan sido mapeadas con <literal>fetch=\"join\"</literal>."

#: index.docbook:1088
msgid "FrontBase"
msgstr "Ver <xref linkend=\"performance-fetching\"/> para m&#x00e1;s informaci&#x00f3;n."

#: index.docbook:1088
msgid "org.hibernate.dialect.FrontbaseDialect"
msgstr "Flujos Binarios"

#: index.docbook:1091
msgid "Firebird"
msgstr "Oracle limita el tama&#x00f1;o de arrays de <literal>byte</literal> que puedan ser pasados a/desde su driver JDBC. Si deseas usar instancias grandes de tipo <literal>binary</literal> o <literal>serializable</literal>, debes habilitar <literal>hibernate.jdbc.use_streams_for_binary</literal>. <emphasis>Esta es una propiedad a nivel de sistema solamente.</emphasis>"

#: index.docbook:1091
msgid "org.hibernate.dialect.FirebirdDialect"
msgstr "Cach&#x00e9; de segundo nivel y de lectura"

#: index.docbook:1100
msgid "Outer Join Fetching"
msgstr "Las propiedades prefijadas por <literal>hibernate.cache</literal> te permiten usar un sistema de cach&#x00e9; de segundo nivel en el &#x00e1;mbito de un proceso o cluster con Hibernate. Ver <xref linkend=\"performance-cache\"/> para m&#x00e1;s detalles."

#: index.docbook:1102
msgid "If your database supports ANSI, Oracle or Sybase style outer joins, <emphasis>outer join fetching</emphasis> will often increase performance by limiting the number of round trips to and from the database (at the cost of possibly more work performed by the database itself). Outer join fetching allows a whole graph of objects connected by many-to-one, one-to-many, many-to-many and one-to-one associations to be retrieved in a single SQL <literal>SELECT</literal>."
msgstr "Sustituci&#x00f3;n de Lenguaje de Consulta"

#: index.docbook:1111
msgid "Outer join fetching may be disabled <emphasis>globally</emphasis> by setting the property <literal>hibernate.max_fetch_depth</literal> to <literal>0</literal>. A setting of <literal>1</literal> or higher enables outer join fetching for one-to-one and many-to-one associations which have been mapped with <literal>fetch=\"join\"</literal>."
msgstr "Puedes definir nuevos s&#x00ed;mbolos de consulta de Hibernate usando <literal>hibernate.query.substitutions</literal>. Por ejemplo:"

#: index.docbook:1119
msgid "See <xref linkend=\"performance-fetching\"/> for more information."
msgstr "hibernate.query.substitutions true=1, false=0"

#: index.docbook:1126
msgid "Binary Streams"
msgstr "causar&#x00ed;a que los s&#x00ed;mbolos <literal>true</literal> y <literal>false</literal> sean traducidos a literales enteros en el SQL generado."

#: index.docbook:1128
msgid "Oracle limits the size of <literal>byte</literal> arrays that may be passed to/from its JDBC driver. If you wish to use large instances of <literal>binary</literal> or <literal>serializable</literal> type, you should enable <literal>hibernate.jdbc.use_streams_for_binary</literal>. <emphasis>This is a system-level setting only.</emphasis>"
msgstr "hibernate.query.substitutions toLowercase=LOWER"

#: index.docbook:1139
msgid "Second-level and query cache"
msgstr "te permitir&#x00ed;a renombrar la funci&#x00f3;n <literal>LOWER</literal> de SQL."

#: index.docbook:1141
msgid "The properties prefixed by <literal>hibernate.cache</literal> allow you to use a process or cluster scoped second-level cache system with Hibernate. See the <xref linkend=\"performance-cache\"/> for more details."
msgstr "Hibernate statistics"

#: index.docbook:1151
msgid "Query Language Substitution"
msgstr "Si habilitas <literal>hibernate.generate_statistics</literal>, Hibernate expondr&#x00e1; un n&#x00fa;mero de m&#x00e9;tricas que son &#x00fa;tiles al afinar un sistema en ejecuci&#x00f3;n v&#x00ed;a <literal>SessionFactory.getStatistics()</literal>. Hibernate puede incluso ser configurado para exponer estas estad&#x00ed;sticas v&#x00ed;a JMX. Lee el Javadoc de las interfaces en <literal>org.hibernate.stats</literal> para m&#x00e1;s informaci&#x00f3;n."

#: index.docbook:1153
msgid "You may define new Hibernate query tokens using <literal>hibernate.query.substitutions</literal>. For example:"
msgstr "Registros de mensajes (Logging)"

#: index.docbook:1158
msgid "hibernate.query.substitutions true=1, false=0"
msgstr "Hibernate registra varios eventos usando commons-logging de Apache."

#: index.docbook:1160
msgid "would cause the tokens <literal>true</literal> and <literal>false</literal> to be translated to integer literals in the generated SQL."
msgstr "El servicio de commons-logging saldr&#x00e1; directamente ya sea a Log4J (si incluyes <literal>log4j.jar</literal> in your classpath) o JDK1.4 logging (al ejecutar bajo JDK1.4 o superior). Puedes descargar Log4J desde <literal>http://logging.apache.org</literal>. Para usar Log4J necesitar&#x00e1;s colocar un fichero <literal>log4j.properties</literal> en tu classpath. Un fichero de propiedades de ejemplo se distribuye con Hibernate en el directorio <literal>src/</literal>."

#: index.docbook:1165
msgid "hibernate.query.substitutions toLowercase=LOWER"
msgstr "Recomendamos fuertemente que te familiarices con los registros de mensajes de Hibernate. Se ha puesto un gran trabajo en hacer los registros de Hibernate tan detallados como se puede, sin hacerlos ilegibles. Es un dispositivo esencial en la resoluci&#x00f3;n de problemas. Las categor&#x00ed;as de registro m&#x00e1;s interesantes son las siguientes:"

#: index.docbook:1167
msgid "would allow you to rename the SQL <literal>LOWER</literal> function."
msgstr "Categor&#x00ed;as de Registro de Hibernate"

#: index.docbook:1174
msgid "Hibernate statistics"
msgstr "Categor&#x00ed;a"

#: index.docbook:1176
msgid "If you enable <literal>hibernate.generate_statistics</literal>, Hibernate will expose a number of metrics that are useful when tuning a running system via <literal>SessionFactory.getStatistics()</literal>. Hibernate can even be configured to expose these statistics via JMX. Read the Javadoc of the interfaces in <literal>org.hibernate.stats</literal> for more information."
msgstr "Funci&#x00f3;n"

#: index.docbook:1188
msgid "Logging"
msgstr "org.hibernate.SQL"

#: index.docbook:1190
msgid "Hibernate logs various events using Apache commons-logging."
msgstr "Registra todas las sentencias DML de SQL a medida que se ejecutan"

#: index.docbook:1194
msgid "The commons-logging service will direct output to either Apache Log4j (if you include <literal>log4j.jar</literal> in your classpath) or JDK1.4 logging (if running under JDK1.4 or above). You may download Log4j from <literal>http://jakarta.apache.org</literal>. To use Log4j you will need to place a <literal>log4j.properties</literal> file in your classpath, an example properties file is distributed with Hibernate in the <literal>src/</literal> directory."
msgstr "org.hibernate.type"

#: index.docbook:1204
msgid "We strongly recommend that you familiarize yourself with Hibernate's log messages. A lot of work has been put into making the Hibernate log as detailed as possible, without making it unreadable. It is an essential troubleshooting device. The most interesting log categories are the following:"
msgstr "Registra todos los par&#x00e1;metros JDBC"

#: index.docbook:1213
msgid "Hibernate Log Categories"
msgstr "org.hibernate.tool.hbm2ddl"

#: index.docbook:1219
msgid "Category"
msgstr "Registra todas las sentencias DDL de SQL a medida que se ejecutan"

#: index.docbook:1220
msgid "Function"
msgstr "org.hibernate.pretty"

#: index.docbook:1225
msgid "org.hibernate.SQL"
msgstr "Registra el estado de todas las entidades (m&#x00e1;ximo de 20 entidades) asociadas con la sesi&#x00f3;n en tiempo de limpieza (flush)"

#: index.docbook:1226
msgid "Log all SQL DML statements as they are executed"
msgstr "org.hibernate.cache"

#: index.docbook:1229
msgid "org.hibernate.type"
msgstr "Registra toda la actividad del cach&#x00e9; de segundo nivel"

#: index.docbook:1230
msgid "Log all JDBC parameters"
msgstr "org.hibernate.transaction"

#: index.docbook:1233
msgid "org.hibernate.tool.hbm2ddl"
msgstr "Registra la actividad relacionada con la transacci&#x00f3;n"

#: index.docbook:1234
msgid "Log all SQL DDL statements as they are executed"
msgstr "org.hibernate.jdbc"

#: index.docbook:1237
msgid "org.hibernate.pretty"
msgstr "Registra toda adquisici&#x00f3;n de recursos JDBC"

#: index.docbook:1238
msgid "Log the state of all entities (max 20 entities) associated with the session at flush time"
msgstr "org.hibernate.hql.ast"

#: index.docbook:1244
msgid "org.hibernate.cache"
msgstr "Regista los ASTs de HQL y SQL, as&#x00ed; como otra informaci&#x00f3;n sobre an&#x00e1;lisis de consultas."

#: index.docbook:1245
msgid "Log all second-level cache activity"
msgstr "org.hibernate.secure"

#: index.docbook:1248
msgid "org.hibernate.transaction"
msgstr "Registra todas las peticiones de autorizaci&#x00f3;n JAAS"

#: index.docbook:1249
msgid "Log transaction related activity"
msgstr "org.hibernate"

#: index.docbook:1252
msgid "org.hibernate.jdbc"
msgstr "Registra todo (mucha informaci&#x00f3;n, pero muy &#x00fa;til para la resoluci&#x00f3;n de problemas)"

#: index.docbook:1253
msgid "Log all JDBC resource acquisition"
msgstr "Al desarrollar aplicacinoes con Hibernate, casi siempre debes trabajar con <literal>debug</literal> habilitado para la categor&#x0ed;a <literal>org.hibernate.SQL</literal> o, alternativamente, la propiedad <literal>hibernate.show_sql</literal> habilitada."

#: index.docbook:1256
msgid "org.hibernate.hql.ast.AST"
msgstr "Implementando una <literal>NamingStrategy</literal>"

#: index.docbook:1257
msgid "Log HQL and SQL ASTs during query parsing"
msgstr "La interface <literal>org.hibernate.cfg.NamingStrategy</literal> te permite especificar un \"est&#x00e1;ndar de nombrado\" para objetos de la base de datos y elementos de esquema."

#: index.docbook:1262
msgid "org.hibernate.secure"
msgstr "Puedes proveer reglas para generar autom&#x00e1;ticamente identificadores de base de datos a partir de identificadores JDBC o para procesar nombres \"l&#x00f3;gicos\" de columnas y tablas dados en el fichero de mapeo en nombres \"f&#x00ed;sicos\" de columnas y tablas. Esta funcionalidad ayuda a reducir la verborragia del documento de mapeo, eliminando ruido repetitivo (prefijos <literal>TBL_</literal>, por ejemplo). La estrategia por defecto usada por Hibernate m&#x00ed;nima en absoluto."

#: index.docbook:1263
msgid "Log all JAAS authorization requests"
msgstr "Puedes especificar una estrategia diferente llamando a <literal>Configuration.setNamingStrategy()</literal> antes de agregar los mapeos:"

#: index.docbook:1266
msgid "org.hibernate"
msgstr ""
      "<![CDATA[SessionFactory sf = new Configuration()\n"
      "    .setNamingStrategy(ImprovedNamingStrategy.INSTANCE)\n"
      "    .addFile(\"Item.hbm.xml\")\n"
      "    .addFile(\"Bid.hbm.xml\")\n"
      "    .buildSessionFactory();]]>"

#: index.docbook:1267
msgid "Log everything (a lot of information, but very useful for troubleshooting)"
msgstr "<literal>org.hibernate.cfg.ImprovedNamingStrategy</literal> es una estrategia prefabricada que puede ser un punto de partida &#x00fa;til para algunas aplicaciones."

#: index.docbook:1276
msgid "When developing applications with Hibernate, you should almost always work with <literal>debug</literal> enabled for the category <literal>org.hibernate.SQL</literal>, or, alternatively, the property <literal>hibernate.show_sql</literal> enabled."
msgstr "Fichero de configuraci&#x00f3;n XML"

#: index.docbook:1286
msgid "Implementing a <literal>NamingStrategy</literal>"
msgstr "Un enfoque alternativo de configuraci&#x00f3;n es especificar una configuraci&#x00f3;n completa en un fichero llamado <literal>hibernate.cfg.xml</literal>. Este fichero puede ser usado como un remplazo del fichero <literal>hibernate.properties</literal> o, si ambos est&#x00e1;n presentes, para sobrescribir propiedades."

#: index.docbook:1288
msgid "The interface <literal>org.hibernate.cfg.NamingStrategy</literal> allows you to specify a \"naming standard\" for database objects and schema elements."
msgstr "El fichero de configuraci&#x00f3;n XML se espera por defecto en la ra&#x00ed;z o tu <literal>CLASSPATH</literal>. He aqu&#x00ed; un ejemplo:"

#: index.docbook:1293
msgid "You may provide rules for automatically generating database identifiers from Java identifiers or for processing \"logical\" column and table names given in the mapping file into \"physical\" table and column names. This feature helps reduce the verbosity of the mapping document, eliminating repetitive noise (<literal>TBL_</literal> prefixes, for example). The default strategy used by Hibernate is quite minimal."
msgstr ""
      "<![CDATA[<?xml version='1.0' encoding='utf-8'?>\n"
      "<!DOCTYPE hibernate-configuration PUBLIC\n"
      "    \"-//Hibernate/Hibernate Configuration DTD//EN\"\n"
      "    \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\">\n"
      "\n"
      "<hibernate-configuration>\n"
      "\n"
      "    <!-- a SessionFactory instance listed as /jndi/name -->\n"
      "    <session-factory\n"
      "        name=\"java:hibernate/SessionFactory\">\n"
      "\n"
      "        <!-- properties -->\n"
      "        <property name=\"connection.datasource\">java:/comp/env/jdbc/MyDB</property>\n"
      "        <property name=\"dialect\">org.hibernate.dialect.MySQLDialect</property>\n"
      "        <property name=\"show_sql\">false</property>\n"
      "        <property name=\"transaction.factory_class\">\n"
      "            org.hibernate.transaction.JTATransactionFactory\n"
      "        </property>\n"
      "        <property name=\"jta.UserTransaction\">java:comp/UserTransaction</property>\n"
      "\n"
      "        <!-- mapping files -->\n"
      "        <mapping resource=\"org/hibernate/auction/Item.hbm.xml\"/>\n"
      "        <mapping resource=\"org/hibernate/auction/Bid.hbm.xml\"/>\n"
      "\n"
      "        <!-- cache settings -->\n"
      "        <class-cache class=\"org.hibernate.auction.Item\" usage=\"read-write\"/>\n"
      "        <class-cache class=\"org.hibernate.auction.Bid\" usage=\"read-only\"/>\n"
      "        <collection-cache collection=\"org.hibernate.auction.Item.bids\" usage=\"read-write\"/>\n"
      "\n"
      "    </session-factory>\n"
      "\n"
      "</hibernate-configuration>]]>"

#: index.docbook:1302
msgid "You may specify a different strategy by calling <literal>Configuration.setNamingStrategy()</literal> before adding mappings:"
msgstr "Como puedes ver, la ventaja de este enfoque es la externalizaci&#x00f3;n de los nombres de los fichero de mapeo a configuraci&#x00f3;n. El <literal>hibernate.cfg.xml</literal> es tambi&#x00e9;n m&#x00e1;s conveniente una vez que hayas afinado el cach&#x00e9; de Hibernate. Observa que elecci&#x00f3;n tuya usar ya sea <literal>hibernate.properties</literal> o <literal>hibernate.cfg.xml</literal>, ambos son equivalentes, excepto por los beneficios de usar la sintaxis XML arriba mencionados."

#: index.docbook:1307
msgid ""
      "<![CDATA[SessionFactory sf = new Configuration()\n"
      "    .setNamingStrategy(ImprovedNamingStrategy.INSTANCE)\n"
      "    .addFile(\"Item.hbm.xml\")\n"
      "    .addFile(\"Bid.hbm.xml\")\n"
      "    .buildSessionFactory();]]>"
msgstr "Con la configuraci&#x00f3;n XML, arrancar Hibernate es tan simple como"

#: index.docbook:1309
msgid "<literal>org.hibernate.cfg.ImprovedNamingStrategy</literal> is a built-in strategy that might be a useful starting point for some applications."
msgstr "<![CDATA[SessionFactory sf = new Configuration().configure().buildSessionFactory();]]>"

#: index.docbook:1317
msgid "XML configuration file"
msgstr "Puedes tomar un fichero XML diferente usando"

#: index.docbook:1319
msgid "An alternative approach to configuration is to specify a full configuration in a file named <literal>hibernate.cfg.xml</literal>. This file can be used as a replacement for the <literal>hibernate.properties</literal> file or, if both are present, to override properties."
msgstr ""
      "<![CDATA[SessionFactory sf = new Configuration()\n"
      "    .configure(\"catdb.cfg.xml\")\n"
      "    .buildSessionFactory();]]>"

#: index.docbook:1326
msgid "The XML configuration file is by default expected to be in the root o your <literal>CLASSPATH</literal>. Here is an example:"
msgstr "Integraci&#x00f3; con Servidores de Aplicaciones J2EE"

#: index.docbook:1331
msgid ""
      "<![CDATA[<?xml version='1.0' encoding='utf-8'?>\n"
      "<!DOCTYPE hibernate-configuration PUBLIC\n"
      "    \"-//Hibernate/Hibernate Configuration DTD//EN\"\n"
      "    \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\">\n"
      "\n"
      "<hibernate-configuration>\n"
      "\n"
      "    <!-- a SessionFactory instance listed as /jndi/name -->\n"
      "    <session-factory\n"
      "        name=\"java:hibernate/SessionFactory\">\n"
      "\n"
      "        <!-- properties -->\n"
      "        <property name=\"connection.datasource\">java:/comp/env/jdbc/MyDB</property>\n"
      "        <property name=\"dialect\">org.hibernate.dialect.MySQLDialect</property>\n"
      "        <property name=\"show_sql\">false</property>\n"
      "        <property name=\"transaction.factory_class\">\n"
      "            org.hibernate.transaction.JTATransactionFactory\n"
      "        </property>\n"
      "        <property name=\"jta.UserTransaction\">java:comp/UserTransaction</property>\n"
      "\n"
      "        <!-- mapping files -->\n"
      "        <mapping resource=\"org/hibernate/auction/Item.hbm.xml\"/>\n"
      "        <mapping resource=\"org/hibernate/auction/Bid.hbm.xml\"/>\n"
      "\n"
      "        <!-- cache settings -->\n"
      "        <class-cache class=\"org.hibernate.auction.Item\" usage=\"read-write\"/>\n"
      "        <class-cache class=\"org.hibernate.auction.Bid\" usage=\"read-only\"/>\n"
      "        <collection-cache collection=\"org.hibernate.auction.Item.bids\" usage=\"read-write\"/>\n"
      "\n"
      "    </session-factory>\n"
      "\n"
      "</hibernate-configuration>]]>"
msgstr "Hibernate tiene los siguientes puntos de integraci&#x00f3;n con la infraestructura J2EE:"

#: index.docbook:1333
msgid "As you can see, the advantage of this approach is the externalization of the mapping file names to configuration. The <literal>hibernate.cfg.xml</literal> is also more convenient once you have to tune the Hibernate cache. Note that is your choice to use either <literal>hibernate.properties</literal> or <literal>hibernate.cfg.xml</literal>, both are equivalent, except for the above mentioned benefits of using the XML syntax."
msgstr "<emphasis>Datasources manejados por contenedor</emphasis>: Hibernate puede usar conexiones JDBC manejadas por el contenedor y provistas a trav&#x00e9;s de JNDI. Usualmente, un <literal>TransactionManager</literal> compatible con JTA y un <literal>ResourceManager</literal> cuidan del manejo de transacciones (CMT), esp. manejo de transacciones distribu&#x00ed;das a trav&#x00e9;s de varios datasources. Puedes tambi&#x00e9;n, por supuesto, demarcar los l&#x00ed;mites de las transacciones program&#x00e1;ticamente (BMT) o podr&#x00ed;as querer usar para esto la API opcional de <literal>Transaction</literal> de Hibernate para mantener tu c&#x00f3;digo portable."

#: index.docbook:1342
msgid "With the XML configuration, starting Hibernate is then as simple as"
msgstr "<emphasis>Ligamento Autom&#x00e1;tico JNDI</emphasis>: Hibernate puede ligar sus <literal>SessionFactory</literal> a JNDI despu&#x00e9;s del arranque."

#: index.docbook:1346
msgid "<![CDATA[SessionFactory sf = new Configuration().configure().buildSessionFactory();]]>"
msgstr "<emphasis>Ligamento de Sesi&#x00f3;n JTA:</emphasis> La <literal>Session</literal> de Hibernate puede ser ligada autom&#x00e1;ticamente al &#x00e1;mbito de transacciones JTA si usas EJBs. Simplemente busca la <literal>SessionFactory</literal> de JNDI y obt&#x00e9;n la <literal>Session</literal> actual. Deja que Hibernate cuide de limpiar y cerrar la <literal>Session</literal> cuando se complete tu transacci&#x00f3;n JTA. La demarcaci&#x00f3;n de transacci&#x00f3;n es declarativa, en descriptores de despliegue de EJB."

#: index.docbook:1348
msgid "You can pick a different XML configuration file using"
msgstr "<emphasis>Despliegue JMX:</emphasis> Si tienes un servidor de aplicaciones capaz de JMX (por ejemplo, JBoss AS), puedes optar por desplegar Hibernate como un MBean manejado. Esto te ahorra el c&#x00f3;digo de una l&#x00ed;nea de arranque para construir tu <literal>SessionFactory</literal> desde una <literal>Configuration</literal>. El contenedor arrancar&#x00e1; tu <literal>HibernateService</literal>, e idealmente tambi&#x00e9;n cuidar&#x00e1; de las dependencias entre servicios (El datasource debe estar disponible antes que arranque Hibernate, etc)."

#: index.docbook:1352
msgid ""
      "<![CDATA[SessionFactory sf = new Configuration()\n"
      "    .configure(\"catdb.cfg.xml\")\n"
      "    .buildSessionFactory();]]>"
msgstr "Dependiendo de tu entorno, podr&#x00ed;as tener que establecer la opci&#x00f3;n de configuraci&#x00f3;n <literal>hibernate.connection.aggressive_release</literal> a true si tu servidor de aplicaciones muestra excepciones \"connection containment\"."

#: index.docbook:1357
msgid "J2EE Application Server integration"
msgstr "Configuraci&#x00f3;n de la estrategia de transacci&#x00f3;n"

#: index.docbook:1359
msgid "Hibernate has the following integration points for J2EE infrastructure:"
msgstr "La API de <literal>Session</literal> de Hibernate es independiente de cualquier demarcaci&#x00f3;n de transacci&#x00f3;n en tu arquitectura. Si dejas que Hibernate use JDBC directamente, a trav&#x00e9;s de un pool de conexiones. puedes comenzar y acabar tus transacciones llamando la API de JDBC. Si ejecutas en un servidor de aplicaciones J2EE, podr&#x00e9;as querer usar transacciones manejadas por bean y llamar la API de JTA y <literal>UserTransaction</literal> cuando sea necesario."

#: index.docbook:1365
msgid "<emphasis>Container-managed datasources</emphasis>: Hibernate can use JDBC connections managed by the container and provided through JNDI. Usually, a JTA compatible <literal>TransactionManager</literal> and a <literal>ResourceManager</literal> take care of transaction management (CMT), esp. distributed transaction handling across several datasources. You may of course also demarcate transaction boundaries programmatically (BMT) or you might want to use the optional Hibernate <literal>Transaction</literal> API for this to keep your code portable."
msgstr "Para mantener tu c&#x00f3;digo portable entre estos dos (y otros) entornos recomendamos la API de <literal>Transaction</literal> de Hibernate, que envuelve y oculta el sistema subyacente. Tienes que especificar una clase f&#x00e1;brica para las instancias de <literal>Transaction</literal> estableciendo la propiedad de configuraci&#x00f3;n <literal>hibernate.transaction.factory_class</literal> de Hibernate."

#: index.docbook:1380
msgid "<emphasis>Automatic JNDI binding</emphasis>: Hibernate can bind its <literal>SessionFactory</literal> to JNDI after startup."
msgstr "Hay tres elecciones est&#x00e1;ndar (prefabricadas):"

#: index.docbook:1389
msgid "<emphasis>JTA Session binding:</emphasis> The Hibernate <literal>Session</literal> may be automatically bound to the scope of JTA transactions. Simply lookup the <literal>SessionFactory</literal> from JNDI and get the current <literal>Session</literal>. Let Hibernate take care of flushing and closing the <literal>Session</literal> when your JTA transaction completes. Transaction demarcation is either declarative (CMT) or programmatic (BMT/UserTransaction)."
msgstr "org.hibernate.transaction.JDBCTransactionFactory"

#: index.docbook:1402
msgid "<emphasis>JMX deployment:</emphasis> If you have a JMX capable application server (e.g. JBoss AS), you can chose to deploy Hibernate as a managed MBean. This saves you the one line startup code to build your <literal>SessionFactory</literal> from a <literal>Configuration</literal>. The container will startup your <literal>HibernateService</literal>, and ideally also take care of service dependencies (Datasource has to be available before Hibernate starts, etc)."
msgstr "delega a transacciones de base de datos (JDBC) (por defecto)"

#: index.docbook:1413
msgid "Depending on your environment, you might have to set the configuration option <literal>hibernate.connection.aggressive_release</literal> to true if your application server shows \"connection containment\" exceptions."
msgstr "org.hibernate.transaction.JTATransactionFactory"

#: index.docbook:1420
msgid "Transaction strategy configuration"
msgstr "delega a transacciones manejadas por contenedor si una transacci&#x00f3;n existente est&#x00f3; por debajo en este contexto (ej. m&#x00e9;todo de un bean de sesi&#x00f3;n EJB), en otro caso una nueva transacci&#x00f3;n es comenzada y se usan transacciones manejadas por bean."

#: index.docbook:1422
msgid "The Hibernate <literal>Session</literal> API is independent of any transaction demarcation system in your architecture. If you let Hibernate use JDBC directly, through a connection pool, you may begin and end your transactions by calling the JDBC API. If you run in a J2EE application server, you might want to use bean-managed transactions and call the JTA API and <literal>UserTransaction</literal> when needed."
msgstr "org.hibernate.transaction.CMTTransactionFactory"

#: index.docbook:1430
msgid "To keep your code portable between these two (and other) environments we recommend the optional Hibernate <literal>Transaction</literal> API, which wraps and hides the underlying system. You have to specify a factory class for <literal>Transaction</literal> instances by setting the Hibernate configuration property <literal>hibernate.transaction.factory_class</literal>."
msgstr "delega a transacciones JTA manejadas por contenedor"

#: index.docbook:1437
msgid "There are three standard (built-in) choices:"
msgstr "Puedes definir tambi&#x00e9;n tus propias estrategias de transacci&#x00f3;n (para un servicio de transacci&#x00f3;n CORBA, por ejemplo)."

#: index.docbook:1443
msgid "org.hibernate.transaction.JDBCTransactionFactory"
msgstr "Algunas funcionalidades en Hibernate (ej, el cach&#x00e9; de segundo nivel, ligamento autom&#x00e1;tico de JTA y Session, etc.) requieren acceso al <literal>TransactionManager</literal> de JTA en un entorno manejado. En un servidor de aplicaciones tienes que especificar c&#x00f3;mo Hibernate debe obtener una referencia al <literal>TransactionManager</literal>, pues J2EE no estandariza un solo mecanismo:"

#: index.docbook:1445
msgid "delegates to database (JDBC) transactions (default)"
msgstr "TransactionManagers de JTA"

#: index.docbook:1449
msgid "org.hibernate.transaction.JTATransactionFactory"
msgstr "Transaction Factory"

#: index.docbook:1451
msgid "delegates to container-managed transaction if an existing transaction is underway in this context (e.g. EJB session bean method), otherwise a new transaction is started and bean-managed transaction are used."
msgstr "Servidor de Aplicaciones"

#: index.docbook:1459
msgid "org.hibernate.transaction.CMTTransactionFactory"
msgstr "org.hibernate.transaction.JBossTransactionManagerLookup"

#: index.docbook:1461
msgid "delegates to container-managed JTA transactions"
msgstr "JBoss"

#: index.docbook:1466
msgid "You may also define your own transaction strategies (for a CORBA transaction service, for example)."
msgstr "org.hibernate.transaction.WeblogicTransactionManagerLookup"

#: index.docbook:1471
msgid "Some features in Hibernate (i.e. the second level cache, Contextual Sessions with JTA, etc.) require access to the JTA <literal>TransactionManager</literal> in a managed environment. In an application server you have to specify how Hibernate should obtain a reference to the <literal>TransactionManager</literal>, since J2EE does not standardize a single mechanism:"
msgstr "Weblogic"

#: index.docbook:1479
msgid "JTA TransactionManagers"
msgstr "org.hibernate.transaction.WebSphereTransactionManagerLookup"

#: index.docbook:1485
msgid "Transaction Factory"
msgstr "WebSphere"

#: index.docbook:1486
msgid "Application Server"
msgstr "org.hibernate.transaction.WebSphereExtendedJTATransactionLookup"

#: index.docbook:1491
msgid "org.hibernate.transaction.JBossTransactionManagerLookup"
msgstr "WebSphere 6"

#: index.docbook:1492
msgid "JBoss"
msgstr "org.hibernate.transaction.OrionTransactionManagerLookup"

#: index.docbook:1495
msgid "org.hibernate.transaction.WeblogicTransactionManagerLookup"
msgstr "Orion"

#: index.docbook:1496
msgid "Weblogic"
msgstr "org.hibernate.transaction.ResinTransactionManagerLookup"

#: index.docbook:1499
msgid "org.hibernate.transaction.WebSphereTransactionManagerLookup"
msgstr "Resin"

#: index.docbook:1500
msgid "WebSphere"
msgstr "org.hibernate.transaction.JOTMTransactionManagerLookup"

#: index.docbook:1503
msgid "org.hibernate.transaction.WebSphereExtendedJTATransactionLookup"
msgstr "JOTM"

#: index.docbook:1504
msgid "WebSphere 6"
msgstr "org.hibernate.transaction.JOnASTransactionManagerLookup"

#: index.docbook:1507
msgid "org.hibernate.transaction.OrionTransactionManagerLookup"
msgstr "JOnAS"

#: index.docbook:1508
msgid "Orion"
msgstr "org.hibernate.transaction.JRun4TransactionManagerLookup"

#: index.docbook:1511
msgid "org.hibernate.transaction.ResinTransactionManagerLookup"
msgstr "JRun4"

#: index.docbook:1512
msgid "Resin"
msgstr "org.hibernate.transaction.BESTransactionManagerLookup"

#: index.docbook:1515
msgid "org.hibernate.transaction.JOTMTransactionManagerLookup"
msgstr "Borland ES"

#: index.docbook:1516
msgid "JOTM"
msgstr "<literal>SessionFactory</literal> ligada a JNDI"

#: index.docbook:1519
msgid "org.hibernate.transaction.JOnASTransactionManagerLookup"
msgstr "Una <literal>SessionFactory</literal> de Hibernate ligada a JNDI puede simplificar la obtenci&#x00f3;n de la f&#x00e1;brica y la creaci&#x00f3;n de nuevas <literal>Session</literal>s. Observa que esto no est&#x00e1; relacionado a un <literal>Datasource</literal> ligado a JNDI, simplemente ambos usan el mismo registro!"

#: index.docbook:1520
msgid "JOnAS"
msgstr "Si deseas tener la <literal>SessionFactory</literal> ligada a un espacio de nombres de JNDI, especifica un nombre (ej. <literal>java:hibernate/SessionFactory</literal>) usando la propiedad <literal>hibernate.session_factory_name</literal>. Si esta propiedad es omitida, la <literal>SessionFactory</literal> no ser&#x00e1; ligada a JNDI (Esto es especialmente &#x00fa;til en entornos con una implementaci&#x00f3; JNDI de s&#x00f3;lo lectura por defecto, ej. Tomcat.)"

#: index.docbook:1523
msgid "org.hibernate.transaction.JRun4TransactionManagerLookup"
msgstr "Al ligar la <literal>SessionFactory</literal> a JNDI, Hibernate usar&#x00e1; los valores de <literal>hibernate.jndi.url</literal>, <literal>hibernate.jndi.class</literal> para instanciar un contexto inicial. Si &#x00e9;tos no se especifican, se usar&#x00e1; el <literal>InitialContext</literal> por defecto."

#: index.docbook:1524
msgid "JRun4"
msgstr "Hibernate colocar&#x00e1; autom&#x00e1;ticamente la <literal>SessionFactory</literal> en JNDI despu&#x00e9;s que llames a <literal>cfg.buildSessionFactory()</literal>. Esto significa que tendr&#x00e1;s al menos esta llamada en alg&#x00fa;n c&#x00f3;digo de arranque (o clase de utilidad) en tu aplicaci&#x00f3;n, a menos qie uses el despliegue JMX con el <literal>HibernateService</literal> (discutido luego)."

#: index.docbook:1527
msgid "org.hibernate.transaction.BESTransactionManagerLookup"
msgstr "Si usas una <literal>SessionFactory</literal> de JNDI, un EJB o cualquier otra clase puede obtener la <literal>SessionFactory</literal> usando una b&#x00fa;squeda JNDI. Observa que esta configuraci&#x00f3;n no es necesaria si usas la clase de ayuda <literal>HibernateUtil</literal> introducida en el cap&#x00ed;tulo uno, que act&#x00fa;a como un registro Singleton. Sin embargo, <literal>HibernateUtil</literal> es m&#x00e1;s com&#x00fa;n en un entorno no manejado."

#: index.docbook:1528
msgid "Borland ES"
msgstr "Ligado autom&#x00e1;tico de JTA y Session"

#: index.docbook:1537
msgid "JNDI-bound <literal>SessionFactory</literal>"
msgstr "Para entornos no manejados hemos sugerido <literal>HibernateUtil</literal> con una <literal>SessionFactory</literal> est&#x00e1;tica, y administraci&#x00f3;n de la <literal>Session</literal> de Hibernate. Este enfoque no es f&#x00e1;cil de usar en un entorno EJB, al poder ejecutarse muchos EJBs dentro de la misma transacci&#x00f3;n pero no en la misma hebra. Recomendados que ligues la <literal>SessionFactory</literal> a JNDI en un entorno manejado."

#: index.docbook:1539
msgid "A JNDI bound Hibernate <literal>SessionFactory</literal> can simplify the lookup of the factory and the creation of new <literal>Session</literal>s. Note that this is not related to a JNDI bound <literal>Datasource</literal>, both simply use the same registry!"
msgstr "En vez de rodar tu propia utilidad de <literal>ThreadLocal</literal>, usa el m&#x00e9;todo <literal>getCurrentSession()</literal> en la <literal>SessionFactory</literal> para obtener una <literal>Session</literal> de Hibernate. Si no hubiese una <literal>Session</literal> de Hibernate en la transacci&#x00f3;n JTA actual, se arrancar&#x00e1; y asignar&#x00e1; una. Ambas opciones de configuraci&#x00f3;n <literal>hibernate.transaction.flush_before_completion</literal> y <literal>hibernate.transaction.auto_close_session</literal>, ser&#x00e1;n establecidas autom&#x00e1;ticamente para cada <literal>Session</literal> que obtengas con <literal>getCurrentSession()</literal>, de modo que &#x00e9;stas ser&#x00e1;n limpiadas (flushed) y cerradas autom&#x00e1;ticamente cuando el contenedor complete las transacciones JTA."

#: index.docbook:1546
msgid "If you wish to have the <literal>SessionFactory</literal> bound to a JNDI namespace, specify a name (eg. <literal>java:hibernate/SessionFactory</literal>) using the property <literal>hibernate.session_factory_name</literal>. If this property is omitted, the <literal>SessionFactory</literal> will not be bound to JNDI. (This is especially useful in environments with a read-only JNDI default implementation, e.g. Tomcat.)"
msgstr "Si tu, por ejemplo, usas el patr&#x00f3;n de dise&#x00f1;o DAO para escribir tu capa de persistencia, todos los DAO's buscan la <literal>SessionFactory</literal> cuando se necesite y abren la sesi&#x00f3;n \"actual\". No hay necesidad de pasar las instancias de <literal>SessionFactory</literal> o <literal>Session</literal> alrededor entre el c&#x00f3;digo de control y el c&#x00f3;digo DAO."

#: index.docbook:1554
msgid "When binding the <literal>SessionFactory</literal> to JNDI, Hibernate will use the values of <literal>hibernate.jndi.url</literal>, <literal>hibernate.jndi.class</literal> to instantiate an initial context. If they are not specified, the default <literal>InitialContext</literal> will be used."
msgstr "Despliegue JMX"

#: index.docbook:1561
msgid "Hibernate will automatically place the <literal>SessionFactory</literal> in JNDI after you call <literal>cfg.buildSessionFactory()</literal>. This means you will at least have this call in some startup code (or utility class) in your application, unless you use JMX deployment with the <literal>HibernateService</literal> (discussed later)."
msgstr "La l&#x00ed;nea <literal>cfg.buildSessionFactory()</literal> todav&#x00ed;a tiene que ser ejecutada en algun sitio para obtener una <literal>SessionFactory</literal> en JNDI. Puedes hacer esto bien en un bloque inicializador <literal>static</literal> (como aquel en <literal>HibernateUtil</literal>) o bien despliegas Hibernate como un <emphasis>servicio manejado</emphasis>."

#: index.docbook:1568
msgid "If you use a JNDI <literal>SessionFactory</literal>, an EJB or any other class may obtain the <literal>SessionFactory</literal> using a JNDI lookup."
msgstr "Hibernate se distribuye con <literal>org.hibernate.jmx.HibernateService</literal> para despliegue en un servidor de aplicaciones con capacidades JMX, como JBoss AS. El despliegue y la configurac&#x00f3;n reales son espec&#x00ed;ficos del vendedor. He aqu&#x00ed; un <literal>jboss-service.xml</literal> de ejemplo para JBoss 4.0.x:"

#: index.docbook:1573
msgid "We recommend that you bind the <literal>SessionFactory</literal> to JNDI in a managed environment and use a <literal>static</literal> singleton otherwise. To shield your application code from these details, we also recommend to hide the actual lookup code for a <literal>SessionFactory</literal> in a helper class, such as <literal>HibernateUtil.getSessionFactory()</literal>. Note that such a class is also a convenient way to startup Hibernate&mdash;see chapter 1."
msgstr ""
      "<![CDATA[<?xml version=\"1.0\"?>\n"
      "<server>\n"
      "\n"
      "<mbean code=\"org.hibernate.jmx.HibernateService\"\n"
      "    name=\"jboss.jca:service=HibernateFactory,name=HibernateFactory\">\n"
      "\n"
      "    <!-- Required services -->\n"
      "    <depends>jboss.jca:service=RARDeployer</depends>\n"
      "    <depends>jboss.jca:service=LocalTxCM,name=HsqlDS</depends>\n"
      "\n"
      "    <!-- Bind the Hibernate service to JNDI -->\n"
      "    <attribute name=\"JndiName\">java:/hibernate/SessionFactory</attribute>\n"
      "\n"
      "    <!-- Datasource settings -->\n"
      "    <attribute name=\"Datasource\">java:HsqlDS</attribute>\n"
      "    <attribute name=\"Dialect\">org.hibernate.dialect.HSQLDialect</attribute>\n"
      "\n"
      "    <!-- Transaction integration -->\n"
      "    <attribute name=\"TransactionStrategy\">\n"
      "        org.hibernate.transaction.JTATransactionFactory</attribute>\n"
      "    <attribute name=\"TransactionManagerLookupStrategy\">\n"
      "        org.hibernate.transaction.JBossTransactionManagerLookup</attribute>\n"
      "    <attribute name=\"FlushBeforeCompletionEnabled\">true</attribute>\n"
      "    <attribute name=\"AutoCloseSessionEnabled\">true</attribute>\n"
      "\n"
      "    <!-- Fetching options -->\n"
      "    <attribute name=\"MaximumFetchDepth\">5</attribute>\n"
      "\n"
      "    <!-- Second-level caching -->\n"
      "    <attribute name=\"SecondLevelCacheEnabled\">true</attribute>\n"
      "    <attribute name=\"CacheProviderClass\">org.hibernate.cache.EhCacheProvider</attribute>\n"
      "    <attribute name=\"QueryCacheEnabled\">true</attribute>\n"
      "\n"
      "    <!-- Logging -->\n"
      "    <attribute name=\"ShowSqlEnabled\">true</attribute>\n"
      "\n"
      "    <!-- Mapping files -->\n"
      "    <attribute name=\"MapResources\">auction/Item.hbm.xml,auction/Category.hbm.xml</attribute>\n"
      "\n"
      "</mbean>\n"
      "\n"
      "</server>]]>"

#: index.docbook:1585
msgid "Current Session context management with JTA"
msgstr "Este fichero es desplegado en un directorio llamado <literal>META-INF</literal> y empaquetado en un fichero JAR con la extensi&#x00f3;n <literal>.sar</literal> (fichero de servicio). Tambi&#x00e9;n necesitas empaquetar Hibernate, sus bibliotecas de terceros requeridas, tus clases persistentes compiladas, as&#x00ed; como tus ficheros de mapeo en el mismo fichero. Tus beans de empresa (usualmente beans de sesi&#x00f3;n) pueden ser mantenidos en su propio fichero JAR, pero debes incluir este fichero EJB JAR en el fichero de servicio principal para obtener una unidad desplegable (en caliente). Consulta la documentaci&#x00f3;n de JBoss AS para m&#x00e1;s informaci&#x00f3;n sobre el servicio JMX y despliegue de EJB."

#: index.docbook:1587
msgid "The easiest way to handle <literal>Session</literal>s and transactions is Hibernates automatic \"current\" <literal>Session</literal> management. See the discussion of <xref linkend=\"architecture-current-session\"/>current sessions. Using the <literal>\"jta\"</literal> session context, if there is no Hibernate <literal>Session</literal> associated with the current JTA transaction, one will be started and associated with that JTA transaction the first time you call <literal>sessionFactory.getCurrentSession()</literal>. The <literal>Session</literal>s retrieved via <literal>getCurrentSession()</literal> in <literal>\"jta\"</literal> context will be set to automatically flush before the transaction completes, close after the transaction completes, and aggressively release JDBC connections after each statement. This allows the <literal>Session</literal>s to be managed by the life cycle of the JTA transaction to which it is associated, keeping user code clean of such management concerns. Your code can either use JTA programmatically through <literal>UserTransaction</literal>, or (recommended for portable code) use the Hibernate <literal>Transaction</literal> API to set transaction boundaries. If you run in an EJB container, declarative transaction demarcation with CMT is preferred."
msgstr ""

#: index.docbook:1610
msgid "JMX deployment"
msgstr ""

#: index.docbook:1612
msgid "The line <literal>cfg.buildSessionFactory()</literal> still has to be executed somewhere to get a <literal>SessionFactory</literal> into JNDI. You can do this either in a <literal>static</literal> initializer block (like the one in <literal>HibernateUtil</literal>) or you deploy Hibernate as a <emphasis>managed service</emphasis>."
msgstr ""

#: index.docbook:1620
msgid "Hibernate is distributed with <literal>org.hibernate.jmx.HibernateService</literal> for deployment on an application server with JMX capabilities, such as JBoss AS. The actual deployment and configuration is vendor specific. Here is an example <literal>jboss-service.xml</literal> for JBoss 4.0.x:"
msgstr ""

#: index.docbook:1627
msgid ""
      "<![CDATA[<?xml version=\"1.0\"?>\n"
      "<server>\n"
      "\n"
      "<mbean code=\"org.hibernate.jmx.HibernateService\"\n"
      "    name=\"jboss.jca:service=HibernateFactory,name=HibernateFactory\">\n"
      "\n"
      "    <!-- Required services -->\n"
      "    <depends>jboss.jca:service=RARDeployer</depends>\n"
      "    <depends>jboss.jca:service=LocalTxCM,name=HsqlDS</depends>\n"
      "\n"
      "    <!-- Bind the Hibernate service to JNDI -->\n"
      "    <attribute name=\"JndiName\">java:/hibernate/SessionFactory</attribute>\n"
      "\n"
      "    <!-- Datasource settings -->\n"
      "    <attribute name=\"Datasource\">java:HsqlDS</attribute>\n"
      "    <attribute name=\"Dialect\">org.hibernate.dialect.HSQLDialect</attribute>\n"
      "\n"
      "    <!-- Transaction integration -->\n"
      "    <attribute name=\"TransactionStrategy\">\n"
      "        org.hibernate.transaction.JTATransactionFactory</attribute>\n"
      "    <attribute name=\"TransactionManagerLookupStrategy\">\n"
      "        org.hibernate.transaction.JBossTransactionManagerLookup</attribute>\n"
      "    <attribute name=\"FlushBeforeCompletionEnabled\">true</attribute>\n"
      "    <attribute name=\"AutoCloseSessionEnabled\">true</attribute>\n"
      "\n"
      "    <!-- Fetching options -->\n"
      "    <attribute name=\"MaximumFetchDepth\">5</attribute>\n"
      "\n"
      "    <!-- Second-level caching -->\n"
      "    <attribute name=\"SecondLevelCacheEnabled\">true</attribute>\n"
      "    <attribute name=\"CacheProviderClass\">org.hibernate.cache.EhCacheProvider</attribute>\n"
      "    <attribute name=\"QueryCacheEnabled\">true</attribute>\n"
      "\n"
      "    <!-- Logging -->\n"
      "    <attribute name=\"ShowSqlEnabled\">true</attribute>\n"
      "\n"
      "    <!-- Mapping files -->\n"
      "    <attribute name=\"MapResources\">auction/Item.hbm.xml,auction/Category.hbm.xml</attribute>\n"
      "\n"
      "</mbean>\n"
      "\n"
      "</server>]]>"
msgstr ""

#: index.docbook:1629
msgid "This file is deployed in a directory called <literal>META-INF</literal> and packaged in a JAR file with the extension <literal>.sar</literal> (service archive). You also need to package Hibernate, its required third-party libraries, your compiled persistent classes, as well as your mapping files in the same archive. Your enterprise beans (usually session beans) may be kept in their own JAR file, but you may include this EJB JAR file in the main service archive to get a single (hot-)deployable unit. Consult the JBoss AS documentation for more information about JMX service and EJB deployment."
msgstr ""

msgid "ROLES_OF_TRANSLATORS"
msgstr "<!--TRANS:ROLES_OF_TRANSLATORS-->"

msgid "CREDIT_FOR_TRANSLATORS"
msgstr "<!--TRANS:CREDIT_FOR_TRANSLATORS-->"

