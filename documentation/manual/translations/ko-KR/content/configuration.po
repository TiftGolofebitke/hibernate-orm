#, fuzzy
msgid ""
msgstr ""
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Content-Type: text/plain; charset=utf-8\n"
#: index.docbook:5
msgid "Configuration"
msgstr "<title>구성</title>"

#: index.docbook:7
msgid "Because Hibernate is designed to operate in many different environments, there are a large number of configuration parameters. Fortunately, most have sensible default values and Hibernate is distributed with an example <literal>hibernate.properties</literal> file in <literal>etc/</literal> that shows the various options. Just put the example file in your classpath and customize it."
msgstr "Hibernate가 많은 다른 환경들에서 동작하도록 설계되어 있으므로, 많은 개수의 구성 파라미터들이 존재한다. 다행히 대부분은 유의미한 디폴트 값들이고 Hibernate는 다양한 옵션들을 보여주는 <literal>etc/</literal> 내의 예제 파일 <literal>hibernate.properties</literal>로 배포된다. 당신은 단지 당신의 classpath 경로 속에 그 파일을 집어넣고 그것을 커스트마이징하기만 해야 한다."

#: index.docbook:16
msgid "Programmatic configuration"
msgstr "프로그램 상의 구성"

#: index.docbook:18
msgid "An instance of <literal>org.hibernate.cfg.Configuration</literal> represents an entire set of mappings of an application's Java types to an SQL database. The <literal>Configuration</literal> is used to build an (immutable) <literal>SessionFactory</literal>. The mappings are compiled from various XML mapping files."
msgstr "<literal>org.hibernate.cfg.Configuration</literal>의 인스턴스는 어플리케이션의 Java 타입들을 SQL 데이터베이스 타입으로의 전체 매핑 집합을 표현한다. <literal>Configuration</literal>은 (불변의) <literal>SessionFactory</literal>를 빌드하는데 사용된다. 매핑들은 여러 XML 매핑 파일들로부터 컴파일 된다."

#: index.docbook:26
msgid "You may obtain a <literal>Configuration</literal> instance by instantiating it directly and specifying XML mapping documents. If the mapping files are in the classpath, use <literal>addResource()</literal>:"
msgstr "당신은 <literal>Configuration</literal> 인스턴스를 초기화 시키고 XML 매핑 문서들을 지정함으로써 <literal>Configuration</literal> 인스턴스를 얻을 수 있다. 만일 매핑 파일들이 classpath 내에 있다면, <literal>addResource()</literal>를 사용하라:"

#: index.docbook:32
msgid ""
      "<![CDATA[Configuration cfg = new Configuration()\n"
      "    .addResource(\"Item.hbm.xml\")\n"
      "    .addResource(\"Bid.hbm.xml\");]]>"
msgstr ""
      "<![CDATA[Configuration cfg = new Configuration()\n"
      "    .addResource(\"Item.hbm.xml\")\n"
      "    .addResource(\"Bid.hbm.xml\");]]>"

#: index.docbook:34
msgid "An alternative (sometimes better) way is to specify the mapped class, and let Hibernate find the mapping document for you:"
msgstr "(때때로 더 나은) 다른 방법은 매핑된 클래스를 지정하는 것이고, Hibernate로 하여금 당신을 위해 매핑 문서를 찾도록 하라:"

#: index.docbook:39
msgid ""
      "<![CDATA[Configuration cfg = new Configuration()\n"
      "    .addClass(org.hibernate.auction.Item.class)\n"
      "    .addClass(org.hibernate.auction.Bid.class);]]>"
msgstr ""
      "<![CDATA[Configuration cfg = new Configuration()\n"
      "    .addClass(org.hibernate.auction.Item.class)\n"
      "    .addClass(org.hibernate.auction.Bid.class);]]>"

#: index.docbook:41
msgid "Then Hibernate will look for mapping files named <literal>/org/hibernate/auction/Item.hbm.xml</literal> and <literal>/org/hibernate/auction/Bid.hbm.xml</literal> in the classpath. This approach eliminates any hardcoded filenames."
msgstr "그때 Hibernate는 classpath 내에서 <literal>/org/hibernate/auction/Item.hbm.xml</literal>과 <literal>/org/hibernate/auction/Bid.hbm.xml</literal>로 명명된 매핑 파일들을 룩업할 것이다. 이 접근법은 임의의 하드코딩된 파일 이름들을 제거한다."

#: index.docbook:48
msgid "A <literal>Configuration</literal> also allows you to specify configuration properties:"
msgstr "<literal>Configuration</literal>은 또한 구성 프로퍼티들을 지정하는 것을 허용해준다:"

#: index.docbook:53
msgid ""
      "<![CDATA[Configuration cfg = new Configuration()\n"
      "    .addClass(org.hibernate.auction.Item.class)\n"
      "    .addClass(org.hibernate.auction.Bid.class)\n"
      "    .setProperty(\"hibernate.dialect\", \"org.hibernate.dialect.MySQLInnoDBDialect\")\n"
      "    .setProperty(\"hibernate.connection.datasource\", \"java:comp/env/jdbc/test\")\n"
      "    .setProperty(\"hibernate.order_updates\", \"true\");]]>"
msgstr ""
      "<![CDATA[Configuration cfg = new Configuration()\n"
      "    .addClass(org.hibernate.auction.Item.class)\n"
      "    .addClass(org.hibernate.auction.Bid.class)\n"
      "    .setProperty(\"hibernate.dialect\", \"org.hibernate.dialect.MySQLInnoDBDialect\")\n"
      "    .setProperty(\"hibernate.connection.datasource\", \"java:comp/env/jdbc/test\")\n"
      "    .setProperty(\"hibernate.order_updates\", \"true\");]]>"

#: index.docbook:55
msgid "This is not the only way to pass configuration properties to Hibernate. The various options include:"
msgstr "이것은 컨피그레이션 프로퍼티들을 Hibernate에 전달하는 유일한 방법이 아니다. 여러 가지 옵션들은 다음을 포함한다:"

#: index.docbook:62
msgid "Pass an instance of <literal>java.util.Properties</literal> to <literal>Configuration.setProperties()</literal>."
msgstr "<literal>java.util.Properties</literal>의 인스턴스를 <literal>Configuration.setProperties()</literal>에 전달한다 ."

#: index.docbook:68
msgid "Place <literal>hibernate.properties</literal> in a root directory of the classpath."
msgstr "classpath의 루트 디렉토리에 <literal>hibernate.properties</literal>를 위치지운다."

#: index.docbook:74
msgid "Set <literal>System</literal> properties using <literal>java -Dproperty=value</literal>."
msgstr "<literal>java -Dproperty=value</literal>를 사용하여 <literal>System</literal> 프로퍼티들을 설정한다."

#: index.docbook:80
msgid "Include <literal>&lt;property&gt;</literal> elements in <literal>hibernate.cfg.xml</literal> (discussed later)."
msgstr "<literal>hibernate.cfg.xml</literal>에 <literal>&lt;property&gt;</literal> 요소들을 포함한다 (나중에 논의됨)."

#: index.docbook:87
msgid "<literal>hibernate.properties</literal> is the easiest approach if you want to get started quickly."
msgstr "당신이 빠르게 시작하고 원할 경우 <literal>hibernate.properties</literal>는 가장 쉬운 접근법이다."

#: index.docbook:92
msgid "The <literal>Configuration</literal> is intended as a startup-time object, to be discarded once a <literal>SessionFactory</literal> is created."
msgstr "<literal>Configuration</literal>은 시작 시(startup-time) 객체로서 일단 <literal>SessionFactory</literal>가 생성되면 폐기되게끔 예정되어 있다."

#: index.docbook:100
msgid "Obtaining a SessionFactory"
msgstr "SessionFactory 얻기"

#: index.docbook:102
msgid "When all mappings have been parsed by the <literal>Configuration</literal>, the application must obtain a factory for <literal>Session</literal> instances. This factory is intended to be shared by all application threads:"
msgstr "모든 매핑들이 <literal>Configuration</literal>에 의해 파싱되었을 때, 어플리케이션은 <literal>Session</literal> 인스턴스들에 대한 팩토리를 얻어야 한다. 이 팩토리는 모든 어플리케이션 쓰레드들에 의해 공유되도록 고안되었다:"

#: index.docbook:108
msgid "<![CDATA[SessionFactory sessions = cfg.buildSessionFactory();]]>"
msgstr "<![CDATA[SessionFactory sessions = cfg.buildSessionFactory();]]>"

#: index.docbook:110
msgid "Hibernate does allow your application to instantiate more than one <literal>SessionFactory</literal>. This is useful if you are using more than one database."
msgstr "하지만 Hibernate는 당신의 어플리케이션이 하나 이상의 <literal>SessionFactory</literal>를 초기화 시키는 것을 허용한다. 이것은 당신이 하나 이상의 데이터베이스를 사용하는 경우에 유용하다."

#: index.docbook:119
msgid "JDBC connections"
msgstr "JDBC 커넥션들"

#: index.docbook:121
msgid "Usually, you want to have the <literal>SessionFactory</literal> create and pool JDBC connections for you. If you take this approach, opening a <literal>Session</literal> is as simple as:"
msgstr "대개 당신은 <literal>SessionFactory</literal>로 하여금 당신을 위한 JDBC 커넥션들을 생성시키고 풀링시키는 것을 원한다. 만일 당신이 이 접근법을 취할 경우, 한 개의 <literal>Session</literal>을 여는 것은 다음과 같이 간단하다:"

#: index.docbook:127
msgid "<![CDATA[Session session = sessions.openSession(); // open a new Session]]>"
msgstr "<![CDATA[Session session = sessions.openSession(); // open a new Session]]>"

#: index.docbook:129
msgid "As soon as you do something that requires access to the database, a JDBC connection will be obtained from the pool."
msgstr "당신이 데이터베이스에 대한 접근을 요청하는 어떤 것을 행하자 마자, 한 개의 JDBC 커넥션이 그 풀로부터 얻어질 것이다."

#: index.docbook:134
msgid "For this to work, we need to pass some JDBC connection properties to Hibernate. All Hibernate property names and semantics are defined on the class <literal>org.hibernate.cfg.Environment</literal>. We will now describe the most important settings for JDBC connection configuration."
msgstr "이것이 동작하도록 하기 위해서, 우리는 몇몇 JDBC 커넥션 프로퍼티들을 Hibernate에 전달할 필요가 있다. 모든 Hibernate 프로퍼티 이름들과 의미론들은 <literal>org.hibernate.cfg.Environment</literal> 클래스 상에 정의되어 있다. 우리는 이제 JDBC 커넥션 구성을 위한 가장 중요한 설정들을 설명할 것이다."

#: index.docbook:141
msgid "Hibernate will obtain (and pool) connections using <literal>java.sql.DriverManager</literal> if you set the following properties:"
msgstr "만일 당신이 다음 프로퍼티들을 설정할 경우 Hibernate는 <literal>java.sql.DriverManager</literal>를 사용하여 커넥션들을 얻을 것이다(그리고 풀링시킬 것이다):"

#: index.docbook:147
msgid "Hibernate JDBC Properties"
msgstr "Hibernate JDBC 프로퍼티들"

#: index.docbook:153, index.docbook:241, index.docbook:338, index.docbook:529, index.docbook:725, index.docbook:832, index.docbook:920
msgid "Property name"
msgstr "프로퍼티 이름"

#: index.docbook:154, index.docbook:242, index.docbook:339, index.docbook:530, index.docbook:726, index.docbook:833, index.docbook:921
msgid "Purpose"
msgstr "<entry>용도</entry>"

#: index.docbook:160
msgid "hibernate.connection.driver_class"
msgstr "hibernate.connection.driver_class"

#: index.docbook:163
msgid "JDBC driver class"
msgstr "jdbc 드라이버 클래스"

#: index.docbook:168
msgid "hibernate.connection.url"
msgstr "hibernate.connection.url"

#: index.docbook:171
msgid "JDBC URL"
msgstr "jdbc URL"

#: index.docbook:176, index.docbook:272
msgid "hibernate.connection.username"
msgstr "hibernate.connection.username"

#: index.docbook:179
msgid "database user"
msgstr "데이터베이스 사용자"

#: index.docbook:184, index.docbook:280
msgid "hibernate.connection.password"
msgstr "hibernate.connection.password"

#: index.docbook:187
msgid "database user password"
msgstr "데이터베이스 사용자 패스워드"

#: index.docbook:192
msgid "hibernate.connection.pool_size"
msgstr "hibernate.connection.pool_size"

#: index.docbook:195
msgid "maximum number of pooled connections"
msgstr "풀링된 커넥션들의 최대 개수"

#: index.docbook:202
msgid "Hibernate's own connection pooling algorithm is however quite rudimentary. It is intended to help you get started and is <emphasis>not intended for use in a production system</emphasis> or even for performance testing. You should use a third party pool for best performance and stability. Just replace the <literal>hibernate.connection.pool_size</literal> property with connection pool specific settings. This will turn off Hibernate's internal pool. For example, you might like to use C3P0."
msgstr "하지만 Hibernate 자신의 커넥션 풀링 알고리즘은 아주 기본적이다. 그것은 당신이 시작하는 것을 도와주려고 의도되었고 <emphasis>제품 시스템 용도 또는 퍼포먼스 테스트용으로는 고안되지 않았다</emphasis>. 최상의 퍼포먼스와 안정성을 위해서는 제 3의 풀을 사용하라. 즉 <literal>hibernate.connection.pool_size</literal> 프로퍼티를 커넥션 풀 지정 설정들로 대체하라. 이것은 Hibernate의 내부 pool을 오프시킬 것이다. 예를 들어 당신은 C3P0를 사용할 수도 있다."

#: index.docbook:212
msgid "C3P0 is an open source JDBC connection pool distributed along with Hibernate in the <literal>lib</literal> directory. Hibernate will use its <literal>C3P0ConnectionProvider</literal> for connection pooling if you set <literal>hibernate.c3p0.*</literal> properties. If you'd like to use Proxool refer to the packaged <literal>hibernate.properties</literal> and the Hibernate web site for more information."
msgstr "C3P0는 <literal>lib</literal> 디펙토리 속에 Hibernate에 배포된 오픈 소스 JDBC 커넥션 풀이다. 당신이 <literal>hibernate.c3p0.*</literal> 프로퍼티들을 설정할 경우 Hibernate는 커넥션 풀링을 위해 그것의 <literal>C3P0ConnectionProvider</literal>를 사용할 것이다. 만일 당신이 Proxool을 사용하고자 원할 경우 패키지화 된 <literal>hibernate.properties</literal>를 참조하고 추가 정보는 Hibernate 웹 사이트를 참조하라."

#: index.docbook:221
msgid "Here is an example <literal>hibernate.properties</literal> file for C3P0:"
msgstr "다음은 C3P0에 대한 사용하는 예제 <literal>hibernate.properties</literal> 파일이다:"

#: index.docbook:225
msgid ""
      "<![CDATA[hibernate.connection.driver_class = org.postgresql.Driver\n"
      "hibernate.connection.url = jdbc:postgresql://localhost/mydatabase\n"
      "hibernate.connection.username = myuser\n"
      "hibernate.connection.password = secret\n"
      "hibernate.c3p0.min_size=5\n"
      "hibernate.c3p0.max_size=20\n"
      "hibernate.c3p0.timeout=1800\n"
      "hibernate.c3p0.max_statements=50\n"
      "hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect]]>"
msgstr ""
      "<![CDATA[hibernate.connection.driver_class = org.postgresql.Driver\n"
      "hibernate.connection.url = jdbc:postgresql://localhost/mydatabase\n"
      "hibernate.connection.username = myuser\n"
      "hibernate.connection.password = secret\n"
      "hibernate.c3p0.min_size=5\n"
      "hibernate.c3p0.max_size=20\n"
      "hibernate.c3p0.timeout=1800\n"
      "hibernate.c3p0.max_statements=50\n"
      "hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect]]>"

#: index.docbook:227
msgid "For use inside an application server, you should almost always configure Hibernate to obtain connections from an application server <literal>Datasource</literal> registered in JNDI. You'll need to set at least one of the following properties:"
msgstr "어플리케이션 서버 내부의 용도로, 당신은 JNDI로 등록된 어플리케이션 서버 <literal>Datasource</literal>로부터 커넥션을 얻기 위해 항상 Hibernate를 구성해야 한다. 당신은 적어도 다음 프로퍼티들 중 하나를 최소한으로 설정할 필요가 있을 것이다."

#: index.docbook:235
msgid "Hibernate Datasource Properties"
msgstr "Hibernate Datasource Properties"

#: index.docbook:248
msgid "hibernate.connection.datasource"
msgstr "hibernate.connection.datasource"

#: index.docbook:251
msgid "datasource JNDI name"
msgstr "데이터소스 JNDI 이름"

#: index.docbook:256
msgid "hibernate.jndi.url"
msgstr "hibernate.jndi.url"

#: index.docbook:258
msgid "<emphasis>URL of the JNDI provider</emphasis> (optional)"
msgstr "<emphasis>JNDI 프로바이더의 URL</emphasis> (옵션)"

#: index.docbook:264
msgid "hibernate.jndi.class"
msgstr "hibernate.jndi.class"

#: index.docbook:266
msgid "<emphasis>class of the JNDI <literal>InitialContextFactory</literal></emphasis> (optional)"
msgstr "<emphasis>JNDI <literal>InitialContextFactory</literal>의 클래스 </emphasis> (옵션)"

#: index.docbook:274
msgid "<emphasis>database user</emphasis> (optional)"
msgstr "<emphasis>데이터베이스 사용자</emphasis> (옵션)"

#: index.docbook:282
msgid "<emphasis>database user password</emphasis> (optional)"
msgstr "<emphasis>데이터베이스 사용자 패스워드</emphasis> (옵션)"

#: index.docbook:290
msgid "Here's an example <literal>hibernate.properties</literal> file for an application server provided JNDI datasource:"
msgstr "다음은 어플리케이션 서버 제공 JNDI 데이터소스용 예제 <literal>hibernate.properties</literal> 파일이다:"

#: index.docbook:295
msgid ""
      "<![CDATA[hibernate.connection.datasource = java:/comp/env/jdbc/test\n"
      "hibernate.transaction.factory_class = \\\n"
      "    org.hibernate.transaction.JTATransactionFactory\n"
      "hibernate.transaction.manager_lookup_class = \\\n"
      "    org.hibernate.transaction.JBossTransactionManagerLookup\n"
      "hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect]]>"
msgstr ""
      "<![CDATA[hibernate.connection.datasource = java:/comp/env/jdbc/test\n"
      "hibernate.transaction.factory_class = \\\n"
      "    org.hibernate.transaction.JTATransactionFactory\n"
      "hibernate.transaction.manager_lookup_class = \\\n"
      "    org.hibernate.transaction.JBossTransactionManagerLookup\n"
      "hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect]]>"

#: index.docbook:297
msgid "JDBC connections obtained from a JNDI datasource will automatically participate in the container-managed transactions of the application server."
msgstr "JNDI datasource로부터 얻어진 JDBC 커넥션들은 어플리케이션 서버의 컨테이너에 의해 관리되는 트랜잭션들에 자동적으로 참여할 것이다."

#: index.docbook:302
msgid "Arbitrary connection properties may be given by prepending \"<literal>hibernate.connection</literal>\" to the property name. For example, you may specify a <literal>charSet</literal> using <literal>hibernate.connection.charSet</literal>."
msgstr "임의의 커넥션 프로퍼티들은 프로퍼티 이름 앞에 \"<literal>hibernate.connnection</literal>\"을 첨가하여 부여될 수 있다. 예를 들어 당신은 <literal>hibernate.connection.charSet</literal>을 사용하여 <literal>charSet</literal>을 지정할 수도 있다."

#: index.docbook:308
msgid "You may define your own plugin strategy for obtaining JDBC connections by implementing the interface <literal>org.hibernate.connection.ConnectionProvider</literal>. You may select a custom implementation by setting <literal>hibernate.connection.provider_class</literal>."
msgstr "당신은 <literal>org.hibernate.connection.ConnectionProvider</literal> 인터페이스를 구현함으로써 JDBC 커넥션들을 얻는 당신 자신의 플러그인 방도를 정의할수도 있다. 당신은 <literal>hibernate.connection.provider_class</literal>를 설정하여 맞춤형 구현을 선택할 수도 있다."

#: index.docbook:317
msgid "Optional configuration properties"
msgstr "선택적인 구성 프로퍼티들"

#: index.docbook:319
msgid "There are a number of other properties that control the behaviour of Hibernate at runtime. All are optional and have reasonable default values."
msgstr "실행 시에 Hibernate의 행위를 제어하는 많은 다른 프로퍼티들이 존재한다. 모든 것이 옵션이지만 합당한 디폴트 값들을 갖는다."

#: index.docbook:324
msgid "<emphasis>Warning: some of these properties are \"system-level\" only.</emphasis> System-level properties can be set only via <literal>java -Dproperty=value</literal> or <literal>hibernate.properties</literal>. They may <emphasis>not</emphasis> be set by the other techniques described above."
msgstr "<emphasis>경고: 이들 프로퍼티들 중 몇몇은 \"system-level\" 전용이다.</emphasis> 시스템 레벨 프로퍼티들은 오직 <literal>java -Dproperty=value</literal> 또는 <literal>hibernate.properties</literal>를 통해서만 설정될 수 있다. 그것들은 위에 설명된 다른 기법들에 의해 설정될 수 <emphasis>없다</emphasis>."

#: index.docbook:332
msgid "Hibernate Configuration Properties"
msgstr "Hibernate 구성 프로퍼티들"

#: index.docbook:345
msgid "hibernate.dialect"
msgstr "hibernate.dialect"

#: index.docbook:347
msgid "The classname of a Hibernate <literal>Dialect</literal> which allows Hibernate to generate SQL optimized for a particular relational database."
msgstr "특정 관계형 데이터베이스에 최적화 된 SQL을 생성시키는 것을 Hibernate에게 허용해주는 Hibernate <literal>Dialect</literal>의 클래스명."

#: index.docbook:351
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>full.classname.of.Dialect</literal>"
msgstr "<emphasis role=\"strong\">예.</emphasis> <literal>full.classname.of.Dialect</literal>"

#: index.docbook:359
msgid "hibernate.show_sql"
msgstr "hibernate.show_sql"

#: index.docbook:361
msgid "Write all SQL statements to console. This is an alternative to setting the log category <literal>org.hibernate.SQL</literal> to <literal>debug</literal>."
msgstr "모든 SQL 문장들을 콘솔에 기록한다. 이것은 로그 카테고리 <literal>org.hibernate.SQL</literal>를 <literal>debug</literal>로 설정하는 것에 대한 하나의 다른 방법이다."

#: index.docbook:365, index.docbook:377, index.docbook:471, index.docbook:484, index.docbook:497, index.docbook:510, index.docbook:564, index.docbook:591, index.docbook:605, index.docbook:660, index.docbook:888, index.docbook:903, index.docbook:993
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>true</literal> | <literal>false</literal>"
msgstr "<emphasis role=\"strong\">예.</emphasis> <literal>true</literal> | <literal>false</literal>"

#: index.docbook:373
msgid "hibernate.format_sql"
msgstr "hibernate.format_sql"

#: index.docbook:375
msgid "Pretty print the SQL in the log and console."
msgstr "로그와 콘솔 속에 SQL을 깔끔하게 프린트한다."

#: index.docbook:385
msgid "hibernate.default_schema"
msgstr "hibernate.default_schema"

#: index.docbook:387
msgid "Qualify unqualified table names with the given schema/tablespace in generated SQL."
msgstr "생성된 SQL 내에 주어진 schema/tablespace로서 수식이 없는 테이블이름들을 수식한다."

#: index.docbook:390
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>SCHEMA_NAME</literal>"
msgstr "<emphasis role=\"strong\">예.</emphasis> <literal>SCHEMA_NAME</literal>"

#: index.docbook:398
msgid "hibernate.default_catalog"
msgstr "hibernate.default_catalog"

#: index.docbook:400
msgid "Qualify unqualified table names with the given catalog in generated SQL."
msgstr "주어진 SQL 내에 주어진 카타록으로서 수식이 없는 테이블이름들을 수식한다."

#: index.docbook:403
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>CATALOG_NAME</literal>"
msgstr "<emphasis role=\"strong\">예.</emphasis> <literal>CATALOG_NAME</literal>"

#: index.docbook:411
msgid "hibernate.session_factory_name"
msgstr "hibernate.session_factory_name"

#: index.docbook:413
msgid "The <literal>SessionFactory</literal> will be automatically bound to this name in JNDI after it has been created."
msgstr "<literal>SessionFactory</literal>는 그것이 생성된 후에 JNDI 내에서 이 이름에 자동적으로 바인드 될 것이다."

#: index.docbook:416, index.docbook:859
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>jndi/composite/name</literal>"
msgstr "<emphasis role=\"strong\">예.</emphasis> <literal>jndi/composite/name</literal>"

#: index.docbook:424
msgid "hibernate.max_fetch_depth"
msgstr "hibernate.max_fetch_depth"

#: index.docbook:426
msgid "Set a maximum \"depth\" for the outer join fetch tree for single-ended associations (one-to-one, many-to-one). A <literal>0</literal> disables default outer join fetching."
msgstr "single-ended 연관관계들(one-to-one, many-to-one)의 경우에 outer join fetch 트리의 최대 \"깊이\"를 설정한다. <literal>0</literal>은 디폴트 outer join fetching을 사용불가능하게 만든다."

#: index.docbook:430
msgid "<emphasis role=\"strong\">eg.</emphasis> recommended values between <literal>0</literal> and <literal>3</literal>"
msgstr "<emphasis role=\"strong\">예.</emphasis> <literal>0</literal>과 <literal>3</literal> 사이의 값들이권장된다"

#: index.docbook:439
msgid "hibernate.default_batch_fetch_size"
msgstr "hibernate.default_batch_fetch_size"

#: index.docbook:441
msgid "Set a default size for Hibernate batch fetching of associations."
msgstr "연관들의 Hibernate 배치 페칭에 대한 디폴트 크기를 설정한다."

#: index.docbook:443
msgid "<emphasis role=\"strong\">eg.</emphasis> recommended values <literal>4</literal>, <literal>8</literal>, <literal>16</literal>"
msgstr "<emphasis role=\"strong\">예.</emphasis> 권장되는 값들은 <literal>4</literal>, <literal>8</literal>, <literal>16</literal>"

#: index.docbook:452
msgid "hibernate.default_entity_mode"
msgstr "hibernate.default_entity_mode"

#: index.docbook:454
msgid "Set a default mode for entity representation for all sessions opened from this <literal>SessionFactory</literal>"
msgstr "이 <literal>SessionFactory</literal>로부터 열려진 모든 세션들에 대해 엔티티 표현을 디폴트 모드로 설정한다"

#: index.docbook:457
msgid "<literal>dynamic-map</literal>, <literal>dom4j</literal>, <literal>pojo</literal>"
msgstr "<literal>dynamic-map</literal>, <literal>dom4j</literal>, <literal>pojo</literal>"

#: index.docbook:465
msgid "hibernate.order_updates"
msgstr "hibernate.order_updates"

#: index.docbook:467
msgid "Force Hibernate to order SQL updates by the primary key value of the items being updated. This will result in fewer transaction deadlocks in highly concurrent systems."
msgstr "업데이트 중인 항목들의 프라이머리 키 값에 의해 SQL 업데이트들이 순서(ordering)지워지도록 Hibernate에게 강제시킨다. 이것은 고도의 동시성 시스템들에서 더 적은 트랜잭션 데드락(deadlock)들로 귀결될 것이다"

#: index.docbook:479
msgid "hibernate.generate_statistics"
msgstr "hibernate.generate_statistics"

#: index.docbook:481
msgid "If enabled, Hibernate will collect statistics useful for performance tuning."
msgstr "이용 가능하게 되면, Hibernate는 퍼포먼스 튜닝에 유용한 통계들을 수집할 것이다."

#: index.docbook:492
msgid "hibernate.use_identifier_rollback"
msgstr "hibernate.use_identifer_rollback"

#: index.docbook:494
msgid "If enabled, generated identifier properties will be reset to default values when objects are deleted."
msgstr "이용 가능하게 되면, 객체가 삭제될 때 생성된 식별자 프로퍼티들은 디폴트 값들로 재설정될 것이다."

#: index.docbook:505
msgid "hibernate.use_sql_comments"
msgstr "hibernate.use_sql_comments"

#: index.docbook:507
msgid "If turned on, Hibernate will generate comments inside the SQL, for easier debugging, defaults to <literal>false</literal>."
msgstr "이용 가능하게 되면, Hibernate는 보다 쉬운 디버깅을 위해 SQL 내에 주석들을 생성시킬 것이다. 디폴트는 <literal>false</literal>."

#: index.docbook:521
msgid "Hibernate JDBC and Connection Properties"
msgstr "Hibernate JDBC 및 커넥션 프로퍼티들"

#: index.docbook:536
msgid "hibernate.jdbc.fetch_size"
msgstr "hibernate.jdbc.fetch_size"

#: index.docbook:538
msgid "A non-zero value determines the JDBC fetch size (calls <literal>Statement.setFetchSize()</literal>)."
msgstr "0 아닌 값은 JDBC fetch 사이즈를 결정한다(<literal>Statement.setFetchSize()</literal>을 호출한다 )."

#: index.docbook:545
msgid "hibernate.jdbc.batch_size"
msgstr "hibernate.jdbc.batch_size"

#: index.docbook:547
msgid "A non-zero value enables use of JDBC2 batch updates by Hibernate."
msgstr "0 아닌 값은 Hibernate에 의한 JDBC2 배치 업데이트의 사용을 이용 가능하게 한다."

#: index.docbook:549
msgid "<emphasis role=\"strong\">eg.</emphasis> recommended values between <literal>5</literal> and <literal>30</literal>"
msgstr "<emphasis role=\"strong\">예.</emphasis> <literal>5</literal>와 <literal>30</literal> 사이의 값들이 권장된다"

#: index.docbook:557
msgid "hibernate.jdbc.batch_versioned_data"
msgstr "hibernate.jdbc.batch_versioned_data"

#: index.docbook:559
msgid "Set this property to <literal>true</literal> if your JDBC driver returns correct row counts from <literal>executeBatch()</literal> (it is usually safe to turn this option on). Hibernate will then use batched DML for automatically versioned data. Defaults to <literal>false</literal>."
msgstr "당신의 JDBC 드라이버가 <literal>executeBatch()</literal>로부터 정확한 행 카운트들을 반환할 경우에 이 프로퍼티를 <literal>true</literal>로 설정하라(대개 이 옵션을 사용 가능하게 하는 것이 안전하다). 그러면 Hibernate는 자동적으로 버전화 된 데이터에 대해 배치화된(batched) DML을 사용할 것이다. 디폴트는 <literal>false</literal>."

#: index.docbook:572
msgid "hibernate.jdbc.factory_class"
msgstr "hibernate.jdbc.factory_class"

#: index.docbook:574
msgid "Select a custom <literal>Batcher</literal>. Most applications will not need this configuration property."
msgstr "맞춤형 <literal>Batcher</literal>를 선택한다. 대부분의 어플리케이션들은 이 구성 프로퍼티를 필요로 하지 않을 것이다."

#: index.docbook:577
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>classname.of.BatcherFactory</literal>"
msgstr "<emphasis role=\"strong\">예.</emphasis> <literal>classname.of.BatcherFactory</literal>"

#: index.docbook:585
msgid "hibernate.jdbc.use_scrollable_resultset"
msgstr "hibernate.jdbc.use_scrollable_resultset"

#: index.docbook:587
msgid "Enables use of JDBC2 scrollable resultsets by Hibernate. This property is only necessary when using user supplied JDBC connections, Hibernate uses connection metadata otherwise."
msgstr "Hibernate에 의한 JDBC2 스크롤 가능한 결과셋들의 사용을 가능하게 해준다. 이 프로퍼티는 사용자가 제공한 JDBC커넥션들을 사용할 때에만 필수적이고, 그 밖의 경우 Hibernate는 커넥션 메타데이터를 사용한다."

#: index.docbook:599
msgid "hibernate.jdbc.use_streams_for_binary"
msgstr "hibernate.jdbc.use_streams_for_binary"

#: index.docbook:601
msgid "Use streams when writing/reading <literal>binary</literal> or <literal>serializable</literal> types to/from JDBC (system-level property)."
msgstr "<literal>binary</literal> 또는 <literal>serializable</literal> 타입들을 JDBC로 기록하고 /JDBC로부터 <literal>binary</literal> 또는 <literal>serializable</literal> 타입들을 읽어들일 때 스트림들을 사용한다(시스템-레벨 프로퍼티)."

#: index.docbook:613
msgid "hibernate.jdbc.use_get_generated_keys"
msgstr "hibernate.jdbc.use_get_generated_keys"

#: index.docbook:615
msgid "Enable use of JDBC3 <literal>PreparedStatement.getGeneratedKeys()</literal> to retrieve natively generated keys after insert. Requires JDBC3+ driver and JRE1.4+, set to false if your driver has problems with the Hibernate identifier generators. By default, tries to determine the driver capabilities using connection metadata."
msgstr "insert 후에 고유하게 생성된 키들을 검색하는데 JDBC3 <literal>PreparedStatement.getGeneratedKeys()</literal>의 사용을 이용 가능하도록 만든다. JDBC3+ 드라이버와 JRE1.4+를 필요로 하고, 당신의 드라이버가 Hibernate 식별자 생성자들에 문제가 있을 경우에 false로 설정하라. 디폴트로 커넥션 메타 데이터를 사용하여 드라이버 가용성들을 결정하려고 시도하라."

#: index.docbook:621, index.docbook:751, index.docbook:763, index.docbook:777, index.docbook:815
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>true|false</literal>"
msgstr "<emphasis role=\"strong\">예.</emphasis> <literal>true|false</literal>"

#: index.docbook:629
msgid "hibernate.connection.provider_class"
msgstr "hibernate.connection.provider_class"

#: index.docbook:631
msgid "The classname of a custom <literal>ConnectionProvider</literal> which provides JDBC connections to Hibernate."
msgstr "Hibernate에 JDBC 커넥션들을 제공하는 맞춤형 <literal>ConnectionProvider</literal>의 클래스명."

#: index.docbook:634
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>classname.of.ConnectionProvider</literal>"
msgstr "<emphasis role=\"strong\">예.</emphasis> <literal>classname.of.ConnectionProvider</literal>"

#: index.docbook:642
msgid "hibernate.connection.isolation"
msgstr "hibernate.connection.isolation"

#: index.docbook:644
msgid "Set the JDBC transaction isolation level. Check <literal>java.sql.Connection</literal> for meaningful values but note that most databases do not support all isolation levels."
msgstr "JDBC transaction isolation 레벨을 설정한다. 의미있는 값들로 <literal>java.sql.Connection</literal>을 체크하지만 대부분의 데이터베이스들이 모든 격리(isolate) 레벨들을 지원하지 않음을 노트하라."

#: index.docbook:648
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>1, 2, 4, 8</literal>"
msgstr "<emphasis role=\"strong\">예.</emphasis> <literal>1, 2, 4, 8</literal>"

#: index.docbook:656
msgid "hibernate.connection.autocommit"
msgstr "hibernate.connection.autocommit"

#: index.docbook:658
msgid "Enables autocommit for JDBC pooled connections (not recommended)."
msgstr "JDBC 풀링된 커넥션들에 대해 자동커밋을 이용 가능하도록 한다(권장되지 않음)."

#: index.docbook:668
msgid "hibernate.connection.release_mode"
msgstr "hibernate.connection.release_mode"

#: index.docbook:670
msgid "Specify when Hibernate should release JDBC connections. By default, a JDBC connection is held until the session is explicitly closed or disconnected. For an application server JTA datasource, you should use <literal>after_statement</literal> to aggressively release connections after every JDBC call. For a non-JTA connection, it often makes sense to release the connection at the end of each transaction, by using <literal>after_transaction</literal>. <literal>auto</literal> will choose <literal>after_statement</literal> for the JTA and CMT transaction strategies and <literal>after_transaction</literal> for the JDBC transaction strategy."
msgstr "Hibernate가 JDBC 커넥션들을 해제하게 될 시점을 지정한다. 디폴트로 한 개의 JDBC 커넥션은 그 세션이 명시적으로 닫히거나 연결해제되기 전까지 보관된다. 어플리케이션 트랜잭션 서버 JTA 데이터소스의 경우, 당신은 모든 JDBC 호출 후에 커넥션들을 과감하게 해제시키기 위해 <literal>after_statement</literal>를 사용해야 한다. 비-JTA 연결의 경우, <literal>after_transaction</literal>을 사용하여 각각의 트랜잭션의 끝에서 커넥션들을 해제시키는 것이 종종 의미가 있다. <literal>auto</literal>는 JTA 및 CMT 트랜잭션 방도들의 경우에 <literal>after_statement</literal>를 선택하고 JDBC 트랜잭션 방도에 대해 <literal>after_transaction</literal>를 선택할 것이다."

#: index.docbook:681
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>auto</literal> (default) | <literal>on_close</literal> | <literal>after_transaction</literal> | <literal>after_statement</literal>"
msgstr "<emphasis role=\"strong\">eg.</emphasis> <literal>auto</literal> (디폴트) | <literal>on_close</literal> | <literal>after_transaction</literal> | <literal>after_statement</literal>"

#: index.docbook:686
msgid "Note that this setting only affects <literal>Session</literal>s returned from <literal>SessionFactory.openSession</literal>. For <literal>Session</literal>s obtained through <literal>SessionFactory.getCurrentSession</literal>, the <literal>CurrentSessionContext</literal> implementation configured for use controls the connection release mode for those <literal>Session</literal>s. See"
msgstr "이 설정이 <literal>SessionFactory.openSession</literal>로부터 반환된 <literal>Session</literal>들에만 영향을 준다는 점을 노트하라. <literal>SessionFactory.getCurrentSession</literal>을 통해 얻어진 <literal>Session</literal>들의 경우, 사용하기 위해 구성된 <literal>CurrentSessionContext</literal> 구현이 그들 <literal>Session</literal>들에 대한 연결 해제를 제어한다. <xref linkend=\"architecture-current-session\"/>를 보라."

#: index.docbook:698
msgid "hibernate.connection.<emphasis>&lt;propertyName&gt;</emphasis>"
msgstr "hibernate.connection.<emphasis>&lt;propertyName&gt;</emphasis>"

#: index.docbook:700
msgid "Pass the JDBC property <literal>propertyName</literal> to <literal>DriverManager.getConnection()</literal>."
msgstr "JDBC 프로퍼티 <literal>propertyName</literal>을 <literal>DriverManager.getConnection()</literal>에 전달한다."

#: index.docbook:707
msgid "hibernate.jndi.<emphasis>&lt;propertyName&gt;</emphasis>"
msgstr "hibernate.jndi.<emphasis>&lt;propertyName&gt;</emphasis>"

#: index.docbook:709
msgid "Pass the property <literal>propertyName</literal> to the JNDI <literal>InitialContextFactory</literal>."
msgstr "<literal>propertyName</literal> 프로퍼티를 JNDI <literal>InitialContextFactory</literal>에 전달한다."

#: index.docbook:719
msgid "Hibernate Cache Properties"
msgstr "Hibernate Cache 프로퍼티들"

#: index.docbook:732
msgid "hibernate.cache.provider_class"
msgstr "hibernate.cache.provider_class"

#: index.docbook:734
msgid "The classname of a custom <literal>CacheProvider</literal>."
msgstr "맞춤형 <literal>CacheProvider</literal>의 클래스명."

#: index.docbook:736
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>classname.of.CacheProvider</literal>"
msgstr "<emphasis role=\"strong\">예.</emphasis> <literal>classname.of.CacheProvider</literal>"

#: index.docbook:744
msgid "hibernate.cache.use_minimal_puts"
msgstr "hibernate.cache.use_minimal_puts"

#: index.docbook:746
msgid "Optimize second-level cache operation to minimize writes, at the cost of more frequent reads. This setting is most useful for clustered caches and, in Hibernate3, is enabled by default for clustered cache implementations."
msgstr "읽기가 매우 빈번한 경우에, 쓰기를 최소화 시키기 위해 second-level 캐시 연산을 최적화 시킨다. 이 설정은 Hibernate3에서 클러스터링 된 캐시들에 가장 유용하고, Hibernate3에서는 클러스터링된 캐시 구현들에 대해 디폴트로 이용 가능하다."

#: index.docbook:759
msgid "hibernate.cache.use_query_cache"
msgstr "hibernate.cache.use_query_cache"

#: index.docbook:761
msgid "Enable the query cache, individual queries still have to be set cachable."
msgstr "질의 캐시를 가능하게 만든다. 개별 질의들은 여전히 캐시 가능한 것으로 설정되어야 한다."

#: index.docbook:771
msgid "hibernate.cache.use_second_level_cache"
msgstr "hibernate.cache.use_second_level_cache"

#: index.docbook:773
msgid "May be used to completely disable the second level cache, which is enabled by default for classes which specify a <literal>&lt;cache&gt;</literal> mapping."
msgstr "second-level 캐시를 완전히 사용 불가능하게 하는데 사용될 수 있고, 그것은 <literal>&lt;cache&gt;</literal> 매핑을 지정하는 클래스들에 대해 디폴트로 이용 가능이다."

#: index.docbook:785
msgid "hibernate.cache.query_cache_factory"
msgstr "hibernate.cache.query_cache_factory"

#: index.docbook:787
msgid "The classname of a custom <literal>QueryCache</literal> interface, defaults to the built-in <literal>StandardQueryCache</literal>."
msgstr "맞춤형 <literal>QueryCache</literal> 인터페이스의 클래스명. 디폴트는 미리 빌드된 <literal>StandardQueryCache</literal>."

#: index.docbook:790
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>classname.of.QueryCache</literal>"
msgstr "<emphasis role=\"strong\">예.</emphasis> <literal>classname.of.QueryCache</literal>"

#: index.docbook:798
msgid "hibernate.cache.region_prefix"
msgstr "hibernate.cache.region_prefix"

#: index.docbook:800
msgid "A prefix to use for second-level cache region names."
msgstr "second-level 캐시 영역 이름들에 사용할 접두어."

#: index.docbook:802
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>prefix</literal>"
msgstr "<emphasis role=\"strong\">예.</emphasis> <literal>prefix</literal>"

#: index.docbook:810
msgid "hibernate.cache.use_structured_entries"
msgstr "hibernate.cache.use_structured_entries"

#: index.docbook:812
msgid "Forces Hibernate to store data in the second-level cache in a more human-friendly format."
msgstr "인간에게 보다 더 친숙한 형식으로 second-level 캐시 속에 데이터를 저장하도록 Hibernate에게 강제시킨다.."

#: index.docbook:826
msgid "Hibernate Transaction Properties"
msgstr "Hibernate 트랜잭션 프로퍼티들"

#: index.docbook:839
msgid "hibernate.transaction.factory_class"
msgstr "hibernate.transaction.factory_class"

#: index.docbook:841
msgid "The classname of a <literal>TransactionFactory</literal> to use with Hibernate <literal>Transaction</literal> API (defaults to <literal>JDBCTransactionFactory</literal>)."
msgstr "Hibernate <literal>Transaction</literal> API 에 사용할 <literal>TransactionFactory</literal>의 클래스 이름.(디폴트는 <literal>JDBCTransactionFactory</literal>)."

#: index.docbook:845
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>classname.of.TransactionFactory</literal>"
msgstr "<emphasis role=\"strong\">예.</emphasis> <literal>classname.of.TransactionFactory</literal>"

#: index.docbook:853
msgid "jta.UserTransaction"
msgstr "jta.UserTransaction"

#: index.docbook:855
msgid "A JNDI name used by <literal>JTATransactionFactory</literal> to obtain the JTA <literal>UserTransaction</literal> from the application server."
msgstr "어플리케이션 서버로부터 JTA <literal>UserTransaction</literal>을 얻기 위해 <literal>JTATransactionFactory</literal>에 의해 사용되는 JNDI 이름."

#: index.docbook:867
msgid "hibernate.transaction.manager_lookup_class"
msgstr "hibernate.transaction.manager_lookup_class"

#: index.docbook:869
msgid "The classname of a <literal>TransactionManagerLookup</literal> - required when JVM-level caching is enabled or when using hilo generator in a JTA environment."
msgstr "<literal>TransactionManagerLookup</literal>의 클래스명- JVM 레벨의 캐싱이 이용 가능할 때 또는 JTA 환경에서 hilo generator를 사용할 때 필요하다."

#: index.docbook:873
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>classname.of.TransactionManagerLookup</literal>"
msgstr "<emphasis role=\"strong\">예.</emphasis> <literal>classname.of.TransactionManagerLookup</literal>"

#: index.docbook:881
msgid "hibernate.transaction.flush_before_completion"
msgstr "hibernate.transaction.flush_before_completion"

#: index.docbook:883
msgid "If enabled, the session will be automatically flushed during the before completion phase of the transaction. Built-in and automatic session context management is preferred, see <xref linkend=\"architecture-current-session\"/>."
msgstr "만일 사용가능하도록 되면, 세션은 트랜잭션의 before completion 단계 동안에 자동적으로 flush 될 것이다. 빌드되어 있는 자동적인 세션 컨텍스트 관리가 선호되는데, <xref linkend=\"architecture-current-session\"/>를 보라."

#: index.docbook:896
msgid "hibernate.transaction.auto_close_session"
msgstr "hibernate.transaction.auto_close_session"

#: index.docbook:898
msgid "If enabled, the session will be automatically closed during the after completion phase of the transaction. Built-in and utomatic session context management is preferred, see <xref linkend=\"architecture-current-session\"/>."
msgstr "만일 사용가능토록 하면, after completion 단계 동안에 세션이 자동적으로 닫혀질 것이다. (CMT에 대해 Hibernate를 사용할 때 매우 유용하다.)"

#: index.docbook:914
msgid "Miscellaneous Properties"
msgstr "여러가지 프로퍼티들"

#: index.docbook:927
msgid "hibernate.current_session_context_class"
msgstr "hibernate.current_session_context_class"

#: index.docbook:929
msgid "Supply a (custom) strategy for the scoping of the \"current\" <literal>Session</literal>. See <xref linkend=\"architecture-current-session\"/> for more information about the built-in strategies."
msgstr "\"현재\" <literal>Session</literal>의 영역화를 위한 하나의 (맞춤) 방도를 제공한다. 빌드되어 있는 방도들에 대한 추가 정보는 <xref linkend=\"architecture-current-session\"/>를 보라."

#: index.docbook:934
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>jta</literal> | <literal>thread</literal> | <literal>managed</literal> | <literal>custom.Class</literal>"
msgstr "<emphasis role=\"strong\">예.</emphasis> <literal>jta</literal> | <literal>thread</literal> | <literal>managed</literal> | <literal>custom.Class</literal>"

#: index.docbook:943
msgid "hibernate.query.factory_class"
msgstr "hibernate.query.factory_class"

#: index.docbook:945
msgid "Chooses the HQL parser implementation."
msgstr "Chooses the HQL 파서 구현을 선택한다."

#: index.docbook:947
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>org.hibernate.hql.ast.ASTQueryTranslatorFactory</literal> or <literal>org.hibernate.hql.classic.ClassicQueryTranslatorFactory</literal>"
msgstr "<emphasis role=\"strong\">예.</emphasis> <literal>org.hibernate.hql.ast.ASTQueryTranslatorFactory</literal> or <literal>org.hibernate.hql.classic.ClassicQueryTranslatorFactory</literal>"

#: index.docbook:956
msgid "hibernate.query.substitutions"
msgstr "hibernate.query.substitutions"

#: index.docbook:958
msgid "Mapping from tokens in Hibernate queries to SQL tokens (tokens might be function or literal names, for example)."
msgstr "Hibernate 질의들 내의 토큰들로부터 SQL 토큰들로의 매핑 (예를 들어 토큰들은 함수 이름 또는 리터럴 이름일 수 있다)."

#: index.docbook:961
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</literal>"
msgstr "<emphasis role=\"strong\">예.</emphasis> <literal>hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</literal>"

#: index.docbook:969
msgid "hibernate.hbm2ddl.auto"
msgstr "hibernate.hbm2ddl.auto"

#: index.docbook:971
msgid "Automatically validate or export schema DDL to the database when the <literal>SessionFactory</literal> is created. With <literal>create-drop</literal>, the database schema will be dropped when the <literal>SessionFactory</literal> is closed explicitly."
msgstr "<literal>SessionFactory</literal>가 생성될 때, 자동적으로 유효성을 검사하거나 schema DDL을 데이터베이스로 내보내기 한다. <literal>create-drop</literal>의 경우, <literal>SessionFactory</literal>가 명시적으로 닫혀질 때 데이터베이스 스키마가 드롭될 것이다."

#: index.docbook:977
msgid "<emphasis role=\"strong\">eg.</emphasis> <literal>validate</literal> | <literal>update</literal> | <literal>create</literal> | <literal>create-drop</literal>"
msgstr "<emphasis role=\"strong\">예.</emphasis> <literal>validate</literal> | <literal>update</literal> | <literal>create</literal> | <literal>create-drop</literal>"

#: index.docbook:986
msgid "hibernate.cglib.use_reflection_optimizer"
msgstr "hibernate.cglib.use_reflection_optimizer"

#: index.docbook:988
msgid "Enables use of CGLIB instead of runtime reflection (System-level property). Reflection can sometimes be useful when troubleshooting, note that Hibernate always requires CGLIB even if you turn off the optimizer. You can not set this property in <literal>hibernate.cfg.xml</literal>."
msgstr "런타임 reflection 대신에 CGLIB의 사용을 가능하도록 만든다(시스템 레벨 프로퍼티). Reflection은 문제가 발생할 시에 때때로 유용할 수 있고, 당신이 optimizer를 사용하지 않을 경우조차도 Hibernate는 항상 필요로 함을 유의하라. 당신은 <literal>hibernate.cfg.xml</literal> 속에 이 프로퍼티를 설정할수 없다."

#: index.docbook:1004
msgid "SQL Dialects"
msgstr "SQL Dialects"

#: index.docbook:1006
msgid "You should always set the <literal>hibernate.dialect</literal> property to the correct <literal>org.hibernate.dialect.Dialect</literal> subclass for your database. If you specify a dialect, Hibernate will use sensible defaults for some of the other properties listed above, saving you the effort of specifying them manually."
msgstr "당신은 항상 당신의 데이터베이스를 위해 <literal>hibernate.dialect</literal> 프로퍼티를 정확한 <literal>org.hibernate.dialect.Dialect</literal> 서브클래스로 설정해야 한다. 만일 당신이 dialect를 지정할 경우, 당신이 프로퍼티들을 수작업으로 지정하는 노력을 절약하도록 Hibernate는 위에 열거된 다른 프로퍼티들 중 몇몇에 대해 의미있는 디폴트들을 사용할 것이다."

#: index.docbook:1014
msgid "Hibernate SQL Dialects (<literal>hibernate.dialect</literal>)"
msgstr "Hibernate SQL Dialects (<literal>hibernate.dialect</literal>)"

#: index.docbook:1022
msgid "RDBMS"
msgstr "RDBMS"

#: index.docbook:1023
msgid "Dialect"
msgstr "Dialect"

#: index.docbook:1028
msgid "<entry>DB2</entry>"
msgstr "<entry>DB2</entry>"

#: index.docbook:1028
msgid "org.hibernate.dialect.DB2Dialect"
msgstr "org.hibernate.dialect.DB2Dialect"

#: index.docbook:1031
msgid "DB2 AS/400"
msgstr "DB2 AS/400"

#: index.docbook:1031
msgid "org.hibernate.dialect.DB2400Dialect"
msgstr "org.hibernate.dialect.DB2400Dialect"

#: index.docbook:1034
msgid "DB2 OS390"
msgstr "DB2 OS390"

#: index.docbook:1034
msgid "org.hibernate.dialect.DB2390Dialect"
msgstr "org.hibernate.dialect.DB2390Dialect"

#: index.docbook:1037
msgid "PostgreSQL"
msgstr "PostgreSQL"

#: index.docbook:1037
msgid "org.hibernate.dialect.PostgreSQLDialect"
msgstr "org.hibernate.dialect.PostgreSQLDialect"

#: index.docbook:1040
msgid "MySQL"
msgstr "MySQL"

#: index.docbook:1040
msgid "org.hibernate.dialect.MySQLDialect"
msgstr "org.hibernate.dialect.MySQLDialect"

#: index.docbook:1043
msgid "MySQL with InnoDB"
msgstr "MySQL with InnoDB"

#: index.docbook:1043
msgid "org.hibernate.dialect.MySQLInnoDBDialect"
msgstr "org.hibernate.dialect.MySQLInnoDBDialect"

#: index.docbook:1046
msgid "MySQL with MyISAM"
msgstr "MySQL with MyISAM"

#: index.docbook:1046
msgid "org.hibernate.dialect.MySQLMyISAMDialect"
msgstr "org.hibernate.dialect.MySQLMyISAMDialect"

#: index.docbook:1049
msgid "Oracle (any version)"
msgstr "Oracle (any version)"

#: index.docbook:1049
msgid "org.hibernate.dialect.OracleDialect"
msgstr "org.hibernate.dialect.OracleDialect"

#: index.docbook:1052
msgid "Oracle 9i/10g"
msgstr "Oracle 9i/10g"

#: index.docbook:1052
msgid "org.hibernate.dialect.Oracle9Dialect"
msgstr "org.hibernate.dialect.Oracle9Dialect"

#: index.docbook:1055
msgid "Sybase"
msgstr "Sybase"

#: index.docbook:1055
msgid "org.hibernate.dialect.SybaseDialect"
msgstr "org.hibernate.dialect.SybaseDialect"

#: index.docbook:1058
msgid "Sybase Anywhere"
msgstr "Sybase Anywhere"

#: index.docbook:1058
msgid "org.hibernate.dialect.SybaseAnywhereDialect"
msgstr "org.hibernate.dialect.SybaseAnywhereDialect"

#: index.docbook:1061
msgid "Microsoft SQL Server"
msgstr "Microsoft SQL Server"

#: index.docbook:1061
msgid "org.hibernate.dialect.SQLServerDialect"
msgstr "org.hibernate.dialect.SQLServerDialect"

#: index.docbook:1064
msgid "SAP DB"
msgstr "SAP DB"

#: index.docbook:1064
msgid "org.hibernate.dialect.SAPDBDialect"
msgstr "org.hibernate.dialect.SAPDBDialect"

#: index.docbook:1067
msgid "Informix"
msgstr "Informix"

#: index.docbook:1067
msgid "org.hibernate.dialect.InformixDialect"
msgstr "org.hibernate.dialect.InformixDialect"

#: index.docbook:1070
msgid "HypersonicSQL"
msgstr "HypersonicSQL"

#: index.docbook:1070
msgid "org.hibernate.dialect.HSQLDialect"
msgstr "org.hibernate.dialect.HSQLDialect"

#: index.docbook:1073
msgid "Ingres"
msgstr "Ingres"

#: index.docbook:1073
msgid "org.hibernate.dialect.IngresDialect"
msgstr "org.hibernate.dialect.IngresDialect"

#: index.docbook:1076
msgid "Progress"
msgstr "Progress"

#: index.docbook:1076
msgid "org.hibernate.dialect.ProgressDialect"
msgstr "org.hibernate.dialect.ProgressDialect"

#: index.docbook:1079
msgid "Mckoi SQL"
msgstr "Mckoi SQL"

#: index.docbook:1079
msgid "org.hibernate.dialect.MckoiDialect"
msgstr "org.hibernate.dialect.MckoiDialect"

#: index.docbook:1082
msgid "Interbase"
msgstr "Interbase"

#: index.docbook:1082
msgid "org.hibernate.dialect.InterbaseDialect"
msgstr "org.hibernate.dialect.InterbaseDialect"

#: index.docbook:1085
msgid "Pointbase"
msgstr "Pointbase"

#: index.docbook:1085
msgid "org.hibernate.dialect.PointbaseDialect"
msgstr "org.hibernate.dialect.PointbaseDialect"

#: index.docbook:1088
msgid "FrontBase"
msgstr "FrontBase"

#: index.docbook:1088
msgid "org.hibernate.dialect.FrontbaseDialect"
msgstr "org.hibernate.dialect.FrontbaseDialect"

#: index.docbook:1091
msgid "Firebird"
msgstr "Firebird"

#: index.docbook:1091
msgid "org.hibernate.dialect.FirebirdDialect"
msgstr "org.hibernate.dialect.FirebirdDialect"

#: index.docbook:1100
msgid "Outer Join Fetching"
msgstr "Outer Join Fetching"

#: index.docbook:1102
msgid "If your database supports ANSI, Oracle or Sybase style outer joins, <emphasis>outer join fetching</emphasis> will often increase performance by limiting the number of round trips to and from the database (at the cost of possibly more work performed by the database itself). Outer join fetching allows a whole graph of objects connected by many-to-one, one-to-many, many-to-many and one-to-one associations to be retrieved in a single SQL <literal>SELECT</literal>."
msgstr "만일 당신의 데이터베이스가 ANSI, Oracle, 또는 Sybase 스타일의 outer join들을 지원할 경우, <emphasis>outer join fetching</emphasis>은 (데이터베이스 그 자체에 의해 보다 더 많은 작업이 수행되는 비용으로) 데이터베이스로의 그리고 데이터베이스로부터의 라운드 트립들의 개수를 제한함으로써 종종 퍼포먼스를 증가시킬 것이다. Outer join fetching은 many-to-one, one-to-many, many-to-many,one-to-one 연관관계들이 에 의해 연결된 객체들의 전체 그래프가 하나의 SQL <literal>SELECT</literal> 속에서 검색되게끔 허용해준다."

#: index.docbook:1111
msgid "Outer join fetching may be disabled <emphasis>globally</emphasis> by setting the property <literal>hibernate.max_fetch_depth</literal> to <literal>0</literal>. A setting of <literal>1</literal> or higher enables outer join fetching for one-to-one and many-to-one associations which have been mapped with <literal>fetch=\"join\"</literal>."
msgstr "Outer join fetching은 hibernate.max_fetch_depth 프로퍼티를 <literal>0</literal>으로 설정함으로써 <emphasis>전역적으로</emphasis> 사용 불가능하게 할 수 있다. <literal>1</literal> 이상의 값을 설정하는 것은 <literal>fetch=\"join\"</literal>으로 매핑되었던 모든 one-to-one 및 many-to-one 연관관계들에 대해 outer join fetching을 사용 가능하도록 만든다."

#: index.docbook:1119
msgid "See <xref linkend=\"performance-fetching\"/> for more information."
msgstr "추가 정보는 <xref linkend=\"performance-fetching\"/>를 보라."

#: index.docbook:1126
msgid "Binary Streams"
msgstr "Binary Streams"

#: index.docbook:1128
msgid "Oracle limits the size of <literal>byte</literal> arrays that may be passed to/from its JDBC driver. If you wish to use large instances of <literal>binary</literal> or <literal>serializable</literal> type, you should enable <literal>hibernate.jdbc.use_streams_for_binary</literal>. <emphasis>This is a system-level setting only.</emphasis>"
msgstr "Oracle은 JDBC 드라이버 로/부터 전달되는 <literal>byte</literal> 배열들의 크기를 제한시킨다. 만일 당신이 <literal>binary</literal> 또는 <literal>serializable</literal> 타입의 대형 인스턴스를 사용하고자 원할 경우에, 당신은 <literal>hibernate.jdbc.use_streams_for_binary</literal>를 사용 가능하게 해야 할 것이다. <emphasis>이것은 오직 시스템 레벨 설정이다.</emphasis>"

#: index.docbook:1139
msgid "Second-level and query cache"
msgstr "Second-level 캐시와 query 캐시"

#: index.docbook:1141
msgid "The properties prefixed by <literal>hibernate.cache</literal> allow you to use a process or cluster scoped second-level cache system with Hibernate. See the <xref linkend=\"performance-cache\"/> for more details."
msgstr "<literal>hibernate.cache</literal> 접두어가 붙은 프로퍼티들은 Hibernate에 대해 프로세스 또는 클러스터 범위의 두 번째 레벨 캐시 시스템을 사용하는 것을 허용해준다. 상세한 것은 <xref linkend=\"performance-cache\"/>를 보라."

#: index.docbook:1151
msgid "Query Language Substitution"
msgstr "Query Language 치환"

#: index.docbook:1153
msgid "You may define new Hibernate query tokens using <literal>hibernate.query.substitutions</literal>. For example:"
msgstr "당신은 <literal>hibernate.query.substitutions</literal>을 사용하여 새로운 Hibernate 질의 토큰들을 정의할 수 있다. 예를 들어:"

#: index.docbook:1158
msgid "hibernate.query.substitutions true=1, false=0"
msgstr "hibernate.query.substitutions true=1, false=0"

#: index.docbook:1160
msgid "would cause the tokens <literal>true</literal> and <literal>false</literal> to be translated to integer literals in the generated SQL."
msgstr "은<literal>true</literal>와 <literal>false</literal> 토큰들이 생성된 SQL 내에서 정수 리터럴들로 번역되도록 강제할 것이다."

#: index.docbook:1165
msgid "hibernate.query.substitutions toLowercase=LOWER"
msgstr "hibernate.query.substitutions toLowercase=LOWER"

#: index.docbook:1167
msgid "would allow you to rename the SQL <literal>LOWER</literal> function."
msgstr "은 SQL <literal>LOWER</literal> function 함수 이름을 변경하는 것을 당신에게 허용해 줄 것이다"

#: index.docbook:1174
msgid "Hibernate statistics"
msgstr "Hibernate 통계"

#: index.docbook:1176
msgid "If you enable <literal>hibernate.generate_statistics</literal>, Hibernate will expose a number of metrics that are useful when tuning a running system via <literal>SessionFactory.getStatistics()</literal>. Hibernate can even be configured to expose these statistics via JMX. Read the Javadoc of the interfaces in <literal>org.hibernate.stats</literal> for more information."
msgstr "만일 당신이 <literal>hibernate.generate_statistics</literal>를 사용 가능하도록 할 경우, Hibernate는 <literal>SessionFactory.getStatistics()</literal>를 통해 가동 중인 시스템을 튜닝할 때 유용한 많은 통계들을 노출시킬 것이다. Hibernate는 심지어 JMX를 통해 이들 통계들을 노출시키도록 구성될 수 있다. 추가 정보는 <literal>org.hibernate.stats</literal>에 있는 인터페이스들에 관한 Javadoc를 읽어라."

#: index.docbook:1188
msgid "Logging"
msgstr "<title>로깅</title>"

#: index.docbook:1190
msgid "Hibernate logs various events using Apache commons-logging."
msgstr "Hibernate는 Apache commons-logging를 사용하여 다양한 이벤트들을 로그시킨다."

#: index.docbook:1194
msgid "The commons-logging service will direct output to either Apache Log4j (if you include <literal>log4j.jar</literal> in your classpath) or JDK1.4 logging (if running under JDK1.4 or above). You may download Log4j from <literal>http://jakarta.apache.org</literal>. To use Log4j you will need to place a <literal>log4j.properties</literal> file in your classpath, an example properties file is distributed with Hibernate in the <literal>src/</literal> directory."
msgstr "commons-logging 서비스는 (만일 당신이 classpath 내에 <literal>log4j.jar</literal>를 포함할 경우) Apache Log4j로 또는 (JDK1.4 이상의 버전에서 실행될 경우) JDK 1.4 로깅으로 직접 출력할 것이다. 당신은 <literal>http://jakarta.apache.org</literal>에서 Log4j를 다운로드 할 수 있다. Log4j를 사용하기 위해, 당신은 <literal>log4j.properties</literal> 파일을 당신의 classpath 내에 위치지울 필요가 있을 것이고, 예제 properties 파일은 Hibernate의 <literal>src/</literal> 디렉토리 내에 배포되어 있다."

#: index.docbook:1204
msgid "We strongly recommend that you familiarize yourself with Hibernate's log messages. A lot of work has been put into making the Hibernate log as detailed as possible, without making it unreadable. It is an essential troubleshooting device. The most interesting log categories are the following:"
msgstr "우리는 당신이 Hibernate의 로그 메시지들에 익숙해지기를 강력히 권장한다. 읽기 불가능하지 않게끔 가능한 한 상세하게 Hibernate 로그를 만들도록 많은 작업이 행해졌다. 그것은 본질적인 문제던지기 장치이다. 가장 흥미로운 로그 카테고리들이 다음에 있다:"

#: index.docbook:1213
msgid "Hibernate Log Categories"
msgstr "Hibernate 로그 카테고리들"

#: index.docbook:1219
msgid "Category"
msgstr "카테고리"

#: index.docbook:1220
msgid "Function"
msgstr "<entry>기능</entry>"

#: index.docbook:1225
msgid "org.hibernate.SQL"
msgstr "org.hibernate.SQL"

#: index.docbook:1226
msgid "Log all SQL DML statements as they are executed"
msgstr "SQL DML 문장들이 실행될 때 그것들 모두를 로그 시킨다"

#: index.docbook:1229
msgid "org.hibernate.type"
msgstr "org.hibernate.type"

#: index.docbook:1230
msgid "Log all JDBC parameters"
msgstr "모든 JDBC 파라미터들을 로그시킨다"

#: index.docbook:1233
msgid "org.hibernate.tool.hbm2ddl"
msgstr "org.hibernate.tool.hbm2ddl"

#: index.docbook:1234
msgid "Log all SQL DDL statements as they are executed"
msgstr "SQL DDL 문장들이 실행될 때 그것들 모두를 로그 시킨다"

#: index.docbook:1237
msgid "org.hibernate.pretty"
msgstr "org.hibernate.pretty"

#: index.docbook:1238
msgid "Log the state of all entities (max 20 entities) associated with the session at flush time"
msgstr "flush 시점에서 세션과 연관된 모든 엔티티들(최대 20개의 엔티티들)의 상태를 로그 시킨다"

#: index.docbook:1244
msgid "org.hibernate.cache"
msgstr "org.hibernate.cache"

#: index.docbook:1245
msgid "Log all second-level cache activity"
msgstr "모든 second-level 캐시 액티비티를 로그시킨다"

#: index.docbook:1248
msgid "org.hibernate.transaction"
msgstr "org.hibernate.transaction"

#: index.docbook:1249
msgid "Log transaction related activity"
msgstr "트랜잭션 관련 액티비티를 로그 시킨다"

#: index.docbook:1252
msgid "org.hibernate.jdbc"
msgstr "org.hibernate.jdbc"

#: index.docbook:1253
msgid "Log all JDBC resource acquisition"
msgstr "모든 JDBC 리소스 취득을 로그 시킨다"

#: index.docbook:1256
msgid "org.hibernate.hql.ast.AST"
msgstr "org.hibernate.hql.ast.AST"

#: index.docbook:1257
msgid "Log HQL and SQL ASTs during query parsing"
msgstr "질의 파싱 동안에 HQL AST와 SQL AST를 로그시킨다"

#: index.docbook:1262
msgid "org.hibernate.secure"
msgstr "org.hibernate.secure"

#: index.docbook:1263
msgid "Log all JAAS authorization requests"
msgstr "모든 JAAS 허가 요청들을 로그시킨다"

#: index.docbook:1266
msgid "org.hibernate"
msgstr "org.hibernate"

#: index.docbook:1267
msgid "Log everything (a lot of information, but very useful for troubleshooting)"
msgstr "모든 것을 로그시킨다(많은 정보이지만, 문제해결에 매우 유용하다)"

#: index.docbook:1276
msgid "When developing applications with Hibernate, you should almost always work with <literal>debug</literal> enabled for the category <literal>org.hibernate.SQL</literal>, or, alternatively, the property <literal>hibernate.show_sql</literal> enabled."
msgstr "Hibernate로 어플리케이션들을 개발할 때, 당신은 거의 항상 <literal>org.hibernate.SQL</literal> 카테고리에 대해 이용 가능한 <literal>debug</literal> 모드로 작업하거나, 다른 방법으로 <literal>hibernate.show_sql</literal> 프로퍼티를 이용가능하게 하여 작업해야 할 것이다."

#: index.docbook:1286
msgid "Implementing a <literal>NamingStrategy</literal>"
msgstr "<literal>NamingStrategy</literal> 구현하기"

#: index.docbook:1288
msgid "The interface <literal>org.hibernate.cfg.NamingStrategy</literal> allows you to specify a \"naming standard\" for database objects and schema elements."
msgstr "<literal>org.hibernate.cfg.NamingStrategy</literal> 인터페이스는 데이터베이스 객체들과 스키마 요소들에 대한 \"네이밍 표준\"을 지정하는 것을 당신에게 허용해준다."

#: index.docbook:1293
msgid "You may provide rules for automatically generating database identifiers from Java identifiers or for processing \"logical\" column and table names given in the mapping file into \"physical\" table and column names. This feature helps reduce the verbosity of the mapping document, eliminating repetitive noise (<literal>TBL_</literal> prefixes, for example). The default strategy used by Hibernate is quite minimal."
msgstr "당신은 Java 식별자들로부터 데이터베이스 식별자들을 자동적으로 생성시키거나 매핑 파일에 주어진 \"논리적\" 컬럼과 테이블 이름들을 \"물리적\" 테이블과 컬럼 이름들로 자동적으로 처리하는 규칙들을 제공할 수 있다. 이 특징은 반복되는 잡음(예를 들어 <literal>TBL_</literal>접두어들)을 제거함으로써, 매핑 문서의 말많은 장황함을 감소시키도록 도와준다. Hibernate에 의해 사용되는 디폴트 방도는 아주 작은 작품이다."

#: index.docbook:1302
msgid "You may specify a different strategy by calling <literal>Configuration.setNamingStrategy()</literal> before adding mappings:"
msgstr "당신은 매핑들을 추가하기 이전에 <literal>Configuration.setNamingStrategy()</literal>를 호출함으로써 다른 방도를 지정할 수 있다:"

#: index.docbook:1307
msgid ""
      "<![CDATA[SessionFactory sf = new Configuration()\n"
      "    .setNamingStrategy(ImprovedNamingStrategy.INSTANCE)\n"
      "    .addFile(\"Item.hbm.xml\")\n"
      "    .addFile(\"Bid.hbm.xml\")\n"
      "    .buildSessionFactory();]]>"
msgstr ""
      "<![CDATA[SessionFactory sf = new Configuration()\n"
      "    .setNamingStrategy(ImprovedNamingStrategy.INSTANCE)\n"
      "    .addFile(\"Item.hbm.xml\")\n"
      "    .addFile(\"Bid.hbm.xml\")\n"
      "    .buildSessionFactory();]]>"

#: index.docbook:1309
msgid "<literal>org.hibernate.cfg.ImprovedNamingStrategy</literal> is a built-in strategy that might be a useful starting point for some applications."
msgstr "<literal>org.hibernate.cfg.ImprovedNamingStrategy</literal>는 어떤 어플리케이션들에 대한 유용한 시작점일 수 있는 미리 빌드된 방도이다."

#: index.docbook:1317
msgid "XML configuration file"
msgstr "XML 구성 파일"

#: index.docbook:1319
msgid "An alternative approach to configuration is to specify a full configuration in a file named <literal>hibernate.cfg.xml</literal>. This file can be used as a replacement for the <literal>hibernate.properties</literal> file or, if both are present, to override properties."
msgstr "구성에 대한 다른 접근법은 <literal>hibernate.cfg.xml</literal>로 명명된 파일 속에 전체 구성을 지정하는 것이다. 이 파일은 <literal>hibernate.properties</literal> 파일에 대한 대용물로서 사용될 수 있거나, 만일 둘 다 존재할 경우에 프로퍼티들을 중복정의하는데 사용될 수 있다."

#: index.docbook:1326
msgid "The XML configuration file is by default expected to be in the root o your <literal>CLASSPATH</literal>. Here is an example:"
msgstr "XML 구성 파일은 디폴트로 당신의 <literal>CLASSPATH</literal>의 루트에 존재하는 것이 기대된다. 다음은 예제이다:"

#: index.docbook:1331
msgid ""
      "<![CDATA[<?xml version='1.0' encoding='utf-8'?>\n"
      "<!DOCTYPE hibernate-configuration PUBLIC\n"
      "    \"-//Hibernate/Hibernate Configuration DTD//EN\"\n"
      "    \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\">\n"
      "\n"
      "<hibernate-configuration>\n"
      "\n"
      "    <!-- a SessionFactory instance listed as /jndi/name -->\n"
      "    <session-factory\n"
      "        name=\"java:hibernate/SessionFactory\">\n"
      "\n"
      "        <!-- properties -->\n"
      "        <property name=\"connection.datasource\">java:/comp/env/jdbc/MyDB</property>\n"
      "        <property name=\"dialect\">org.hibernate.dialect.MySQLDialect</property>\n"
      "        <property name=\"show_sql\">false</property>\n"
      "        <property name=\"transaction.factory_class\">\n"
      "            org.hibernate.transaction.JTATransactionFactory\n"
      "        </property>\n"
      "        <property name=\"jta.UserTransaction\">java:comp/UserTransaction</property>\n"
      "\n"
      "        <!-- mapping files -->\n"
      "        <mapping resource=\"org/hibernate/auction/Item.hbm.xml\"/>\n"
      "        <mapping resource=\"org/hibernate/auction/Bid.hbm.xml\"/>\n"
      "\n"
      "        <!-- cache settings -->\n"
      "        <class-cache class=\"org.hibernate.auction.Item\" usage=\"read-write\"/>\n"
      "        <class-cache class=\"org.hibernate.auction.Bid\" usage=\"read-only\"/>\n"
      "        <collection-cache collection=\"org.hibernate.auction.Item.bids\" usage=\"read-write\"/>\n"
      "\n"
      "    </session-factory>\n"
      "\n"
      "</hibernate-configuration>]]>"
msgstr ""
      "<![CDATA[<?xml version='1.0' encoding='utf-8'?>\n"
      "<!DOCTYPE hibernate-configuration PUBLIC\n"
      "    \"-//Hibernate/Hibernate Configuration DTD//EN\"\n"
      "    \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\">\n"
      "\n"
      "<hibernate-configuration>\n"
      "\n"
      "    <!-- a SessionFactory instance listed as /jndi/name -->\n"
      "    <session-factory\n"
      "        name=\"java:hibernate/SessionFactory\">\n"
      "\n"
      "        <!-- properties -->\n"
      "        <property name=\"connection.datasource\">java:/comp/env/jdbc/MyDB</property>\n"
      "        <property name=\"dialect\">org.hibernate.dialect.MySQLDialect</property>\n"
      "        <property name=\"show_sql\">false</property>\n"
      "        <property name=\"transaction.factory_class\">\n"
      "            org.hibernate.transaction.JTATransactionFactory\n"
      "        </property>\n"
      "        <property name=\"jta.UserTransaction\">java:comp/UserTransaction</property>\n"
      "\n"
      "        <!-- mapping files -->\n"
      "        <mapping resource=\"org/hibernate/auction/Item.hbm.xml\"/>\n"
      "        <mapping resource=\"org/hibernate/auction/Bid.hbm.xml\"/>\n"
      "\n"
      "        <!-- cache settings -->\n"
      "        <class-cache class=\"org.hibernate.auction.Item\" usage=\"read-write\"/>\n"
      "        <class-cache class=\"org.hibernate.auction.Bid\" usage=\"read-only\"/>\n"
      "        <collection-cache collection=\"org.hibernate.auction.Item.bids\" usage=\"read-write\"/>\n"
      "\n"
      "    </session-factory>\n"
      "\n"
      "</hibernate-configuration>]]>"

#: index.docbook:1333
msgid "As you can see, the advantage of this approach is the externalization of the mapping file names to configuration. The <literal>hibernate.cfg.xml</literal> is also more convenient once you have to tune the Hibernate cache. Note that is your choice to use either <literal>hibernate.properties</literal> or <literal>hibernate.cfg.xml</literal>, both are equivalent, except for the above mentioned benefits of using the XML syntax."
msgstr "당신이 볼 수 있듯이, 이 접근법의 장점은 구성에 대한 매핑 파일 이름들을 구체화 시키는 것이다. <literal>hibernate.cfg.xml</literal>은 또한 당신이 Hibernate 캐시를 튜닝해야할 때 보다 편리하다. <literal>hibernate.properties</literal> 또는 <literal>hibernate.cfg.xml</literal> 중 어느 것을 사용하는가는 당신의 선택이다. XML 구문을 사용하는 위에 언급된 이점들을 제외하면 둘다 같은 것임을 노트하라."

#: index.docbook:1342
msgid "With the XML configuration, starting Hibernate is then as simple as"
msgstr "Hibernate 구성으로, Hibernate를 시작하는 것은 다음과 같이 간단하다"

#: index.docbook:1346
msgid "<![CDATA[SessionFactory sf = new Configuration().configure().buildSessionFactory();]]>"
msgstr "<![CDATA[SessionFactory sf = new Configuration().configure().buildSessionFactory();]]>"

#: index.docbook:1348
msgid "You can pick a different XML configuration file using"
msgstr "당신은 다음을 사용하여 다른 XML 구성 파일을 찾아낼 수 있다"

#: index.docbook:1352
msgid ""
      "<![CDATA[SessionFactory sf = new Configuration()\n"
      "    .configure(\"catdb.cfg.xml\")\n"
      "    .buildSessionFactory();]]>"
msgstr ""
      "<![CDATA[SessionFactory sf = new Configuration()\n"
      "    .configure(\"catdb.cfg.xml\")\n"
      "    .buildSessionFactory();]]>"

#: index.docbook:1357
msgid "J2EE Application Server integration"
msgstr "J2EE 어플리케이션 서버 통합"

#: index.docbook:1359
msgid "Hibernate has the following integration points for J2EE infrastructure:"
msgstr "Hibernate는 J2EE 인프라스트럭처에 대한 다음 통합 점들을 갖고 있다:"

#: index.docbook:1365
msgid "<emphasis>Container-managed datasources</emphasis>: Hibernate can use JDBC connections managed by the container and provided through JNDI. Usually, a JTA compatible <literal>TransactionManager</literal> and a <literal>ResourceManager</literal> take care of transaction management (CMT), esp. distributed transaction handling across several datasources. You may of course also demarcate transaction boundaries programmatically (BMT) or you might want to use the optional Hibernate <literal>Transaction</literal> API for this to keep your code portable."
msgstr "<emphasis>Container-managed datasources</emphasis>: Hibernate는 컨테이너에 의해 관리되는 JDBC 커넥션들을 사용할 수 있고 JNDI를 통해 제공된다. 대개 JTA 호환 <literal>TransactionManager</literal>와 <literal>ResourceManager</literal>는 트랜잭션 관리(CMT), 특히 몇몇 데이터소스들을 가로질러 분산된 트랜잭션 핸들링을 처리한다. 물론 당신은 또한 프로그램 상으로 트랜잭션 경계들을 한정할 수도 있거나(BMT) 당신은 당신의 코드가 이식성을 유지하도록 이것에 대한 선택적인 Hibernate <literal>Transaction</literal> API를 사용하고자 원할 수도 있다."

#: index.docbook:1380
msgid "<emphasis>Automatic JNDI binding</emphasis>: Hibernate can bind its <literal>SessionFactory</literal> to JNDI after startup."
msgstr "<emphasis>자동적인 JNDI 바인딩</emphasis>: Hibernate는 시작 후에 그것의 <literal>SessionFactory</literal>를 JNDI에 바인드 시킬 수 있다."

#: index.docbook:1389
msgid "<emphasis>JTA Session binding:</emphasis> The Hibernate <literal>Session</literal> may be automatically bound to the scope of JTA transactions. Simply lookup the <literal>SessionFactory</literal> from JNDI and get the current <literal>Session</literal>. Let Hibernate take care of flushing and closing the <literal>Session</literal> when your JTA transaction completes. Transaction demarcation is either declarative (CMT) or programmatic (BMT/UserTransaction)."
msgstr "<emphasis>JTA Session 바인딩</emphasis>: Hibernate <literal>Session</literal>은 JTA 트랜잭션들의 영역(scope)에 자동적으로 바인드 시킬 수도 있다. 간단하게 JNDI로부터 <literal>SessionFactory</literal>를 룩업하고 현재 <literal>Session</literal>을 얻어라. Hibernate로 하여금 당신의 JTA 트랜잭션이 완료될 때 <literal>Session</literal>을 flush시키고 닫는 것을 처리하도록 하라. 트랜잭션 경계 구분은 선언적(CMT)이거나 프로그래밍적((BMT/UserTransaction))이다."

#: index.docbook:1402
msgid "<emphasis>JMX deployment:</emphasis> If you have a JMX capable application server (e.g. JBoss AS), you can chose to deploy Hibernate as a managed MBean. This saves you the one line startup code to build your <literal>SessionFactory</literal> from a <literal>Configuration</literal>. The container will startup your <literal>HibernateService</literal>, and ideally also take care of service dependencies (Datasource has to be available before Hibernate starts, etc)."
msgstr "<emphasis>JMX 배치</emphasis>: 만일 당신이 JMX 가용성이 있는 어플리케이션 서버(예를 들면 JBoss AS)를 갖고 있다면, 당신은 Hibernate를 하나의 managed MBean으로서 배치하는 것을 선택할 수 있다. 이것은 <literal>Configuration</literal>으로부터 당신의 <literal>SessionFactory</literal>를 빌드 시키는 한 줄의 시작 코드를 절약해준다. 컨테이너는 당신의 <literal>HibernateService</literal>를 시작할 것이고, 또한 이상적으로 서비스 의존성들을 처리할 것이다(데이터소스는 Hibernate가 시작되기 전에 이용 가능해야 한다)."

#: index.docbook:1413
msgid "Depending on your environment, you might have to set the configuration option <literal>hibernate.connection.aggressive_release</literal> to true if your application server shows \"connection containment\" exceptions."
msgstr "당신의 환경에 따라, 당신은 당신의 어플리케이션 서버가 \"connection containment(연결 봉쇄)\" 예외상황들을 보일 경우에 구성 옵션 <literal>hibernate.connection.aggressive_release</literal>를 true로 설정해야 될 수도 있다."

#: index.docbook:1420
msgid "Transaction strategy configuration"
msgstr "트랜잭션 방도 구성"

#: index.docbook:1422
msgid "The Hibernate <literal>Session</literal> API is independent of any transaction demarcation system in your architecture. If you let Hibernate use JDBC directly, through a connection pool, you may begin and end your transactions by calling the JDBC API. If you run in a J2EE application server, you might want to use bean-managed transactions and call the JTA API and <literal>UserTransaction</literal> when needed."
msgstr "Hibernate <literal>Session</literal> API는 당신의 아카텍처 내에서 임의의 트랜잭션 관할 시스템에 독립적이다. 만일 당신이 Hibernate로 하여금 커넥션 풀을 통해 직접 JDBC를 사용하도록 강제할 경우, 당신은 JDBC API를 호출하여 당신의 트랜잭션을 시작하고 끝낼 수 있다. 만일 당신이 J2EE 어플리케이션 서버를 실행 중이라면, 당신은 필요할 때 bean-managed 트랜잭션들을 사용하고 JTA API와 <literal>UserTransaction</literal>을 호출하고자 원할 수 있다."

#: index.docbook:1430
msgid "To keep your code portable between these two (and other) environments we recommend the optional Hibernate <literal>Transaction</literal> API, which wraps and hides the underlying system. You have to specify a factory class for <literal>Transaction</literal> instances by setting the Hibernate configuration property <literal>hibernate.transaction.factory_class</literal>."
msgstr "이들 두 개의 (그리고 다른) 환경들에서 당신의 코드에 이식성을 유지하기 위해 우리는 기본 시스템을 포장하고 은폐시키는 선택적인 Hibernate <literal>Transaction</literal> API를 권장한다. 당신은 Hibernate 구성 프로퍼티 <literal>hibernate.transaction.factory_class</literal>를 사용하여 <literal>Transaction</literal> 인스턴스들에 대한 팩토리 클래스를 지정해야 한다."

#: index.docbook:1437
msgid "There are three standard (built-in) choices:"
msgstr "세 개의 표준(미리 만들어진) 선택들이 존재한다:"

#: index.docbook:1443
msgid "org.hibernate.transaction.JDBCTransactionFactory"
msgstr "org.hibernate.transaction.JDBCTransactionFactory"

#: index.docbook:1445
msgid "delegates to database (JDBC) transactions (default)"
msgstr "데이터베이스 (JDBC) 트랜잭션들에게 위임시킨다(디폴트)"

#: index.docbook:1449
msgid "org.hibernate.transaction.JTATransactionFactory"
msgstr "org.hibernate.transaction.JTATransactionFactory"

#: index.docbook:1451
msgid "delegates to container-managed transaction if an existing transaction is underway in this context (e.g. EJB session bean method), otherwise a new transaction is started and bean-managed transaction are used."
msgstr "기존의 트랜잭션이 이 컨텍스트(예를 들면 EJB session bean 메소드) 내에서 진행 중일 경우에 container-managed transaction에게 위임시키고, 그 밖의 경우 새로운 트랜잭션이 시작되고 bean-managed transaction이 사용된다."

#: index.docbook:1459
msgid "org.hibernate.transaction.CMTTransactionFactory"
msgstr "org.hibernate.transaction.CMTTransactionFactory"

#: index.docbook:1461
msgid "delegates to container-managed JTA transactions"
msgstr "container-managed JTA 트랜잭션들에게 위임시킨다"

#: index.docbook:1466
msgid "You may also define your own transaction strategies (for a CORBA transaction service, for example)."
msgstr "당신은 또한 당신 자신의 트랜잭션 방도들(예를 들면 CORBA 트랜잭션 서비스)을 정의할 수도 있다."

#: index.docbook:1471
msgid "Some features in Hibernate (i.e. the second level cache, Contextual Sessions with JTA, etc.) require access to the JTA <literal>TransactionManager</literal> in a managed environment. In an application server you have to specify how Hibernate should obtain a reference to the <literal>TransactionManager</literal>, since J2EE does not standardize a single mechanism:"
msgstr "Hibernate에 있는 몇몇 특징들(예를 들면. second level 캐시, JTA를 가진 컨텍스트 상의 세션들, 기타.)은 관리되는 환경에서 JTA <literal>TransactionManager</literal>에 대한 접근을 필요로 한다. 어플리케이션 서버에서 당신은 Hibernate가 <literal>TransactionManager</literal>에 대한 참조를 획득하는 방법을 지정해야 한다. 왜냐하면 J2EE가 한 개의 메커니즘을 표준화 시키고 있지 않기 때문이다:"

#: index.docbook:1479
msgid "JTA TransactionManagers"
msgstr "JTA TransactionManagers"

#: index.docbook:1485
msgid "Transaction Factory"
msgstr "트랜잭션 팩토리"

#: index.docbook:1486
msgid "Application Server"
msgstr "어플리케이션 서버"

#: index.docbook:1491
msgid "org.hibernate.transaction.JBossTransactionManagerLookup"
msgstr "org.hibernate.transaction.JBossTransactionManagerLookup"

#: index.docbook:1492
msgid "JBoss"
msgstr "JBoss"

#: index.docbook:1495
msgid "org.hibernate.transaction.WeblogicTransactionManagerLookup"
msgstr "org.hibernate.transaction.WeblogicTransactionManagerLookup"

#: index.docbook:1496
msgid "Weblogic"
msgstr "Weblogic"

#: index.docbook:1499
msgid "org.hibernate.transaction.WebSphereTransactionManagerLookup"
msgstr "org.hibernate.transaction.WebSphereTransactionManagerLookup"

#: index.docbook:1500
msgid "WebSphere"
msgstr "WebSphere"

#: index.docbook:1503
msgid "org.hibernate.transaction.WebSphereExtendedJTATransactionLookup"
msgstr "org.hibernate.transaction.WebSphereExtendedJTATransactionLookup"

#: index.docbook:1504
msgid "WebSphere 6"
msgstr "WebSphere 6"

#: index.docbook:1507
msgid "org.hibernate.transaction.OrionTransactionManagerLookup"
msgstr "org.hibernate.transaction.OrionTransactionManagerLookup"

#: index.docbook:1508
msgid "Orion"
msgstr "Orion"

#: index.docbook:1511
msgid "org.hibernate.transaction.ResinTransactionManagerLookup"
msgstr "org.hibernate.transaction.ResinTransactionManagerLookup"

#: index.docbook:1512
msgid "Resin"
msgstr "Resin"

#: index.docbook:1515
msgid "org.hibernate.transaction.JOTMTransactionManagerLookup"
msgstr "org.hibernate.transaction.JOTMTransactionManagerLookup"

#: index.docbook:1516
msgid "JOTM"
msgstr "JOTM"

#: index.docbook:1519
msgid "org.hibernate.transaction.JOnASTransactionManagerLookup"
msgstr "org.hibernate.transaction.JOnASTransactionManagerLookup"

#: index.docbook:1520
msgid "JOnAS"
msgstr "JOnAS"

#: index.docbook:1523
msgid "org.hibernate.transaction.JRun4TransactionManagerLookup"
msgstr "org.hibernate.transaction.JRun4TransactionManagerLookup"

#: index.docbook:1524
msgid "JRun4"
msgstr "JRun4"

#: index.docbook:1527
msgid "org.hibernate.transaction.BESTransactionManagerLookup"
msgstr "org.hibernate.transaction.BESTransactionManagerLookup"

#: index.docbook:1528
msgid "Borland ES"
msgstr "Borland ES"

#: index.docbook:1537
msgid "JNDI-bound <literal>SessionFactory</literal>"
msgstr "JNDI-bound <literal>SessionFactory</literal>"

#: index.docbook:1539
msgid "A JNDI bound Hibernate <literal>SessionFactory</literal> can simplify the lookup of the factory and the creation of new <literal>Session</literal>s. Note that this is not related to a JNDI bound <literal>Datasource</literal>, both simply use the same registry!"
msgstr "하나의 JNDI 바인드된 Hibernate <literal>SessionFactory</literal>는 그 팩토리에 대한 룩업과 새로운 <literal>Session</literal>들의 생성을 단순화 시킬 수 있다. 이것은 JNDI 바인드된 <literal>Datasource</literal>에 관련되어 있지 않고, 단순하게 둘 다 동일한 레지스트리를 사용한다는 점을 노트하라!"

#: index.docbook:1546
msgid "If you wish to have the <literal>SessionFactory</literal> bound to a JNDI namespace, specify a name (eg. <literal>java:hibernate/SessionFactory</literal>) using the property <literal>hibernate.session_factory_name</literal>. If this property is omitted, the <literal>SessionFactory</literal> will not be bound to JNDI. (This is especially useful in environments with a read-only JNDI default implementation, e.g. Tomcat.)"
msgstr "만일 당신이 <literal>SessionFactory</literal>를 하나의 JNDI namespace에 바인드 시키고자 원할 경우, <literal>hibernate.session_factory_name</literal> 프로퍼티를 사용하여 한 개의 이름(예를 들면. <literal>java:hibernate/SessionFactory</literal>)을 지정하라. 만일 이 프로퍼티가 생략될 경우, <literal>SessionFactory</literal>는 JNDI에 바인드 되지 않을 것이다. (이것은 읽기-전용 JNDI 디폴트 구현을 가진 환경들, 예를 들면 Tomcat에서 특히 유용하다.)"

#: index.docbook:1554
msgid "When binding the <literal>SessionFactory</literal> to JNDI, Hibernate will use the values of <literal>hibernate.jndi.url</literal>, <literal>hibernate.jndi.class</literal> to instantiate an initial context. If they are not specified, the default <literal>InitialContext</literal> will be used."
msgstr "<literal>SessionFactory</literal>를 JNDI에 바인드 시킬 때, Hibernate는 초기 컨텍스트를 초기화 시키기 위해 <literal>hibernate.jndi.url</literal>, <literal>hibernate.jndi.class</literal>의 값들을 사용할 것이다. 만일 그것들이 지정되어 있지 않을 경우, 디폴트 <literal>InitialContext</literal>가 사용될 것이다."

#: index.docbook:1561
msgid "Hibernate will automatically place the <literal>SessionFactory</literal> in JNDI after you call <literal>cfg.buildSessionFactory()</literal>. This means you will at least have this call in some startup code (or utility class) in your application, unless you use JMX deployment with the <literal>HibernateService</literal> (discussed later)."
msgstr "Hibernate는 당신이 <literal>cfg.buildSessionFactory()</literal>를 호출한 후에 <literal>SessionFactory</literal>를 JNDI 내에 자동적으로 위치지울 것이다. 이것은 당신이 (나중에 논의되는) <literal>HibernateService</literal>를 가진 JMX 배치를 사용하지 않는 한, 당신이 적어도 당신의 어플리케이션 내에 있는 어떤 시작 코드 (또는 유틸리티 클래스) 내에서 이것을 호출할 것임을 의미한다."

#: index.docbook:1568
msgid "If you use a JNDI <literal>SessionFactory</literal>, an EJB or any other class may obtain the <literal>SessionFactory</literal> using a JNDI lookup."
msgstr "만일 당신이 하나의 JNDI <literal>SessionFactory</literal>를 사용할 경우, 하나의 EJB 또는 어떤 다른 클래스는 JNDI 룩업을 사용하여 <literal>SessionFactory</literal>를 얻을 수 있다."

#: index.docbook:1573
msgid "We recommend that you bind the <literal>SessionFactory</literal> to JNDI in a managed environment and use a <literal>static</literal> singleton otherwise. To shield your application code from these details, we also recommend to hide the actual lookup code for a <literal>SessionFactory</literal> in a helper class, such as <literal>HibernateUtil.getSessionFactory()</literal>. Note that such a class is also a convenient way to startup Hibernate&mdash;see chapter 1."
msgstr "우리는 관리되는 환경들에서 <literal>SessionFactory</literal>를 JNDI에 바인드 시키고 그 밖의 경우에는 하나의 <literal>static</literal> 싱글톤을 사용하는 것을 권장한다. 이들 상세로부터 당신의 어플리케이션 코드를 은폐시키기 위해, 우리는 또한 <literal>HibernateUtil.getSessionFactory()</literal>과 같은 하나의 helper 클래스 내에서 <literal>SessionFactory</literal>에 대한 실제 룩업 코드를 은폐시키기를 권장한다. 그런 클래스는 또한 Hibernate를 시작하는 편리한 방법임을 노트하라&mdash; 1장을 보라."

#: index.docbook:1585
msgid "Current Session context management with JTA"
msgstr "Current Session context management with JTA"

#: index.docbook:1587
msgid "The easiest way to handle <literal>Session</literal>s and transactions is Hibernates automatic \"current\" <literal>Session</literal> management. See the discussion of <xref linkend=\"architecture-current-session\"/>current sessions. Using the <literal>\"jta\"</literal> session context, if there is no Hibernate <literal>Session</literal> associated with the current JTA transaction, one will be started and associated with that JTA transaction the first time you call <literal>sessionFactory.getCurrentSession()</literal>. The <literal>Session</literal>s retrieved via <literal>getCurrentSession()</literal> in <literal>\"jta\"</literal> context will be set to automatically flush before the transaction completes, close after the transaction completes, and aggressively release JDBC connections after each statement. This allows the <literal>Session</literal>s to be managed by the life cycle of the JTA transaction to which it is associated, keeping user code clean of such management concerns. Your code can either use JTA programmatically through <literal>UserTransaction</literal>, or (recommended for portable code) use the Hibernate <literal>Transaction</literal> API to set transaction boundaries. If you run in an EJB container, declarative transaction demarcation with CMT is preferred."
msgstr "당신 자신의 <literal>ThreadLocal</literal> 유틸리티를 작동시키는 대신에, 우리는 또한 Hibernate <literal>Session</literal>를 얻기 위해 <literal>SessionFactory</literal> 상의 <literal>getCurrentSession()</literal> 메소드 사용을 권장한다. <xref linkend=\"architecture-current-session\"/>현재 세션들에 관한 논의를 보라. <literal>\"jta\"</literal> 세션 컨텍스트를 사용하고 있는 경우에, 현재의 JTA 트랜잭션으로 시작되고 연관된 Hibernate <literal>Session</literal>이 존재하지 않을 경우, 우리는 JTA 트랜잭션으로 시작되고 연관될 것이다. <literal>\"jta\"</literal> 컨텍스트에서 <literal>getCurrentSession()</literal>를 통해 검색된 <literal>Session</literal>들은 그 트랜잭션이 완료되기 전에 자동적으로 flush될 것이고 트랜잭션 완료 후에 닫혀질 것이고, 그리고 각각의 문장 뒤에 JDBC 커넥션들을 적극적으로 해제할 것이다. 이것은 그런 관리 사항들에 대해 사용자 코드를 명료하게 유지시켜서, 연관되어 있는 JTA 트랜잭션의 생명주기에 의해 <literal>Session</literal>들이 관리되도록 허용해준다. 이것은 그런 관리 사항들에 대해 사용자 코드를 명료하게 유지시켜서, 세션이 연관되어 있는 JTA 트랜잭션의 생명주기에 의해 관리되는 것을 <literal>Session</literal>들에게 허용해준다. 당신의 코드는 <literal>Session</literal>들과 트랜잭션들을 처리하는 가장 손쉬운 방법은 Hibernate의 자동적인 \"현재\" <literal>Session</literal>이다. <xref linkend=\"architecture-current-session\"/>current sessions에 관한 논의를 보라. <literal>\"jta\"</literal> 세션 컨텍스트를 사용하는 경우, 현재의 JTA 트랜잭션으로 시작되고 연관된 Hibernate <literal>Session</literal>들이 존재하지 않을 경우, 당신이 <literal>sessionFactory.getCurrentSession()</literal>을 처음 호출할 때 하나의 세션이 현재의 JTA 트랜잭션에 대해 시작되고 연관될 것이다. <literal>\"jta\"</literal> 컨텍스트에서 <literal>getCurrentSession()</literal>을 통해 검색된 <literal>Session</literal>들은 그 트랜잭션이 완료되기 전에 자동적으로 flush될 것이고 그 트랜잭션 완료들 후에 닫혀질 것이고 각각의 문장 후에 JDBC 커넥션들을 적극적으로 해제할 것이다. 이것은 그런 관리 사항들에 대해 사용자 코드를 명료하게 유지시켜서, 연관되어 있는 JTA 트랜잭션의 생명주기에 의해 <literal>Session</literal>들이 관리되도록 허용해준다. 이것은 그런 관리 사항들에 대해 사용자 코드를 명료하게 유지시켜서, 세션이 연관되어 있는 JTA 트랜잭션의 생명주기에 의해 관리되는 것을 <literal>Session</literal>들에게 허용해준다. 당신의 코드는 트랜잭션 경계들을 설정하는데 <literal>UserTransaction</literal>을 통해 프로그램 상으로 JTA를 사용하거나, Hibernate <literal>Transaction</literal> API를 (이식성을 위한 코드로 권장됨) 사용할 수 있다. 만일 당신이 하나의 EJB 컨테이너에서 실행하고 있을 경우, CMT의 경우에 선언적인 트랜잭션 경계설정이 선호된다."

#: index.docbook:1610
msgid "JMX deployment"
msgstr "JMX 배치"

#: index.docbook:1612
msgid "The line <literal>cfg.buildSessionFactory()</literal> still has to be executed somewhere to get a <literal>SessionFactory</literal> into JNDI. You can do this either in a <literal>static</literal> initializer block (like the one in <literal>HibernateUtil</literal>) or you deploy Hibernate as a <emphasis>managed service</emphasis>."
msgstr "<literal>cfg.buildSessionFactory()</literal> 줄은 여전히 JNDI에 붙은 하나의 <literal>SessionFactory</literal>를 얻기 위해 어딘가에서 실행되어야 한다. 당신은 (<literal>HibernateUtil</literal> 내에 있는 것처럼) <literal>static</literal> initializer 블록 속에서 이것을 행할 수 있거나 당신은 Hibernate를 <emphasis>managed service</emphasis>로서 배치할 수 있다."

#: index.docbook:1620
msgid "Hibernate is distributed with <literal>org.hibernate.jmx.HibernateService</literal> for deployment on an application server with JMX capabilities, such as JBoss AS. The actual deployment and configuration is vendor specific. Here is an example <literal>jboss-service.xml</literal> for JBoss 4.0.x:"
msgstr "Hibernate는 JBoss AS와 같은 JMX 가용성들을 가진 어플리케이션 서버 상의 배치를 위해 <literal>org.hibernate.jmx.HibernateService</literal>를 배포하고 있다. 실제 배치와 구성은 벤더 지정적이다. 다음은 JBoss 4.0.x를 위한 <literal>jboss-service.xml</literal> 예제이다:"

#: index.docbook:1627
msgid ""
      "<![CDATA[<?xml version=\"1.0\"?>\n"
      "<server>\n"
      "\n"
      "<mbean code=\"org.hibernate.jmx.HibernateService\"\n"
      "    name=\"jboss.jca:service=HibernateFactory,name=HibernateFactory\">\n"
      "\n"
      "    <!-- Required services -->\n"
      "    <depends>jboss.jca:service=RARDeployer</depends>\n"
      "    <depends>jboss.jca:service=LocalTxCM,name=HsqlDS</depends>\n"
      "\n"
      "    <!-- Bind the Hibernate service to JNDI -->\n"
      "    <attribute name=\"JndiName\">java:/hibernate/SessionFactory</attribute>\n"
      "\n"
      "    <!-- Datasource settings -->\n"
      "    <attribute name=\"Datasource\">java:HsqlDS</attribute>\n"
      "    <attribute name=\"Dialect\">org.hibernate.dialect.HSQLDialect</attribute>\n"
      "\n"
      "    <!-- Transaction integration -->\n"
      "    <attribute name=\"TransactionStrategy\">\n"
      "        org.hibernate.transaction.JTATransactionFactory</attribute>\n"
      "    <attribute name=\"TransactionManagerLookupStrategy\">\n"
      "        org.hibernate.transaction.JBossTransactionManagerLookup</attribute>\n"
      "    <attribute name=\"FlushBeforeCompletionEnabled\">true</attribute>\n"
      "    <attribute name=\"AutoCloseSessionEnabled\">true</attribute>\n"
      "\n"
      "    <!-- Fetching options -->\n"
      "    <attribute name=\"MaximumFetchDepth\">5</attribute>\n"
      "\n"
      "    <!-- Second-level caching -->\n"
      "    <attribute name=\"SecondLevelCacheEnabled\">true</attribute>\n"
      "    <attribute name=\"CacheProviderClass\">org.hibernate.cache.EhCacheProvider</attribute>\n"
      "    <attribute name=\"QueryCacheEnabled\">true</attribute>\n"
      "\n"
      "    <!-- Logging -->\n"
      "    <attribute name=\"ShowSqlEnabled\">true</attribute>\n"
      "\n"
      "    <!-- Mapping files -->\n"
      "    <attribute name=\"MapResources\">auction/Item.hbm.xml,auction/Category.hbm.xml</attribute>\n"
      "\n"
      "</mbean>\n"
      "\n"
      "</server>]]>"
msgstr ""
      "<![CDATA[<?xml version=\"1.0\"?>\n"
      "<server>\n"
      "\n"
      "<mbean code=\"org.hibernate.jmx.HibernateService\"\n"
      "    name=\"jboss.jca:service=HibernateFactory,name=HibernateFactory\">\n"
      "\n"
      "    <!-- Required services -->\n"
      "    <depends>jboss.jca:service=RARDeployer</depends>\n"
      "    <depends>jboss.jca:service=LocalTxCM,name=HsqlDS</depends>\n"
      "\n"
      "    <!-- Bind the Hibernate service to JNDI -->\n"
      "    <attribute name=\"JndiName\">java:/hibernate/SessionFactory</attribute>\n"
      "\n"
      "    <!-- Datasource settings -->\n"
      "    <attribute name=\"Datasource\">java:HsqlDS</attribute>\n"
      "    <attribute name=\"Dialect\">org.hibernate.dialect.HSQLDialect</attribute>\n"
      "\n"
      "    <!-- Transaction integration -->\n"
      "    <attribute name=\"TransactionStrategy\">\n"
      "        org.hibernate.transaction.JTATransactionFactory</attribute>\n"
      "    <attribute name=\"TransactionManagerLookupStrategy\">\n"
      "        org.hibernate.transaction.JBossTransactionManagerLookup</attribute>\n"
      "    <attribute name=\"FlushBeforeCompletionEnabled\">true</attribute>\n"
      "    <attribute name=\"AutoCloseSessionEnabled\">true</attribute>\n"
      "\n"
      "    <!-- Fetching options -->\n"
      "    <attribute name=\"MaximumFetchDepth\">5</attribute>\n"
      "\n"
      "    <!-- Second-level caching -->\n"
      "    <attribute name=\"SecondLevelCacheEnabled\">true</attribute>\n"
      "    <attribute name=\"CacheProviderClass\">org.hibernate.cache.EhCacheProvider</attribute>\n"
      "    <attribute name=\"QueryCacheEnabled\">true</attribute>\n"
      "\n"
      "    <!-- Logging -->\n"
      "    <attribute name=\"ShowSqlEnabled\">true</attribute>\n"
      "\n"
      "    <!-- Mapping files -->\n"
      "    <attribute name=\"MapResources\">auction/Item.hbm.xml,auction/Category.hbm.xml</attribute>\n"
      "\n"
      "</mbean>\n"
      "\n"
      "</server>]]>"

#: index.docbook:1629
msgid "This file is deployed in a directory called <literal>META-INF</literal> and packaged in a JAR file with the extension <literal>.sar</literal> (service archive). You also need to package Hibernate, its required third-party libraries, your compiled persistent classes, as well as your mapping files in the same archive. Your enterprise beans (usually session beans) may be kept in their own JAR file, but you may include this EJB JAR file in the main service archive to get a single (hot-)deployable unit. Consult the JBoss AS documentation for more information about JMX service and EJB deployment."
msgstr "이 파일은 <literal>META-INF</literal>로 명명된 디렉토리 속에 배치되고 확장자 <literal>.sar</literal> (service archive)를 가진 한 개의 JAR 파일 속에 패키징된다. 당신은 또한 Hibernate, 그것의 필요한 제 3의 라이브러리들, 당신의 컴파일된 영속 클래스들 뿐만 아니라 당신의 매핑 파일들을 동일한 아카이브 속에 패키징할 필요가 있다. 당신의 엔터프라이즈 빈즈(대개 session beans)는 그것들 자신의 JAR 파일 속에 유지될 수 있지만, 당신은 한 개의 (hot-)배치 가능한 단위를 얻기 위해 메인 서비스 아카이브 속에 이 EJB JAR 파일을 포함시킬 수도 있다. JMX 서비스와 EJB 배치에 관한 추가 정보는 JBoss AS 문서를 참조하라."

msgid "ROLES_OF_TRANSLATORS"
msgstr "<!--TRANS:ROLES_OF_TRANSLATORS-->"

msgid "CREDIT_FOR_TRANSLATORS"
msgstr "<!--TRANS:CREDIT_FOR_TRANSLATORS-->"

