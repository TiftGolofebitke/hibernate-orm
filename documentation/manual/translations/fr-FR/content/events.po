#, fuzzy
msgid ""
msgstr ""
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Content-Type: text/plain; charset=utf-8\n"
#: index.docbook:5
msgid "Interceptors and events"
msgstr "Les intercepteurs et les événements"

#: index.docbook:7
msgid "It is often useful for the application to react to certain events that occur inside Hibernate. This allows implementation of certain kinds of generic functionality, and extension of Hibernate functionality."
msgstr "Il est souvent utile pour l'application de réagir à certains événements qui surviennent dans Hibernate. Cela autorise l'implémentation de certaines sortes de fonctionnalités génériques, et d'extensions de fonctionnalités d'Hibernate."

#: index.docbook:14
msgid "Interceptors"
msgstr "Intercepteurs"

#: index.docbook:16
msgid "The <literal>Interceptor</literal> interface provides callbacks from the session to the application allowing the application to inspect and/or manipulate properties of a persistent object before it is saved, updated, deleted or loaded. One possible use for this is to track auditing information. For example, the following <literal>Interceptor</literal> automatically sets the <literal>createTimestamp</literal> when an <literal>Auditable</literal> is created and updates the <literal>lastUpdateTimestamp</literal> property when an <literal>Auditable</literal> is updated."
msgstr "L'interface <literal>Interceptor</literal> fournit des \"callbacks\" de la session vers l'application et permettent à l'application de consulter et/ou de manipuler des propriétés d'un objet persistant avant qu'il soit sauvegardé, mis à jour, supprimé ou chargé. Une utilisation possible de cette fonctionnalité est de tracer l'accès à l'information. Par exemple, l'<literal>Interceptor</literal> suivant positionne <literal>createTimestamp</literal> quand un <literal>Auditable</literal> est créé et met à jour la propriété <literal>lastUpdateTimestamp</literal> quand un <literal>Auditable</literal> est mis à jour."

#: index.docbook:27
msgid "You may either implement <literal>Interceptor</literal> directly or (better) extend <literal>EmptyInterceptor</literal>."
msgstr "Vous pouvez soit implémenter <literal>Interceptor</literal> directement ou (mieux) étendre <literal>EmptyInterceptor</literal>."

#: index.docbook:32
msgid ""
      "<![CDATA[package org.hibernate.test;\n"
      "\n"
      "import java.io.Serializable;\n"
      "import java.util.Date;\n"
      "import java.util.Iterator;\n"
      "\n"
      "import org.hibernate.EmptyInterceptor;\n"
      "import org.hibernate.Transaction;\n"
      "import org.hibernate.type.Type;\n"
      "\n"
      "public class AuditInterceptor extends EmptyInterceptor {\n"
      "\n"
      "    private int updates;\n"
      "    private int creates;\n"
      "    private int loads;\n"
      "\n"
      "    public void onDelete(Object entity,\n"
      "                         Serializable id,\n"
      "                         Object[] state,\n"
      "                         String[] propertyNames,\n"
      "                         Type[] types) {\n"
      "        // do nothing\n"
      "    }\n"
      "\n"
      "    public boolean onFlushDirty(Object entity,\n"
      "                                Serializable id,\n"
      "                                Object[] currentState,\n"
      "                                Object[] previousState,\n"
      "                                String[] propertyNames,\n"
      "                                Type[] types) {\n"
      "\n"
      "        if ( entity instanceof Auditable ) {\n"
      "            updates++;\n"
      "            for ( int i=0; i < propertyNames.length; i++ ) {\n"
      "                if ( \"lastUpdateTimestamp\".equals( propertyNames[i] ) ) {\n"
      "                    currentState[i] = new Date();\n"
      "                    return true;\n"
      "                }\n"
      "            }\n"
      "        }\n"
      "        return false;\n"
      "    }\n"
      "\n"
      "    public boolean onLoad(Object entity,\n"
      "                          Serializable id,\n"
      "                          Object[] state,\n"
      "                          String[] propertyNames,\n"
      "                          Type[] types) {\n"
      "        if ( entity instanceof Auditable ) {\n"
      "            loads++;\n"
      "        }\n"
      "        return false;\n"
      "    }\n"
      "\n"
      "    public boolean onSave(Object entity,\n"
      "                          Serializable id,\n"
      "                          Object[] state,\n"
      "                          String[] propertyNames,\n"
      "                          Type[] types) {\n"
      "\n"
      "        if ( entity instanceof Auditable ) {\n"
      "            creates++;\n"
      "            for ( int i=0; i<propertyNames.length; i++ ) {\n"
      "                if ( \"createTimestamp\".equals( propertyNames[i] ) ) {\n"
      "                    state[i] = new Date();\n"
      "                    return true;\n"
      "                }\n"
      "            }\n"
      "        }\n"
      "        return false;\n"
      "    }\n"
      "\n"
      "    public void afterTransactionCompletion(Transaction tx) {\n"
      "        if ( tx.wasCommitted() ) {\n"
      "            System.out.println(\"Creations: \" + creates + \", Updates: \" + updates, \"Loads: \" + loads);\n"
      "        }\n"
      "        updates=0;\n"
      "        creates=0;\n"
      "        loads=0;\n"
      "    }\n"
      "\n"
      "}]]>"
msgstr ""
      "<![CDATA[package org.hibernate.test;\n"
      "\n"
      "import java.io.Serializable;\n"
      "import java.util.Date;\n"
      "import java.util.Iterator;\n"
      "\n"
      "import org.hibernate.EmptyInterceptor;\n"
      "import org.hibernate.Transaction;\n"
      "import org.hibernate.type.Type;\n"
      "\n"
      "public class AuditInterceptor extends EmptyInterceptor {\n"
      "\n"
      "    private int updates;\n"
      "    private int creates;\n"
      "    private int loads;\n"
      "\n"
      "    public void onDelete(Object entity,\n"
      "                         Serializable id,\n"
      "                         Object[] state,\n"
      "                         String[] propertyNames,\n"
      "                         Type[] types) {\n"
      "        // ne fait rien\n"
      "    }\n"
      "\n"
      "    public boolean onFlushDirty(Object entity,\n"
      "                                Serializable id,\n"
      "                                Object[] currentState,\n"
      "                                Object[] previousState,\n"
      "                                String[] propertyNames,\n"
      "                                Type[] types) {\n"
      "\n"
      "        if ( entity instanceof Auditable ) {\n"
      "            updates++;\n"
      "            for ( int i=0; i < propertyNames.length; i++ ) {\n"
      "                if ( \"lastUpdateTimestamp\".equals( propertyNames[i] ) ) {\n"
      "                    currentState[i] = new Date();\n"
      "                    return true;\n"
      "                }\n"
      "            }\n"
      "        }\n"
      "        return false;\n"
      "    }\n"
      "\n"
      "    public boolean onLoad(Object entity,\n"
      "                          Serializable id,\n"
      "                          Object[] state,\n"
      "                          String[] propertyNames,\n"
      "                          Type[] types) {\n"
      "        if ( entity instanceof Auditable ) {\n"
      "            loads++;\n"
      "        }\n"
      "        return false;\n"
      "    }\n"
      "\n"
      "    public boolean onSave(Object entity,\n"
      "                          Serializable id,\n"
      "                          Object[] state,\n"
      "                          String[] propertyNames,\n"
      "                          Type[] types) {\n"
      "\n"
      "        if ( entity instanceof Auditable ) {\n"
      "            creates++;\n"
      "            for ( int i=0; i<propertyNames.length; i++ ) {\n"
      "                if ( \"createTimestamp\".equals( propertyNames[i] ) ) {\n"
      "                    state[i] = new Date();\n"
      "                    return true;\n"
      "                }\n"
      "            }\n"
      "        }\n"
      "        return false;\n"
      "    }\n"
      "\n"
      "    public void postFlush(Iterator entities) {\n"
      "        System.out.println(\"Creations: \" + creates + \", Updates: \" + updates);\n"
      "    }\n"
      "\n"
      "    public void afterTransactionCompletion(Transaction tx) {\n"
      "        if ( tx.wasCommitted() ) {\n"
      "            System.out.println(\"Creations: \" + creates + \", Updates: \" + updates, \"Loads: \" + loads);\n"
      "        }\n"
      "        updates=0;\n"
      "        creates=0;\n"
      "        loads=0;\n"
      "    }\n"
      "\n"
      "}]]>"

#: index.docbook:34
msgid "Interceptors come in two flavors: <literal>Session</literal>-scoped and <literal>SessionFactory</literal>-scoped."
msgstr "L'intercepteur doit être spécifié quand une session est créée."

#: index.docbook:39
msgid "A <literal>Session</literal>-scoped interceptor is specified when a session is opened using one of the overloaded SessionFactory.openSession() methods accepting an <literal>Interceptor</literal>."
msgstr "<![CDATA[Session session = sf.openSession( new AuditInterceptor() );]]>"

#: index.docbook:45
msgid "<![CDATA[Session session = sf.openSession( new AuditInterceptor() );]]>"
msgstr "Vous pouvez aussi mettre un intercepteur au niveau global, en utilisant l'objet <literal>Configuration</literal>. Dans ce cas, l'intercepteur doit être \"threadsafe\"."

#: index.docbook:47
msgid "A <literal>SessionFactory</literal>-scoped interceptor is registered with the <literal>Configuration</literal> object prior to building the <literal>SessionFactory</literal>. In this case, the supplied interceptor will be applied to all sessions opened from that <literal>SessionFactory</literal>; this is true unless a session is opened explicitly specifying the interceptor to use. <literal>SessionFactory</literal>-scoped interceptors must be thread safe, taking care to not store session-specific state since multiple sessions will use this interceptor (potentially) concurrently."
msgstr "<![CDATA[new Configuration().setInterceptor( new AuditInterceptor() );]]>"

#: index.docbook:56
msgid "<![CDATA[new Configuration().setInterceptor( new AuditInterceptor() );]]>"
msgstr "Système d'événements"

#: index.docbook:61
msgid "Event system"
msgstr "Si vous devez réagir à des événements particuliers dans votre couche de persistance, vous pouvez aussi utiliser l'architecture d'<emphasis>événements</emphasis> d'Hibernate3. Le système d'événements peut être utilisé en supplément ou en remplacement des interceptors."

#: index.docbook:63
msgid "If you have to react to particular events in your persistence layer, you may also use the Hibernate3 <emphasis>event</emphasis> architecture. The event system can be used in addition or as a replacement for interceptors."
msgstr "Essentiellement toutes les méthodes de l'interface <literal>Session</literal> sont corrélées à un événement. Vous avez un <literal>LoadEvent</literal>, un <literal>FlushEvent</literal>, etc (consultez la DTD du fichier de configuration XML ou le paquet <literal>org.hibernate.event</literal> pour avoir la liste complète des types d'événement définis). Quand une requête est faite à partir d'une de ces méthodes, la <literal>Session</literal> Hibernate génère un événement approprié et le passe au listener configuré pour ce type. Par défaut, ces listeners implémentent le même traitement dans lequel ces méthodes aboutissent toujours. Cependant, vous êtes libre d'implémenter une version personnalisée d'une de ces interfaces de listener (c'est-à-dire, le <literal>LoadEvent</literal> est traité par l'implémentation de l'interface <literal>LoadEventListener</literal> déclarée), dans quel cas leur implémentation devrait être responsable du traitement des requêtes <literal>load()</literal> faites par la <literal>Session</literal>."

#: index.docbook:69
msgid "Essentially all of the methods of the <literal>Session</literal> interface correlate to an event. You have a <literal>LoadEvent</literal>, a <literal>FlushEvent</literal>, etc (consult the XML configuration-file DTD or the <literal>org.hibernate.event</literal> package for the full list of defined event types). When a request is made of one of these methods, the Hibernate <literal>Session</literal> generates an appropriate event and passes it to the configured event listeners for that type. Out-of-the-box, these listeners implement the same processing in which those methods always resulted. However, you are free to implement a customization of one of the listener interfaces (i.e., the <literal>LoadEvent</literal> is processed by the registered implemenation of the <literal>LoadEventListener</literal> interface), in which case their implementation would be responsible for processing any <literal>load()</literal> requests made of the <literal>Session</literal>."
msgstr "Les listeners devraient effectivement être considérés comme des singletons ; dans le sens où ils sont partagés entre des requêtes, et donc ne devraient pas sauvegarder des états de variables d'instance."

#: index.docbook:84
msgid "The listeners should be considered effectively singletons; meaning, they are shared between requests, and thus should not save any state as instance variables."
msgstr "Un listener personnalisé devrait implémenter l'interface appropriée pour l'événement qu'il veut traiter et/ou étendre une des classes de base (ou même l'événement prêt à l'emploi utilisé par Hibernate comme ceux déclarés non-finaux à cette intention). Les listeners personnalisés peuvent être soit inscrits par programmation à travers l'objet <literal>Configuration</literal>, ou spécifiés la configuration XML d'Hibernate (la configuration déclarative à travers le fichier de propriétés n'est pas supportée). Voici un exemple de listener personnalisé pour l'événement de chargement :"

#: index.docbook:89
msgid "A custom listener should implement the appropriate interface for the event it wants to process and/or extend one of the convenience base classes (or even the default event listeners used by Hibernate out-of-the-box as these are declared non-final for this purpose). Custom listeners can either be registered programmatically through the <literal>Configuration</literal> object, or specified in the Hibernate configuration XML (declarative configuration through the properties file is not supported). Here's an example of a custom load event listener:"
msgstr ""
      "<![CDATA[public class MyLoadListener implements LoadEventListener {\n"
      "    // C'est une simple méthode définie par l'interface LoadEventListener\n"
      "    public void onLoad(LoadEvent event, LoadEventListener.LoadType loadType)\n"
      "            throws HibernateException {\n"
      "        if ( !MySecurity.isAuthorized( event.getEntityClassName(), event.getEntityId() ) ) {\n"
      "            throw MySecurityException(\"Unauthorized access\");\n"
      "        }\n"
      "    }\n"
      "}]]>"

#: index.docbook:99
msgid ""
      "<![CDATA[public class MyLoadListener implements LoadEventListener {\n"
      "    // this is the single method defined by the LoadEventListener interface\n"
      "    public void onLoad(LoadEvent event, LoadEventListener.LoadType loadType)\n"
      "            throws HibernateException {\n"
      "        if ( !MySecurity.isAuthorized( event.getEntityClassName(), event.getEntityId() ) ) {\n"
      "            throw MySecurityException(\"Unauthorized access\");\n"
      "        }\n"
      "    }\n"
      "}]]>"
msgstr "Vous avez aussi besoin d'une entrée de configuration disant à Hibernate d'utiliser ce listener en plus du listener par défaut :"

#: index.docbook:101
msgid "You also need a configuration entry telling Hibernate to use the listener in addition to the default listener:"
msgstr ""
      "<![CDATA[<hibernate-configuration>\n"
      "    <session-factory>\n"
      "        ...\n"
      "        <event type=\"load\">\n"
      "            <listener class=\"com.eg.MyLoadListener\"/>\n"
      "            <listener class=\"org.hibernate.event.def.DefaultLoadEventListener\"/>\n"
      "        </event>\n"
      "    </session-factory>\n"
      "</hibernate-configuration>]]>"

#: index.docbook:106
msgid ""
      "<![CDATA[<hibernate-configuration>\n"
      "    <session-factory>\n"
      "        ...\n"
      "        <event type=\"load\">\n"
      "            <listener class=\"com.eg.MyLoadListener\"/>\n"
      "            <listener class=\"org.hibernate.event.def.DefaultLoadEventListener\"/>\n"
      "        </event>\n"
      "    </session-factory>\n"
      "</hibernate-configuration>]]>"
msgstr "Vous pouvez aussi l'inscrire par programmation :"

#: index.docbook:108
msgid "Instead, you may register it programmatically:"
msgstr ""
      "<![CDATA[Configuration cfg = new Configuration();\n"
      "LoadEventListener[] stack = { new MyLoadListener(), new DefaultLoadEventListener() };\n"
      "cfg.EventListeners().setLoadEventListeners(stack);]]>"

#: index.docbook:112
msgid ""
      "<![CDATA[Configuration cfg = new Configuration();\n"
      "LoadEventListener[] stack = { new MyLoadListener(), new DefaultLoadEventListener() };\n"
      "cfg.EventListeners().setLoadEventListeners(stack);]]>"
msgstr "Les listeners inscrits déclarativement ne peuvent pas partager d'instances. Si le même nom de classe est utilisée dans plusieurs éléments <literal>&lt;listener/&gt;</literal>, chaque référence sera une instance distincte de cette classe. Si vous avez besoin de la faculté de partager des instances de listener entre plusieurs types de listener, vous devez utiliser l'approche d'inscription par programmation."

#: index.docbook:114
msgid "Listeners registered declaratively cannot share instances. If the same class name is used in multiple <literal>&lt;listener/&gt;</literal> elements, each reference will result in a separate instance of that class. If you need the capability to share listener instances between listener types you must use the programmatic registration approach."
msgstr "Pourquoi implémenter une interface et définir le type spécifique durant la configuration ? Une implémentation de listener pourrait implémenter plusieurs interfaces de listener d'événements. Avoir en plus le type défini durant l'inscription rend plus facile l'activation ou la désactivation pendant la configuration."

#: index.docbook:122
msgid "Why implement an interface and define the specific type during configuration? Well, a listener implementation could implement multiple event listener interfaces. Having the type additionally defined during registration makes it easier to turn custom listeners on or off during configuration."
msgstr "Sécurité déclarative d'Hibernate"

#: index.docbook:132
msgid "Hibernate declarative security"
msgstr "Généralement, la sécurité déclarative dans les applications Hibernate est gérée dans la couche de session. Maintenant, Hibernate3 permet à certaines actions d'être approuvées via JACC, et autorisées via JAAS. Cette fonctionnalité optionnelle est construite au dessus de l'architecture d'événements."

#: index.docbook:133
msgid "Usually, declarative security in Hibernate applications is managed in a session facade layer. Now, Hibernate3 allows certain actions to be permissioned via JACC, and authorized via JAAS. This is optional functionality built on top of the event architecture."
msgstr "D'abord, vous devez configurer les listeners d'événements appropriés pour permettre l'utilisation d'autorisations JAAS."

#: index.docbook:139
msgid "First, you must configure the appropriate event listeners, to enable the use of JAAS authorization."
msgstr ""
      "<![CDATA[<listener type=\"pre-delete\" class=\"org.hibernate.secure.JACCPreDeleteEventListener\"/>\n"
      "<listener type=\"pre-update\" class=\"org.hibernate.secure.JACCPreUpdateEventListener\"/>\n"
      "<listener type=\"pre-insert\" class=\"org.hibernate.secure.JACCPreInsertEventListener\"/>\n"
      "<listener type=\"pre-load\" class=\"org.hibernate.secure.JACCPreLoadEventListener\"/>]]>"

#: index.docbook:144
msgid ""
      "<![CDATA[<listener type=\"pre-delete\" class=\"org.hibernate.secure.JACCPreDeleteEventListener\"/>\n"
      "<listener type=\"pre-update\" class=\"org.hibernate.secure.JACCPreUpdateEventListener\"/>\n"
      "<listener type=\"pre-insert\" class=\"org.hibernate.secure.JACCPreInsertEventListener\"/>\n"
      "<listener type=\"pre-load\" class=\"org.hibernate.secure.JACCPreLoadEventListener\"/>]]>"
msgstr "Notez que <literal>&lt;listener type=\"...\" class=\"...\"/&gt;</literal> est juste un raccourci pour <literal>&lt;event type=\"...\"&gt;&lt;listener class=\"...\"/&gt;&lt;/event&gt;</literal> quand il y a exactement un listener pour un type d'événement particulier."

#: index.docbook:146
msgid "Note that <literal>&lt;listener type=\"...\" class=\"...\"/&gt;</literal> is just a shorthand for <literal>&lt;event type=\"...\"&gt;&lt;listener class=\"...\"/&gt;&lt;/event&gt;</literal> when there is exactly one listener for a particular event type."
msgstr "Ensuite, toujours dans <literal>hibernate.cfg.xml</literal>, lier les permissions aux rôles :"

#: index.docbook:152
msgid "Next, still in <literal>hibernate.cfg.xml</literal>, bind the permissions to roles:"
msgstr ""
      "<![CDATA[<grant role=\"admin\" entity-name=\"User\" actions=\"insert,update,read\"/>\n"
      "<grant role=\"su\" entity-name=\"User\" actions=\"*\"/>]]>"

#: index.docbook:156
msgid ""
      "<![CDATA[<grant role=\"admin\" entity-name=\"User\" actions=\"insert,update,read\"/>\n"
      "<grant role=\"su\" entity-name=\"User\" actions=\"*\"/>]]>"
msgstr "Les noms de rôle sont les rôles compris par votre fournisseur JAAC."

#: index.docbook:158
msgid "The role names are the roles understood by your JACC provider."
msgstr ""

msgid "ROLES_OF_TRANSLATORS"
msgstr "<!--TRANS:ROLES_OF_TRANSLATORS-->"

msgid "CREDIT_FOR_TRANSLATORS"
msgstr "<!--TRANS:CREDIT_FOR_TRANSLATORS-->"

