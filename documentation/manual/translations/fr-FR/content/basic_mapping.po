#, fuzzy
msgid ""
msgstr ""
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Content-Type: text/plain; charset=utf-8\n"
#: index.docbook:5
msgid "Basic O/R Mapping"
msgstr "Mapping O/R basique"

#: index.docbook:8
msgid "Mapping declaration"
msgstr "Déclaration de Mapping"

#: index.docbook:10
msgid "Object/relational mappings are usually defined in an XML document. The mapping document is designed to be readable and hand-editable. The mapping language is Java-centric, meaning that mappings are constructed around persistent class declarations, not table declarations."
msgstr "Les mappings Objet/relationnel sont généralement définis dans un document XML. Le document de mapping est conçu pour être lisible et éditable à la main. Le langage de mapping est Java-centrique, c'est à dire que les mappings sont construits à partir des déclarations des classes persistantes et non des déclarations des tables."

#: index.docbook:17
msgid "Note that, even though many Hibernate users choose to write the XML by hand, a number of tools exist to generate the mapping document, including XDoclet, Middlegen and AndroMDA."
msgstr "Remarquez que même si beaucoup d'utilisateurs de Hibernate préfèrent écrire les fichiers de mappings à la main, plusieurs outils existent pour générer ce document, notamment XDoclet, Middlegen et AndroMDA."

#: index.docbook:23
msgid "Lets kick off with an example mapping:"
msgstr "Démarrons avec un exemple de mapping :"

#: index.docbook:27
msgid ""
      "<![CDATA[<?xml version=\"1.0\"?>\n"
      "<!DOCTYPE hibernate-mapping PUBLIC\n"
      "      \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
      "          \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\">\n"
      "\n"
      "<hibernate-mapping package=\"eg\">\n"
      "\n"
      "        <class name=\"Cat\"\n"
      "            table=\"cats\"\n"
      "            discriminator-value=\"C\">\n"
      "\n"
      "                <id name=\"id\">\n"
      "                        <generator class=\"native\"/>\n"
      "                </id>\n"
      "\n"
      "                <discriminator column=\"subclass\"\n"
      "                     type=\"character\"/>\n"
      "\n"
      "                <property name=\"weight\"/>\n"
      "\n"
      "                <property name=\"birthdate\"\n"
      "                    type=\"date\"\n"
      "                    not-null=\"true\"\n"
      "                    update=\"false\"/>\n"
      "\n"
      "                <property name=\"color\"\n"
      "                    type=\"eg.types.ColorUserType\"\n"
      "                    not-null=\"true\"\n"
      "                    update=\"false\"/>\n"
      "\n"
      "                <property name=\"sex\"\n"
      "                    not-null=\"true\"\n"
      "                    update=\"false\"/>\n"
      "\n"
      "                <property name=\"litterId\"\n"
      "                    column=\"litterId\"\n"
      "                    update=\"false\"/>\n"
      "\n"
      "                <many-to-one name=\"mother\"\n"
      "                    column=\"mother_id\"\n"
      "                    update=\"false\"/>\n"
      "\n"
      "                <set name=\"kittens\"\n"
      "                    inverse=\"true\"\n"
      "                    order-by=\"litter_id\">\n"
      "                        <key column=\"mother_id\"/>\n"
      "                        <one-to-many class=\"Cat\"/>\n"
      "                </set>\n"
      "\n"
      "                <subclass name=\"DomesticCat\"\n"
      "                    discriminator-value=\"D\">\n"
      "\n"
      "                        <property name=\"name\"\n"
      "                            type=\"string\"/>\n"
      "\n"
      "                </subclass>\n"
      "\n"
      "        </class>\n"
      "\n"
      "        <class name=\"Dog\">\n"
      "                <!-- mapping for Dog could go here -->\n"
      "        </class>\n"
      "\n"
      "</hibernate-mapping>]]>"
msgstr ""
      "<![CDATA[<?xml version=\"1.0\"?>\n"
      "<!DOCTYPE hibernate-mapping PUBLIC\n"
      "      \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
      "          \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\">\n"
      "\n"
      "<hibernate-mapping package=\"eg\">\n"
      "\n"
      "        <class name=\"Cat\" \n"
      "            table=\"cats\"\n"
      "            discriminator-value=\"C\">\n"
      "                \n"
      "                <id name=\"id\">\n"
      "                        <generator class=\"native\"/>\n"
      "                </id>\n"
      "\n"
      "                <discriminator column=\"subclass\" \n"
      "                     type=\"character\"/>\n"
      "\n"
      "                <property name=\"weight\"/>\n"
      "\n"
      "                <property name=\"birthdate\"\n"
      "                    type=\"date\" \n"
      "                    not-null=\"true\" \n"
      "                    update=\"false\"/>\n"
      "\n"
      "                <property name=\"color\"\n"
      "                    type=\"eg.types.ColorUserType\"\n"
      "                    not-null=\"true\"\n"
      "                    update=\"false\"/>\n"
      "\n"
      "                <property name=\"sex\"\n"
      "                    not-null=\"true\" \n"
      "                    update=\"false\"/>\n"
      "\n"
      "                <property name=\"litterId\"\n"
      "                    column=\"litterId\"\n"
      "                    update=\"false\"/>\n"
      "\n"
      "                <many-to-one name=\"mother\"\n"
      "                    column=\"mother_id\"\n"
      "                    update=\"false\"/>\n"
      "\n"
      "                <set name=\"kittens\"\n"
      "                    inverse=\"true\"\n"
      "                    order-by=\"litter_id\">\n"
      "                        <key column=\"mother_id\"/>\n"
      "                        <one-to-many class=\"Cat\"/>\n"
      "                </set>\n"
      "\n"
      "                <subclass name=\"DomesticCat\"\n"
      "                    discriminator-value=\"D\">\n"
      "\n"
      "                        <property name=\"name\" \n"
      "                            type=\"string\"/>\n"
      "\n"
      "                </subclass>\n"
      "\n"
      "        </class>\n"
      "\n"
      "        <class name=\"Dog\">\n"
      "                <!-- mapping for Dog could go here -->\n"
      "        </class>\n"
      "\n"
      "</hibernate-mapping>]]>"

#: index.docbook:29
msgid "We will now discuss the content of the mapping document. We will only describe the document elements and attributes that are used by Hibernate at runtime. The mapping document also contains some extra optional attributes and elements that affect the database schemas exported by the schema export tool. (For example the <literal> not-null</literal> attribute.)"
msgstr "Etudions le contenu du document de mapping. Nous décrirons uniquement les éléments et attributs du document utilisés par Hibernate à l'exécution. Le document de mapping contient aussi des attributs et éléments optionnels qui agissent sur le schéma de base de données exporté par l'outil de génération de schéma. (Par exemple l'attribut <literal>not-null</literal>.)"

#: index.docbook:40
msgid "Doctype"
msgstr "Doctype"

#: index.docbook:42
msgid "All XML mappings should declare the doctype shown. The actual DTD may be found at the URL above, in the directory <literal>hibernate-x.x.x/src/org/hibernate </literal> or in <literal>hibernate3.jar</literal>. Hibernate will always look for the DTD in its classpath first. If you experience lookups of the DTD using an Internet connection, check your DTD declaration against the contents of your claspath."
msgstr "Tous les mappings XML devraient utiliser le doctype indiqué. Ce fichier est présent à l'URL ci-dessus, dans le répertoire <literal>hibernate-x.x.x/src/org/hibernate</literal> ou dans <literal>hibernate3.jar</literal>. Hibernate va toujours chercher la DTD dans son classpath en premier lieu. Si vous constatez des recherches de la DTD sur Internet, vérifiez votre déclaration de DTD par rapport au contenu de votre classpath."

#: index.docbook:52
msgid "EntityResolver"
msgstr "hibernate-mapping"

#: index.docbook:53
msgid "As mentioned previously, Hibernate will first attempt to resolve DTDs in its classpath. The manner in which it does this is by registering a custom <literal>org.xml.sax.EntityResolver</literal> implementation with the SAXReader it uses to read in the xml files. This custom <literal>EntityResolver</literal> recognizes two different systemId namespaces."
msgstr "Cet élément a plusieurs attributs optionnels. Les attributs <literal>schema</literal> et <literal>catalog</literal> indiquent que les tables référencées par ce mapping appartiennent au schéma nommé et/ou au catalogue. S'ils sont spécifiés, les noms de tables seront qualifiés par les noms de schéma et catalogue. L'attribut <literal>default-cascade</literal> indique quel type de cascade sera utlisé par défaut pour les propriétés et collections qui ne précisent pas l'attribut <literal>cascade</literal>. L'attribut <literal>auto-import</literal> nous permet d'utiliser par défaut des noms de classes non qualifiés dans le langage de requête."

#: index.docbook:61
msgid "a <literal>hibernate namespace</literal> is recognized whenever the resolver encounteres a systemId starting with <literal>http://hibernate.sourceforge.net/</literal>; the resolver attempts to resolve these entities via the classlaoder which loaded the Hibernate classes."
msgstr ""
      "<![CDATA[<hibernate-mapping\n"
      "         schema=\"schemaName\"\n"
      "         catalog=\"catalogName\"\n"
      "         default-cascade=\"cascade_style\"\n"
      "         default-access=\"field|property|ClassName\"\n"
      "         default-lazy=\"true|false\"\n"
      "         auto-import=\"true|false\"\n"
      "         package=\"package.name\"\n"
      " />]]>"

#: index.docbook:70
msgid "a <literal>user namespace</literal> is recognized whenever the resolver encounteres a systemId using a <literal>classpath://</literal> URL protocol; the resolver will attempt to resolve these entities via (1) the current thread context classloader and (2) the classloader which loaded the Hibernate classes."
msgstr "<literal>schema</literal> (optionnel) : Le nom d'un schéma de base de données."

#: index.docbook:79
msgid "An example of utilizing user namespacing:"
msgstr "<literal>catalog</literal> (optionnel) : Le nom d'un catalogue de base de données."

#: index.docbook:82
msgid ""
      "<![CDATA[<?xml version=\"1.0\"?>\n"
      "<!DOCTYPE hibernate-mapping PUBLIC\n"
      "        \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
      "        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\" [\n"
      "    <!ENTITY types SYSTEM \"classpath://your/domain/types.xml\">\n"
      "]>\n"
      "\n"
      "<hibernate-mapping package=\"your.domain\">\n"
      "    <class name=\"MyEntity\">\n"
      "        <id name=\"id\" type=\"my-custom-id-type\">\n"
      "            ...\n"
      "        </id>\n"
      "    <class>\n"
      "    &types;\n"
      "</hibernate-mapping>]]>"
msgstr "<literal>default-cascade</literal> (optionnel - par défaut vaut : <literal>none</literal>) : Un type de cascade par défaut."

#: index.docbook:83
msgid "Where <literal>types.xml</literal> is a resource in the <literal>your.domain</literal> package and contains a custom <xref linkend=\"mapping-types-custom\"/>typedef."
msgstr "<literal>default-access</literal> (optionnel - par défaut vaut : <literal>property</literal>) : Comment hibernate accèdera aux propriétés. On peut aussi redéfinir sa propre implémentation de <literal>PropertyAccessor</literal>."

#: index.docbook:91
msgid "hibernate-mapping"
msgstr "<literal>default-lazy</literal> (optionnel - par défaut vaut : <literal>true</literal>) : Valeur par défaut pour un attribut <literal>lazy</literal> non spécifié : celui des mappings de classes et de collection."

#: index.docbook:93
msgid "This element has several optional attributes. The <literal>schema</literal> and <literal>catalog</literal> attributes specify that tables referred to in this mapping belong to the named schema and/or catalog. If specified, tablenames will be qualified by the given schema and catalog names. If missing, tablenames will be unqualified. The <literal>default-cascade</literal> attribute specifies what cascade style should be assumed for properties and collections which do not specify a <literal>cascade</literal> attribute. The <literal>auto-import</literal> attribute lets us use unqualified class names in the query language, by default."
msgstr "<literal>auto-import</literal> (optionnel - par défaut vaut : <literal>true</literal>) : Spécifie si l'on peut utiliser des noms de classes non qualifiés (des classes de ce mapping) dans le langage de requête."

#: index.docbook:114
msgid ""
      "<![CDATA[<hibernate-mapping\n"
      "         schema=\"schemaName\"\n"
      "         catalog=\"catalogName\"\n"
      "         default-cascade=\"cascade_style\"\n"
      "         default-access=\"field|property|ClassName\"\n"
      "         default-lazy=\"true|false\"\n"
      "         auto-import=\"true|false\"\n"
      "         package=\"package.name\"\n"
      " />]]>"
msgstr "<literal>package</literal> (optionnel) : Préfixe de package par défaut pour les noms de classe non qualifiés du document de mapping."

#: index.docbook:117
msgid "<literal>schema</literal> (optional): The name of a database schema."
msgstr "Si deux classes possèdent le même nom de classe (non qualifié), vous devez indiquer <literal>auto-import=\"false\"</literal>. Hibernate lancera une exception si vous essayez d'assigner à deux classes le même nom importé."

#: index.docbook:122
msgid "<literal>catalog</literal> (optional): The name of a database catalog."
msgstr "Notez que l'élément <literal>hibernate-mapping</literal> vous permet d'imbriquer plusieurs mappings de <literal>&lt;class&gt;</literal> persistantes, comme dans l'exemple ci-dessus. Cependant la bonne pratique (ce qui est attendu par certains outils) est de mapper une seule classe (ou une seule hiérarchie de classes) par fichier de mapping et de nommer ce fichier d'après le nom de la superclasse, par exemple <literal>Cat.hbm.xml</literal>, <literal>Dog.hbm.xml</literal>, ou en cas d'héritage, <literal>Animal.hbm.xml</literal>."

#: index.docbook:127
msgid "<literal>default-cascade</literal> (optional - defaults to <literal>none</literal>): A default cascade style."
msgstr "<title>class</title>"

#: index.docbook:133
msgid "<literal>default-access</literal> (optional - defaults to <literal>property</literal>): The strategy Hibernate should use for accessing all properties. Can be a custom implementation of <literal>PropertyAccessor</literal>."
msgstr "Déclarez une classe persistante avec l'élément <literal>class</literal> :"

#: index.docbook:140
msgid "<literal>default-lazy</literal> (optional - defaults to <literal>true</literal>): The default value for unspecifed <literal>lazy</literal> attributes of class and collection mappings."
msgstr ""
      "<![CDATA[<class\n"
      "        name=\"ClassName\"\n"
      "        table=\"tableName\"\n"
      "        discriminator-value=\"discriminator_value\"\n"
      "        mutable=\"true|false\"\n"
      "        schema=\"owner\"\n"
      "        catalog=\"catalog\"\n"
      "        proxy=\"ProxyInterface\"\n"
      "        dynamic-update=\"true|false\"\n"
      "        dynamic-insert=\"true|false\"\n"
      "        select-before-update=\"true|false\"\n"
      "        polymorphism=\"implicit|explicit\"\n"
      "        where=\"arbitrary sql where condition\"\n"
      "        persister=\"PersisterClass\"\n"
      "        batch-size=\"N\"\n"
      "        optimistic-lock=\"none|version|dirty|all\"\n"
      "        lazy=\"true|false\"\n"
      "        entity-name=\"EntityName\"\n"
      "        catalog=\"catalog\"\n"
      "        check=\"arbitrary sql check condition\"\n"
      "        rowid=\"rowid\"\n"
      "        subselect=\"SQL expression\"\n"
      "        abstract=\"true|false\"\n"
      "        entity-name=\"EntityName\"\n"
      "/>]]>"

#: index.docbook:147
msgid "<literal>auto-import</literal> (optional - defaults to <literal>true</literal>): Specifies whether we can use unqualified class names (of classes in this mapping) in the query language."
msgstr "<literal>name</literal> (optionnel) : Le nom Java complet de la classe (ou interface) persistante. Si cet attribut est absent, il est supposé que ce mapping ne se rapporte pas à une entité POJO."

#: index.docbook:154
msgid "<literal>package</literal> (optional): Specifies a package prefix to assume for unqualified class names in the mapping document."
msgstr "<literal>table</literal> (optionnel - par défaut le nom (non-qualifié) de la classe) : Le nom de sa table en base de données."

#: index.docbook:162
msgid "If you have two persistent classes with the same (unqualified) name, you should set <literal>auto-import=\"false\"</literal>. Hibernate will throw an exception if you attempt to assign two classes to the same \"imported\" name."
msgstr "<literal>discriminator-value</literal> (optionnel - par défaut le nom de la classe) : Une valeur permettant de distinguer les sous-classes dans le cas de l'utilisation du polymorphisme. Les valeurs <literal>null</literal> et <literal>not null</literal> sont autorisées."

#: index.docbook:168
msgid "Note that the <literal>hibernate-mapping</literal> element allows you to nest several persistent <literal>&lt;class&gt;</literal> mappings, as shown above. It is however good practice (and expected by some tools) to map only a single persistent class (or a single class hierarchy) in one mapping file and name it after the persistent superclass, e.g. <literal>Cat.hbm.xml</literal>, <literal>Dog.hbm.xml</literal>, or if using inheritance, <literal>Animal.hbm.xml</literal>."
msgstr "<literal>mutable</literal> (optionnel, vaut <literal>true</literal> par défaut) : Spécifie que des instances de la classe sont (ou non) immuables."

#: index.docbook:181
msgid "<title>class</title>"
msgstr "<literal>schema</literal> (optionnel) : Surcharge le nom de schéma spécifié par l'élément racine <literal>&lt;hibernate-mapping&gt;</literal>."

#: index.docbook:183
msgid "You may declare a persistent class using the <literal>class</literal> element:"
msgstr "<literal>catalog</literal> (optionnel) : Surcharge le nom du catalogue spécifié par l'élément racine <literal>&lt;hibernate-mapping&gt;</literal>."

#: index.docbook:211
msgid ""
      "<![CDATA[<class\n"
      "        name=\"ClassName\"\n"
      "        table=\"tableName\"\n"
      "        discriminator-value=\"discriminator_value\"\n"
      "        mutable=\"true|false\"\n"
      "        schema=\"owner\"\n"
      "        catalog=\"catalog\"\n"
      "        proxy=\"ProxyInterface\"\n"
      "        dynamic-update=\"true|false\"\n"
      "        dynamic-insert=\"true|false\"\n"
      "        select-before-update=\"true|false\"\n"
      "        polymorphism=\"implicit|explicit\"\n"
      "        where=\"arbitrary sql where condition\"\n"
      "        persister=\"PersisterClass\"\n"
      "        batch-size=\"N\"\n"
      "        optimistic-lock=\"none|version|dirty|all\"\n"
      "        lazy=\"true|false\"\n"
      "        entity-name=\"EntityName\"\n"
      "        check=\"arbitrary sql check condition\"\n"
      "        rowid=\"rowid\"\n"
      "        subselect=\"SQL expression\"\n"
      "        abstract=\"true|false\"\n"
      "        node=\"element-name\"\n"
      "/>]]>"
msgstr "<literal>proxy</literal> (optionnel) : Spécifie une interface à utiliser pour l'initialisation différée (lazy loading) des proxies. Vous pouvez indiquer le nom de la classe elle-même."

#: index.docbook:214
msgid "<literal>name</literal> (optional): The fully qualified Java class name of the persistent class (or interface). If this attribute is missing, it is assumed that the mapping is for a non-POJO entity."
msgstr "<literal>dynamic-update</literal> (optionnel, par défaut à <literal>false</literal>) : Spécifie que les <literal>UPDATE</literal> SQL doivent être générés à l'exécution et contenir uniquement les colonnes dont les valeurs ont été modifiées."

#: index.docbook:221
msgid "<literal>table</literal> (optional - defaults to the unqualified class name): The name of its database table."
msgstr "<literal>dynamic-insert</literal> (optionnel, par défaut à <literal>false</literal>): Spécifie que les <literal>INSERT</literal> SQL doivent être générés à l'exécution et ne contenir que les colonnes dont les valeurs sont non nulles."

#: index.docbook:227
msgid "<literal>discriminator-value</literal> (optional - defaults to the class name): A value that distiguishes individual subclasses, used for polymorphic behaviour. Acceptable values include <literal>null</literal> and <literal>not null</literal>."
msgstr "<literal>select-before-update</literal> (optionnel, par défaut à <literal>false</literal>): Spécifie que Hibernate ne doit <emphasis>jamais</emphasis> exécuter un <literal>UPDATE</literal> SQL sans être certain qu'un objet a été réellement modifié. Dans certains cas, (en réalité, seulement quand un objet transient a été associé à une nouvelle session par <literal>update()</literal>), cela signifie que Hibernate exécutera un <literal>SELECT</literal> SQL pour s'assurer qu'un <literal>UPDATE</literal> SQL est véritablement nécessaire."

#: index.docbook:234
msgid "<literal>mutable</literal> (optional, defaults to <literal>true</literal>): Specifies that instances of the class are (not) mutable."
msgstr "<literal>polymorphism</literal> (optionnel, vaut <literal>implicit</literal> par défaut) : Détermine si, pour cette classe, une requête polymorphique implicite ou explicite est utilisée."

#: index.docbook:240, index.docbook:2204
msgid "<literal>schema</literal> (optional): Override the schema name specified by the root <literal>&lt;hibernate-mapping&gt;</literal> element."
msgstr "<literal>where</literal> (optionnel) spécifie une clause SQL <literal>WHERE</literal> à utiliser lorsque l'on récupère des objets de cette classe."

#: index.docbook:246, index.docbook:2210
msgid "<literal>catalog</literal> (optional): Override the catalog name specified by the root <literal>&lt;hibernate-mapping&gt;</literal> element."
msgstr "<literal>persister</literal> (optionnel) : Spécifie un <literal>ClassPersister</literal> particulier."

#: index.docbook:252
msgid "<literal>proxy</literal> (optional): Specifies an interface to use for lazy initializing proxies. You may specify the name of the class itself."
msgstr "<literal>batch-size</literal> (optionnel, par défaut = <literal>1</literal>) : spécifie une taille de batch pour remplir les instances de cette classe par identifiant en une seule requête."

#: index.docbook:258
msgid "<literal>dynamic-update</literal> (optional, defaults to <literal>false</literal>): Specifies that <literal>UPDATE</literal> SQL should be generated at runtime and contain only those columns whose values have changed."
msgstr "<literal>optimistic-lock</literal> (optionnel, par défaut = <literal>version</literal>) : Détermine la stratégie de verrou optimiste."

#: index.docbook:265
msgid "<literal>dynamic-insert</literal> (optional, defaults to <literal>false</literal>): Specifies that <literal>INSERT</literal> SQL should be generated at runtime and contain only the columns whose values are not null."
msgstr "<literal>lazy</literal> (optionnel) : Déclarer <literal>lazy=\"true\"</literal> est un raccourci pour spécifier le nom de la classe comme étant l'interface <literal>proxy</literal>."

#: index.docbook:272
msgid "<literal>select-before-update</literal> (optional, defaults to <literal>false</literal>): Specifies that Hibernate should <emphasis>never</emphasis> perform an SQL <literal>UPDATE</literal> unless it is certain that an object is actually modified. In certain cases (actually, only when a transient object has been associated with a new session using <literal>update()</literal>), this means that Hibernate will perform an extra SQL <literal>SELECT</literal> to determine if an <literal>UPDATE</literal> is actually required."
msgstr "<literal>entity-name</literal> (optionnel) : Hibernate3 permet à une classe d'être mappée plusieurs fois (potentiellement à plusieurs tables), et permet aux mappings d'entité d'être représentés par des Maps ou du XML au niveau Java. Dans ces cas, vous devez indiquer un nom explicite arbitraire pour les entités. Voir <xref linkend=\"persistent-classes-dynamicmodels\"/> et <xref linkend=\"xml\"/> pour plus d'informations."

#: index.docbook:282
msgid "<literal>polymorphism</literal> (optional, defaults to <literal>implicit</literal>): Determines whether implicit or explicit query polymorphism is used."
msgstr "<literal>catalog</literal> (optionnel) : The name of a database catalog used for this class and its table."

#: index.docbook:288
msgid "<literal>where</literal> (optional) specify an arbitrary SQL <literal>WHERE</literal> condition to be used when retrieving objects of this class"
msgstr "<literal>check</literal> (optionnel) : expression SQL utilisée pour générer une contrainte de vérification multi-lignes pour la génération automatique de schéma."

#: index.docbook:294
msgid "<literal>persister</literal> (optional): Specifies a custom <literal>ClassPersister</literal>."
msgstr "<literal>rowid</literal> (optionnel) : Hibernate peut utiliser des ROWID sur les bases de données qui utilisent ce mécanisme. Par exemple avec Oracle, Hibernate peut utiliser la colonne additionnelle <literal>rowid</literal> pour des mises à jour rapides si cette option vaut <literal>rowid</literal>. Un ROWID représente la localisation physique d'un tuple enregistré."

#: index.docbook:299
msgid "<literal>batch-size</literal> (optional, defaults to <literal>1</literal>) specify a \"batch size\" for fetching instances of this class by identifier."
msgstr "<literal>subselect</literal> (optionnel) : Permet de mapper une entité immuable en lecture-seule sur un sous-select de base de données. Utile pour avoir une vue au lieu d'une table en base, mais à éviter. Voir plus bas pour plus d'information."

#: index.docbook:305
msgid "<literal>optimistic-lock</literal> (optional, defaults to <literal>version</literal>): Determines the optimistic locking strategy."
msgstr "<literal>abstract</literal> (optionnel) : Utilisé pour marquer des superclasses abstraites dans des hiérarchies de <literal>&lt;union-subclass&gt;</literal>."

#: index.docbook:311
msgid "<literal>lazy</literal> (optional): Lazy fetching may be completely disabled by setting <literal>lazy=\"false\"</literal>."
msgstr "Il est tout à fait possible d'utiliser une interface comme nom de classe persistante. Vous devez alors déclarer les classes implémentant cette interface en utilisant l'élément <literal>&lt;subclass&gt;</literal>. Vous pouvez faire persister toute classe interne <emphasis>static</emphasis>. Vous devez alors spécifier le nom de la classe par la notation habituelle des classes internes c'est à dire <literal>eg.Foo$Bar</literal>."

#: index.docbook:317
msgid "<literal>entity-name</literal> (optional, defaults to the class name): Hibernate3 allows a class to be mapped multiple times (to different tables, potentially), and allows entity mappings that are represented by Maps or XML at the Java level. In these cases, you should provide an explicit arbitrary name for the entity. See <xref linkend=\"persistent-classes-dynamicmodels\"/> and <xref linkend=\"xml\"/> for more information."
msgstr "Les classes immuables, <literal>mutable=\"false\"</literal>, ne peuvent pas être modifiées ou supprimées par l'application. Cela permet à Hibernate de faire quelques optimisations mineures sur les performances."

#: index.docbook:327
msgid "<literal>check</literal> (optional): A SQL expression used to generate a multi-row <emphasis>check</emphasis> constraint for automatic schema generation."
msgstr "L'attribut optionnnel <literal>proxy</literal> permet les intialisations différées des instances persistantes de la classe. Hibernate retournera initialement des proxies CGLIB qui implémentent l'interface nommée. Le véritable objet persistant ne sera chargé que lorsque une méthode du proxy sera appelée. Voir plus bas le paragraphe abordant les proxies et le chargement différé (lazy initialization)."

#: index.docbook:333
msgid "<literal>rowid</literal> (optional): Hibernate can use so called ROWIDs on databases which support. E.g. on Oracle, Hibernate can use the <literal>rowid</literal> extra column for fast updates if you set this option to <literal>rowid</literal>. A ROWID is an implementation detail and represents the physical location of a stored tuple."
msgstr "Le polymorphisme <emphasis>implicite</emphasis> signifie que les instances de la classe seront retournées par une requête qui utilise les noms de la classe ou de chacune de ses superclasses ou encore des interfaces implémentées par cette classe ou ses superclasses. Les instances des classes filles seront retournées par une requête qui utilise le nom de la classe elle même. Le polymorphisme <emphasis>explicite</emphasis> signifie que les instances de la classe ne seront retournées que par une requête qui utilise explicitement son nom et que seules les instances des classes filles déclarées dans les éléments <literal>&lt;subclass&gt;</literal> ou <literal>&lt;joined-subclass&gt;</literal> seront retournées. Dans la majorités des cas la valeur par défaut, <literal>polymorphism=\"implicit\"</literal>, est appropriée. Le polymorphisme explicite est utile lorsque deux classes différentes sont mappées à la même table (ceci permet d'écrire une classe \"légère\" qui ne contient qu'une partie des colonnes de la table - voir la partie design pattern du site communautaire)."

#: index.docbook:341
msgid "<literal>subselect</literal> (optional): Maps an immutable and read-only entity to a database subselect. Useful if you want to have a view instead of a base table, but don't. See below for more information."
msgstr "L'attribut <literal>persister</literal> vous permet de customiser la stratégie utilisée pour la classe. Vous pouvez, par exemple, spécifier votre propre sous-classe de <literal>org.hibernate.persister.EntityPersister</literal> ou vous pourriez aussi créer une nouvelle implémentation de l'interface <literal>org.hibernate.persister.ClassPersister</literal> qui proposerait une persistance via, par exemple, des appels de procédures stockées, de la sérialisation vers des fichiers plats ou un annuaire LDAP. Voir <literal>org.hibernate.test.CustomPersister</literal> pour un exemple simple (d'une \"persistance\" vers une <literal>Hashtable</literal>)."

#: index.docbook:348
msgid "<literal>abstract</literal> (optional): Used to mark abstract superclasses in <literal>&lt;union-subclass&gt;</literal> hierarchies."
msgstr "Notez que les paramètres <literal>dynamic-update</literal> et <literal>dynamic-insert</literal> ne sont pas hérités par les sous-classes et peuvent donc être spécifiés pour les éléments <literal>&lt;subclass&gt;</literal> ou <literal>&lt;joined-subclass&gt;</literal> Ces paramètres peuvent améliorer les performances dans certains cas, mais peuvent aussi les amoindrir. A utiliser en connaissance de causes."

#: index.docbook:356
msgid "It is perfectly acceptable for the named persistent class to be an interface. You would then declare implementing classes of that interface using the <literal>&lt;subclass&gt;</literal> element. You may persist any <emphasis>static</emphasis> inner class. You should specify the class name using the standard form ie. <literal>eg.Foo$Bar</literal>."
msgstr "L'utilisation de <literal>select-before-update</literal> va généralement faire baisser les performances. Ce paramètre est pratique pour prévenir l'appel inutile d'un trigger sur modification quand on réattache un graphe d'instances à une <literal>Session</literal>."

#: index.docbook:363
msgid "Immutable classes, <literal>mutable=\"false\"</literal>, may not be updated or deleted by the application. This allows Hibernate to make some minor performance optimizations."
msgstr "Si vous utilisez le <literal>dynamic-update</literal>, les différentes stratégies de verrouillage optimiste (optimistic locking) sont les suivantes:"

#: index.docbook:368
msgid "The optional <literal>proxy</literal> attribute enables lazy initialization of persistent instances of the class. Hibernate will initially return CGLIB proxies which implement the named interface. The actual persistent object will be loaded when a method of the proxy is invoked. See \"Initializing collections and proxies\" below."
msgstr "<literal>version</literal> vérifie les colonnes version/timestamp"

#: index.docbook:375
msgid "<emphasis>Implicit</emphasis> polymorphism means that instances of the class will be returned by a query that names any superclass or implemented interface or the class and that instances of any subclass of the class will be returned by a query that names the class itself. <emphasis>Explicit</emphasis> polymorphism means that class instances will be returned only by queries that explicitly name that class and that queries that name the class will return only instances of subclasses mapped inside this <literal>&lt;class&gt;</literal> declaration as a <literal>&lt;subclass&gt;</literal> or <literal>&lt;joined-subclass&gt;</literal>. For most purposes the default, <literal>polymorphism=\"implicit\"</literal>, is appropriate. Explicit polymorphism is useful when two different classes are mapped to the same table (this allows a \"lightweight\" class that contains a subset of the table columns)."
msgstr "<literal>all</literal> vérifie toutes les colonnes"

#: index.docbook:387
msgid "The <literal>persister</literal> attribute lets you customize the persistence strategy used for the class. You may, for example, specify your own subclass of <literal>org.hibernate.persister.EntityPersister</literal> or you might even provide a completely new implementation of the interface <literal>org.hibernate.persister.ClassPersister</literal> that implements persistence via, for example, stored procedure calls, serialization to flat files or LDAP. See <literal>org.hibernate.test.CustomPersister</literal> for a simple example (of \"persistence\" to a <literal>Hashtable</literal>)."
msgstr "<literal>dirty</literal> vérifie les colonnes modifiées, permettant des updates concurrents"

#: index.docbook:398
msgid "Note that the <literal>dynamic-update</literal> and <literal>dynamic-insert</literal> settings are not inherited by subclasses and so may also be specified on the <literal>&lt;subclass&gt;</literal> or <literal>&lt;joined-subclass&gt;</literal> elements. These settings may increase performance in some cases, but might actually decrease performance in others. Use judiciously."
msgstr "<literal>none</literal> pas de verrouillage optimiste"

#: index.docbook:406
msgid "Use of <literal>select-before-update</literal> will usually decrease performance. It is very useful to prevent a database update trigger being called unnecessarily if you reattach a graph of detached instances to a <literal>Session</literal>."
msgstr "Nous encourageons <emphasis>très</emphasis> fortement l'utilisation de colonnes de version/timestamp pour le verrouillage optimiste avec Hibernate. C'est la meilleure stratégie en regard des performances et la seule qui gère correctement les modifications sur les objets détachés (c'est à dire lorsqu'on utilise <literal>Session.merge()</literal>)."

#: index.docbook:412
msgid "If you enable <literal>dynamic-update</literal>, you will have a choice of optimistic locking strategies:"
msgstr "Il n'y a pas de différence entre table et vue pour le mapping Hibernate, tant que c'est transparent au niveau base de données (remarquez que certaines BDD ne supportent pas les vues correctement, notamment pour les updates). Vous rencontrerez peut-être des cas où vous souhaitez utiliser une vue mais ne pouvez pas en créer sur votre BDD (par exemple à cause de schémas anciens et figés). Dans ces cas, vous pouvez mapper une entité immuable en lecture seule sur un sous-select SQL donné:"

#: index.docbook:418
msgid "<literal>version</literal> check the version/timestamp columns"
msgstr ""
      "<![CDATA[<class name=\"Summary\">\n"
      "    <subselect>\n"
      "        select item.name, max(bid.amount), count(*)\n"
      "        from item\n"
      "        join bid on bid.item_id = item.id\n"
      "        group by item.name\n"
      "    </subselect>\n"
      "    <synchronize table=\"item\"/>\n"
      "    <synchronize table=\"bid\"/>\n"
      "    <id name=\"name\"/>\n"
      "    ...\n"
      "</class>]]>"

#: index.docbook:423
msgid "<literal>all</literal> check all columns"
msgstr "Déclarez les tables à synchroniser avec cette entité pour assurer que le flush automatique se produise correctement, et pour que les requêtes sur l'entité dérivée ne renvoient pas des données périmées. Le litéral <literal>&lt;subselect&gt;</literal> est disponible comme attribut ou comme élément de mapping."

#: index.docbook:428
msgid "<literal>dirty</literal> check the changed columns, allowing some concurrent updates"
msgstr "<title>id</title>"

#: index.docbook:433
msgid "<literal>none</literal> do not use optimistic locking"
msgstr "Les classes mappées <emphasis>doivent</emphasis> déclarer la clef primaire de la table en base de données. La plupart des classes auront aussi une propriété de type javabean présentant l'identifiant unique d'une instance. L'élément <literal>&lt;id&gt;</literal> sert à définir le mapping entre cette propriété et la clef primaire en base."

#: index.docbook:438
msgid "We <emphasis>very</emphasis> strongly recommend that you use version/timestamp columns for optimistic locking with Hibernate. This is the optimal strategy with respect to performance and is the only strategy that correctly handles modifications made to detached instances (ie. when <literal>Session.merge()</literal> is used)."
msgstr ""
      "<![CDATA[<id\n"
      "        name=\"propertyName\"\n"
      "        type=\"typename\"\n"
      "        column=\"column_name\"\n"
      "        unsaved-value=\"null|any|none|undefined|id_value\"\n"
      "        access=\"field|property|ClassName\">\n"
      "\n"
      "        <generator class=\"generatorClass\"/>\n"
      "</id>]]>"

#: index.docbook:445
msgid "There is no difference between a view and a base table for a Hibernate mapping, as expected this is transparent at the database level (note that some DBMS don't support views properly, especially with updates). Sometimes you want to use a view, but can't create one in the database (ie. with a legacy schema). In this case, you can map an immutable and read-only entity to a given SQL subselect expression:"
msgstr "<literal>name</literal> (optionnel) : Nom de la propriété qui sert d'identifiant."

#: index.docbook:453
msgid ""
      "<![CDATA[<class name=\"Summary\">\n"
      "    <subselect>\n"
      "        select item.name, max(bid.amount), count(*)\n"
      "        from item\n"
      "        join bid on bid.item_id = item.id\n"
      "        group by item.name\n"
      "    </subselect>\n"
      "    <synchronize table=\"item\"/>\n"
      "    <synchronize table=\"bid\"/>\n"
      "    <id name=\"name\"/>\n"
      "    ...\n"
      "</class>]]>"
msgstr "<literal>type</literal> (optionnel) : Nom indiquant le type Hibernate."

#: index.docbook:455
msgid "Declare the tables to synchronize this entity with, ensuring that auto-flush happens correctly, and that queries against the derived entity do not return stale data. The <literal>&lt;subselect&gt;</literal> is available as both as an attribute and a nested mapping element."
msgstr "<literal>column</literal> (optionnel - le nom de la propriété est pris par défaut) : Nom de la clef primaire."

#: index.docbook:465
msgid "<title>id</title>"
msgstr "<literal>unsaved-value</literal> (optionnel - par défaut une valeur \"bien choisie\") : Une valeur de la propriété d'identifiant qui indique que l'instance est nouvellement instanciée (non sauvegardée), et qui la distingue des instances <literal>transient</literal>s qui ont été sauvegardées ou chargées dans une session précédente."

#: index.docbook:467
msgid "Mapped classes <emphasis>must</emphasis> declare the primary key column of the database table. Most classes will also have a JavaBeans-style property holding the unique identifier of an instance. The <literal>&lt;id&gt;</literal> element defines the mapping from that property to the primary key column."
msgstr "<literal>access</literal> (optionnel - par défaut <literal>property</literal>) : La stratégie que doit utiliser Hibernate pour accéder aux valeurs des propriétés."

#: index.docbook:482
msgid ""
      "<![CDATA[<id\n"
      "        name=\"propertyName\"\n"
      "        type=\"typename\"\n"
      "        column=\"column_name\"\n"
      "        unsaved-value=\"null|any|none|undefined|id_value\"\n"
      "        access=\"field|property|ClassName\">\n"
      "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
      "\n"
      "        <generator class=\"generatorClass\"/>\n"
      "</id>]]>"
msgstr "Si l'attribut <literal>name</literal> est absent, Hibernate considère que la classe ne possède pas de propriété identifiant."

#: index.docbook:485
msgid "<literal>name</literal> (optional): The name of the identifier property."
msgstr "L'attribut <literal>unsaved-value</literal> est important ! Si l'identifiant de votre classe n'a pas une valeur par défaut compatible avec le comportement standard de Java (zéro ou null), vous devez alors préciser la valeur par défaut."

#: index.docbook:490
msgid "<literal>type</literal> (optional): A name that indicates the Hibernate type."
msgstr "La déclaration alternative <literal>&lt;composite-id&gt;</literal> permet l'acccès aux données d'anciens systèmes qui utilisent des clefs composées. Son utilisation est fortement déconseillée pour d'autres cas."

#: index.docbook:495
msgid "<literal>column</literal> (optional - defaults to the property name): The name of the primary key column."
msgstr "Generator"

#: index.docbook:501
msgid "<literal>unsaved-value</literal> (optional - defaults to a \"sensible\" value): An identifier property value that indicates that an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session."
msgstr "L'élément fils <literal>&lt;generator&gt;</literal> nomme une classe Java utilisée pour générer les identifiants uniques pour les instances des classes persistantes. Si des paramètres sont requis pour configurer ou initialiser l'instance du générateur, ils sont passés en utilisant l'élément <literal>&lt;param&gt;</literal>."

#: index.docbook:509, index.docbook:1017, index.docbook:1156, index.docbook:1238, index.docbook:1345, index.docbook:1534, index.docbook:1708, index.docbook:1878, index.docbook:2457
msgid "<literal>access</literal> (optional - defaults to <literal>property</literal>): The strategy Hibernate should use for accessing the property value."
msgstr ""
      "<![CDATA[<id name=\"id\" type=\"long\" column=\"cat_id\">\n"
      "        <generator class=\"org.hibernate.id.TableHiLoGenerator\">\n"
      "                <param name=\"table\">uid_table</param>\n"
      "                <param name=\"column\">next_hi_value_column</param>\n"
      "        </generator>\n"
      "</id>]]>"

#: index.docbook:517
msgid "If the <literal>name</literal> attribute is missing, it is assumed that the class has no identifier property."
msgstr "Tous les générateurs doivent implémenter l'interface <literal>org.hibernate.id.IdentifierGenerator</literal>. C'est une interface très simple ; certaines applications peuvent proposer leur propre implémentations spécialisées. Cependant, Hibernate propose une série d'implémentations intégrées. Il existe des noms raccourcis pour les générateurs intégrés :"

#: index.docbook:522
msgid "The <literal>unsaved-value</literal> attribute is almost never needed in Hibernate3."
msgstr "increment"

#: index.docbook:526
msgid "There is an alternative <literal>&lt;composite-id&gt;</literal> declaration to allow access to legacy data with composite keys. We strongly discourage its use for anything else."
msgstr "Génère des identifiants de type <literal>long</literal>, <literal>short</literal> ou <literal>int</literal> qui ne sont uniques que si aucun autre processus n'insère de données dans la même table. <emphasis>Ne pas utiliser en environnement clusterisé.</emphasis>"

#: index.docbook:532
msgid "Generator"
msgstr "identity"

#: index.docbook:534
msgid "The optional <literal>&lt;generator&gt;</literal> child element names a Java class used to generate unique identifiers for instances of the persistent class. If any parameters are required to configure or initialize the generator instance, they are passed using the <literal>&lt;param&gt;</literal> element."
msgstr "Utilisation de la colonne identity de DB2, MySQL, MS SQL Server, Sybase et HypersonicSQL. L'identifiant renvoyé est de type <literal>long</literal>, <literal>short</literal> ou <literal>int</literal>."

#: index.docbook:541
msgid ""
      "<![CDATA[<id name=\"id\" type=\"long\" column=\"cat_id\">\n"
      "        <generator class=\"org.hibernate.id.TableHiLoGenerator\">\n"
      "                <param name=\"table\">uid_table</param>\n"
      "                <param name=\"column\">next_hi_value_column</param>\n"
      "        </generator>\n"
      "</id>]]>"
msgstr "sequence"

#: index.docbook:543
msgid "All generators implement the interface <literal>org.hibernate.id.IdentifierGenerator</literal>. This is a very simple interface; some applications may choose to provide their own specialized implementations. However, Hibernate provides a range of built-in implementations. There are shortcut names for the built-in generators:"
msgstr "Utilisation des séquences dans DB2, PostgreSQL, Oracle, SAP DB, McKoi ou d'un générateur dans Interbase. L'identifiant renvoyé est de type <literal>long</literal>, <literal>short</literal> ou <literal>int</literal>"

#: index.docbook:551
msgid "increment"
msgstr "hilo"

#: index.docbook:553
msgid "generates identifiers of type <literal>long</literal>, <literal>short</literal> or <literal>int</literal> that are unique only when no other process is inserting data into the same table. <emphasis>Do not use in a cluster.</emphasis>"
msgstr "Utilise un algorithme hi/lo pour générer de façon efficace des identifiants de type <literal>long</literal>, <literal>short</literal> ou <literal>int</literal>, en prenant comme source de valeur \"hi\" une table et une colonne (par défaut <literal>hibernate_unique_key</literal> et <literal>next_hi</literal> respectivement). L'algorithme hi/lo génère des identifiants uniques pour une base de données particulière seulement."

#: index.docbook:562
msgid "identity"
msgstr "seqhilo"

#: index.docbook:564
msgid "supports identity columns in DB2, MySQL, MS SQL Server, Sybase and HypersonicSQL. The returned identifier is of type <literal>long</literal>, <literal>short</literal> or <literal>int</literal>."
msgstr "Utilise un algorithme hi/lo pour générer efficacement des identifiants de type <literal>long</literal>, <literal>short</literal> ou <literal>int</literal>, étant donné un nom de séquence en base."

#: index.docbook:572
msgid "sequence"
msgstr "uuid"

#: index.docbook:574
msgid "uses a sequence in DB2, PostgreSQL, Oracle, SAP DB, McKoi or a generator in Interbase. The returned identifier is of type <literal>long</literal>, <literal>short</literal> or <literal>int</literal>"
msgstr "Utilise un algorithme de type UUID 128 bits pour générer des identifiants de type string, unique au sein d'un réseau (l'adresse IP est utilisée). Le UUID en codé en une chaîne de nombre héxadécimaux de longueur 32."

#: index.docbook:582
msgid "hilo"
msgstr "guid"

#: index.docbook:584
msgid "uses a hi/lo algorithm to efficiently generate identifiers of type <literal>long</literal>, <literal>short</literal> or <literal>int</literal>, given a table and column (by default <literal>hibernate_unique_key</literal> and <literal>next_hi</literal> respectively) as a source of hi values. The hi/lo algorithm generates identifiers that are unique only for a particular database."
msgstr "Utilise une chaîne GUID générée par la base pour MS SQL Server et MySQL."

#: index.docbook:594
msgid "seqhilo"
msgstr "native"

#: index.docbook:596
msgid "uses a hi/lo algorithm to efficiently generate identifiers of type <literal>long</literal>, <literal>short</literal> or <literal>int</literal>, given a named database sequence."
msgstr "Choisit <literal>identity</literal>, <literal>sequence</literal> ou <literal>hilo</literal> selon les possibilités offertes par la base de données sous-jacente."

#: index.docbook:604
msgid "uuid"
msgstr "assigned"

#: index.docbook:606
msgid "uses a 128-bit UUID algorithm to generate identifiers of type string, unique within a network (the IP address is used). The UUID is encoded as a string of hexadecimal digits of length 32."
msgstr "Laisse l'application affecter un identifiant à l'objet avant que la métode <literal>save()</literal> soit appelée. Il s'agit de la stratégie par défaut si aucun <literal>&lt;generator&gt;</literal> n'est spécifié."

#: index.docbook:614
msgid "guid"
msgstr "select"

#: index.docbook:616
msgid "uses a database-generated GUID string on MS SQL Server and MySQL."
msgstr "Récupère une clef primaire assignée par un trigger en sélectionnant la ligne par une clef unique quelconque."

#: index.docbook:622
msgid "native"
msgstr "foreign"

#: index.docbook:624
msgid "picks <literal>identity</literal>, <literal>sequence</literal> or <literal>hilo</literal> depending upon the capabilities of the underlying database."
msgstr "Utilise l'identifiant d'un objet associé. Habituellement utilisé en conjonction avec une association <literal>&lt;one-to-one&gt;</literal> sur la clef primaire."

#: index.docbook:632
msgid "assigned"
msgstr "algorithme Hi/lo"

#: index.docbook:634
msgid "lets the application to assign an identifier to the object before <literal>save()</literal> is called. This is the default strategy if no <literal>&lt;generator&gt;</literal> element is specified."
msgstr "Les générateurs <literal>hilo</literal> et <literal>seqhilo</literal> proposent deux implémentations alternatives de l'algorithme hi/lo, une approche largement utilisée pour générer des identifiants. La première implémentation nécessite une table \"spéciale\" en base pour héberger la prochaine valeur \"hi\" disponible. La seconde utilise une séquence de type Oracle (quand la base sous-jacente le propose)."

#: index.docbook:642
msgid "select"
msgstr ""
      "<![CDATA[<id name=\"id\" type=\"long\" column=\"cat_id\">\n"
      "        <generator class=\"hilo\">\n"
      "                <param name=\"table\">hi_value</param>\n"
      "                <param name=\"column\">next_value</param>\n"
      "                <param name=\"max_lo\">100</param>\n"
      "        </generator>\n"
      "</id>]]>"

#: index.docbook:644
msgid "retrieves a primary key assigned by a database trigger by selecting the row by some unique key and retrieving the primary key value."
msgstr ""
      "<![CDATA[<id name=\"id\" type=\"long\" column=\"cat_id\">\n"
      "        <generator class=\"seqhilo\">\n"
      "                <param name=\"sequence\">hi_value</param>\n"
      "                <param name=\"max_lo\">100</param>\n"
      "        </generator>\n"
      "</id>]]>"

#: index.docbook:651
msgid "foreign"
msgstr "Malheureusement, vous ne pouvez pas utilisez <literal>hilo</literal> quand vous apportez votre propre <literal>Connection</literal> à Hibernate. Quand Hibernate utilise une datasource du serveur d'application pour obtenir des connexions inscrites avec JTA, vous devez correctement configurer <literal>hibernate.transaction.manager_lookup_class</literal>."

#: index.docbook:653
msgid "uses the identifier of another associated object. Usually used in conjunction with a <literal>&lt;one-to-one&gt;</literal> primary key association."
msgstr "UUID algorithm"

#: index.docbook:660
msgid "sequence-identity"
msgstr "Le contenu du UUID est : adresse IP, date de démarrage de la JVM (précis au quart de seconde), l'heure système et un compteur (unique au sein de la JVM). Il n'est pas possible d'obtenir l'adresse MAC ou une adresse mémoire à partir de Java, c'est donc le mieux que l'on puisse faire sans utiliser JNI."

#: index.docbook:662
msgid "a specialized sequence generation strategy which utilizes a database sequence for the actual value generation, but combines this with JDBC3 getGeneratedKeys to actually return the generated identifier value as part of the insert statement execution. This strategy is only known to be supported on Oracle 10g drivers targetted for JDK 1.4. Note comments on these insert statements are disabled due to a bug in the Oracle drivers."
msgstr "Colonnes identifiantes et séquences"

#: index.docbook:679
msgid "Hi/lo algorithm"
msgstr "Pour les bases qui implémentent les colonnes \"identité\" (DB2, MySQL, Sybase, MS SQL), vous pouvez utiliser la génération de clef par <literal>identity</literal>. Pour les bases qui implémentent les séquences (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) vous pouvez utiliser la génération de clef par <literal>sequence</literal>. Ces deux méthodes nécessitent deux requêtes SQL pour insérer un objet."

#: index.docbook:680
msgid "The <literal>hilo</literal> and <literal>seqhilo</literal> generators provide two alternate implementations of the hi/lo algorithm, a favorite approach to identifier generation. The first implementation requires a \"special\" database table to hold the next available \"hi\" value. The second uses an Oracle-style sequence (where supported)."
msgstr ""
      "<![CDATA[<id name=\"id\" type=\"long\" column=\"person_id\">\n"
      "        <generator class=\"sequence\">\n"
      "                <param name=\"sequence\">person_id_sequence</param>\n"
      "        </generator>\n"
      "</id>]]>"

#: index.docbook:687
msgid ""
      "<![CDATA[<id name=\"id\" type=\"long\" column=\"cat_id\">\n"
      "        <generator class=\"hilo\">\n"
      "                <param name=\"table\">hi_value</param>\n"
      "                <param name=\"column\">next_value</param>\n"
      "                <param name=\"max_lo\">100</param>\n"
      "        </generator>\n"
      "</id>]]>"
msgstr ""
      "<![CDATA[<id name=\"id\" type=\"long\" column=\"person_id\" unsaved-value=\"0\">\n"
      "        <generator class=\"identity\"/>\n"
      "</id>]]>"

#: index.docbook:689
msgid ""
      "<![CDATA[<id name=\"id\" type=\"long\" column=\"cat_id\">\n"
      "        <generator class=\"seqhilo\">\n"
      "                <param name=\"sequence\">hi_value</param>\n"
      "                <param name=\"max_lo\">100</param>\n"
      "        </generator>\n"
      "</id>]]>"
msgstr "Pour le développement multi-plateformes, la stratégie <literal>native</literal> choisira entre les méthodes <literal>identity</literal>, <literal>sequence</literal> et <literal>hilo</literal>, selon les possibilités offertes par la base sous-jacente."

#: index.docbook:691
msgid "Unfortunately, you can't use <literal>hilo</literal> when supplying your own <literal>Connection</literal> to Hibernate. When Hibernate is using an application server datasource to obtain connections enlisted with JTA, you must properly configure the <literal>hibernate.transaction.manager_lookup_class</literal>."
msgstr "Identifiants assignés"

#: index.docbook:700
msgid "UUID algorithm"
msgstr "Si vous souhaitez que l'application assigne des identifiants (par opposition à la génération par Hibernate), vous pouvez utiliser le générateur <literal>assigned</literal>. Ce générateur spécial utilisera une valeur d'identifiant déjà utilisé par la propriété identifiant l'objet. Ce générateur est utilisé quand la clef primaire est une clef naturelle plutôt qu'une clef secondaire. C'est le comportement par défaut si vous ne précisez pas d'élément <literal>&lt;generator&gt;</literal>."

#: index.docbook:701
msgid "The UUID contains: IP address, startup time of the JVM (accurate to a quarter second), system time and a counter value (unique within the JVM). It's not possible to obtain a MAC address or memory address from Java code, so this is the best we can do without using JNI."
msgstr "Choisir le générateur <literal>assigned</literal> fait utiliser <literal>unsaved-value=\"undefined\"</literal> par Hibernate, le forçant à interroger la base pour déterminer si l'instance est transiente ou détachée, à moins d'utiliser une propriété version ou timestamp, ou alors de définir <literal>Interceptor.isUnsaved()</literal>."

#: index.docbook:710
msgid "Identity columns and sequences"
msgstr "Clefs primaires assignées par trigger"

#: index.docbook:711
msgid "For databases which support identity columns (DB2, MySQL, Sybase, MS SQL), you may use <literal>identity</literal> key generation. For databases that support sequences (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) you may use <literal>sequence</literal> style key generation. Both these strategies require two SQL queries to insert a new object."
msgstr "Pour les schémas de base hérités d'anciens systèmes uniquement (Hibernate ne génère pas de DDL avec des triggers)"

#: index.docbook:719
msgid ""
      "<![CDATA[<id name=\"id\" type=\"long\" column=\"person_id\">\n"
      "        <generator class=\"sequence\">\n"
      "                <param name=\"sequence\">person_id_sequence</param>\n"
      "        </generator>\n"
      "</id>]]>"
msgstr ""
      "<![CDATA[<id name=\"id\" type=\"long\" column=\"person_id\">\n"
      "        <generator class=\"select\">\n"
      "                <param name=\"key\">socialSecurityNumber</param>\n"
      "        </generator>\n"
      "</id>]]>"

#: index.docbook:721
msgid ""
      "<![CDATA[<id name=\"id\" type=\"long\" column=\"person_id\" unsaved-value=\"0\">\n"
      "        <generator class=\"identity\"/>\n"
      "</id>]]>"
msgstr "Dans l'exemple ci-dessus, <literal>socialSecurityNumber</literal> a une valeur unique définie par la classe en tant que clef naturelle et <literal>person_id</literal> est une clef secondaire dont la valeur est générée par trigger."

#: index.docbook:723
msgid "For cross-platform development, the <literal>native</literal> strategy will choose from the <literal>identity</literal>, <literal>sequence</literal> and <literal>hilo</literal> strategies, dependant upon the capabilities of the underlying database."
msgstr "composite-id"

#: index.docbook:732
msgid "Assigned identifiers"
msgstr ""
      "<![CDATA[<composite-id\n"
      "        name=\"propertyName\"\n"
      "        class=\"ClassName\"\n"
      "        mapped=\"true|false\"\n"
      "        access=\"field|property|ClassName\">\n"
      "        node=\"element-name|.\"\n"
      "\n"
      "        <key-property name=\"propertyName\" type=\"typename\" column=\"column_name\"/>\n"
      "        <key-many-to-one name=\"propertyName class=\"ClassName\" column=\"column_name\"/>\n"
      "        ......\n"
      "</composite-id>]]>"

#: index.docbook:733
msgid "If you want the application to assign identifiers (as opposed to having Hibernate generate them), you may use the <literal>assigned</literal> generator. This special generator will use the identifier value already assigned to the object's identifier property. This generator is used when the primary key is a natural key instead of a surrogate key. This is the default behavior if you do no specify a <literal>&lt;generator&gt;</literal> element."
msgstr "Pour une table avec clef composée, vous pouvez mapper plusieurs attributs de la classe comme propriétés identifiantes. L'élement <literal>&lt;composite-id&gt;</literal> accepte les mappings de propriétés <literal>&lt;key-property&gt;</literal> et les mappings <literal>&lt;key-many-to-one&gt;</literal> comme fils."

#: index.docbook:742
msgid "Choosing the <literal>assigned</literal> generator makes Hibernate use <literal>unsaved-value=\"undefined\"</literal>, forcing Hibernate to go to the database to determine if an instance is transient or detached, unless there is a version or timestamp property, or you define <literal>Interceptor.isUnsaved()</literal>."
msgstr ""
      "<![CDATA[<composite-id>\n"
      "        <key-property name=\"medicareNumber\"/>\n"
      "        <key-property name=\"dependent\"/>\n"
      "</composite-id>]]>"

#: index.docbook:752
msgid "Primary keys assigned by triggers"
msgstr "Vos classes persistantes <emphasis>doivent</emphasis> surcharger les méthodes <literal>equals()</literal> et <literal>hashCode()</literal> pour implémenter l'égalité d'identifiant composé. Elles doivent aussi implenter l'interface <literal>Serializable</literal>."

#: index.docbook:753
msgid "For legacy schemas only (Hibernate does not generate DDL with triggers)."
msgstr "Malheureusement cette approche sur les identifiants composés signifie qu'un objet persistant est son propre identifiant. Il n'y a pas d'autre moyen pratique de manipuler l'objet que par l'objet lui-même. Vous devez instancier une instance de la classe persistante elle-même et peupler ses attributs identifiants avant de pouvoir appeler la méthode <literal>load()</literal> pour charger son état persistant associé à une clef composée. Nous appelons cette approche \"identifiant composé <emphasis>embarqué</emphasis>\" et ne la recommandons pas pour des applications complexes."

#: index.docbook:757
msgid ""
      "<![CDATA[<id name=\"id\" type=\"long\" column=\"person_id\">\n"
      "        <generator class=\"select\">\n"
      "                <param name=\"key\">socialSecurityNumber</param>\n"
      "        </generator>\n"
      "</id>]]>"
msgstr "Une seconde approche, appelée identifiant composé <emphasis>mappé</emphasis>, consiste à encapsuler les propriétés identifiantes (celles contenues dans <literal>&lt;composite-id&gt;</literal>) dans une classe particulière."

#: index.docbook:759
msgid "In the above example, there is a unique valued property named <literal>socialSecurityNumber</literal> defined by the class, as a natural key, and a surrogate key named <literal>person_id</literal> whose value is generated by a trigger."
msgstr ""
      "<![CDATA[<composite-id class=\"MedicareId\" mapped=\"true\">\n"
      "        <key-property name=\"medicareNumber\"/>\n"
      "        <key-property name=\"dependent\"/>\n"
      "</composite-id>]]>"

#: index.docbook:771
msgid "Enhanced identifier generators"
msgstr "Dans cet exemple, la classe d'identifiant composée,<literal>MedicareId</literal> et la classe mappée elle-même, possèdent les propriétés <literal>medicareNumber</literal> et <literal>dependent</literal>. La classe identifiante doit redéfinir <literal>equals()</literal> et <literal>hashCode()</literal> et implémenter <literal>Serializable</literal>. Le désavantage de cette approche est la duplication du code."

#: index.docbook:773
msgid "Starting with release 3.2.3, there are 2 new generators which represent a re-thinking of 2 different aspects of identifier generation. The first aspect is database portability; the second is optimization (not having to query the database for every request for a new identifier value). These two new generators are intended to take the place of some of the named generators described above (starting in 3.3.x); however, they are included in the current releases and can be referenced by FQN."
msgstr "Les attributs suivants servent à configurer un identifiant composé mappé :"

#: index.docbook:781
msgid "The first of these new generators is <literal>org.hibernate.id.enhanced.SequenceStyleGenerator</literal> which is intended firstly as a replacement for the <literal>sequence</literal> generator and secondly as a better portability generator than <literal>native</literal> (because <literal>native</literal> (generally) chooses between <literal>identity</literal> and <literal>sequence</literal> which have largely different semantics which can cause subtle isssues in applications eyeing portability). <literal>org.hibernate.id.enhanced.SequenceStyleGenerator</literal> however achieves portability in a different manner. It chooses between using a table or a sequence in the database to store its incrementing values depending on the capabilities of the dialect being used. The difference between this and <literal>native</literal> is that table-based and sequence-based storage have the same exact semantic (in fact sequences are exactly what Hibernate tries to emmulate with its table-based generators). This generator has a number of configuration parameters:"
msgstr "<literal>mapped</literal> (optionnel, défaut à <literal>false</literal>) : indique qu'un identifiant composé mappé est utilisé, et que les propriétés contenues font référence aux deux classes (celle mappée et la classe identifiante)."

#: index.docbook:795
msgid "<literal>sequence_name</literal> (optional, defaults to <literal>hibernate_sequence</literal>): The name of the sequence (or table) to be used."
msgstr "<literal>class</literal> (optionnel, mais requis pour un identifiant composé mappé) : La classe composant utilisée comme identifiant composé."

#: index.docbook:801
msgid "<literal>initial_value</literal> (optional, defaults to <literal>1</literal>): The initial value to be retrieved from the sequence/table. In sequence creation terms, this is analogous to the clause typical named \"STARTS WITH\"."
msgstr "Nous décrirons une troisième approche beaucoup plus efficace ou l'identifiant composé est implémenté comme une classe composant dans <xref linkend=\"components-compositeid\"/>. Les attributs décrits ci dessous, ne s'appliquent que pour cette dernière approche :"

#: index.docbook:808
msgid "<literal>increment_size</literal> (optional, defaults to <literal>1</literal>): The value by which subsequent calls to the sequence/table should differ. In sequence creation terms, this is analogous to the clause typical named \"INCREMENT BY\"."
msgstr "<literal>name</literal> (optionnel, requis pour cette approche) : une propriété de type composant qui contient l'identifiant composé (voir chapitre 9)."

#: index.docbook:815
msgid "<literal>force_table_use</literal> (optional, defaults to <literal>false</literal>): Should we force the use of a table as the backing structure even though the dialect might support sequence?"
msgstr "<literal>access</literal> (optionnel - défaut à <literal>property</literal>) : La stratégie qu'Hibernate utilisera pour accéder à la valeur de la propriété."

#: index.docbook:822
msgid "<literal>value_column</literal> (optional, defaults to <literal>next_val</literal>): Only relevant for table structures! The name of the column on the table which is used to hold the value."
msgstr "<literal>class</literal> (optionnel - défaut au type de la propriété déterminé par réflexion) : La classe composant utilisée comme identifiant (voir prochaine section)."

#: index.docbook:829
msgid "<literal>optimizer</literal> (optional, defaults to <literal>none</literal>): See"
msgstr "Cette dernière approche est celle que nous recommandons pour toutes vos applications."

#: index.docbook:836
msgid "The second of these new generators is <literal>org.hibernate.id.enhanced.TableGenerator</literal> which is intended firstly as a replacement for the <literal>table</literal> generator (although it actually functions much more like <literal>org.hibernate.id.MultipleHiLoPerTableGenerator</literal>) and secondly as a re-implementation of <literal>org.hibernate.id.MultipleHiLoPerTableGenerator</literal> utilizing the notion of pluggable optimiziers. Essentially this generator defines a table capable of holding a number of different increment values simultaneously by using multiple distinctly keyed rows. This generator has a number of configuration parameters:"
msgstr "discriminator"

#: index.docbook:846
msgid "<literal>table_name</literal> (optional, defaults to <literal>hibernate_sequences</literal>): The name of the table to be used."
msgstr "L'élément <literal>&lt;discriminator&gt;</literal> est nécessaire pour la persistance polymorphique qui utilise la stratégie de mapping de table par hiérarchie de classe. La colonne discriminante contient une valeur marqueur qui permet à la couche de persistance de savoir quelle sous-classe instancier pour une ligne particulière de table en base. Un nombre restreint de types peuvent être utilisés : <literal>string</literal>, <literal>character</literal>, <literal>integer</literal>, <literal>byte</literal>, <literal>short</literal>, <literal>boolean</literal>, <literal>yes_no</literal>, <literal>true_false</literal>."

#: index.docbook:852
msgid "<literal>value_column_name</literal> (optional, defaults to <literal>next_val</literal>): The name of the column on the table which is used to hold the value."
msgstr ""
      "<![CDATA[<discriminator\n"
      "        column=\"discriminator_column\"\n"
      "        type=\"discriminator_type\"\n"
      "        force=\"true|false\"\n"
      "        insert=\"true|false\"\n"
      "        formula=\"arbitrary sql expression\"\n"
      "/>]]>"

#: index.docbook:858
msgid "<literal>segment_column_name</literal> (optional, defaults to <literal>sequence_name</literal>): The name of the column on the table which is used to hold the \"segement key\". This is the value which distinctly identifies which increment value to use."
msgstr "<literal>column</literal> (optionnel - par défaut à <literal>class</literal>) le nom de la colonne discriminante."

#: index.docbook:865
msgid "<literal>segment_value</literal> (optional, defaults to <literal>default</literal>): The \"segment key\" value for the segment from which we want to pull increment values for this generator."
msgstr "<literal>type</literal> (optionnel - par défaut à <literal>string</literal>) un nom indiquant le type Hibernate."

#: index.docbook:872
msgid "<literal>segment_value_length</literal> (optional, defaults to <literal>255</literal>): Used for schema generation; the column size to create this segment key column."
msgstr "<literal>force</literal> (optionnel - par défaut à <literal>false</literal>) \"oblige\" Hibernate à spécifier une valeur discriminante autorisée même quand on récupère toutes les instances de la classe de base."

#: index.docbook:878
msgid "<literal>initial_value</literal> (optional, defaults to <literal>1</literal>): The initial value to be retrieved from the table."
msgstr "<literal>insert</literal> (optionnel - par défaut à <literal>true</literal>) à passer à <literal>false</literal> si la colonne discriminante fait aussi partie d'un identifiant composé mappé (Indique à Hibernate de ne pas inclure la colonne dans les <literal>INSERT</literal> SQL)."

#: index.docbook:884
msgid "<literal>increment_size</literal> (optional, defaults to <literal>1</literal>): The value by which subsequent calls to the table should differ."
msgstr "<literal>formula</literal> (optionnel) une expression SQL arbitraire qui est exécutée quand un type doit être évalué. Permet la discrimination basée sur le contenu."

#: index.docbook:890
msgid "<literal>optimizer</literal> (optional, defaults to <literal></literal>): See"
msgstr "Les véritables valeurs de la colonne discriminante sont spécifiées par l'attribut <literal>discriminator-value</literal> des éléments <literal>&lt;class&gt;</literal> et <literal>&lt;subclass&gt;</literal>."

#: index.docbook:900
msgid "Identifier generator optimization"
msgstr "L'attribut <literal>force</literal> n'est utile que si la table contient des lignes avec des valeurs \"extra\" discriminantes qui ne sont pas mappées à une classe persistante. Ce ne sera généralement pas le cas."

#: index.docbook:901
msgid "For identifier generators which store values in the database, it is inefficient for them to hit the database on each and every call to generate a new identifier value. Instead, you'd ideally want to group a bunch of them in memory and only hit the database when you have exhausted your in-memory value group. This is the role of the pluggable optimizers. Currently only the two enhanced generators (<xref linkend=\"mapping-declaration-id-enhanced\"/> support this notion."
msgstr "En utilisant l'attribut <literal>formula</literal> vous pouvez déclarer une expression SQL arbitraire qui sera utilisée pour évaluer le type d'une ligne :"

#: index.docbook:909
msgid "<literal>none</literal> (generally this is the default if no optimizer was specified): This says to not perform any optimizations, and hit the database each and every request."
msgstr ""
      "<![CDATA[<discriminator\n"
      "    formula=\"case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end\"\n"
      "    type=\"integer\"/>]]>"

#: index.docbook:915
msgid "<literal>hilo</literal>: applies a hi/lo algorithm around the database retrieved values. The values from the database for this optimizer are expected to be sequential. The values retrieved from the database structure for this optimizer indicates the \"group number\"; the <literal>increment_size</literal> is multiplied by that value in memory to define a group \"hi value\"."
msgstr "version (optionnel)"

#: index.docbook:924
msgid "<literal>pooled</literal>: like was discussed for <literal>hilo</literal>, this optimizers attempts to minimize the number of hits to the database. Here, however, we simply store the starting value for the \"next group\" into the database structure rather than a sequential value in combination with an in-memory grouping algorithm. <literal>increment_size</literal> here refers to the values coming from the database."
msgstr "L'élément <literal>&lt;version&gt;</literal> est optionnel et indique que la table contient des données versionnées. C'est particulièrement utile si vous avez l'intention d'utiliser des <emphasis>transactions longues</emphasis> (voir plus-bas)."

#: index.docbook:937
msgid "composite-id"
msgstr ""
      "<![CDATA[<version\n"
      "        column=\"version_column\"\n"
      "        name=\"propertyName\"\n"
      "        type=\"typename\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        unsaved-value=\"null|negative|undefined\"\n"
      "        generated=\"never|always\"\n"
      "        insert=\"true|false\"\n"
      "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
      "/>]]>"

#: index.docbook:939
msgid ""
      "<![CDATA[<composite-id\n"
      "        name=\"propertyName\"\n"
      "        class=\"ClassName\"\n"
      "        mapped=\"true|false\"\n"
      "        access=\"field|property|ClassName\">\n"
      "        node=\"element-name|.\"\n"
      "\n"
      "        <key-property name=\"propertyName\" type=\"typename\" column=\"column_name\"/>\n"
      "        <key-many-to-one name=\"propertyName class=\"ClassName\" column=\"column_name\"/>\n"
      "        ......\n"
      "</composite-id>]]>"
msgstr "<literal>column</literal> (optionnel - par défaut égal au nom de la propriété) : Le nom de la colonne contenant le numéro de version."

#: index.docbook:941
msgid "For a table with a composite key, you may map multiple properties of the class as identifier properties. The <literal>&lt;composite-id&gt;</literal> element accepts <literal>&lt;key-property&gt;</literal> property mappings and <literal>&lt;key-many-to-one&gt;</literal> mappings as child elements."
msgstr "<literal>name</literal> : Le nom d'un attribut de la classe persistante."

#: index.docbook:948
msgid ""
      "<![CDATA[<composite-id>\n"
      "        <key-property name=\"medicareNumber\"/>\n"
      "        <key-property name=\"dependent\"/>\n"
      "</composite-id>]]>"
msgstr "<literal>type</literal> (optionnel - par défaut à <literal>integer</literal>) : Le type du numéro de version."

#: index.docbook:950
msgid "Your persistent class <emphasis>must</emphasis> override <literal>equals()</literal> and <literal>hashCode()</literal> to implement composite identifier equality. It must also implements <literal>Serializable</literal>."
msgstr "<literal>access</literal> (optionnel - par défaut à <literal>property</literal>) : La stratégie à utiliser par Hibernate pour accéder à la valeur de la propriété."

#: index.docbook:956
msgid "Unfortunately, this approach to composite identifiers means that a persistent object is its own identifier. There is no convenient \"handle\" other than the object itself. You must instantiate an instance of the persistent class itself and populate its identifier properties before you can <literal>load()</literal> the persistent state associated with a composite key. We call this approach an <emphasis>embedded</emphasis> composite identifier, and discourage it for serious applications."
msgstr "<literal>unsaved-value</literal> (optionnel - par défaut à <literal>undefined</literal>) : Une valeur de la propriété d'identifiant qui indique que l'instance est nouvellement instanciée (non sauvegardée), et qui la distingue des instances détachées qui ont été sauvegardées ou chargées dans une session précédente (<literal>undefined</literal> indique que la valeur de l'atribut identifiant devrait être utilisé)."

#: index.docbook:965
msgid "A second approach is what we call a <emphasis>mapped</emphasis> composite identifier, where the identifier properties named inside the <literal>&lt;composite-id&gt;</literal> element are duplicated on both the persistent class and a separate identifier class."
msgstr "<literal>generated</literal> (optional - défaut à <literal>never</literal>) : Indique que la valeur de la propriété version est générée par la base de données cf. <xref linkend=\"mapping-generated\"/>generated properties."

#: index.docbook:971
msgid ""
      "<![CDATA[<composite-id class=\"MedicareId\" mapped=\"true\">\n"
      "        <key-property name=\"medicareNumber\"/>\n"
      "        <key-property name=\"dependent\"/>\n"
      "</composite-id>]]>"
msgstr "<literal>insert</literal> (optionnel - défaut à <literal>true</literal>) : Indique si la colonne de version doit être incluse dans les ordres insert. Peut être à <literal>false</literal> si et seulement si la colonne de la base de données est définie avec une valeur par défaut à <literal>0</literal>."

#: index.docbook:973
msgid "In this example, both the composite identifier class, <literal>MedicareId</literal>, and the entity class itself have properties named <literal>medicareNumber</literal> and <literal>dependent</literal>. The identifier class must override <literal>equals()</literal> and <literal>hashCode()</literal> and implement. <literal>Serializable</literal>. The disadvantage of this approach is quite obvious&mdash;code duplication."
msgstr "Les numéros de version doivent avoir les types Hibernate <literal>long</literal>, <literal>integer</literal>, <literal>short</literal>, <literal>timestamp</literal> ou <literal>calendar</literal>."

#: index.docbook:982
msgid "The following attributes are used to specify a mapped composite identifier:"
msgstr "Une propriété de version ou un timestamp ne doit jamais être null pour une instance détachée, ainsi Hibernate pourra détecter toute instance ayant une version ou un timestamp null comme transient, quelles que soient les stratégies <literal>unsaved-value</literal> spécifiées. <emphasis>Déclarer un numéro de version ou un timestamp \"nullable\" est un moyen pratique d'éviter tout problème avec les réattachements transitifs dans Hibernate, particulièrement utile pour ceux qui utilisent des identifiants assignés ou des clefs composées !</emphasis>"

#: index.docbook:988
msgid "<literal>mapped</literal> (optional, defaults to <literal>false</literal>): indicates that a mapped composite identifier is used, and that the contained property mappings refer to both the entity class and the composite identifier class."
msgstr "timestamp (optionnel)"

#: index.docbook:996
msgid "<literal>class</literal> (optional, but required for a mapped composite identifier): The class used as a composite identifier."
msgstr "L'élément optionnel <literal>&lt;timestamp&gt;</literal> indique que la table contient des données horodatées (timestamp). Cela sert d'alternative à l'utilisation de numéros de version. Les timestamps (ou horodatage) sont par nature une implémentation moins fiable pour l'optimistic locking. Cependant, l'application peut parfois utiliser l'horodatage à d'autres fins."

#: index.docbook:1003
msgid "We will describe a third, even more convenient approach where the composite identifier is implemented as a component class in <xref linkend=\"components-compositeid\"/>. The attributes described below apply only to this alternative approach:"
msgstr ""
      "<![CDATA[<timestamp\n"
      "        column=\"timestamp_column\"\n"
      "        name=\"propertyName\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        unsaved-value=\"null|undefined\"\n"
      "        source=\"vm|db\"\n"
      "        generated=\"never|always\"\n"
      "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
      "/>]]>"

#: index.docbook:1011
msgid "<literal>name</literal> (optional, required for this approach): A property of component type that holds the composite identifier (see chapter 9)."
msgstr "<literal>column</literal> (optionnel - par défaut à le nom de la propriété) : Le nom d'une colonne contenant le timestamp."

#: index.docbook:1023
msgid "<literal>class</literal> (optional - defaults to the property type determined by reflection): The component class used as a composite identifier (see next section)."
msgstr "<literal>access</literal> (optionnel - par défaut à <literal>property</literal>) : La stratégie à utiliser par Hibernate pour accéder à la valeur de la propriété."

#: index.docbook:1030
msgid "This third approach, an <emphasis>identifier component</emphasis> is the one we recommend for almost all applications."
msgstr "<literal>unsaved-value</literal> (optionnel - par défaut à <literal>null</literal>) : Propriété dont la valeur est un numéro de version qui indique que l'instance est nouvellement instanciée (non sauvegardée), et qui la distingue des instances détachées qui ont été sauvegardées ou chargées dans une session précédente (<literal>undefined</literal> indique que la valeur de l'attribut identifiant devrait être utilisée)."

#: index.docbook:1038
msgid "discriminator"
msgstr "<literal>source</literal> (optionnel - par défaut à <literal>vm</literal>) : D'où Hibernate doit-il récupérer la valeur du timestamp? Depuis la base de données ou depuis la JVM d'exécution? Les valeurs de timestamp de la base de données provoquent une surcharge puisque Hibernate doit interroger la base pour déterminer la prochaine valeur mais cela est plus sûr lorsque vous fonctionnez dans un cluster. Remarquez aussi que certains des dialectes ne supportent pas cette fonction, et que d'autres l'implémentent mal, provoquant des erreurs de précision (Oracle 8 par exemple)."

#: index.docbook:1040
msgid "The <literal>&lt;discriminator&gt;</literal> element is required for polymorphic persistence using the table-per-class-hierarchy mapping strategy and declares a discriminator column of the table. The discriminator column contains marker values that tell the persistence layer what subclass to instantiate for a particular row. A restricted set of types may be used: <literal>string</literal>, <literal>character</literal>, <literal>integer</literal>, <literal>byte</literal>, <literal>short</literal>, <literal>boolean</literal>, <literal>yes_no</literal>, <literal>true_false</literal>."
msgstr "<literal>generated</literal> (optional - défaut à <literal>never</literal>) : Indique que la valeur de ce timestamp est générée par la base de données cf. <xref linkend=\"mapping-generated\"/>generated properties."

#: index.docbook:1058
msgid ""
      "<![CDATA[<discriminator\n"
      "        column=\"discriminator_column\"\n"
      "        type=\"discriminator_type\"\n"
      "        force=\"true|false\"\n"
      "        insert=\"true|false\"\n"
      "        formula=\"arbitrary sql expression\"\n"
      "/>]]>"
msgstr "Notez que <literal>&lt;timestamp&gt;</literal> est équivalent à <literal>&lt;version type=\"timestamp\"&gt;</literal>."

#: index.docbook:1061
msgid "<literal>column</literal> (optional - defaults to <literal>class</literal>) the name of the discriminator column."
msgstr "property"

#: index.docbook:1067
msgid "<literal>type</literal> (optional - defaults to <literal>string</literal>) a name that indicates the Hibernate type"
msgstr "L'élément <literal>&lt;property&gt;</literal> déclare une propriété de la classe au sens JavaBean."

#: index.docbook:1073
msgid "<literal>force</literal> (optional - defaults to <literal>false</literal>) \"force\" Hibernate to specify allowed discriminator values even when retrieving all instances of the root class."
msgstr ""
      "<![CDATA[<property\n"
      "        name=\"propertyName\"\n"
      "        column=\"column_name\"\n"
      "        type=\"typename\"\n"
      "        update=\"true|false\"\n"
      "        insert=\"true|false\"\n"
      "        formula=\"arbitrary SQL expression\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        lazy=\"true|false\"\n"
      "        unique=\"true|false\"\n"
      "        not-null=\"true|false\"\n"
      "        optimistic-lock=\"true|false\"\n"
      "        generated=\"never|insert|always\"\n"
      "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
      "        index=\"index_name\"\n"
      "        unique_key=\"unique_key_id\"\n"
      "        length=\"L\"\n"
      "        precision=\"P\"\n"
      "        scale=\"S\"\n"
      "/>]]>"

#: index.docbook:1080
msgid "<literal>insert</literal> (optional - defaults to <literal>true</literal>) set this to <literal>false</literal> if your discriminator column is also part of a mapped composite identifier. (Tells Hibernate to not include the column in SQL <literal>INSERT</literal>s.)"
msgstr "<literal>name</literal> : nom de la propriété, avec une lettre initiale en minuscule."

#: index.docbook:1088
msgid "<literal>formula</literal> (optional) an arbitrary SQL expression that is executed when a type has to be evaluated. Allows content-based discrimination."
msgstr "<literal>column</literal> (optionnel - par défaut au nom de la propriété) : le nom de la colonne mappée. Cela peut aussi être indiqué dans le(s) sous-élément(s) <literal>&lt;column&gt;</literal>."

#: index.docbook:1096
msgid "Actual values of the discriminator column are specified by the <literal>discriminator-value</literal> attribute of the <literal>&lt;class&gt;</literal> and <literal>&lt;subclass&gt;</literal> elements."
msgstr "<literal>type</literal> (optionnel) : nom indiquant le type Hibernate."

#: index.docbook:1102
msgid "The <literal>force</literal> attribute is (only) useful if the table contains rows with \"extra\" discriminator values that are not mapped to a persistent class. This will not usually be the case."
msgstr "<literal>update, insert</literal> (optionnel - par défaut à <literal>true</literal>) : indique que les colonnes mappées devraient être incluses dans des <literal>UPDATE</literal> SQL et/ou des <literal>INSERT</literal>. Mettre les deux à <literal>false</literal> empêche la propagation en base de données (utile si vous savez qu'un trigger affectera la valeur à la colonne)."

#: index.docbook:1108
msgid "Using the <literal>formula</literal> attribute you can declare an arbitrary SQL expression that will be used to evaluate the type of a row:"
msgstr "<literal>formula</literal> (optionnel) : une expression SQL qui définit la valeur pour une propriété <emphasis>calculée</emphasis>. Les propriétés calculées ne possède pas leur propre mapping."

#: index.docbook:1113
msgid ""
      "<![CDATA[<discriminator\n"
      "    formula=\"case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end\"\n"
      "    type=\"integer\"/>]]>"
msgstr "<literal>access</literal> (optionnel - par défaut à <literal>property</literal>): Stratégie que Hibernate doit utiliser pour accéder à cette valeur."

#: index.docbook:1118
msgid "version (optional)"
msgstr "<literal>lazy</literal> (optionnel - par défaut à <literal>false</literal>): Indique que cette propriété devrait être chargée en différé (lazy loading) quand on accède à la variable d'instance pour la première fois."

#: index.docbook:1120
msgid "The <literal>&lt;version&gt;</literal> element is optional and indicates that the table contains versioned data. This is particularly useful if you plan to use <emphasis>long transactions</emphasis> (see below)."
msgstr "<literal>unique</literal> (optionnel): Génère le DDL d'une contrainte d'unicité pour les colonnes. Permet aussi d'en faire la cible d'un <literal>property-ref</literal>."

#: index.docbook:1136
msgid ""
      "<![CDATA[<version\n"
      "        column=\"version_column\"\n"
      "        name=\"propertyName\"\n"
      "        type=\"typename\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        unsaved-value=\"null|negative|undefined\"\n"
      "        generated=\"never|always\"\n"
      "        insert=\"true|false\"\n"
      "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
      "/>]]>"
msgstr "<literal>not-null</literal> (optionnel): Génère le DDL d'une contrainte de non nullité pour les colonnes."

#: index.docbook:1139
msgid "<literal>column</literal> (optional - defaults to the property name): The name of the column holding the version number."
msgstr "<literal>optimistic-lock</literal> (optionnel - par défaut à <literal>true</literal>): Indique que les mises à jour de cette propriété peuvent ou non nécessiter l'acquisition d'un verrou optimiste. En d'autres termes, cela détermine s'il est nécessaire d'incrémenter un numéro de version quand cette propriété est marquée obsolète (dirty)."

#: index.docbook:1145
msgid "<literal>name</literal>: The name of a property of the persistent class."
msgstr "<literal>generated</literal> (optional - défaut à<literal>never</literal>): Indique que la valeur de ce timestamp est générée par la base de données cf. <xref linkend=\"mapping-generated\"/>generated properties."

#: index.docbook:1150
msgid "<literal>type</literal> (optional - defaults to <literal>integer</literal>): The type of the version number."
msgstr "<emphasis>typename</emphasis> peut être:"

#: index.docbook:1162
msgid "<literal>unsaved-value</literal> (optional - defaults to <literal>undefined</literal>): A version property value that indicates that an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. (<literal>undefined</literal> specifies that the identifier property value should be used.)"
msgstr "Nom d'une classe Java avec un type basique par défaut (ex: <literal>int, float, char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</literal>)."

#: index.docbook:1171
msgid "<literal>generated</literal> (optional - defaults to <literal>never</literal>): Specifies that this version property value is actually generated by the database. See the discussion of <xref linkend=\"mapping-generated\"/>generated properties."
msgstr "Nom d'une classe Java sérialisable."

#: index.docbook:1178
msgid "<literal>insert</literal> (optional - defaults to <literal>true</literal>): Specifies whether the version column should be included in SQL insert statements. May be set to <literal>false</literal> if and only if the database column is defined with a default value of <literal>0</literal>."
msgstr "Nom d'une classe ayant un type spécifique (ex: <literal>com.illflow.type.MyCustomType</literal>)."

#: index.docbook:1188
msgid "Version numbers may be of Hibernate type <literal>long</literal>, <literal>integer</literal>, <literal>short</literal>, <literal>timestamp</literal> or <literal>calendar</literal>."
msgstr "Si vous n'indiquez pas un type, Hibernate utlisera la réflexion sur le nom de la propriété pour tenter de trouver le type Hibernate correct. Hibernate essayera d'interprêter le nom de la classe retournée par le getter de la propriété en utilisant les régles 2, 3, 4 dans cet ordre. Cependant, ce n'est pas toujours suffisant. Dans certains cas vous aurez encore besoin de l'attribut <literal>type</literal> (Par exemple, pour distinguer <literal>Hibernate.DATE</literal> et <literal>Hibernate.TIMESTAMP</literal>, ou pour préciser un type spécifique)."

#: index.docbook:1193
msgid "A version or timestamp property should never be null for a detached instance, so Hibernate will detect any instance with a null version or timestamp as transient, no matter what other <literal>unsaved-value</literal> strategies are specified. <emphasis>Declaring a nullable version or timestamp property is an easy way to avoid any problems with transitive reattachment in Hibernate, especially useful for people using assigned identifiers or composite keys!</emphasis>"
msgstr "L'attribut <literal>access</literal> permet de contrôler comment Hibernate accèdera à la propriété à l'exécution. Par défaut, Hibernate utilisera les méthodes set/get. Si vous indiquez <literal>access=\"field\"</literal>, Hibernate ignorera les getter/setter et accèdera à la propriété directement en utilisant la réflexion. Vous pouvez spécifier votre propre stratégie d'accès aux propriété en donnant une classe qui implémente l'interface <literal>org.hibernate.property.PropertyAccessor</literal>."

#: index.docbook:1204
msgid "timestamp (optional)"
msgstr "Une fonctionnalité particulièrement intéressante est les propriétés dérivées. Ces propriétés sont par définition en lecture seule, la valeur de la propriété est calculée au chargement. Le calcul est déclaré comme une expression SQL, qui se traduit par une sous-requête <literal>SELECT</literal> dans la requête SQL qui charge une instance :"

#: index.docbook:1206
msgid "The optional <literal>&lt;timestamp&gt;</literal> element indicates that the table contains timestamped data. This is intended as an alternative to versioning. Timestamps are by nature a less safe implementation of optimistic locking. However, sometimes the application might use the timestamps in other ways."
msgstr ""
      "<![CDATA[\n"
      "<property name=\"totalPrice\"\n"
      "    formula=\"( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product p\n"
      "                WHERE li.productId = p.productId\n"
      "                AND li.customerId = customerId\n"
      "                AND li.orderNumber = orderNumber )\"/>]]>"

#: index.docbook:1222
msgid ""
      "<![CDATA[<timestamp\n"
      "        column=\"timestamp_column\"\n"
      "        name=\"propertyName\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        unsaved-value=\"null|undefined\"\n"
      "        source=\"vm|db\"\n"
      "        generated=\"never|always\"\n"
      "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
      "/>]]>"
msgstr "Remarquez que vous pouvez référencer la propre table des entités en ne déclarant pas un alias sur une colonne particulière (<literal>customerId</literal> dans l'exemple donné). Notez aussi que vous pouvez utiliser le sous-élément de mapping <literal>&lt;formula&gt;</literal> plutôt que d'utiliser l'attribut si vous le souhaitez."

#: index.docbook:1225
msgid "<literal>column</literal> (optional - defaults to the property name): The name of a column holding the timestamp."
msgstr "many-to-one"

#: index.docbook:1231
msgid "<literal>name</literal>: The name of a JavaBeans style property of Java type <literal>Date</literal> or <literal>Timestamp</literal> of the persistent class."
msgstr "Une association ordinaire vers une autre classe persistante est déclarée en utilisant un élément <literal>many-to-one</literal>. Le modèle relationnel est une association de type many-to-one : une clef étrangère dans une table référence la ou les clef(s) primaire(s) dans la table cible."

#: index.docbook:1244
msgid "<literal>unsaved-value</literal> (optional - defaults to <literal>null</literal>): A version property value that indicates that an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. (<literal>undefined</literal> specifies that the identifier property value should be used.)"
msgstr "<literal>name</literal> : Nom de la propriété."

#: index.docbook:1253
msgid "<literal>source</literal> (optional - defaults to <literal>vm</literal>): From where should Hibernate retrieve the timestamp value? From the database, or from the current JVM? Database-based timestamps incur an overhead because Hibernate must hit the database in order to determine the \"next value\", but will be safer for use in clustered environments. Note also, that not all <literal>Dialect</literal>s are known to support retrieving of the database's current timestamp, while others might be unsafe for usage in locking due to lack of precision (Oracle 8 for example)."
msgstr "<literal>column</literal> (optionnel) : Le nom de la clef étrangère. Cela peut être aussi indiqué avec le sous-élément <literal>&lt;column&gt;</literal>."

#: index.docbook:1265
msgid "<literal>generated</literal> (optional - defaults to <literal>never</literal>): Specifies that this timestamp property value is actually generated by the database. See the discussion of <xref linkend=\"mapping-generated\"/>generated properties."
msgstr "<literal>class</literal> (optionnel - par défaut le type de la propriété déterminé par réflexion) : Le nom de la classe associée."

#: index.docbook:1274
msgid "Note that <literal>&lt;timestamp&gt;</literal> is equivalent to <literal>&lt;version type=\"timestamp\"&gt;</literal>. And <literal>&lt;timestamp source=\"db\"&gt;</literal> is equivalent to <literal>&lt;version type=\"dbtimestamp\"&gt;</literal>"
msgstr "<literal>cascade</literal> (optionnel) : Indique quelles opérations doivent être propagées de l'objet père vers les objets associés."

#: index.docbook:1284
msgid "property"
msgstr "<literal>fetch</literal> (optionnel - par défaut à <literal>select</literal>) : Choisit entre le chargement de type outer-join ou le chargement par select successifs."

#: index.docbook:1286
msgid "The <literal>&lt;property&gt;</literal> element declares a persistent, JavaBean style property of the class."
msgstr "<literal>update, insert</literal> (optionnel - par défaut à <literal>true</literal>) : indique que les colonnes mappées devraient être incluses dans des <literal>UPDATE</literal> SQL et/ou des <literal>INSERT</literal>. Mettre les deux à <literal>false</literal> empêche la propagation en base de données (utile si vous savez qu'un trigger affectera la valeur à la colonne)."

#: index.docbook:1308
msgid ""
      "<![CDATA[<property\n"
      "        name=\"propertyName\"\n"
      "        column=\"column_name\"\n"
      "        type=\"typename\"\n"
      "        update=\"true|false\"\n"
      "        insert=\"true|false\"\n"
      "        formula=\"arbitrary SQL expression\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        lazy=\"true|false\"\n"
      "        unique=\"true|false\"\n"
      "        not-null=\"true|false\"\n"
      "        optimistic-lock=\"true|false\"\n"
      "        generated=\"never|insert|always\"\n"
      "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
      "        index=\"index_name\"\n"
      "        unique_key=\"unique_key_id\"\n"
      "        length=\"L\"\n"
      "        precision=\"P\"\n"
      "        scale=\"S\"\n"
      "/>]]>"
msgstr "<literal>property-ref</literal> : (optionnel) Le nom d'une propriété de la classe associée qui est liée à cette clef étrangère. Si ce n'est pas spécifié, la clef primaire de la classe associée est utilisée."

#: index.docbook:1311
msgid "<literal>name</literal>: the name of the property, with an initial lowercase letter."
msgstr "<literal>access</literal> (optionnel - par défaut à <literal>property</literal>) : La stratégie à utiliser par Hibernate pour accéder à la valeur de cette propriété."

#: index.docbook:1317
msgid "<literal>column</literal> (optional - defaults to the property name): the name of the mapped database table column. This may also be specified by nested <literal>&lt;column&gt;</literal> element(s)."
msgstr "<literal>unique</literal> (optionnel) : Génère le DDL d'une contrainte d'unicité pour la clef étrangère. Permet aussi d'en faire la cible d'un <literal>property-ref</literal>. Cela permet de créer une véritable association one-to-one."

#: index.docbook:1324
msgid "<literal>type</literal> (optional): a name that indicates the Hibernate type."
msgstr "<literal>not-null</literal> (optionnel) : Génère le DDL pour une contrainte de non nullité pour la clef étrangère."

#: index.docbook:1329
msgid "<literal>update, insert</literal> (optional - defaults to <literal>true</literal>) : specifies that the mapped columns should be included in SQL <literal>UPDATE</literal> and/or <literal>INSERT</literal> statements. Setting both to <literal>false</literal> allows a pure \"derived\" property whose value is initialized from some other property that maps to the same colum(s) or by a trigger or other application."
msgstr "<literal>optimistic-lock</literal> (optionnel - par défaut à <literal>true</literal>) : Indique que les mises à jour de cette propriété requièrent ou non l'acquisition d'un verrou optimiste. En d'autres termes, détermine si un incrément de version doit avoir lieu quand la propriété est marquée obsolète (dirty)."

#: index.docbook:1338
msgid "<literal>formula</literal> (optional): an SQL expression that defines the value for a <emphasis>computed</emphasis> property. Computed properties do not have a column mapping of their own."
msgstr "<literal>lazy</literal> (optionnel - par défaut à <literal>false</literal>) : Indique que cette propriété doit être chargée en différé (lazy loading) au premier accès à la variable d'instance (nécessite une instrumentation du bytecode lors de la phase de construction). Remarquez que cela n'influence pas le comportement du proxy Hibernate - comme l'attribut <literal>lazy</literal> sur des classes ou des mappings de collections, mais utilise l'interception pour le chargement différé. <literal>lazy=\"false\"</literal> indique que l'association sera toujours chargée."

#: index.docbook:1351
msgid "<literal>lazy</literal> (optional - defaults to <literal>false</literal>): Specifies that this property should be fetched lazily when the instance variable is first accessed (requires build-time bytecode instrumentation)."
msgstr "<literal>entity-name</literal> (optionnel) : Le nom de l'entité de la classe associée."

#: index.docbook:1358
msgid "<literal>unique</literal> (optional): Enable the DDL generation of a unique constraint for the columns. Also, allow this to be the target of a <literal>property-ref</literal>."
msgstr "<literal>formula</literal> (optionnel) : une expression SQL qui définit la valeur pour une clé étrangère calculée."

#: index.docbook:1365
msgid "<literal>not-null</literal> (optional): Enable the DDL generation of a nullability constraint for the columns."
msgstr "Donner une valeur significative à l'attribut <literal>cascade</literal> autre que <literal>none</literal> propagera certaines opérations à l'objet associé. Les valeurs significatives sont les noms des opérations Hibernate basiques, <literal>persist, merge, delete, save-update, evict, replicate, lock, refresh</literal>, ainsi que les valeurs spéciales <literal>delete-orphan</literal> et <literal>all</literal> et des combinaisons de noms d'opérations séparées par des virgules, comme par exemple <literal>cascade=\"persist,merge,evict\"</literal> ou <literal>cascade=\"all,delete-orphan\"</literal>. Voir <xref linkend=\"objectstate-transitive\"/> pour une explication complète. Notez que les assocations many-to-one et one-to-one ne supportent pas orphan delete."

#: index.docbook:1371
msgid "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>): Specifies that updates to this property do or do not require acquisition of the optimistic lock. In other words, determines if a version increment should occur when this property is dirty."
msgstr "Une déclaration <literal>many-to-one</literal> typique est aussi simple que :"

#: index.docbook:1379
msgid "<literal>generated</literal> (optional - defaults to <literal>never</literal>): Specifies that this property value is actually generated by the database. See the discussion of <xref linkend=\"mapping-generated\"/>generated properties."
msgstr "<![CDATA[<many-to-one name=\"product\" class=\"Product\" column=\"PRODUCT_ID\"/>]]>"

#: index.docbook:1388
msgid "<emphasis>typename</emphasis> could be:"
msgstr "L'attribut <literal>property-ref</literal> devrait être utilisé pour mapper seulement des données provenant d'un ancien système où les clefs étrangères font référence à une clef unique de la table associée et qui n'est pas la clef primaire. C'est un cas de mauvaise conception relationnelle. Par exemple, supposez que la classe <literal>Product</literal> a un numéro de série unique qui n'est pas la clef primaire. (L'attribut <literal>unique</literal> contrôle la génération DDL par Hibernate avec l'outil SchemaExport.)"

#: index.docbook:1394
msgid "The name of a Hibernate basic type (eg. <literal>integer, string, character, date, timestamp, float, binary, serializable, object, blob</literal>)."
msgstr "<![CDATA[<property name=\"serialNumber\" unique=\"true\" type=\"string\" column=\"SERIAL_NUMBER\"/>]]>"

#: index.docbook:1400
msgid "The name of a Java class with a default basic type (eg. <literal>int, float, char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</literal>)."
msgstr "Ainsi le mapping pour <literal>OrderItem</literal> peut utiliser :"

#: index.docbook:1406
msgid "The name of a serializable Java class."
msgstr "<![CDATA[<many-to-one name=\"product\" property-ref=\"serialNumber\" column=\"PRODUCT_SERIAL_NUMBER\"/>]]>"

#: index.docbook:1411
msgid "The class name of a custom type (eg. <literal>com.illflow.type.MyCustomType</literal>)."
msgstr "bien que ce ne soit certainement pas encouragé."

#: index.docbook:1417
msgid "If you do not specify a type, Hibernate will use reflection upon the named property to take a guess at the correct Hibernate type. Hibernate will try to interpret the name of the return class of the property getter using rules 2, 3, 4 in that order. However, this is not always enough. In certain cases you will still need the <literal>type</literal> attribute. (For example, to distinguish between <literal>Hibernate.DATE</literal> and <literal>Hibernate.TIMESTAMP</literal>, or to specify a custom type.)"
msgstr "Si la clef unique référencée comprend des propriétés multiples de l'entité associée, vous devez mapper ces propriétés à l'intérieur d'un élément <literal>&lt;properties&gt;</literal>."

#: index.docbook:1427
msgid "The <literal>access</literal> attribute lets you control how Hibernate will access the property at runtime. By default, Hibernate will call the property get/set pair. If you specify <literal>access=\"field\"</literal>, Hibernate will bypass the get/set pair and access the field directly, using reflection. You may specify your own strategy for property access by naming a class that implements the interface <literal>org.hibernate.property.PropertyAccessor</literal>."
msgstr "one-to-one"

#: index.docbook:1436
msgid "An especially powerful feature are derived properties. These properties are by definition read-only, the property value is computed at load time. You declare the computation as a SQL expression, this translates to a <literal>SELECT</literal> clause subquery in the SQL query that loads an instance:"
msgstr "Une association one-to-one vers une autre classe persistante est déclarée avec l'élément <literal>one-to-one</literal>."

#: index.docbook:1443
msgid ""
      "<![CDATA[\n"
      "<property name=\"totalPrice\"\n"
      "    formula=\"( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product p\n"
      "                WHERE li.productId = p.productId\n"
      "                AND li.customerId = customerId\n"
      "                AND li.orderNumber = orderNumber )\"/>]]>"
msgstr ""
      "<![CDATA[<one-to-one\n"
      "        name=\"propertyName\"\n"
      "        class=\"ClassName\"\n"
      "        cascade=\"cascade_style\"\n"
      "        constrained=\"true|false\"\n"
      "        fetch=\"join|select\"\n"
      "        property-ref=\"propertyNameFromAssociatedClass\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        formula=\"any SQL expression\"\n"
      "        entity-name=\"EntityName\"\n"
      "/>]]>"

#: index.docbook:1445
msgid "Note that you can reference the entities own table by not declaring an alias on a particular column (<literal>customerId</literal> in the given example). Also note that you can use the nested <literal>&lt;formula&gt;</literal> mapping element if you don't like to use the attribute."
msgstr "<literal>name</literal> : Le nom de la propriété."

#: index.docbook:1455
msgid "many-to-one"
msgstr "<literal>class</literal> (optionnel - par défaut du type de la propriété déterminé par réflexion) : Le nom de la classe associée."

#: index.docbook:1457
msgid "An ordinary association to another persistent class is declared using a <literal>many-to-one</literal> element. The relational model is a many-to-one association: a foreign key in one table is referencing the primary key column(s) of the target table."
msgstr "<literal>cascade</literal> (optionnel) : Indique quelles opérations doivent être cascadées de l'objet père vers l'objet associé."

#: index.docbook:1485
msgid ""
      "<![CDATA[<many-to-one\n"
      "        name=\"propertyName\"\n"
      "        column=\"column_name\"\n"
      "        class=\"ClassName\"\n"
      "        cascade=\"cascade_style\"\n"
      "        fetch=\"join|select\"\n"
      "        update=\"true|false\"\n"
      "        insert=\"true|false\"\n"
      "        property-ref=\"propertyNameFromAssociatedClass\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        unique=\"true|false\"\n"
      "        not-null=\"true|false\"\n"
      "        optimistic-lock=\"true|false\"\n"
      "        lazy=\"proxy|no-proxy|false\"\n"
      "        not-found=\"ignore|exception\"\n"
      "        entity-name=\"EntityName\"\n"
      "        formula=\"arbitrary SQL expression\"\n"
      "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
      "        embed-xml=\"true|false\"\n"
      "        index=\"index_name\"\n"
      "        unique_key=\"unique_key_id\"\n"
      "        foreign-key=\"foreign_key_name\"\n"
      "/>]]>"
msgstr "<literal>constrained</literal> (optionnel) : Indique qu'une contrainte de clef étrangère sur la clef primaire de la table mappée référence la table de la classe associée. Cette option affecte l'ordre dans lequel chaque <literal>save()</literal> et chaque <literal>delete()</literal> sont cascadés et détermine si l'association peut utiliser un proxy (aussi utilisé par l'outil d'export de schéma)."

#: index.docbook:1488, index.docbook:1669, index.docbook:1855
msgid "<literal>name</literal>: The name of the property."
msgstr "<literal>fetch</literal> (optionnel - par défaut à <literal>select</literal>) : Choisit entre récupération par jointure externe ou select séquentiel."

#: index.docbook:1493, index.docbook:2284
msgid "<literal>column</literal> (optional): The name of the foreign key column. This may also be specified by nested <literal>&lt;column&gt;</literal> element(s)."
msgstr "<literal>property-ref</literal> (optionnel) : Le nom de la propriété de la classe associée qui est jointe à la clef primaire de cette classe. Si ce n'est pas spécifié, la clef primaire de la classe associée est utilisée."

#: index.docbook:1500, index.docbook:1674
msgid "<literal>class</literal> (optional - defaults to the property type determined by reflection): The name of the associated class."
msgstr "<literal>access</literal> (optionnel - par défaut à <literal>property</literal>) : La stratégie à utiliser par Hibernate pour accéder à la valeur de la propriété."

#: index.docbook:1506
msgid "<literal>cascade</literal> (optional): Specifies which operations should be cascaded from the parent object to the associated object."
msgstr "<literal>formula</literal> (optionnel) : Presque toutes les associations one-to-one pointent sur la clef primaire de l'entité propriétaire. Dans les rares cas différents, vous devez donner une ou plusieurs autres colonnes ou expression à joindre par une formule SQL (voir <literal>org.hibernate.test.onetooneformula</literal> pour un exemple)."

#: index.docbook:1512, index.docbook:1695
msgid "<literal>fetch</literal> (optional - defaults to <literal>select</literal>): Chooses between outer-join fetching or sequential select fetching."
msgstr "<literal>lazy</literal> (optionnel - par défaut <literal>proxy</literal>) : Par défaut, les associations simples sont soumise à proxy. <literal>lazy=\"no-proxy\"</literal> spécifie que la propriété doit être chargée à la demande au premier accès à l'instance. (nécessite l'intrumentation du bytecode à la construction). <literal>lazy=\"false\"</literal> indique que l'association sera toujours chargée agressivement. <emphasis>Notez que si <literal>constrained=\"false\"</literal>, l'utilisation de proxy est impossible et Hibernate chargera automatiquement l'association !</emphasis>"

#: index.docbook:1518
msgid "<literal>update, insert</literal> (optional - defaults to <literal>true</literal>) specifies that the mapped columns should be included in SQL <literal>UPDATE</literal> and/or <literal>INSERT</literal> statements. Setting both to <literal>false</literal> allows a pure \"derived\" association whose value is initialized from some other property that maps to the same colum(s) or by a trigger or other application."
msgstr "<literal>entity-name</literal> (optional) : The entity name of the associated class."

#: index.docbook:1527
msgid "<literal>property-ref</literal>: (optional) The name of a property of the associated class that is joined to this foreign key. If not specified, the primary key of the associated class is used."
msgstr "Il existe deux types d'associations one-to-one :"

#: index.docbook:1540
msgid "<literal>unique</literal> (optional): Enable the DDL generation of a unique constraint for the foreign-key column. Also, allow this to be the target of a <literal>property-ref</literal>. This makes the association multiplicity effectively one to one."
msgstr "association par clef étrangère unique"

#: index.docbook:1548
msgid "<literal>not-null</literal> (optional): Enable the DDL generation of a nullability constraint for the foreign key columns."
msgstr "Les associations par clef primaire ne nécessitent pas une colonne supplémentaire en table ; si deux lignes sont liés par l'association alors les deux lignes de la table partagent la même valeur de clef primaire. Donc si vous voulez que deux objets soient liés par une association par clef primaire, vous devez faire en sorte qu'on leur assigne la même valeur d'identifiant !"

#: index.docbook:1554
msgid "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>): Specifies that updates to this property do or do not require acquisition of the optimistic lock. In other words, dertermines if a version increment should occur when this property is dirty."
msgstr "Pour une association par clef primaire, ajoutez les mappings suivants à <literal>Employee</literal> et <literal>Person</literal>, respectivement."

#: index.docbook:1562
msgid "<literal>lazy</literal> (optional - defaults to <literal>proxy</literal>): By default, single point associations are proxied. <literal>lazy=\"no-proxy\"</literal> specifies that the property should be fetched lazily when the instance variable is first accessed (requires build-time bytecode instrumentation). <literal>lazy=\"false\"</literal> specifies that the association will always be eagerly fetched."
msgstr "<![CDATA[<one-to-one name=\"person\" class=\"Person\"/>]]>"

#: index.docbook:1572
msgid "<literal>not-found</literal> (optional - defaults to <literal>exception</literal>): Specifies how foreign keys that reference missing rows will be handled: <literal>ignore</literal> will treat a missing row as a null association."
msgstr "<![CDATA[<one-to-one name=\"employee\" class=\"Employee\" constrained=\"true\"/>]]>"

#: index.docbook:1579, index.docbook:1733
msgid "<literal>entity-name</literal> (optional): The entity name of the associated class."
msgstr "Maintenant, vous devez faire en sorte que les clefs primaires des lignes liées dans les tables PERSON et EMPLOYEE sont égales. On utilise une stratégie Hibernate spéciale de génération d'identifiants appelée <literal>foreign</literal> :"

#: index.docbook:1585
msgid "<literal>formula</literal> (optional): an SQL expression that defines the value for a <emphasis>computed</emphasis> foreign key."
msgstr ""
      "<![CDATA[<class name=\"person\" table=\"PERSON\">\n"
      "    <id name=\"id\" column=\"PERSON_ID\">\n"
      "        <generator class=\"foreign\">\n"
      "            <param name=\"property\">employee</param>\n"
      "        </generator>\n"
      "    </id>\n"
      "    ...\n"
      "    <one-to-one name=\"employee\"\n"
      "        class=\"Employee\"\n"
      "        constrained=\"true\"/>\n"
      "</class>]]>"

#: index.docbook:1592
msgid "Setting a value of the <literal>cascade</literal> attribute to any meaningful value other than <literal>none</literal> will propagate certain operations to the associated object. The meaningful values are the names of Hibernate's basic operations, <literal>persist, merge, delete, save-update, evict, replicate, lock, refresh</literal>, as well as the special values <literal>delete-orphan</literal> and <literal>all</literal> and comma-separated combinations of operation names, for example, <literal>cascade=\"persist,merge,evict\"</literal> or <literal>cascade=\"all,delete-orphan\"</literal>. See <xref linkend=\"objectstate-transitive\"/> for a full explanation. Note that single valued associations (many-to-one and one-to-one associations) do not support orphan delete."
msgstr "Une instance fraîchement enregistrée de <literal>Person</literal> se voit alors assignée la même valeur de clef primaire que l'instance de <literal>Employee</literal> référencée par la propriété <literal>employee</literal> de cette <literal>Person</literal>."

#: index.docbook:1605
msgid "A typical <literal>many-to-one</literal> declaration looks as simple as this:"
msgstr "Alternativement, une clef étrangère avec contrainte d'unicité de <literal>Employee</literal> vers <literal>Person</literal> peut être indiquée ainsi :"

#: index.docbook:1609
msgid "<![CDATA[<many-to-one name=\"product\" class=\"Product\" column=\"PRODUCT_ID\"/>]]>"
msgstr "<![CDATA[<many-to-one name=\"person\" class=\"Person\" column=\"PERSON_ID\" unique=\"true\"/>]]>"

#: index.docbook:1611
msgid "The <literal>property-ref</literal> attribute should only be used for mapping legacy data where a foreign key refers to a unique key of the associated table other than the primary key. This is an ugly relational model. For example, suppose the <literal>Product</literal> class had a unique serial number, that is not the primary key. (The <literal>unique</literal> attribute controls Hibernate's DDL generation with the SchemaExport tool.)"
msgstr "Et cette association peut être rendue bidirectionnelle en ajoutant ceci au mapping de <literal>Person</literal> :"

#: index.docbook:1620
msgid "<![CDATA[<property name=\"serialNumber\" unique=\"true\" type=\"string\" column=\"SERIAL_NUMBER\"/>]]>"
msgstr "<![CDATA[<one-to-one name=\"employee\" class=\"Employee\" property-ref=\"person\"/>]]>"

#: index.docbook:1622
msgid "Then the mapping for <literal>OrderItem</literal> might use:"
msgstr "natural-id"

#: index.docbook:1626
msgid "<![CDATA[<many-to-one name=\"product\" property-ref=\"serialNumber\" column=\"PRODUCT_SERIAL_NUMBER\"/>]]>"
msgstr ""
      "<![CDATA[<natural-id mutable=\"true|false\"/>\n"
      "        <property ... />\n"
      "        <many-to-one ... />\n"
      "        ......\n"
      "</natural-id>]]>"

#: index.docbook:1628
msgid "This is certainly not encouraged, however."
msgstr "Bien que nous recommandions l'utilisation de clé primaire générée, vous devriez toujours essayer d'identifier des clé métier (naturelles) pour toutes vos entités. Une clé naturelle est une propriété ou une combinaison de propriétés uniques et non nulles. Si elle est aussi immuable, c'est encore mieux. Mappez les propriétés de la clé naturelle dans l'élément <literal>&lt;natural-id&gt;</literal>. Hibernate générera la clé unique nécessaire et les contraintes de non-nullité, et votre mapping s'auto-documentera."

#: index.docbook:1632
msgid "If the referenced unique key comprises multiple properties of the associated entity, you should map the referenced properties inside a named <literal>&lt;properties&gt;</literal> element."
msgstr "Nous vous recommandons fortement d'implémenter <literal>equals()</literal> et <literal>hashCode()</literal> pour comparer les clés naturelles de l'entité."

#: index.docbook:1637
msgid "If the referenced unique key is the property of a component, you may specify a property path:"
msgstr "Ce mapping n'est pas destiné à être utilisé avec des entités qui ont des clés naturelles."

#: index.docbook:1641
msgid "<![CDATA[<many-to-one name=\"owner\" property-ref=\"identity.ssn\" column=\"OWNER_SSN\"/>]]>"
msgstr "<literal>mutable</literal> (optionel, par défaut à <literal>false</literal>) : Par défaut, les identifiants naturels sont supposés être immuable (constants)."

#: index.docbook:1646
msgid "one-to-one"
msgstr "component, dynamic-component"

#: index.docbook:1648
msgid "A one-to-one association to another persistent class is declared using a <literal>one-to-one</literal> element."
msgstr "L'élément <literal>&lt;component&gt;</literal> mappe les propriétés d'un objet fils aux colonnes d'une classe parente. Les composants peuvent en retour déclarer leurs propres propriétés, composants ou collections. Voir \"Components\" plus bas."

#: index.docbook:1666
msgid ""
      "<![CDATA[<one-to-one\n"
      "        name=\"propertyName\"\n"
      "        class=\"ClassName\"\n"
      "        cascade=\"cascade_style\"\n"
      "        constrained=\"true|false\"\n"
      "        fetch=\"join|select\"\n"
      "        property-ref=\"propertyNameFromAssociatedClass\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        formula=\"any SQL expression\"\n"
      "        lazy=\"proxy|no-proxy|false\"\n"
      "        entity-name=\"EntityName\"\n"
      "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
      "        embed-xml=\"true|false\"\n"
      "        foreign-key=\"foreign_key_name\"\n"
      "/>]]>"
msgstr ""
      "<![CDATA[<component \n"
      "        name=\"propertyName\" \n"
      "        class=\"className\"\n"
      "        insert=\"true|false\"\n"
      "        update=\"true|false\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        lazy=\"true|false\"\n"
      "        optimistic-lock=\"true|false\"\n"
      "        unique=\"true|false\"\n"
      ">\n"
      "        \n"
      "        <property ...../>\n"
      "        <many-to-one .... />\n"
      "        ........\n"
      "</component>]]>"

#: index.docbook:1680
msgid "<literal>cascade</literal> (optional) specifies which operations should be cascaded from the parent object to the associated object."
msgstr "<literal>insert</literal> : Est ce que les colonnes mappées apparaissent dans les <literal>INSERT</literal>s ?"

#: index.docbook:1686
msgid "<literal>constrained</literal> (optional) specifies that a foreign key constraint on the primary key of the mapped table references the table of the associated class. This option affects the order in which <literal>save()</literal> and <literal>delete()</literal> are cascaded, and determines whether the association may be proxied (it is also used by the schema export tool)."
msgstr "<literal>update</literal>: Est ce que les colonnes mappées apparaissent dans les <literal>UPDATE</literal>s ?"

#: index.docbook:1701
msgid "<literal>property-ref</literal>: (optional) The name of a property of the associated class that is joined to the primary key of this class. If not specified, the primary key of the associated class is used."
msgstr "<literal>lazy</literal> (optionnel - par défaut à <literal>false</literal>) : Indique que ce composant doit être chargé au premier accès à la variable d'instance (nécessite une instrumentation du bytecode au moment du build)."

#: index.docbook:1714
msgid "<literal>formula</literal> (optional): Almost all one to one associations map to the primary key of the owning entity. In the rare case that this is not the case, you may specify a some other column, columns or expression to join on using an SQL formula. (See <literal>org.hibernate.test.onetooneformula</literal> for an example.)"
msgstr "<literal>unique</literal> (optionnel - par défaut à <literal>false</literal>) : Indique qu'une contrainte d'unicité existe sur toutes les colonnes mappées de ce composant."

#: index.docbook:1722
msgid "<literal>lazy</literal> (optional - defaults to <literal>proxy</literal>): By default, single point associations are proxied. <literal>lazy=\"no-proxy\"</literal> specifies that the property should be fetched lazily when the instance variable is first accessed (requires build-time bytecode instrumentation). <literal>lazy=\"false\"</literal> specifies that the association will always be eagerly fetched. <emphasis>Note that if <literal>constrained=\"false\"</literal>, proxying is impossible and Hibernate will eager fetch the association!</emphasis>"
msgstr "Les tags fils <literal>&lt;property&gt;</literal> mappent les propriétés de la classe fille sur les colonnes de la table."

#: index.docbook:1740
msgid "There are two varieties of one-to-one association:"
msgstr "L'élément <literal>&lt;dynamic-component&gt;</literal> permet à une <literal>Map</literal> d'être mappée comme un composant, quand les noms de la propriété font référence aux clefs de cette Map, voir <xref linkend=\"components-dynamic\"/>."

#: index.docbook:1744
msgid "primary key associations"
msgstr "properties"

#: index.docbook:1747
msgid "unique foreign key associations"
msgstr "L'élément <literal>&lt;properties&gt;</literal> permet la définition d'un groupement logique nommé des propriétés d'une classe. L'utilisation la plus importante de cette construction est la possibilité pour une combinaison de propriétés d'être la cible d'un <literal>property-ref</literal>. C'est aussi un moyen pratique de définir une contrainte d'unicité multi-colonnes."

#: index.docbook:1752
msgid "Primary key associations don't need an extra table column; if two rows are related by the association then the two table rows share the same primary key value. So if you want two objects to be related by a primary key association, you must make sure that they are assigned the same identifier value!"
msgstr ""
      "<![CDATA[<properties \n"
      "        name=\"logicalName\" \n"
      "        insert=\"true|false\"\n"
      "        update=\"true|false\"\n"
      "        optimistic-lock=\"true|false\"\n"
      "        unique=\"true|false\"\n"
      ">\n"
      "        \n"
      "        <property ...../>\n"
      "        <many-to-one .... />\n"
      "        ........\n"
      "</properties>]]>"

#: index.docbook:1759
msgid "For a primary key association, add the following mappings to <literal>Employee</literal> and <literal>Person</literal>, respectively."
msgstr "<literal>name</literal> : Le nom logique d'un regroupement et <emphasis>non</emphasis> le véritable nom d'une propriété."

#: index.docbook:1764
msgid "<![CDATA[<one-to-one name=\"person\" class=\"Person\"/>]]>"
msgstr "<literal>insert</literal> : Est-ce que les colonnes mappées apparaissent dans les <literal>INSERT</literal>s ?"

#: index.docbook:1765
msgid "<![CDATA[<one-to-one name=\"employee\" class=\"Employee\" constrained=\"true\"/>]]>"
msgstr "<literal>update</literal> : Est-ce que les colonnes mappées apparaissent dans les <literal>UPDATE</literal>s ?"

#: index.docbook:1767
msgid "Now we must ensure that the primary keys of related rows in the PERSON and EMPLOYEE tables are equal. We use a special Hibernate identifier generation strategy called <literal>foreign</literal>:"
msgstr "<literal>optimistic-lock</literal> (optionnel - par défaut à <literal>true</literal>) : Indique que les mises à jour sur ce composant nécessitent ou non l'acquisition d'un verrou optimiste. En d'autres termes, cela détermine si une incrémentation de version doit avoir lieu quand la propriété est marquée obsolète (dirty)."

#: index.docbook:1773
msgid ""
      "<![CDATA[<class name=\"person\" table=\"PERSON\">\n"
      "    <id name=\"id\" column=\"PERSON_ID\">\n"
      "        <generator class=\"foreign\">\n"
      "            <param name=\"property\">employee</param>\n"
      "        </generator>\n"
      "    </id>\n"
      "    ...\n"
      "    <one-to-one name=\"employee\"\n"
      "        class=\"Employee\"\n"
      "        constrained=\"true\"/>\n"
      "</class>]]>"
msgstr "<literal>unique</literal> (optionnel - par défaut à <literal>false</literal>) : Indique qu'une contrainte d'unicité existe sur toutes les colonnes mappées de ce composant."

#: index.docbook:1775
msgid "A newly saved instance of <literal>Person</literal> is then assigned the same primary key value as the <literal>Employee</literal> instance refered with the <literal>employee</literal> property of that <literal>Person</literal>."
msgstr "Par exemple, si nous avons le mapping de <literal>&lt;properties&gt;</literal> suivant :"

#: index.docbook:1781
msgid "Alternatively, a foreign key with a unique constraint, from <literal>Employee</literal> to <literal>Person</literal>, may be expressed as:"
msgstr ""
      "<![CDATA[<class name=\"Person\">\n"
      "    <id name=\"personNumber\"/>\n"
      "    ...\n"
      "    <properties name=\"name\" \n"
      "            unique=\"true\" update=\"false\">\n"
      "        <property name=\"firstName\"/>\n"
      "        <property name=\"initial\"/>\n"
      "        <property name=\"lastName\"/>\n"
      "    </properties>\n"
      "</class>]]>"

#: index.docbook:1786
msgid "<![CDATA[<many-to-one name=\"person\" class=\"Person\" column=\"PERSON_ID\" unique=\"true\"/>]]>"
msgstr "Alors nous pourrions avoir une association sur des données d'un ancien système (legacy) qui font référence à cette clef unique de la table <literal>Person</literal> au lieu de la clef primaire :"

#: index.docbook:1788
msgid "And this association may be made bidirectional by adding the following to the <literal>Person</literal> mapping:"
msgstr ""
      "<![CDATA[<many-to-one name=\"person\" \n"
      "         class=\"Person\" property-ref=\"name\">\n"
      "    <column name=\"firstName\"/>\n"
      "    <column name=\"initial\"/>\n"
      "    <column name=\"lastName\"/>\n"
      "</many-to-one>]]>"

#: index.docbook:1793
msgid "<![CDATA[<one-to-one name=\"employee\" class=\"Employee\" property-ref=\"person\"/>]]>"
msgstr "Nous ne recommandons pas l'utilisation de ce genre de chose en dehors du contexte de mapping de données héritées d'anciens systèmes."

#: index.docbook:1798
msgid "natural-id"
msgstr "subclass"

#: index.docbook:1800
msgid ""
      "<![CDATA[<natural-id mutable=\"true|false\"/>\n"
      "        <property ... />\n"
      "        <many-to-one ... />\n"
      "        ......\n"
      "</natural-id>]]>"
msgstr "Pour finir, la persistance polymorphique nécessite la déclaration de chaque sous-classe de la classe persistante de base. pour la stratégie de mapping de type table-per-class-hierarchy, on utilise la déclaration <literal>&lt;subclass&gt;</literal>."

#: index.docbook:1802
msgid "Even though we recommend the use of surrogate keys as primary keys, you should still try to identify natural keys for all entities. A natural key is a property or combination of properties that is unique and non-null. If it is also immutable, even better. Map the properties of the natural key inside the <literal>&lt;natural-id&gt;</literal> element. Hibernate will generate the necessary unique key and nullability constraints, and your mapping will be more self-documenting."
msgstr ""
      "<![CDATA[<subclass\n"
      "        name=\"ClassName\"\n"
      "        discriminator-value=\"discriminator_value\"\n"
      "        proxy=\"ProxyInterface\"\n"
      "        lazy=\"true|false\"\n"
      "        dynamic-update=\"true|false\"\n"
      "        dynamic-insert=\"true|false\"\n"
      "        entity-name=\"EntityName\"\n"
      "        node=\"element-name\"\n"
      "        extends=\"SuperclassName\">\n"
      "\n"
      "        <property .... />\n"
      "        .....\n"
      "</subclass>]]>"

#: index.docbook:1811
msgid "We strongly recommend that you implement <literal>equals()</literal> and <literal>hashCode()</literal> to compare the natural key properties of the entity."
msgstr "<literal>name</literal> : Le nom complet de la sous-classe."

#: index.docbook:1816
msgid "This mapping is not intended for use with entities with natural primary keys."
msgstr "<literal>discriminator-value</literal> (optionnel - par défaut le nom de la classe) : une valeur qui distingue les différentes sous-classes."

#: index.docbook:1822
msgid "<literal>mutable</literal> (optional, defaults to <literal>false</literal>): By default, natural identifier properties as assumed to be immutable (constant)."
msgstr "<literal>proxy</literal> (optionnel) : Indique une classe ou interface à utiliser pour les chargements à la demande des proxies (lazy)."

#: index.docbook:1832
msgid "component, dynamic-component"
msgstr "<literal>lazy</literal> (optionnel, par défaut à <literal>true</literal>) : Spécifier <literal>lazy=\"false\"</literal> désactive l'utilisation du chargement à la demande (lazy)."

#: index.docbook:1834
msgid "The <literal>&lt;component&gt;</literal> element maps properties of a child object to columns of the table of a parent class. Components may, in turn, declare their own properties, components or collections. See \"Components\" below."
msgstr "Chaque sous-classe devrait déclarer ses propres propriétés persistantes et sous-classes. Les propriétés <literal>&lt;version&gt;</literal> et <literal>&lt;id&gt;</literal> sont implicitement hérités de la classe de base. Chaque sous-classe dans une hiérarchie doit définir une unique <literal>discriminator-value</literal>. Si aucune n'est spécifiée, le nom complet de la classe Java est utilisé."

#: index.docbook:1852
msgid ""
      "<![CDATA[<component\n"
      "        name=\"propertyName\"\n"
      "        class=\"className\"\n"
      "        insert=\"true|false\"\n"
      "        update=\"true|false\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        lazy=\"true|false\"\n"
      "        optimistic-lock=\"true|false\"\n"
      "        unique=\"true|false\"\n"
      "        node=\"element-name|.\"\n"
      ">\n"
      "\n"
      "        <property ...../>\n"
      "        <many-to-one .... />\n"
      "        ........\n"
      "</component>]]>"
msgstr "Pour plus d'infos sur le mapping d'héritage, voir <xref linkend=\"inheritance\"/>."

#: index.docbook:1860
msgid "<literal>class</literal> (optional - defaults to the property type determined by reflection): The name of the component (child) class."
msgstr "Pour des informations sur les mappings d'héritage, voir <xref linkend=\"inheritance\"/>."

#: index.docbook:1866, index.docbook:1955
msgid "<literal>insert</literal>: Do the mapped columns appear in SQL <literal>INSERT</literal>s?"
msgstr "joined-subclass"

#: index.docbook:1872, index.docbook:1961
msgid "<literal>update</literal>: Do the mapped columns appear in SQL <literal>UPDATE</literal>s?"
msgstr "Une autre façon possible de faire est la suivante, chaque sous-classe peut être mappée vers sa propre table (stratégie de mapping de type table-per-subclass). L'état hérité est récupéré en joignant la table de la super-classe. L'élément <literal>&lt;joined-subclass&gt;</literal> est utilisé."

#: index.docbook:1884
msgid "<literal>lazy</literal> (optional - defaults to <literal>false</literal>): Specifies that this component should be fetched lazily when the instance variable is first accessed (requires build-time bytecode instrumentation)."
msgstr "<literal>name</literal> : Le nom Java complet de la sous-classe."

#: index.docbook:1891
msgid "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>): Specifies that updates to this component do or do not require acquisition of the optimistic lock. In other words, determines if a version increment should occur when this property is dirty."
msgstr "<literal>table</literal> : Le nom de la table de la sous-classe."

#: index.docbook:1899, index.docbook:1975
msgid "<literal>unique</literal> (optional - defaults to <literal>false</literal>): Specifies that a unique constraint exists upon all mapped columns of the component."
msgstr "<literal>proxy</literal> (optionnel) : Indique une classe ou interface pour le chargement différé des proxies."

#: index.docbook:1908
msgid "The child <literal>&lt;property&gt;</literal> tags map properties of the child class to table columns."
msgstr "<literal>lazy</literal> (optionnel, par défaut à <literal>true</literal>) : Indiquer <literal>lazy=\"false\"</literal> désactive l'utilisation du chargement à la demande."

#: index.docbook:1913
msgid "The <literal>&lt;component&gt;</literal> element allows a <literal>&lt;parent&gt;</literal> subelement that maps a property of the component class as a reference back to the containing entity."
msgstr "Aucune colonne discriminante n'est nécessaire pour cette stratégie de mapping. Cependant, chaque sous-classe doit déclarer une colonne de table contenant l'objet identifiant qui utilise l'élément <literal>&lt;key&gt;</literal>. Le mapping au début de ce chapitre serait ré-écrit ainsi :"

#: index.docbook:1919
msgid "The <literal>&lt;dynamic-component&gt;</literal> element allows a <literal>Map</literal> to be mapped as a component, where the property names refer to keys of the map, see <xref linkend=\"components-dynamic\"/>."
msgstr ""
      "<![CDATA[<?xml version=\"1.0\"?>\n"
      "<!DOCTYPE hibernate-mapping PUBLIC\n"
      "        \"-//Hibernate/Hibernate Mapping DTD//EN\"\n"
      "        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\">\n"
      "\n"
      "<hibernate-mapping package=\"eg\">\n"
      "\n"
      "        <class name=\"Cat\" table=\"CATS\">\n"
      "                <id name=\"id\" column=\"uid\" type=\"long\">\n"
      "                        <generator class=\"hilo\"/>\n"
      "                </id>\n"
      "                <property name=\"birthdate\" type=\"date\"/>\n"
      "                <property name=\"color\" not-null=\"true\"/>\n"
      "                <property name=\"sex\" not-null=\"true\"/>\n"
      "                <property name=\"weight\"/>\n"
      "                <many-to-one name=\"mate\"/>\n"
      "                <set name=\"kittens\">\n"
      "                        <key column=\"MOTHER\"/>\n"
      "                        <one-to-many class=\"Cat\"/>\n"
      "                </set>\n"
      "                <joined-subclass name=\"DomesticCat\" table=\"DOMESTIC_CATS\">\n"
      "                    <key column=\"CAT\"/>\n"
      "                    <property name=\"name\" type=\"string\"/>\n"
      "                </joined-subclass>\n"
      "        </class>\n"
      "\n"
      "        <class name=\"eg.Dog\">\n"
      "                <!-- mapping for Dog could go here -->\n"
      "        </class>\n"
      "\n"
      "</hibernate-mapping>]]>"

#: index.docbook:1928
msgid "properties"
msgstr "Pour des informations sur les mappings d'héritage, voir <xref linkend=\"inheritance\"/>."

#: index.docbook:1930
msgid "The <literal>&lt;properties&gt;</literal> element allows the definition of a named, logical grouping of properties of a class. The most important use of the construct is that it allows a combination of properties to be the target of a <literal>property-ref</literal>. It is also a convenient way to define a multi-column unique constraint."
msgstr "union-subclass"

#: index.docbook:1946
msgid ""
      "<![CDATA[<properties\n"
      "        name=\"logicalName\"\n"
      "        insert=\"true|false\"\n"
      "        update=\"true|false\"\n"
      "        optimistic-lock=\"true|false\"\n"
      "        unique=\"true|false\"\n"
      ">\n"
      "\n"
      "        <property ...../>\n"
      "        <many-to-one .... />\n"
      "        ........\n"
      "</properties>]]>"
msgstr "Une troisième option est de seulement mapper vers des tables les classes concrètes d'une hiérarchie d'héritage, (stratégie de type table-per-concrete-class) où chaque table définit tous les états persistants de la classe, y compris les états hérités. Dans Hibernate il n'est absolument pas nécessaire de mapper explicitement de telles hiérarchies d'héritage. Vous pouvez simplement mapper chaque classe avec une déclaration <literal>&lt;class&gt;</literal> différente. Cependant, si vous souhaitez utiliser des associations polymorphiques (càd une association vers la superclasse de la hiérarchie), vous devez utiliser le mapping <literal>&lt;union-subclass&gt;</literal>."

#: index.docbook:1949
msgid "<literal>name</literal>: The logical name of the grouping - <emphasis>not</emphasis> an actual property name."
msgstr ""
      "<![CDATA[<union-subclass\n"
      "        name=\"ClassName\"\n"
      "        table=\"tablename\"\n"
      "        proxy=\"ProxyInterface\"\n"
      "        lazy=\"true|false\"\n"
      "        dynamic-update=\"true|false\"\n"
      "        dynamic-insert=\"true|false\"\n"
      "        schema=\"schema\"\n"
      "        catalog=\"catalog\"\n"
      "        extends=\"SuperclassName\"\n"
      "        abstract=\"true|false\"\n"
      "        persister=\"ClassName\"\n"
      "        subselect=\"SQL expression\"\n"
      "        entity-name=\"EntityName\">\n"
      "\n"
      "        <property .... />\n"
      "        .....\n"
      "</union-subclass>]]>"

#: index.docbook:1967
msgid "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>): Specifies that updates to these properties do or do not require acquisition of the optimistic lock. In other words, determines if a version increment should occur when these properties are dirty."
msgstr "<literal>proxy</literal> (optionnel) : Indique une classe ou interface pour le chargement différé des proxies."

#: index.docbook:1984
msgid "For example, if we have the following <literal>&lt;properties&gt;</literal> mapping:"
msgstr "Aucune colonne discriminante ou colonne clef n'est requise pour cette stratégie de mapping."

#: index.docbook:1988
msgid ""
      "<![CDATA[<class name=\"Person\">\n"
      "    <id name=\"personNumber\"/>\n"
      "    ...\n"
      "    <properties name=\"name\"\n"
      "            unique=\"true\" update=\"false\">\n"
      "        <property name=\"firstName\"/>\n"
      "        <property name=\"initial\"/>\n"
      "        <property name=\"lastName\"/>\n"
      "    </properties>\n"
      "</class>]]>"
msgstr "Pour des informations sur les mappings d'héritage, voir <xref linkend=\"inheritance\"/>."

#: index.docbook:1990
msgid "Then we might have some legacy data association which refers to this unique key of the <literal>Person</literal> table, instead of to the primary key:"
msgstr "join"

#: index.docbook:1995
msgid ""
      "<![CDATA[<many-to-one name=\"person\"\n"
      "         class=\"Person\" property-ref=\"name\">\n"
      "    <column name=\"firstName\"/>\n"
      "    <column name=\"initial\"/>\n"
      "    <column name=\"lastName\"/>\n"
      "</many-to-one>]]>"
msgstr "En utilisant l'élément <literal>&lt;join&gt;</literal>, il est possible de mapper des propriétés d'une classe sur plusieurs tables."

#: index.docbook:1997
msgid "We don't recommend the use of this kind of thing outside the context of mapping legacy data."
msgstr ""
      "<![CDATA[<join\n"
      "        table=\"tablename\"\n"
      "        schema=\"owner\"\n"
      "        catalog=\"catalog\"\n"
      "        fetch=\"join|select\"\n"
      "        inverse=\"true|false\"\n"
      "        optionnel=\"true|false\">\n"
      "        \n"
      "        <key ... />\n"
      "        \n"
      "        <property ... />\n"
      "        ...\n"
      "</join>]]>"

#: index.docbook:2005
msgid "subclass"
msgstr "<literal>table</literal> : Le nom de la table jointe."

#: index.docbook:2007
msgid "Finally, polymorphic persistence requires the declaration of each subclass of the root persistent class. For the table-per-class-hierarchy mapping strategy, the <literal>&lt;subclass&gt;</literal> declaration is used."
msgstr "<literal>schema</literal> (optionnel) : court-circuite le nom de schéma spécifié par l'élément de base <literal>&lt;hibernate-mapping&gt;</literal>."

#: index.docbook:2020
msgid ""
      "<![CDATA[<subclass\n"
      "        name=\"ClassName\"\n"
      "        discriminator-value=\"discriminator_value\"\n"
      "        proxy=\"ProxyInterface\"\n"
      "        lazy=\"true|false\"\n"
      "        dynamic-update=\"true|false\"\n"
      "        dynamic-insert=\"true|false\"\n"
      "        entity-name=\"EntityName\"\n"
      "        node=\"element-name\"\n"
      "        extends=\"SuperclassName\">\n"
      "\n"
      "        <property .... />\n"
      "        .....\n"
      "</subclass>]]>"
msgstr "<literal>catalog</literal> (optionnel) : court-circuite le nom de catalogue spécifié par l'élément de base <literal>&lt;hibernate-mapping&gt;</literal>."

#: index.docbook:2023, index.docbook:2081, index.docbook:2144
msgid "<literal>name</literal>: The fully qualified class name of the subclass."
msgstr "<literal>fetch</literal> (optionnel - par défaut à <literal>join</literal>) : Si positionné à <literal>join</literal>, Hibernate utilisera une jointure interne pour charger une <literal>jointure</literal> définie par une classe ou ses super-classes et une jointure externe pour une <literal>&lt;jointure&gt;</literal> définie par une sous-classe. Si positionné à <literal>select</literal> alors Hibernate utilisera un select séquentiel pour une <literal>&lt;jointure&gt;</literal> définie sur une sous-classe, qui ne sera délivrée que si une ligne se représente une instance de la sous-classe. Les jointures internes seront quand même utilisées pour charger une <literal>&lt;jointure&gt;</literal> définie par une classe et ses super-classes."

#: index.docbook:2028
msgid "<literal>discriminator-value</literal> (optional - defaults to the class name): A value that distiguishes individual subclasses."
msgstr "<literal>inverse</literal> (optionnel - par défaut à <literal>false</literal>) : Si positionné à true, Hibernate n'essaiera pas d'insérer ou de mettre à jour les propriétés définies par cette jointure."

#: index.docbook:2034, index.docbook:2091, index.docbook:2154
msgid "<literal>proxy</literal> (optional): Specifies a class or interface to use for lazy initializing proxies."
msgstr "<literal>optionnel</literal> (optionnel - par défaut à <literal>false</literal>) : Si positionné à true, Hibernate insèrera une ligne seulement si les propriétés définies par cette jointure sont non-nulles et utilisera toujours une jointure externe pour charger les propriétés."

#: index.docbook:2040, index.docbook:2097, index.docbook:2160
msgid "<literal>lazy</literal> (optional, defaults to <literal>true</literal>): Setting <literal>lazy=\"false\"</literal> disables the use of lazy fetching."
msgstr "Par exemple, les informations d'adresse pour une personne peuvent être mappées vers une table séparée (tout en préservant des sémantiques de type valeur pour toutes ses propriétés) :"

#: index.docbook:2048
msgid "Each subclass should declare its own persistent properties and subclasses. <literal>&lt;version&gt;</literal> and <literal>&lt;id&gt;</literal> properties are assumed to be inherited from the root class. Each subclass in a heirarchy must define a unique <literal>discriminator-value</literal>. If none is specified, the fully qualified Java class name is used."
msgstr ""
      "<![CDATA[<class name=\"Person\"\n"
      "    table=\"PERSON\">\n"
      "\n"
      "    <id name=\"id\" column=\"PERSON_ID\">...</id>\n"
      "\n"
      "    <join table=\"ADDRESS\">\n"
      "        <key column=\"ADDRESS_ID\"/>\n"
      "        <property name=\"address\"/>\n"
      "        <property name=\"zip\"/>\n"
      "        <property name=\"country\"/>\n"
      "    </join>\n"
      "    ...]]>"

#: index.docbook:2056, index.docbook:2114, index.docbook:2172
msgid "For information about inheritance mappings, see <xref linkend=\"inheritance\"/>."
msgstr "Cette fonctionnalité est souvent seulement utile pour les modèles de données hérités d'anciens systèmes (legacy), nous recommandons d'utiliser moins de tables que de classes et un modèle de domaine à granularité fine. Cependant, c'est utile pour passer d'une stratégie de mapping d'héritage à une autre dans une hiérarchie simple ainsi qu'il est expliqué plus tard."

#: index.docbook:2063
msgid "joined-subclass"
msgstr "<title>key</title>"

#: index.docbook:2065
msgid "Alternatively, each subclass may be mapped to its own table (table-per-subclass mapping strategy). Inherited state is retrieved by joining with the table of the superclass. We use the <literal>&lt;joined-subclass&gt;</literal> element."
msgstr "Nous avons rencontré l'élément <literal>&lt;key&gt;</literal> à plusieurs reprises maintenant. Il apparaît partout que l'élément de mapping parent définit une jointure sur une nouvele table, et définit la clef étrangère dans la table jointe, ce qui référence la clef primaire de la table d'origine."

#: index.docbook:2078
msgid ""
      "<![CDATA[<joined-subclass\n"
      "        name=\"ClassName\"\n"
      "        table=\"tablename\"\n"
      "        proxy=\"ProxyInterface\"\n"
      "        lazy=\"true|false\"\n"
      "        dynamic-update=\"true|false\"\n"
      "        dynamic-insert=\"true|false\"\n"
      "        schema=\"schema\"\n"
      "        catalog=\"catalog\"\n"
      "        extends=\"SuperclassName\"\n"
      "        persister=\"ClassName\"\n"
      "        subselect=\"SQL expression\"\n"
      "        entity-name=\"EntityName\"\n"
      "        node=\"element-name\">\n"
      "\n"
      "        <key .... >\n"
      "\n"
      "        <property .... />\n"
      "        .....\n"
      "</joined-subclass>]]>"
msgstr ""
      "<![CDATA[<key\n"
      "        column=\"columnname\"\n"
      "        on-delete=\"noaction|cascade\"\n"
      "        property-ref=\"propertyName\"\n"
      "        not-null=\"true|false\"\n"
      "        update=\"true|false\"\n"
      "        unique=\"true|false\"\n"
      "/>]]>"

#: index.docbook:2086, index.docbook:2149
msgid "<literal>table</literal>: The name of the subclass table."
msgstr "<literal>on-delete</literal> (optionnel, par défaut à <literal>noaction</literal>) : Indique si la contrainte de clef étrangère possède la possibilité au niveau base de données de suppression en cascade."

#: index.docbook:2105
msgid "No discriminator column is required for this mapping strategy. Each subclass must, however, declare a table column holding the object identifier using the <literal>&lt;key&gt;</literal> element. The mapping at the start of the chapter would be re-written as:"
msgstr "<literal>update</literal> (optionnel) : Indique que la clef étrangère ne devrait jamais être mise à jour (implicite si celle-ci fait partie de la clef primaire)."

#: index.docbook:2112
msgid ""
      "<![CDATA[<?xml version=\"1.0\"?>\n"
      "<!DOCTYPE hibernate-mapping PUBLIC\n"
      "        \"-//Hibernate/Hibernate Mapping DTD//EN\"\n"
      "        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\">\n"
      "\n"
      "<hibernate-mapping package=\"eg\">\n"
      "\n"
      "        <class name=\"Cat\" table=\"CATS\">\n"
      "                <id name=\"id\" column=\"uid\" type=\"long\">\n"
      "                        <generator class=\"hilo\"/>\n"
      "                </id>\n"
      "                <property name=\"birthdate\" type=\"date\"/>\n"
      "                <property name=\"color\" not-null=\"true\"/>\n"
      "                <property name=\"sex\" not-null=\"true\"/>\n"
      "                <property name=\"weight\"/>\n"
      "                <many-to-one name=\"mate\"/>\n"
      "                <set name=\"kittens\">\n"
      "                        <key column=\"MOTHER\"/>\n"
      "                        <one-to-many class=\"Cat\"/>\n"
      "                </set>\n"
      "                <joined-subclass name=\"DomesticCat\" table=\"DOMESTIC_CATS\">\n"
      "                    <key column=\"CAT\"/>\n"
      "                    <property name=\"name\" type=\"string\"/>\n"
      "                </joined-subclass>\n"
      "        </class>\n"
      "\n"
      "        <class name=\"eg.Dog\">\n"
      "                <!-- mapping for Dog could go here -->\n"
      "        </class>\n"
      "\n"
      "</hibernate-mapping>]]>"
msgstr "<literal>unique</literal> (optionnel) : Indique que la clef étrangère doit posséder une contrainte d'unicité (implicite si la clef étrangère est aussi la clef primaire)."

#: index.docbook:2121
msgid "union-subclass"
msgstr "Les attributs <literal>not-null</literal> et <literal>update</literal> sont utiles pour mapper une association one-to-many unidirectionnelle. Si vous mappez un one-to-many unidirectionnel vers une clef étrangère non nulle, vous <emphasis>devez</emphasis> déclarer la colonne de la clef en utilisant <literal>&lt;key not-null=\"true\"&gt;</literal>."

#: index.docbook:2123
msgid "A third option is to map only the concrete classes of an inheritance hierarchy to tables, (the table-per-concrete-class strategy) where each table defines all persistent state of the class, including inherited state. In Hibernate, it is not absolutely necessary to explicitly map such inheritance hierarchies. You can simply map each class with a separate <literal>&lt;class&gt;</literal> declaration. However, if you wish use polymorphic associations (e.g. an association to the superclass of your hierarchy), you need to use the <literal>&lt;union-subclass&gt;</literal> mapping."
msgstr "éléments column et formula"

#: index.docbook:2141
msgid ""
      "<![CDATA[<union-subclass\n"
      "        name=\"ClassName\"\n"
      "        table=\"tablename\"\n"
      "        proxy=\"ProxyInterface\"\n"
      "        lazy=\"true|false\"\n"
      "        dynamic-update=\"true|false\"\n"
      "        dynamic-insert=\"true|false\"\n"
      "        schema=\"schema\"\n"
      "        catalog=\"catalog\"\n"
      "        extends=\"SuperclassName\"\n"
      "        abstract=\"true|false\"\n"
      "        persister=\"ClassName\"\n"
      "        subselect=\"SQL expression\"\n"
      "        entity-name=\"EntityName\"\n"
      "        node=\"element-name\">\n"
      "\n"
      "        <property .... />\n"
      "        .....\n"
      "</union-subclass>]]>"
msgstr "Tout élément de mapping qui accepte un attribut <literal>column</literal> acceptera alternativement un sous-élément <literal>&lt;column&gt;</literal>. De façon identique, <literal>&lt;formula&gt;</literal> est une alternative à l'attribut <literal>formula</literal>."

#: index.docbook:2168
msgid "No discriminator column or key column is required for this mapping strategy."
msgstr "import"

#: index.docbook:2179
msgid "join"
msgstr "<![CDATA[<import class=\"java.lang.Object\" rename=\"Universe\"/>]]>"

#: index.docbook:2181
msgid "Using the <literal>&lt;join&gt;</literal> element, it is possible to map properties of one class to several tables, when there's a 1-to-1 relationship between the tables."
msgstr ""
      "<![CDATA[<import\n"
      "        class=\"ClassName\"\n"
      "        rename=\"ShortName\"\n"
      "/>]]>"

#: index.docbook:2195
msgid ""
      "<![CDATA[<join\n"
      "        table=\"tablename\"\n"
      "        schema=\"owner\"\n"
      "        catalog=\"catalog\"\n"
      "        fetch=\"join|select\"\n"
      "        inverse=\"true|false\"\n"
      "        optional=\"true|false\">\n"
      "\n"
      "        <key ... />\n"
      "\n"
      "        <property ... />\n"
      "        ...\n"
      "</join>]]>"
msgstr "<literal>class</literal> : Nom Java complet de la classe."

#: index.docbook:2199
msgid "<literal>table</literal>: The name of the joined table."
msgstr "<literal>rename</literal> (optionnel - par défaut vaut le nom de la classe Java (sans package)) : Nom pouvant être utilisé dans le langage de requête."

#: index.docbook:2216
msgid "<literal>fetch</literal> (optional - defaults to <literal>join</literal>): If set to <literal>join</literal>, the default, Hibernate will use an inner join to retrieve a <literal>&lt;join&gt;</literal> defined by a class or its superclasses and an outer join for a <literal>&lt;join&gt;</literal> defined by a subclass. If set to <literal>select</literal> then Hibernate will use a sequential select for a <literal>&lt;join&gt;</literal> defined on a subclass, which will be issued only if a row turns out to represent an instance of the subclass. Inner joins will still be used to retrieve a <literal>&lt;join&gt;</literal> defined by the class and its superclasses."
msgstr "L'attribut <literal>meta-type</literal> permet à l'application de spécifier un type personnalisé qui mappe des valeurs de colonnes de le base de données sur des classes persistantes qui ont un attribut identifiant du type spécifié par <literal>id-type</literal>. Vous devez spécifier le mapping à partir de valeurs du méta-type sur les noms des classes."

#: index.docbook:2229
msgid "<literal>inverse</literal> (optional - defaults to <literal>false</literal>): If enabled, Hibernate will not try to insert or update the properties defined by this join."
msgstr ""
      "<![CDATA[<any name=\"being\" id-type=\"long\" meta-type=\"string\">\n"
      "    <meta-value value=\"TBL_ANIMAL\" class=\"Animal\"/>\n"
      "    <meta-value value=\"TBL_HUMAN\" class=\"Human\"/>\n"
      "    <meta-value value=\"TBL_ALIEN\" class=\"Alien\"/>\n"
      "    <column name=\"table_name\"/>\n"
      "    <column name=\"id\"/>\n"
      "</any>]]>"

#: index.docbook:2236
msgid "<literal>optional</literal> (optional - defaults to <literal>false</literal>): If enabled, Hibernate will insert a row only if the properties defined by this join are non-null and will always use an outer join to retrieve the properties."
msgstr ""
      "<![CDATA[<any\n"
      "        name=\"propertyName\"\n"
      "        id-type=\"idtypename\"\n"
      "        meta-type=\"metatypename\"\n"
      "        cascade=\"cascade_style\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        optimistic-lock=\"true|false\"\n"
      ">\n"
      "        <meta-value ... />\n"
      "        <meta-value ... />\n"
      "        .....\n"
      "        <column .... />\n"
      "        <column .... />\n"
      "        .....\n"
      "</any>]]>"

#: index.docbook:2245
msgid "For example, the address information for a person can be mapped to a separate table (while preserving value type semantics for all properties):"
msgstr "<literal>name</literal> : le nom de la propriété."

#: index.docbook:2250
msgid ""
      "<![CDATA[<class name=\"Person\"\n"
      "    table=\"PERSON\">\n"
      "\n"
      "    <id name=\"id\" column=\"PERSON_ID\">...</id>\n"
      "\n"
      "    <join table=\"ADDRESS\">\n"
      "        <key column=\"ADDRESS_ID\"/>\n"
      "        <property name=\"address\"/>\n"
      "        <property name=\"zip\"/>\n"
      "        <property name=\"country\"/>\n"
      "    </join>\n"
      "    ...]]>"
msgstr "<literal>id-type</literal> : le type identifiant."

#: index.docbook:2252
msgid "This feature is often only useful for legacy data models, we recommend fewer tables than classes and a fine-grained domain model. However, it is useful for switching between inheritance mapping strategies in a single hierarchy, as explained later."
msgstr "<literal>meta-type</literal> (optionnel - par défaut à <literal>string</literal>) : Tout type permis pour un mapping par discriminateur."

#: index.docbook:2262
msgid "<title>key</title>"
msgstr "<literal>cascade</literal> (optionnel - par défaut à <literal>none</literal>) : le style de cascade."

#: index.docbook:2264
msgid "We've seen the <literal>&lt;key&gt;</literal> element crop up a few times now. It appears anywhere the parent mapping element defines a join to a new table, and defines the foreign key in the joined table, that references the primary key of the original table."
msgstr "<literal>access</literal> (optionnel - par défaut à <literal>property</literal>) : La stratégie à utiliser par Hibernate pour accéder à cette propriété."

#: index.docbook:2280
msgid ""
      "<![CDATA[<key\n"
      "        column=\"columnname\"\n"
      "        on-delete=\"noaction|cascade\"\n"
      "        property-ref=\"propertyName\"\n"
      "        not-null=\"true|false\"\n"
      "        update=\"true|false\"\n"
      "        unique=\"true|false\"\n"
      "/>]]>"
msgstr "<literal>optimistic-lock</literal> (optionnel - par défaut à <literal>true</literal>) : Indique que les mises à jour sur cette propriété nécessitent ou non l'acquisition d'un verrou optimiste. En d'autres termes, définit si un incrément de version doit avoir lieu quand cette propriété est marquée dirty."

#: index.docbook:2291
msgid "<literal>on-delete</literal> (optional, defaults to <literal>noaction</literal>): Specifies whether the foreign key constraint has database-level cascade delete enabled."
msgstr "Entités et valeurs"

#: index.docbook:2298
msgid "<literal>property-ref</literal> (optional): Specifies that the foreign key refers to columns that are not the primary key of the orginal table. (Provided for legacy data.)"
msgstr "Pour comprendre le comportement des différents objets Java par rapport au service de persistance, nous avons besoin de les classer en deux groupes :"

#: index.docbook:2305
msgid "<literal>not-null</literal> (optional): Specifies that the foreign key columns are not nullable (this is implied whenever the foreign key is also part of the primary key)."
msgstr "Une <emphasis>entité</emphasis> existe indépendamment de tout autre objet possédant une référence vers l'entité. Comparez cela avec le modèle Java habituel où un objet est supprimé par le garbage collector dès qu'il n'est plus référencé. Les entités doivent être explicitement enregistrées et supprimées (sauf dans les cas où sauvegardes et suppressions sont <emphasis>cascadées</emphasis> d'une entité mère vers ses enfants). C'est différent du modèle ODMG de persistance par atteignabilité - et correspond mieux à la façon dont les objets sont habituellement utilisés dans des grands systèmes. Les entités permettent les références circulaires et partagées. Elles peuvent aussi être versionnées."

#: index.docbook:2312
msgid "<literal>update</literal> (optional): Specifies that the foreign key should never be updated (this is implied whenever the foreign key is also part of the primary key)."
msgstr "L'état persistant d'une entité consiste en des références vers d'autres entités et instances de types <emphasis>valeurs</emphasis>. Ces valeurs sont des types primitifs, des collections (et non le contenu d'une collection), des composants de certains objets immuables. Contrairement aux entités, les valeurs (et en particulier les collections et composants) <emphasis>sont</emphasis> persistés par atteignabiliité. Comme les valeurs (et types primitifs) sont persistés et supprimés avec l'entité qui les contient, ils ne peuvent pas posséder leurs propres versions. Les valeurs n'ont pas d'identité indépendantes, ainsi elles ne peuvent pas être partagées par deux entités ou collections."

#: index.docbook:2319
msgid "<literal>unique</literal> (optional): Specifies that the foreign key should have a unique constraint (this is implied whenever the foreign key is also the primary key)."
msgstr "Jusqu'à présent nous avons utilisé le terme \"classe persistante\" pour parler d'entités. Nous allons continuer à faire ainsi. Cependant, au sens strict, toutes les classes définies par un utilisateur possédant un état persistant ne sont pas des entités. Un <emphasis>composant</emphasis> est une classe définie par un utilisateur avec les caractéristiques d'une valeur. Une propriété Java de type <literal>java.lang.String</literal> a aussi les caractéristiques d'une valeur. Given this definition, we can say that all types (classes) provided by the JDK have value type semantics in Java, while user-defined types may be mapped with entity or value type semantics. This decision is up to the application developer. A good hint for an entity class in a domain model are shared references to a single instance of that class, while composition or aggregation usually translates to a value type."

#: index.docbook:2327
msgid "We recommend that for systems where delete performance is important, all keys should be defined <literal>on-delete=\"cascade\"</literal>, and Hibernate will use a database-level <literal>ON CASCADE DELETE</literal> constraint, instead of many individual <literal>DELETE</literal> statements. Be aware that this feature bypasses Hibernate's usual optimistic locking strategy for versioned data."
msgstr "Nous nous pencherons sur ces deux concepts tout au long de la documentation."

#: index.docbook:2335
msgid "The <literal>not-null</literal> and <literal>update</literal> attributes are useful when mapping a unidirectional one to many association. If you map a unidirectional one to many to a non-nullable foreign key, you <emphasis>must</emphasis> declare the key column using <literal>&lt;key not-null=\"true\"&gt;</literal>."
msgstr "Le défi est de mapper les type Javas (et la définition des développeurs des entités et valeurs types) sur les types du SQL ou des bases de données. Le pont entre les deux systèmes est proposé par Hibernate : pour les entités nous utilisons <literal>&lt;class&gt;</literal>, <literal>&lt;subclass&gt;</literal> et ainsi de suite. Pour les types valeurs nous utilisons <literal>&lt;property&gt;</literal>, <literal>&lt;component&gt;</literal>, etc., habituellement avec un attribut <literal>type</literal>. La valeur de cet attribut est le nom d'un <emphasis>type de mapping</emphasis> Hibernate. Hibernate propose de base de nombreux mappings (pour les types de valeurs standards du JDK). Vous pouvez écrire vos propres types de mappings et implémenter aussi vos propres stratégies de conversion, nous le verrons plus tard."

#: index.docbook:2345
msgid "column and formula elements"
msgstr "Tous les types proposés de base par Hibernate à part les collections autorisent la valeur null."

#: index.docbook:2346
msgid "Any mapping element which accepts a <literal>column</literal> attribute will alternatively accept a <literal>&lt;column&gt;</literal> subelement. Likewise, <literal>&lt;formula&gt;</literal> is an alternative to the <literal>formula</literal> attribute."
msgstr "Basic value types"

#: index.docbook:2352
msgid ""
      "<![CDATA[<column\n"
      "        name=\"column_name\"\n"
      "        length=\"N\"\n"
      "        precision=\"N\"\n"
      "        scale=\"N\"\n"
      "        not-null=\"true|false\"\n"
      "        unique=\"true|false\"\n"
      "        unique-key=\"multicolumn_unique_key_name\"\n"
      "        index=\"index_name\"\n"
      "        sql-type=\"sql_type_name\"\n"
      "        check=\"SQL expression\"\n"
      "        default=\"SQL expression\"/>]]>"
msgstr "Les <emphasis>types basiques de mapping</emphasis> proposés de base peuvent grossièrement être rangés dans les catégories suivantes :"

#: index.docbook:2354
msgid "<![CDATA[<formula>SQL expression</formula>]]>"
msgstr "integer, long, short, float, double, character, byte, boolean, yes_no, true_false"

#: index.docbook:2356
msgid "<literal>column</literal> and <literal>formula</literal> attributes may even be combined within the same property or association mapping to express, for example, exotic join conditions."
msgstr "Les mappings de type des primitives Java ou leurs classes wrappers (ex: Integer pour int) vers les types SQL (propriétaires) appropriés. <literal>boolean, yes_no</literal>et <literal>true_false</literal> sont tous des alternatives pour les types Java <literal>boolean</literal> ou <literal>java.lang.Boolean</literal>."

#: index.docbook:2362
msgid ""
      "<![CDATA[<many-to-one name=\"homeAddress\" class=\"Address\"\n"
      "        insert=\"false\" update=\"false\">\n"
      "    <column name=\"person_id\" not-null=\"true\" length=\"10\"/>\n"
      "    <formula>'MAILING'</formula>\n"
      "</many-to-one>]]>"
msgstr "string"

#: index.docbook:2367
msgid "import"
msgstr "Mapping de type de <literal>java.lang.String</literal> vers <literal>VARCHAR</literal> (ou le <literal>VARCHAR2</literal> Oracle)."

#: index.docbook:2369
msgid "Suppose your application has two persistent classes with the same name, and you don't want to specify the fully qualified (package) name in Hibernate queries. Classes may be \"imported\" explicitly, rather than relying upon <literal>auto-import=\"true\"</literal>. You may even import classes and interfaces that are not explicitly mapped."
msgstr "date, time, timestamp"

#: index.docbook:2376
msgid "<![CDATA[<import class=\"java.lang.Object\" rename=\"Universe\"/>]]>"
msgstr "Mappings de type pour <literal>java.util.Date</literal> et ses sous-classes vers les types SQL <literal>DATE</literal>, <literal>TIME</literal> et <literal>TIMESTAMP</literal> (ou équivalent)."

#: index.docbook:2383
msgid ""
      "<![CDATA[<import\n"
      "        class=\"ClassName\"\n"
      "        rename=\"ShortName\"\n"
      "/>]]>"
msgstr "calendar, calendar_date"

#: index.docbook:2386
msgid "<literal>class</literal>: The fully qualified class name of of any Java class."
msgstr "Mappings de type pour <literal>java.util.Calendar</literal> vers les types SQL <literal>TIMESTAMP</literal> et <literal>DATE</literal> (ou équivalent)."

#: index.docbook:2391
msgid "<literal>rename</literal> (optional - defaults to the unqualified class name): A name that may be used in the query language."
msgstr "big_decimal, big_integer"

#: index.docbook:2402
msgid "<title>any</title>"
msgstr "Mappings de type pour <literal>java.math.BigDecimal</literal> et <literal>java.math.BigInteger</literal> vers <literal>NUMERIC</literal> (ou le <literal>NUMBER</literal> Oracle)."

#: index.docbook:2404
msgid "There is one further type of property mapping. The <literal>&lt;any&gt;</literal> mapping element defines a polymorphic association to classes from multiple tables. This type of mapping always requires more than one column. The first column holds the type of the associated entity. The remaining columns hold the identifier. It is impossible to specify a foreign key constraint for this kind of association, so this is most certainly not meant as the usual way of mapping (polymorphic) associations. You should use this only in very special cases (eg. audit logs, user session data, etc)."
msgstr "locale, timezone, currency"

#: index.docbook:2414
msgid "The <literal>meta-type</literal> attribute lets the application specify a custom type that maps database column values to persistent classes which have identifier properties of the type specified by <literal>id-type</literal>. You must specify the mapping from values of the meta-type to class names."
msgstr "Mappings de type pour <literal>java.util.Locale</literal>, <literal>java.util.TimeZone</literal> et <literal>java.util.Currency</literal> vers <literal>VARCHAR</literal> (ou le <literal>VARCHAR2</literal> Oracle). Les instances de <literal>Locale</literal> et <literal>Currency</literal> sont mappées sur leurs codes ISO. Les instances de <literal>TimeZone</literal> sont mappées sur leur <literal>ID</literal>."

#: index.docbook:2421
msgid ""
      "<![CDATA[<any name=\"being\" id-type=\"long\" meta-type=\"string\">\n"
      "    <meta-value value=\"TBL_ANIMAL\" class=\"Animal\"/>\n"
      "    <meta-value value=\"TBL_HUMAN\" class=\"Human\"/>\n"
      "    <meta-value value=\"TBL_ALIEN\" class=\"Alien\"/>\n"
      "    <column name=\"table_name\"/>\n"
      "    <column name=\"id\"/>\n"
      "</any>]]>"
msgstr "<literal>class</literal>"

#: index.docbook:2432
msgid ""
      "<![CDATA[<any\n"
      "        name=\"propertyName\"\n"
      "        id-type=\"idtypename\"\n"
      "        meta-type=\"metatypename\"\n"
      "        cascade=\"cascade_style\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        optimistic-lock=\"true|false\"\n"
      ">\n"
      "        <meta-value ... />\n"
      "        <meta-value ... />\n"
      "        .....\n"
      "        <column .... />\n"
      "        <column .... />\n"
      "        .....\n"
      "</any>]]>"
msgstr "Un type de mapping pour <literal>java.lang.Class</literal> vers <literal>VARCHAR</literal> (ou le <literal>VARCHAR2</literal> Oracle). Un objet <literal>Class</literal> est mappé sur son nom Java complet."

#: index.docbook:2435
msgid "<literal>name</literal>: the property name."
msgstr "binary"

#: index.docbook:2440
msgid "<literal>id-type</literal>: the identifier type."
msgstr "Mappe les tableaux de bytes vers le type binaire SQL approprié."

#: index.docbook:2445
msgid "<literal>meta-type</literal> (optional - defaults to <literal>string</literal>): Any type that is allowed for a discriminator mapping."
msgstr "text"

#: index.docbook:2451
msgid "<literal>cascade</literal> (optional- defaults to <literal>none</literal>): the cascade style."
msgstr "Mappe les longues chaînes de caractères Java vers les types SQL <literal>CLOB</literal> ou <literal>TEXT</literal>."

#: index.docbook:2463
msgid "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>): Specifies that updates to this property do or do not require acquisition of the optimistic lock. In other words, define if a version increment should occur if this property is dirty."
msgstr "Mappe les types Java sérialisables vers le type SQL binaire approprié. Vous pouvez aussi indiquer le type Hibernate <literal>serializable</literal> avec le nom d'une classe Java sérialisable ou une interface qui ne soit pas par défaut un type de base."

#: index.docbook:2478
msgid "Hibernate Types"
msgstr "clob, blob"

#: index.docbook:2481
msgid "Entities and values"
msgstr "Mappings de type pour les classes JDBC <literal>java.sql.Clob</literal> and <literal>java.sql.Blob</literal>. Ces types peuvent ne pas convenir pour certaines applications car un objet blob ou clob peut ne pas être réutilisable en dehors d'une transaction (de plus l'implémentation par les pilotes est moyennement bonne)."

#: index.docbook:2483
msgid "To understand the behaviour of various Java language-level objects with respect to the persistence service, we need to classify them into two groups:"
msgstr "imm_date, imm_time, imm_timestamp, imm_calendar, imm_calendar_date, imm_serializable, imm_binary"

#: index.docbook:2488
msgid "An <emphasis>entity</emphasis> exists independently of any other objects holding references to the entity. Contrast this with the usual Java model where an unreferenced object is garbage collected. Entities must be explicitly saved and deleted (except that saves and deletions may be <emphasis>cascaded</emphasis> from a parent entity to its children). This is different from the ODMG model of object persistence by reachablity - and corresponds more closely to how application objects are usually used in large systems. Entities support circular and shared references. They may also be versioned."
msgstr "Mappings de type pour ceux qui sont habituellement modifiable, pour lesquels Hibernate effectue certains optimisations convenant seulement aux types Java immuables, et l'application les traite comme immuable. Par exemple, vous ne devriez pas appeler <literal>Date.setTime()</literal> sur une instance mappée sur un <literal>imm_timestamp</literal>. Pour changer la valeur de la propriété, et faire que cette modification soit persistée, l'application doit assigner un nouvel (non identique) objet à la propriété."

#: index.docbook:2499
msgid "An entity's persistent state consists of references to other entities and instances of <emphasis>value</emphasis> types. Values are primitives, collections (not what's inside a collection), components and certain immutable objects. Unlike entities, values (in particular collections and components) <emphasis>are</emphasis> persisted and deleted by reachability. Since value objects (and primitives) are persisted and deleted along with their containing entity they may not be independently versioned. Values have no independent identity, so they cannot be shared by two entities or collections."
msgstr "Les identifiants uniques des entités et collections peuvent être de n'importe quel type de base excepté <literal>binary</literal>, <literal>blob</literal> et <literal>clob</literal> (les identifiants composites sont aussi permis, voir plus bas)."

#: index.docbook:2510
msgid "Up until now, we've been using the term \"persistent class\" to refer to entities. We will continue to do that. Strictly speaking, however, not all user-defined classes with persistent state are entities. A <emphasis>component</emphasis> is a user defined class with value semantics. A Java property of type <literal>java.lang.String</literal> also has value semantics. Given this definition, we can say that all types (classes) provided by the JDK have value type semantics in Java, while user-defined types may be mapped with entity or value type semantics. This decision is up to the application developer. A good hint for an entity class in a domain model are shared references to a single instance of that class, while composition or aggregation usually translates to a value type."
msgstr "Les types de base des valeurs ont des <literal>Type</literal> constants correspondants définis dans <literal>org.hibernate.Hibernate</literal>. Par exemple, <literal>Hibernate.STRING</literal> représenté le type <literal>string</literal>."

#: index.docbook:2524
msgid "We'll revisit both concepts throughout the documentation."
msgstr "Types de valeur définis par l'utilisateur"

#: index.docbook:2528
msgid "The challenge is to map the Java type system (and the developers' definition of entities and value types) to the SQL/database type system. The bridge between both systems is provided by Hibernate: for entities we use <literal>&lt;class&gt;</literal>, <literal>&lt;subclass&gt;</literal> and so on. For value types we use <literal>&lt;property&gt;</literal>, <literal>&lt;component&gt;</literal>, etc, usually with a <literal>type</literal> attribute. The value of this attribute is the name of a Hibernate <emphasis>mapping type</emphasis>. Hibernate provides many mappings (for standard JDK value types) out of the box. You can write your own mapping types and implement your custom conversion strategies as well, as you'll see later."
msgstr "Il est assez facile pour les développeurs de créer leurs propres types de valeurs. Par exemple, vous pourriez vouloir persister des propriétés du type <literal>java.lang.BigInteger</literal> dans des colonnnes <literal>VARCHAR</literal>. Hibernate ne procure pas par défaut un type pour cela. Mais les types que vous pouvez créer ne se limitent pas à mapper des propriétés (ou élément collection) à une simple colonne d'une table. Donc, par exemple, vous pourriez avoir une propriété Java <literal>getName()</literal>/<literal>setName()</literal> de type <literal>java.lang.String</literal> persistée dans les colonnes <literal>FIRST_NAME</literal>, <literal>INITIAL</literal>, <literal>SURNAME</literal>."

#: index.docbook:2541
msgid "All built-in Hibernate types except collections support null semantics."
msgstr "Pour implémenter votre propre type, vous pouvez soit implémenter <literal>org.hibernate.UserType</literal> soit <literal>org.hibernate.CompositeUserType</literal> et déclarer des propriétés utilisant des noms de classes complets du type. Regardez <literal>org.hibernate.test.DoubleStringType</literal> pour voir ce qu'il est possible de faire."

#: index.docbook:2548
msgid "Basic value types"
msgstr ""
      "<![CDATA[<property name=\"twoStrings\" type=\"org.hibernate.test.DoubleStringType\">\n"
      "    <column name=\"first_string\"/>\n"
      "    <column name=\"second_string\"/>\n"
      "</property>]]>"

#: index.docbook:2550
msgid "The built-in <emphasis>basic mapping types</emphasis> may be roughly categorized into"
msgstr "Remarquez l'utilisation des tags <literal>&lt;column&gt;</literal> pour mapper une propriété sur des colonnes multiples."

#: index.docbook:2555
msgid "integer, long, short, float, double, character, byte, boolean, yes_no, true_false"
msgstr "Les interfaces <literal>CompositeUserType</literal>, <literal>EnhancedUserType</literal>, <literal>UserCollectionType</literal>, et <literal>UserVersionType</literal> permettent des utilisations plus spécialisées."

#: index.docbook:2558
msgid "Type mappings from Java primitives or wrapper classes to appropriate (vendor-specific) SQL column types. <literal>boolean, yes_no</literal> and <literal>true_false</literal> are all alternative encodings for a Java <literal>boolean</literal> or <literal>java.lang.Boolean</literal>."
msgstr "Vous pouvez même donner des paramètres en indiquant <literal>UserType</literal> dans le fichier de mapping ; Pour cela, votre <literal>UserType</literal> doit implémenter l'interface <literal>org.hibernate.usertype.ParameterizedType</literal>. Pour spécifier des paramètres dans votre type propre, vous pouvez utiliser l'élément <literal>&lt;type&gt;</literal> dans vos fichiers de mapping."

#: index.docbook:2567
msgid "string"
msgstr ""
      "<![CDATA[<property name=\"priority\">\n"
      "    <type name=\"com.mycompany.usertypes.DefaultValueIntegerType\">\n"
      "        <param name=\"default\">0</param>\n"
      "    </type>\n"
      "</property>]]>"

#: index.docbook:2569
msgid "A type mapping from <literal>java.lang.String</literal> to <literal>VARCHAR</literal> (or Oracle <literal>VARCHAR2</literal>)."
msgstr "Le <literal>UserType</literal> permet maintenant de récupérer la valeur pour le paramètre nommé <literal>default</literal> à partir de l'objet <literal>Properties</literal> qui lui est passé."

#: index.docbook:2576
msgid "date, time, timestamp"
msgstr "Si vous utilisez fréquemment un <literal>UserType</literal>, cela peut être utile de lui définir un nom plus court. Vous pouvez faire cela en utilisant l'élément <literal>&lt;typedef&gt;</literal>. Les typedefs permettent d'assigner un nom à votre type propre et peuvent aussi contenir une liste de valeurs de paramètres par défaut si ce type est paramétré."

#: index.docbook:2578
msgid "Type mappings from <literal>java.util.Date</literal> and its subclasses to SQL types <literal>DATE</literal>, <literal>TIME</literal> and <literal>TIMESTAMP</literal> (or equivalent)."
msgstr ""
      "<![CDATA[<typedef class=\"com.mycompany.usertypes.DefaultValueIntegerType\" name=\"default_zero\">\n"
      "    <param name=\"default\">0</param>\n"
      "</typedef>]]>"

#: index.docbook:2586
msgid "calendar, calendar_date"
msgstr "<![CDATA[<property name=\"priority\" type=\"default_zero\"/>]]>"

#: index.docbook:2588
msgid "Type mappings from <literal>java.util.Calendar</literal> to SQL types <literal>TIMESTAMP</literal> and <literal>DATE</literal> (or equivalent)."
msgstr "Il est aussi possible de redéfinir les paramètres par défaut du typedef au cas par cas en utilisant des paramètres type sur le mapping de la propriété."

#: index.docbook:2596
msgid "big_decimal, big_integer"
msgstr "Bien que le fait que Hibernate propose de base une riche variété de types, et qu'il supporte les composants signifie que vous aurez très rarement <emphasis>besoin</emphasis> d'utiliser un nouveau type propre, il est néanmoins de bonne pratique d'utiliser des types propres pour les classes (non entités) qui apparaissent fréquemment dans votre application. Par exemple une classe <literal>MonetaryAmount</literal> est un bon candidat pour un <literal>CompositeUserType</literal> même s'il pourrait facilement être mappé comme un composant. Une motivation pour cela est l'abstraction. Avec un type propre vos documents de mapping sont à l'abri des changements futurs dans votre façon de représenter des valeurs monétaires."

#: index.docbook:2598
msgid "Type mappings from <literal>java.math.BigDecimal</literal> and <literal>java.math.BigInteger</literal> to <literal>NUMERIC</literal> (or Oracle <literal>NUMBER</literal>)."
msgstr "Mapper une classe plus d'une fois"

#: index.docbook:2606
msgid "locale, timezone, currency"
msgstr "Il est possible de proposer plus d'un mapping par classe persistante. Dans ce cas, vous devez spécifier un <emphasis>nom d'entité</emphasis> pour lever l'ambiguité entre les instances des entités mappées (par défaut, le nom de l'entité est celui de la classe). Hibernate vous permet de spécifier le nom de l'entité lorsque vous utilisez des objets persistants, lorsque vous écrivez des requêtes ou quand vous mappez des associations vers les entités nommées."

#: index.docbook:2608
msgid "Type mappings from <literal>java.util.Locale</literal>, <literal>java.util.TimeZone</literal> and <literal>java.util.Currency</literal> to <literal>VARCHAR</literal> (or Oracle <literal>VARCHAR2</literal>). Instances of <literal>Locale</literal> and <literal>Currency</literal> are mapped to their ISO codes. Instances of <literal>TimeZone</literal> are mapped to their <literal>ID</literal>."
msgstr ""
      "<![CDATA[<class name=\"Contract\" table=\"Contracts\" \n"
      "        entity-name=\"CurrentContract\">\n"
      "    ...\n"
      "    <set name=\"history\" inverse=\"true\" \n"
      "            order-by=\"effectiveEndDate desc\">\n"
      "        <key column=\"currentContractId\"/>\n"
      "        <one-to-many entity-name=\"HistoricalContract\"/>\n"
      "    </set>\n"
      "</class>\n"
      "\n"
      "<class name=\"Contract\" table=\"ContractHistory\" \n"
      "        entity-name=\"HistoricalContract\">\n"
      "    ...\n"
      "    <many-to-one name=\"currentContract\" \n"
      "            column=\"currentContractId\" \n"
      "            entity-name=\"CurrentContract\"/>\n"
      "</class>]]>"

#: index.docbook:2620
msgid "<literal>class</literal>"
msgstr "Remarquez comment les associations sont désormais spécifiées en utilisant <literal>entity-name</literal> au lieu de <literal>class</literal>."

#: index.docbook:2622
msgid "A type mapping from <literal>java.lang.Class</literal> to <literal>VARCHAR</literal> (or Oracle <literal>VARCHAR2</literal>). A <literal>Class</literal> is mapped to its fully qualified name."
msgstr "SQL quoted identifiers"

#: index.docbook:2630
msgid "binary"
msgstr "Vous pouvez forcer Hibernate à mettre un identifiant entre quotes dans le SQL généré en mettant le nom de la table ou de la colonne entre backticks dans le document de mapping. Hibernate utilisera les bons styles de quotes pour le <literal>Dialect</literal> SQL (habituellement des doubles quotes, mais des parenthèses pour SQL server et des backticks pour MySQL)."

#: index.docbook:2632
msgid "Maps byte arrays to an appropriate SQL binary type."
msgstr ""
      "<![CDATA[<class name=\"LineItem\" table=\"`Line Item`\">\n"
      "    <id name=\"id\" column=\"`Item Id`\"/><generator class=\"assigned\"/></id>\n"
      "    <property name=\"itemNumber\" column=\"`Item #`\"/>\n"
      "    ...\n"
      "</class>]]>"

#: index.docbook:2638
msgid "text"
msgstr "alternatives Metadata"

#: index.docbook:2640
msgid "Maps long Java strings to a SQL <literal>CLOB</literal> or <literal>TEXT</literal> type."
msgstr "XML ne convient pas à tout le monde, il y a donc des moyens alternatifs pour définir des metatda de mappings O/R dans Hibernate."

#: index.docbook:2647
msgid "serializable"
msgstr "utilisation de XDoclet"

#: index.docbook:2649
msgid "Maps serializable Java types to an appropriate SQL binary type. You may also indicate the Hibernate type <literal>serializable</literal> with the name of a serializable Java class or interface that does not default to a basic type."
msgstr "De nombreux utilisateurs de Hibernate préfèrent embarquer les informations de mappings directement au sein du code source en utilisant les tags XDoclet <literal>@hibernate.tags</literal>. Nous ne couvrons pas cette approche dans ce document cependant, puisque c'est considéré comme faisant partie de XDoclet. Cependant, nous présentons l'exemple suivant de la classe <literal>Cat</literal> avec des mappings XDoclet."

#: index.docbook:2658
msgid "clob, blob"
msgstr ""
      "<![CDATA[package eg;\n"
      "import java.util.Set;\n"
      "import java.util.Date;\n"
      "\n"
      "/**\n"
      " * @hibernate.class\n"
      " *  table=\"CATS\"\n"
      " */\n"
      "public class Cat {\n"
      "    private Long id; // identifier\n"
      "    private Date birthdate;\n"
      "    private Cat mother;\n"
      "    private Set kittens\n"
      "    private Color color;\n"
      "    private char sex;\n"
      "    private float weight;\n"
      "\n"
      "    /*\n"
      "     * @hibernate.id\n"
      "     *  generator-class=\"native\"\n"
      "     *  column=\"CAT_ID\"\n"
      "     */\n"
      "    public Long getId() {\n"
      "        return id;\n"
      "    }\n"
      "    private void setId(Long id) {\n"
      "        this.id=id;\n"
      "    }\n"
      "\n"
      "    /**\n"
      "     * @hibernate.many-to-one\n"
      "     *  column=\"PARENT_ID\"\n"
      "     */\n"
      "    public Cat getMother() {\n"
      "        return mother;\n"
      "    }\n"
      "    void setMother(Cat mother) {\n"
      "        this.mother = mother;\n"
      "    }\n"
      "\n"
      "    /**\n"
      "     * @hibernate.property\n"
      "     *  column=\"BIRTH_DATE\"\n"
      "     */\n"
      "    public Date getBirthdate() {\n"
      "        return birthdate;\n"
      "    }\n"
      "    void setBirthdate(Date date) {\n"
      "        birthdate = date;\n"
      "    }\n"
      "    /**\n"
      "     * @hibernate.property\n"
      "     *  column=\"WEIGHT\"\n"
      "     */\n"
      "    public float getWeight() {\n"
      "        return weight;\n"
      "    }\n"
      "    void setWeight(float weight) {\n"
      "        this.weight = weight;\n"
      "    }\n"
      "\n"
      "    /**\n"
      "     * @hibernate.property\n"
      "     *  column=\"COLOR\"\n"
      "     *  not-null=\"true\"\n"
      "     */\n"
      "    public Color getColor() {\n"
      "        return color;\n"
      "    }\n"
      "    void setColor(Color color) {\n"
      "        this.color = color;\n"
      "    }\n"
      "    /**\n"
      "     * @hibernate.set\n"
      "     *  inverse=\"true\"\n"
      "     *  order-by=\"BIRTH_DATE\"\n"
      "     * @hibernate.collection-key\n"
      "     *  column=\"PARENT_ID\"\n"
      "     * @hibernate.collection-one-to-many\n"
      "     */\n"
      "    public Set getKittens() {\n"
      "        return kittens;\n"
      "    }\n"
      "    void setKittens(Set kittens) {\n"
      "        this.kittens = kittens;\n"
      "    }\n"
      "    // addKitten not needed by Hibernate\n"
      "    public void addKitten(Cat kitten) {\n"
      "        kittens.add(kitten);\n"
      "    }\n"
      "\n"
      "    /**\n"
      "     * @hibernate.property\n"
      "     *  column=\"SEX\"\n"
      "     *  not-null=\"true\"\n"
      "     *  update=\"false\"\n"
      "     */\n"
      "    public char getSex() {\n"
      "        return sex;\n"
      "    }\n"
      "    void setSex(char sex) {\n"
      "        this.sex=sex;\n"
      "    }\n"
      "}]]>"

#: index.docbook:2660
msgid "Type mappings for the JDBC classes <literal>java.sql.Clob</literal> and <literal>java.sql.Blob</literal>. These types may be inconvenient for some applications, since the blob or clob object may not be reused outside of a transaction. (Furthermore, driver support is patchy and inconsistent.)"
msgstr "Voyez le site web de Hibernate pour plus d'exemples sur XDoclet et Hibernate."

#: index.docbook:2670
msgid "imm_date, imm_time, imm_timestamp, imm_calendar, imm_calendar_date, imm_serializable, imm_binary"
msgstr "Utilisation des annotations JDK 5.0"

#: index.docbook:2674
msgid "Type mappings for what are usually considered mutable Java types, where Hibernate makes certain optimizations appropriate only for immutable Java types, and the application treats the object as immutable. For example, you should not call <literal>Date.setTime()</literal> for an instance mapped as <literal>imm_timestamp</literal>. To change the value of the property, and have that change made persistent, the application must assign a new (nonidentical) object to the property."
msgstr "Le JDK 5.0 introduit des annotations proches de celles de XDoclet au niveau java, qui sont type-safe et vérifiées à la compilation. Ce mécanisme est plus puissant que XDoclet et mieux supporté par les outils et IDE. IntelliJ IDEA, par exemple, supporte l'auto-complétion et le surlignement syntaxique des annotations JDK 5.0. La nouvelle révision des spécifications des EJB (JSR-220) utilise les annotations JDK 5.0 comme mécanisme primaire pour les meta-données des beans entités. Hibernate3 implémente l'<literal>EntityManager</literal> de la JSR-220 (API de persistance), le support du mapping de meta-données est disponible via le package <emphasis>Hibernate Annotations</emphasis>, en tant que module séparé à télécharger. EJB3 (JSR-220) et les métadata Hibernate3 sont supportés."

#: index.docbook:2689
msgid "Unique identifiers of entities and collections may be of any basic type except <literal>binary</literal>, <literal>blob</literal> and <literal>clob</literal>. (Composite identifiers are also allowed, see below.)"
msgstr "Ceci est un exemple d'une classe POJO annotée comme un EJB entité :"

#: index.docbook:2695
msgid "The basic value types have corresponding <literal>Type</literal> constants defined on <literal>org.hibernate.Hibernate</literal>. For example, <literal>Hibernate.STRING</literal> represents the <literal>string</literal> type."
msgstr ""
      "<![CDATA[@Entity(access = AccessType.FIELD)\n"
      "public class Customer implements Serializable {\n"
      "\n"
      "    @Id;\n"
      "    Long id;\n"
      "\n"
      "    String firstName;\n"
      "    String lastName;\n"
      "    Date birthday;\n"
      "\n"
      "    @Transient\n"
      "    Integer age;\n"
      "\n"
      "    @Embedded\n"
      "    private Address homeAddress;\n"
      "\n"
      "    @OneToMany(cascade=CascadeType.ALL)\n"
      "    @JoinColumn(name=\"CUSTOMER_ID\")\n"
      "    Set<Order> orders;\n"
      "\n"
      "    // Getter/setter and business methods\n"
      "}]]>"

#: index.docbook:2704
msgid "Custom value types"
msgstr "Notez que le support des annotations JDK 5.0 (et de la JSR-220) est encore en cours et n'est pas terminé. Référez vous au module Hibernate Annotation pour plus de détails."

#: index.docbook:2706
msgid "It is relatively easy for developers to create their own value types. For example, you might want to persist properties of type <literal>java.lang.BigInteger</literal> to <literal>VARCHAR</literal> columns. Hibernate does not provide a built-in type for this. But custom types are not limited to mapping a property (or collection element) to a single table column. So, for example, you might have a Java property <literal>getName()</literal>/<literal>setName()</literal> of type <literal>java.lang.String</literal> that is persisted to the columns <literal>FIRST_NAME</literal>, <literal>INITIAL</literal>, <literal>SURNAME</literal>."
msgstr "Propriétés générées"

#: index.docbook:2717
msgid "To implement a custom type, implement either <literal>org.hibernate.UserType</literal> or <literal>org.hibernate.CompositeUserType</literal> and declare properties using the fully qualified classname of the type. Check out <literal>org.hibernate.test.DoubleStringType</literal> to see the kind of things that are possible."
msgstr "Les propriétés générées sont des propriétés dont les valeurs sont générées par la base de données. Typiquement, les applications Hibernate avaient besoin d'invoquer <literal>refresh</literal> sur les instances qui contenaient des propriétés pour lesquelles la base de données générait des valeurs. Marquer les propriétés comme générées permet à l'application de déléguer cette responsabilité à Hibernate. Principalement, à chaque fois qu'Hibernate réalise une insertion ou une mise à jour en base de données pour une entité marquée comme telle, cela provoque immédiatement un select pour récupérer les valeurs générées."

#: index.docbook:2725
msgid ""
      "<![CDATA[<property name=\"twoStrings\" type=\"org.hibernate.test.DoubleStringType\">\n"
      "    <column name=\"first_string\"/>\n"
      "    <column name=\"second_string\"/>\n"
      "</property>]]>"
msgstr "Les propriétés marquées comme générées doivent de plus ne pas être insérables et modifiables Seuls <xref linkend=\"mapping-declaration-version\"/>versions, <xref linkend=\"mapping-declaration-timestamp\"/>timestamps, et <xref linkend=\"mapping-declaration-property\"/>simple properties peuvent être marqués comme générées."

#: index.docbook:2727
msgid "Notice the use of <literal>&lt;column&gt;</literal> tags to map a property to multiple columns."
msgstr "<literal>never</literal> (par défaut) - indique la valeur de la propriété n'est pas générée dans la base de données."

#: index.docbook:2732
msgid "The <literal>CompositeUserType</literal>, <literal>EnhancedUserType</literal>, <literal>UserCollectionType</literal>, and <literal>UserVersionType</literal> interfaces provide support for more specialized uses."
msgstr "<literal>insert</literal> - indique que la valeur de la propriété donnée est générée à l'insertion mais pas lors des futures mises à jour de l'enregistrement. Les colonnes de type \"date de création\" sont le cas d'utilisation typique de cette option. Notez que même les propriétés <xref linkend=\"mapping-declaration-version\"/>version et <xref linkend=\"mapping-declaration-timestamp\"/>timestamp peuvent être déclarées comme générées, cette option n'est pas disponible à cet endroit..."

#: index.docbook:2738
msgid "You may even supply parameters to a <literal>UserType</literal> in the mapping file. To do this, your <literal>UserType</literal> must implement the <literal>org.hibernate.usertype.ParameterizedType</literal> interface. To supply parameters to your custom type, you can use the <literal>&lt;type&gt;</literal> element in your mapping files."
msgstr "<literal>always</literal> - indique que la valeur de la propriété est générée à l'insert comme aux updates."

#: index.docbook:2746
msgid ""
      "<![CDATA[<property name=\"priority\">\n"
      "    <type name=\"com.mycompany.usertypes.DefaultValueIntegerType\">\n"
      "        <param name=\"default\">0</param>\n"
      "    </type>\n"
      "</property>]]>"
msgstr "Objets auxiliaires de la base de données"

#: index.docbook:2748
msgid "The <literal>UserType</literal> can now retrieve the value for the parameter named <literal>default</literal> from the <literal>Properties</literal> object passed to it."
msgstr "Permettent les ordres CREATE et DROP d'objets arbitraire de la base de donnéées, en conjonction avec les outils Hibernate d'évolutions de schéma, pour permettre de définir complètement un schéma utilisateur au sein des fichiers de mapping Hibernate. Bien que conçu spécifiquement pour créer et supprimer des objets tels que des triggers et des procédures stockées, ou toute commande pouvant être exécutée via une méthode de <literal>java.sql.Statement.execute()</literal> (ALTERs, INSERTS, etc). Il y a principalement deux modes pour définir les objets auxiliaires de base de données..."

#: index.docbook:2753
msgid "If you use a certain <literal>UserType</literal> very often, it may be useful to define a shorter name for it. You can do this using the <literal>&lt;typedef&gt;</literal> element. Typedefs assign a name to a custom type, and may also contain a list of default parameter values if the type is parameterized."
msgstr "Le premier mode est de lister explicitement les commandes CREATE et DROP dans le fichier de mapping:"

#: index.docbook:2760
msgid ""
      "<![CDATA[<typedef class=\"com.mycompany.usertypes.DefaultValueIntegerType\" name=\"default_zero\">\n"
      "    <param name=\"default\">0</param>\n"
      "</typedef>]]>"
msgstr ""
      "<![CDATA[<hibernate-mapping>\n"
      "    ...\n"
      "    <database-object>\n"
      "        <create>CREATE TRIGGER my_trigger ...</create>\n"
      "        <drop>DROP TRIGGER my_trigger</drop>\n"
      "    </database-object>\n"
      "</hibernate-mapping>]]>"

#: index.docbook:2762
msgid "<![CDATA[<property name=\"priority\" type=\"default_zero\"/>]]>"
msgstr "Le second mode est de fournir une classe particulière qui connait comment construire les commandes CREATE et DROP. Cette classe particulière doit implémenter l'interface <literal>org.hibernate.mapping.AuxiliaryDatabaseObject</literal>."

#: index.docbook:2764
msgid "It is also possible to override the parameters supplied in a typedef on a case-by-case basis by using type parameters on the property mapping."
msgstr ""
      "<![CDATA[<hibernate-mapping>\n"
      "    ...\n"
      "    <database-object>\n"
      "        <definition class=\"MyTriggerDefinition\"/>\n"
      "    </database-object>\n"
      "</hibernate-mapping>]]>"

#: index.docbook:2769
msgid "Even though Hibernate's rich range of built-in types and support for components means you will very rarely <emphasis>need</emphasis> to use a custom type, it is nevertheless considered good form to use custom types for (non-entity) classes that occur frequently in your application. For example, a <literal>MonetaryAmount</literal> class is a good candidate for a <literal>CompositeUserType</literal>, even though it could easily be mapped as a component. One motivation for this is abstraction. With a custom type, your mapping documents would be future-proofed against possible changes in your way of representing monetary values."
msgstr "Additionnellement, ces objets de base de données peuvent être optionnellement traités selon l'utilisation de dialectes particuliers.."

#: index.docbook:2785
msgid "Mapping a class more than once"
msgstr ""
      "<![CDATA[<hibernate-mapping>\n"
      "    ...\n"
      "    <database-object>\n"
      "        <definition class=\"MyTriggerDefinition\"/>\n"
      "        <dialect-scope name=\"org.hibernate.dialect.Oracle9Dialect\"/>\n"
      "        <dialect-scope name=\"org.hibernate.dialect.OracleDialect\"/>\n"
      "    </database-object>\n"
      "</hibernate-mapping>]]>"

#: index.docbook:2786
msgid "It is possible to provide more than one mapping for a particular persistent class. In this case you must specify an <emphasis>entity name</emphasis> do disambiguate between instances of the two mapped entities. (By default, the entity name is the same as the class name.) Hibernate lets you specify the entity name when working with persistent objects, when writing queries, or when mapping associations to the named entity."
msgstr ""

#: index.docbook:2794
msgid ""
      "<![CDATA[<class name=\"Contract\" table=\"Contracts\"\n"
      "        entity-name=\"CurrentContract\">\n"
      "    ...\n"
      "    <set name=\"history\" inverse=\"true\"\n"
      "            order-by=\"effectiveEndDate desc\">\n"
      "        <key column=\"currentContractId\"/>\n"
      "        <one-to-many entity-name=\"HistoricalContract\"/>\n"
      "    </set>\n"
      "</class>\n"
      "\n"
      "<class name=\"Contract\" table=\"ContractHistory\"\n"
      "        entity-name=\"HistoricalContract\">\n"
      "    ...\n"
      "    <many-to-one name=\"currentContract\"\n"
      "            column=\"currentContractId\"\n"
      "            entity-name=\"CurrentContract\"/>\n"
      "</class>]]>"
msgstr ""

#: index.docbook:2796
msgid "Notice how associations are now specified using <literal>entity-name</literal> instead of <literal>class</literal>."
msgstr ""

#: index.docbook:2804
msgid "SQL quoted identifiers"
msgstr ""

#: index.docbook:2805
msgid "You may force Hibernate to quote an identifier in the generated SQL by enclosing the table or column name in backticks in the mapping document. Hibernate will use the correct quotation style for the SQL <literal>Dialect</literal> (usually double quotes, but brackets for SQL Server and backticks for MySQL)."
msgstr ""

#: index.docbook:2812
msgid ""
      "<![CDATA[<class name=\"LineItem\" table=\"`Line Item`\">\n"
      "    <id name=\"id\" column=\"`Item Id`\"/><generator class=\"assigned\"/></id>\n"
      "    <property name=\"itemNumber\" column=\"`Item #`\"/>\n"
      "    ...\n"
      "</class>]]>"
msgstr ""

#: index.docbook:2818
msgid "Metadata alternatives"
msgstr ""

#: index.docbook:2820
msgid "XML isn't for everyone, and so there are some alternative ways to define O/R mapping metadata in Hibernate."
msgstr ""

#: index.docbook:2825
msgid "Using XDoclet markup"
msgstr ""

#: index.docbook:2827
msgid "Many Hibernate users prefer to embed mapping information directly in sourcecode using XDoclet <literal>@hibernate.tags</literal>. We will not cover this approach in this document, since strictly it is considered part of XDoclet. However, we include the following example of the <literal>Cat</literal> class with XDoclet mappings."
msgstr ""

#: index.docbook:2834
msgid ""
      "<![CDATA[package eg;\n"
      "import java.util.Set;\n"
      "import java.util.Date;\n"
      "\n"
      "/**\n"
      " * @hibernate.class\n"
      " *  table=\"CATS\"\n"
      " */\n"
      "public class Cat {\n"
      "    private Long id; // identifier\n"
      "    private Date birthdate;\n"
      "    private Cat mother;\n"
      "    private Set kittens\n"
      "    private Color color;\n"
      "    private char sex;\n"
      "    private float weight;\n"
      "\n"
      "    /*\n"
      "     * @hibernate.id\n"
      "     *  generator-class=\"native\"\n"
      "     *  column=\"CAT_ID\"\n"
      "     */\n"
      "    public Long getId() {\n"
      "        return id;\n"
      "    }\n"
      "    private void setId(Long id) {\n"
      "        this.id=id;\n"
      "    }\n"
      "\n"
      "    /**\n"
      "     * @hibernate.many-to-one\n"
      "     *  column=\"PARENT_ID\"\n"
      "     */\n"
      "    public Cat getMother() {\n"
      "        return mother;\n"
      "    }\n"
      "    void setMother(Cat mother) {\n"
      "        this.mother = mother;\n"
      "    }\n"
      "\n"
      "    /**\n"
      "     * @hibernate.property\n"
      "     *  column=\"BIRTH_DATE\"\n"
      "     */\n"
      "    public Date getBirthdate() {\n"
      "        return birthdate;\n"
      "    }\n"
      "    void setBirthdate(Date date) {\n"
      "        birthdate = date;\n"
      "    }\n"
      "    /**\n"
      "     * @hibernate.property\n"
      "     *  column=\"WEIGHT\"\n"
      "     */\n"
      "    public float getWeight() {\n"
      "        return weight;\n"
      "    }\n"
      "    void setWeight(float weight) {\n"
      "        this.weight = weight;\n"
      "    }\n"
      "\n"
      "    /**\n"
      "     * @hibernate.property\n"
      "     *  column=\"COLOR\"\n"
      "     *  not-null=\"true\"\n"
      "     */\n"
      "    public Color getColor() {\n"
      "        return color;\n"
      "    }\n"
      "    void setColor(Color color) {\n"
      "        this.color = color;\n"
      "    }\n"
      "    /**\n"
      "     * @hibernate.set\n"
      "     *  inverse=\"true\"\n"
      "     *  order-by=\"BIRTH_DATE\"\n"
      "     * @hibernate.collection-key\n"
      "     *  column=\"PARENT_ID\"\n"
      "     * @hibernate.collection-one-to-many\n"
      "     */\n"
      "    public Set getKittens() {\n"
      "        return kittens;\n"
      "    }\n"
      "    void setKittens(Set kittens) {\n"
      "        this.kittens = kittens;\n"
      "    }\n"
      "    // addKitten not needed by Hibernate\n"
      "    public void addKitten(Cat kitten) {\n"
      "        kittens.add(kitten);\n"
      "    }\n"
      "\n"
      "    /**\n"
      "     * @hibernate.property\n"
      "     *  column=\"SEX\"\n"
      "     *  not-null=\"true\"\n"
      "     *  update=\"false\"\n"
      "     */\n"
      "    public char getSex() {\n"
      "        return sex;\n"
      "    }\n"
      "    void setSex(char sex) {\n"
      "        this.sex=sex;\n"
      "    }\n"
      "}]]>"
msgstr ""

#: index.docbook:2836
msgid "See the Hibernate web site for more examples of XDoclet and Hibernate."
msgstr ""

#: index.docbook:2843
msgid "Using JDK 5.0 Annotations"
msgstr ""

#: index.docbook:2845
msgid "JDK 5.0 introduced XDoclet-style annotations at the language level, type-safe and checked at compile time. This mechnism is more powerful than XDoclet annotations and better supported by tools and IDEs. IntelliJ IDEA, for example, supports auto-completion and syntax highlighting of JDK 5.0 annotations. The new revision of the EJB specification (JSR-220) uses JDK 5.0 annotations as the primary metadata mechanism for entity beans. Hibernate3 implements the <literal>EntityManager</literal> of JSR-220 (the persistence API), support for mapping metadata is available via the <emphasis>Hibernate Annotations</emphasis> package, as a separate download. Both EJB3 (JSR-220) and Hibernate3 metadata is supported."
msgstr ""

#: index.docbook:2856
msgid "This is an example of a POJO class annotated as an EJB entity bean:"
msgstr ""

#: index.docbook:2860
msgid ""
      "<![CDATA[@Entity(access = AccessType.FIELD)\n"
      "public class Customer implements Serializable {\n"
      "\n"
      "    @Id;\n"
      "    Long id;\n"
      "\n"
      "    String firstName;\n"
      "    String lastName;\n"
      "    Date birthday;\n"
      "\n"
      "    @Transient\n"
      "    Integer age;\n"
      "\n"
      "    @Embedded\n"
      "    private Address homeAddress;\n"
      "\n"
      "    @OneToMany(cascade=CascadeType.ALL)\n"
      "    @JoinColumn(name=\"CUSTOMER_ID\")\n"
      "    Set<Order> orders;\n"
      "\n"
      "    // Getter/setter and business methods\n"
      "}]]>"
msgstr ""

#: index.docbook:2862
msgid "Note that support for JDK 5.0 Annotations (and JSR-220) is still work in progress and not completed. Please refer to the Hibernate Annotations module for more details."
msgstr ""

#: index.docbook:2871
msgid "Generated Properties"
msgstr ""

#: index.docbook:2872
msgid "Generated properties are properties which have their values generated by the database. Typically, Hibernate applications needed to <literal>refresh</literal> objects which contain any properties for which the database was generating values. Marking properties as generated, however, lets the application delegate this responsibility to Hibernate. Essentially, whenever Hibernate issues an SQL INSERT or UPDATE for an entity which has defined generated properties, it immediately issues a select afterwards to retrieve the generated values."
msgstr ""

#: index.docbook:2881
msgid "Properties marked as generated must additionally be non-insertable and non-updateable. Only <xref linkend=\"mapping-declaration-version\"/>versions, <xref linkend=\"mapping-declaration-timestamp\"/>timestamps, and <xref linkend=\"mapping-declaration-property\"/>simple properties can be marked as generated."
msgstr ""

#: index.docbook:2888
msgid "<literal>never</literal> (the default) - means that the given property value is not generated within the database."
msgstr ""

#: index.docbook:2892
msgid "<literal>insert</literal> - states that the given property value is generated on insert, but is not regenerated on subsequent updates. Things like created-date would fall into this category. Note that even thought <xref linkend=\"mapping-declaration-version\"/>version and <xref linkend=\"mapping-declaration-timestamp\"/>timestamp properties can be marked as generated, this option is not available there..."
msgstr ""

#: index.docbook:2900
msgid "<literal>always</literal> - states that the property value is generated both on insert and on update."
msgstr ""

#: index.docbook:2907
msgid "Auxiliary Database Objects"
msgstr ""

#: index.docbook:2908
msgid "Allows CREATE and DROP of arbitrary database objects, in conjunction with Hibernate's schema evolution tools, to provide the ability to fully define a user schema within the Hibernate mapping files. Although designed specifically for creating and dropping things like triggers or stored procedures, really any SQL command that can be run via a <literal>java.sql.Statement.execute()</literal> method is valid here (ALTERs, INSERTS, etc). There are essentially two modes for defining auxiliary database objects..."
msgstr ""

#: index.docbook:2917
msgid "The first mode is to explicitly list the CREATE and DROP commands out in the mapping file:"
msgstr ""

#: index.docbook:2921
msgid ""
      "<![CDATA[<hibernate-mapping>\n"
      "    ...\n"
      "    <database-object>\n"
      "        <create>CREATE TRIGGER my_trigger ...</create>\n"
      "        <drop>DROP TRIGGER my_trigger</drop>\n"
      "    </database-object>\n"
      "</hibernate-mapping>]]>"
msgstr ""

#: index.docbook:2922
msgid "The second mode is to supply a custom class which knows how to construct the CREATE and DROP commands. This custom class must implement the <literal>org.hibernate.mapping.AuxiliaryDatabaseObject</literal> interface."
msgstr ""

#: index.docbook:2927
msgid ""
      "<![CDATA[<hibernate-mapping>\n"
      "    ...\n"
      "    <database-object>\n"
      "        <definition class=\"MyTriggerDefinition\"/>\n"
      "    </database-object>\n"
      "</hibernate-mapping>]]>"
msgstr ""

#: index.docbook:2928
msgid "Additionally, these database objects can be optionally scoped such that they only apply when certain dialects are used."
msgstr ""

#: index.docbook:2932
msgid ""
      "<![CDATA[<hibernate-mapping>\n"
      "    ...\n"
      "    <database-object>\n"
      "        <definition class=\"MyTriggerDefinition\"/>\n"
      "        <dialect-scope name=\"org.hibernate.dialect.Oracle9Dialect\"/>\n"
      "        <dialect-scope name=\"org.hibernate.dialect.OracleDialect\"/>\n"
      "    </database-object>\n"
      "</hibernate-mapping>]]>"
msgstr ""

msgid "ROLES_OF_TRANSLATORS"
msgstr "<!--TRANS:ROLES_OF_TRANSLATORS-->"

msgid "CREDIT_FOR_TRANSLATORS"
msgstr "<!--TRANS:CREDIT_FOR_TRANSLATORS-->"

