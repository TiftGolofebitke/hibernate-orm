#, fuzzy
msgid ""
msgstr ""
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Content-Type: text/plain; charset=utf-8\n"
#: index.docbook:5
msgid "Working with objects"
msgstr "Travailler avec des objets"

#: index.docbook:7
msgid "Hibernate is a full object/relational mapping solution that not only shields the developer from the details of the underlying database management system, but also offers <emphasis>state management</emphasis> of objects. This is, contrary to the management of SQL <literal>statements</literal> in common JDBC/SQL persistence layers, a very natural object-oriented view of persistence in Java applications."
msgstr "Hibernate est une solution de mapping objet/relationnel complète qui ne masque pas seulement au développpeur les détails du système de gestion de base de données sous-jacent, mais offre aussi <emphasis>la gestion d'état</emphasis> des objets. C'est, contrairement à la gestion de <literal>statements</literal> SQL dans les couches de persistance habituelles JDBC/SQL, une vue orientée objet très naturelle de la persistance dans les applications Java."

#: index.docbook:16
msgid "In other words, Hibernate application developers should always think about the <emphasis>state</emphasis> of their objects, and not necessarily about the execution of SQL statements. This part is taken care of by Hibernate and is only relevant for the application developer when tuning the performance of the system."
msgstr "En d'autres mots, les développeurs d'applications Hibernate devrait toujours réfléchir à <emphasis>l'état</emphasis> de leurs objets, et pas nécessairement à l'exécution des expressions SQL. Cette part est prise en charge pas Hibernate et seulement importante pour les développeurs d'applications lors du réglage de la performance de leur système."

#: index.docbook:24
msgid "Hibernate object states"
msgstr "États des objets Hibernate"

#: index.docbook:26
msgid "Hibernate defines and supports the following object states:"
msgstr "Hibernate définit et comprend les états suivants :"

#: index.docbook:32
msgid "<emphasis>Transient</emphasis> - an object is transient if it has just been instantiated using the <literal>new</literal> operator, and it is not associated with a Hibernate <literal>Session</literal>. It has no persistent representation in the database and no identifier value has been assigned. Transient instances will be destroyed by the garbage collector if the application doesn't hold a reference anymore. Use the Hibernate <literal>Session</literal> to make an object persistent (and let Hibernate take care of the SQL statements that need to be executed for this transition)."
msgstr "<emphasis>Éphémère</emphasis> (NdT : transient) - un objet est éphémère s'il a juste été instancié en utilisant l'opérateur <literal>new</literal>. Il n'a aucune représentation persistante dans la base de données et aucune valeur d'identifiant n'a été assignée. Les instances éphémères seront détruites par le ramasse-miettes si l'application n'en conserve aucune référence. Utilisez la <literal>Session</literal> d'Hibernate pour rendre un objet persistant (et laisser Hibernate s'occuper des expressions SQL qui ont besoin d'être exécutées pour cette transistion)."

#: index.docbook:44
msgid "<emphasis>Persistent</emphasis> - a persistent instance has a representation in the database and an identifier value. It might just have been saved or loaded, however, it is by definition in the scope of a <literal>Session</literal>. Hibernate will detect any changes made to an object in persistent state and synchronize the state with the database when the unit of work completes. Developers don't execute manual <literal>UPDATE</literal> statements, or <literal>DELETE</literal> statements when an object should be made transient."
msgstr "<emphasis>Persistant</emphasis> - une instance persistante a une représentation dans la base de données et une valeur d'identifiant. Elle pourrait avoir juste été sauvegardée ou chargée, pourtant, elle est par définition dans la portée d'une <literal>Session</literal>. Hibernate détectera n'importe quels changements effectués sur un objet dans l'état persistant et synchronisera l'état avec la base de données lors de la fin l'unité de travail. Les développeurs n'exécutent pas d'expressions <literal>UPDATE</literal> ou <literal>DELETE</literal> manuelles lorsqu'un objet devrait être rendu éphémère."

#: index.docbook:55
msgid "<emphasis>Detached</emphasis> - a detached instance is an object that has been persistent, but its <literal>Session</literal> has been closed. The reference to the object is still valid, of course, and the detached instance might even be modified in this state. A detached instance can be reattached to a new <literal>Session</literal> at a later point in time, making it (and all the modifications) persistent again. This feature enables a programming model for long running units of work that require user think-time. We call them <emphasis>application transactions</emphasis>, i.e. a unit of work from the point of view of the user."
msgstr "<emphasis>Détaché</emphasis> - une instance détachée est un objet qui a été persistant, mais dont sa <literal>Session</literal> a été fermée. La référence à l'objet est encore valide, bien sûr, et l'instance détachée pourrait même être modifiée dans cet état. Une instance détachée peut être réattachée à une nouvelle <literal>Session</literal> plus tard dans le temps, la rendant (et toutes les modifications avec) de nouveau persistante. Cette fonctionnalité rend possible un modèle de programmation pour de longues unités de travail qui requièrent un temps de réflexion de l'utilisateur. Nous les appelons des <emphasis>conversations</emphasis>, c'est-à-dire une unité de travail du point de vue de l'utilisateur."

#: index.docbook:69
msgid "We'll now discuss the states and state transitions (and the Hibernate methods that trigger a transition) in more detail."
msgstr "Nous alons maintenant dicuster des états et des transitions d'état (et des méthodes d'Hibernate qui déclenchent une transition) plus en détails."

#: index.docbook:77
msgid "Making objects persistent"
msgstr "Rendre des objets persistants"

#: index.docbook:79
msgid "Newly instantiated instances of a a persistent class are considered <emphasis>transient</emphasis> by Hibernate. We can make a transient instance <emphasis>persistent</emphasis> by associating it with a session:"
msgstr "Les instances nouvellement instanciées d'une classe persistante sont considérées <emphasis>éphémères</emphasis> par Hibernate. Nous pouvons rendre une instance éphémère <emphasis>persistante</emphasis> en l'associant avec une session :"

#: index.docbook:86
msgid ""
      "<![CDATA[DomesticCat fritz = new DomesticCat();\n"
      "fritz.setColor(Color.GINGER);\n"
      "fritz.setSex('M');\n"
      "fritz.setName(\"Fritz\");\n"
      "Long generatedId = (Long) sess.save(fritz);]]>"
msgstr ""
      "<![CDATA[DomesticCat fritz = new DomesticCat();\n"
      "fritz.setColor(Color.GINGER);\n"
      "fritz.setSex('M');\n"
      "fritz.setName(\"Fritz\");\n"
      "Long generatedId = (Long) sess.save(fritz);]]>"

#: index.docbook:88
msgid "If <literal>Cat</literal> has a generated identifier, the identifier is generated and assigned to the <literal>cat</literal> when <literal>save()</literal> is called. If <literal>Cat</literal> has an <literal>assigned</literal> identifier, or a composite key, the identifier should be assigned to the <literal>cat</literal> instance before calling <literal>save()</literal>. You may also use <literal>persist()</literal> instead of <literal>save()</literal>, with the semantics defined in the EJB3 early draft."
msgstr "Si <literal>Cat</literal> a un identifiant généré, l'identifiant est généré et assigné au <literal>cat</literal> lorsque <literal>save()</literal> est appelée. Si <literal>Cat</literal> a un identifiant <literal>assigned</literal>, ou une clef composée, l'identifiant devrait être assigné à l'instance de <literal>cat</literal> avant d'appeler <literal>save()</literal>. Vous pouvez aussi utiliser <literal>persist()</literal> à la place de<literal>save()</literal>, avec la sémantique définie plus tôt dans le brouillon d'EJB3."

#: index.docbook:100
msgid "<literal>persist()</literal> makes a transient instance persistent. However, it doesn't guarantee that the identifier value will be assigned to the persistent instance immediately, the assignment might happen at flush time. <literal>persist()</literal> also guarantees that it will not execute an <literal>INSERT</literal> statement if it is called outside of transaction boundaries. This is useful in long-running conversations with an extended Session/persistence context."
msgstr "Alternativement, vous pouvez assigner l'identifiant en utilisant une version surchargée de <literal>save()</literal>."

#: index.docbook:111
msgid "<literal>save()</literal> does guarantee to return an identifier. If an INSERT has to be executed to get the identifier ( e.g. \"identity\" generator, not \"sequence\"), this INSERT happens immediately, no matter if you are inside or outside of a transaction. This is problematic in a long-running conversation with an extended Session/persistence context."
msgstr ""
      "<![CDATA[DomesticCat pk = new DomesticCat();\n"
      "pk.setColor(Color.TABBY);\n"
      "pk.setSex('F');\n"
      "pk.setName(\"PK\");\n"
      "pk.setKittens( new HashSet() );\n"
      "pk.addKitten(fritz);\n"
      "sess.save( pk, new Long(1234) );]]>"

#: index.docbook:121
msgid "Alternatively, you may assign the identifier using an overloaded version of <literal>save()</literal>."
msgstr "Si l'objet que vous rendez persistant a des objets associés (par exemple, la collection <literal>kittens</literal> dans l'exemple précédent), ces objets peuvent être rendus persistants dans n'importe quel ordre que vous souhaitez à moins que vous ayez une contrainte <literal>NOT NULL</literal> sur la colonne de la clef étrangère. Il n'y a jamais de risque de violer une contrainte de clef étrangère. Cependant, vous pourriez violer une contrainte <literal>NOT NULL</literal> si vous appeliez <literal>save()</literal> sur les objets dans le mauvais ordre."

#: index.docbook:126
msgid ""
      "<![CDATA[DomesticCat pk = new DomesticCat();\n"
      "pk.setColor(Color.TABBY);\n"
      "pk.setSex('F');\n"
      "pk.setName(\"PK\");\n"
      "pk.setKittens( new HashSet() );\n"
      "pk.addKitten(fritz);\n"
      "sess.save( pk, new Long(1234) );]]>"
msgstr "Habituellement, vous ne vous préoccupez pas de ce détail, puisque vous utiliserez très probablement la fonctionnalité de <emphasis>persistance transitive</emphasis> d'Hibernate pour sauvegarder les objets associés automatiquement. Alors, même les violations de contrainte <literal>NOT NULL</literal> n'ont plus lieu - Hibernate prendra soin de tout. La persistance transitive est traitée plus loin dans ce chapitre."

#: index.docbook:128
msgid "If the object you make persistent has associated objects (e.g. the <literal>kittens</literal> collection in the previous example), these objects may be made persistent in any order you like unless you have a <literal>NOT NULL</literal> constraint upon a foreign key column. There is never a risk of violating foreign key constraints. However, you might violate a <literal>NOT NULL</literal> constraint if you <literal>save()</literal> the objects in the wrong order."
msgstr "Chargement d'un objet"

#: index.docbook:138
msgid "Usually you don't bother with this detail, as you'll very likely use Hibernate's <emphasis>transitive persistence</emphasis> feature to save the associated objects automatically. Then, even <literal>NOT NULL</literal> constraint violations don't occur - Hibernate will take care of everything. Transitive persistence is discussed later in this chapter."
msgstr "Les méthodes <literal>load()</literal> de <literal>Session</literal> vous donnent un moyen de récupérer une instance persistante si vous connaissez déjà son identifiant. <literal>load()</literal> prend un objet de classe et chargera l'état dans une instance nouvellement instanciée de cette classe, dans un état persistant."

#: index.docbook:149
msgid "Loading an object"
msgstr "<![CDATA[Cat fritz = (Cat) sess.load(Cat.class, generatedId);]]>"

#: index.docbook:151
msgid "The <literal>load()</literal> methods of <literal>Session</literal> gives you a way to retrieve a persistent instance if you already know its identifier. <literal>load()</literal> takes a class object and will load the state into a newly instantiated instance of that class, in persistent state."
msgstr ""
      "<![CDATA[// vous avez besoin d'envelopper les identiants primitifs\n"
      "long pkId = 1234;\n"
      "DomesticCat pk = (DomesticCat) sess.load( Cat.class, new Long(pkId) );]]>"

#: index.docbook:158
msgid "<![CDATA[Cat fritz = (Cat) sess.load(Cat.class, generatedId);]]>"
msgstr "Alternativement, vous pouvez charger un état dans une instance donnée :"

#: index.docbook:160
msgid ""
      "<![CDATA[// you need to wrap primitive identifiers\n"
      "long id = 1234;\n"
      "DomesticCat pk = (DomesticCat) sess.load( DomesticCat.class, new Long(id) );]]>"
msgstr ""
      "<![CDATA[Cat cat = new DomesticCat();\n"
      "// load pk's state into cat\n"
      "sess.load( cat, new Long(pkId) );\n"
      "Set kittens = cat.getKittens();]]>"

#: index.docbook:162
msgid "Alternatively, you can load state into a given instance:"
msgstr "Notez que <literal>load()</literal> lèvera une exception irrécupérable s'il n'y a pas de ligne correspondante dans la base de données. Si la classe est mappée avec un proxy, <literal>load()</literal> retourne juste un proxy non initialisé et n'accède en fait pas à la base de données jusqu'à ce que vous invoquiez une méthode du proxy. Ce comportement est très utile si vous souhaitez créer une association vers un objet sans réellement le charger à partir de la base de données. Cela permet aussi à de multiples instances d'être chargées comme un lot si <literal>batch-size</literal> est défini pour le mapping de la classe."

#: index.docbook:166
msgid ""
      "<![CDATA[Cat cat = new DomesticCat();\n"
      "// load pk's state into cat\n"
      "sess.load( cat, new Long(pkId) );\n"
      "Set kittens = cat.getKittens();]]>"
msgstr "Si vous n'êtes pas certain qu'une ligne correspondante existe, vous devriez utiliser la méthode <literal>get()</literal>, laquelle accède à la base de données immédiatement et retourne null s'il n'y a pas de ligne correspondante."

#: index.docbook:168
msgid "Note that <literal>load()</literal> will throw an unrecoverable exception if there is no matching database row. If the class is mapped with a proxy, <literal>load()</literal> just returns an uninitialized proxy and does not actually hit the database until you invoke a method of the proxy. This behaviour is very useful if you wish to create an association to an object without actually loading it from the database. It also allows multiple instances to be loaded as a batch if <literal>batch-size</literal> is defined for the class mapping."
msgstr ""
      "<![CDATA[Cat cat = (Cat) sess.get(Cat.class, id);\n"
      "if (cat==null) {\n"
      "    cat = new Cat();\n"
      "    sess.save(cat, id);\n"
      "}\n"
      "return cat;]]>"

#: index.docbook:179
msgid "If you are not certain that a matching row exists, you should use the <literal>get()</literal> method, which hits the database immediately and returns null if there is no matching row."
msgstr "Vous pouvez même charger un objet en employant un <literal>SELECT ... FOR UPDATE</literal> SQL, en utilisant un <literal>LockMode</literal>. Voir la documentation de l'API pour plus d'informations."

#: index.docbook:185
msgid ""
      "<![CDATA[Cat cat = (Cat) sess.get(Cat.class, id);\n"
      "if (cat==null) {\n"
      "    cat = new Cat();\n"
      "    sess.save(cat, id);\n"
      "}\n"
      "return cat;]]>"
msgstr "<![CDATA[Cat cat = (Cat) sess.get(Cat.class, id, LockMode.UPGRADE);]]>"

#: index.docbook:187
msgid "You may even load an object using an SQL <literal>SELECT ... FOR UPDATE</literal>, using a <literal>LockMode</literal>. See the API documentation for more information."
msgstr "Notez que n'importe quelles instances associées ou collections contenues <emphasis>ne sont pas</emphasis> sélectionnées par <literal>FOR UPDATE</literal>, à moins que vous ne décidiez de spécifier <literal>lock</literal> ou <literal>all</literal> en tant que style de cascade pour l'association."

#: index.docbook:192
msgid "<![CDATA[Cat cat = (Cat) sess.get(Cat.class, id, LockMode.UPGRADE);]]>"
msgstr "Il est possible de re-charger un objet et toutes ses collections à n'importe quel moment, en utilisant la méthode <literal>refresh()</literal>. C'est utile lorsque des \"triggers\" de base de données sont utilisés pour initiliser certains propriétés de l'objet."

#: index.docbook:194
msgid "Note that any associated instances or contained collections are <emphasis>not</emphasis> selected <literal>FOR UPDATE</literal>, unless you decide to specify <literal>lock</literal> or <literal>all</literal> as a cascade style for the association."
msgstr ""
      "<![CDATA[sess.save(cat);\n"
      "sess.flush(); //force the SQL INSERT\n"
      "sess.refresh(cat); //re-read the state (after the trigger executes)]]>"

#: index.docbook:201
msgid "It is possible to re-load an object and all its collections at any time, using the <literal>refresh()</literal> method. This is useful when database triggers are used to initialize some of the properties of the object."
msgstr "Une question importante apparaît généralement à ce point : combien (NdT : de données) Hibernate charge-t-il de la base de données et combient de <literal>SELECT</literal>s utilisera-t-il ? Cela dépent de la <emphasis>stratégie de récupération</emphasis> et cela est expliqué dans <xref linkend=\"performance-fetching\"/>."

#: index.docbook:207
msgid ""
      "<![CDATA[sess.save(cat);\n"
      "sess.flush(); //force the SQL INSERT\n"
      "sess.refresh(cat); //re-read the state (after the trigger executes)]]>"
msgstr "Requêtage"

#: index.docbook:209
msgid "An important question usually appears at this point: How much does Hibernate load from the database and how many SQL <literal>SELECT</literal>s will it use? This depends on the <emphasis>fetching strategy</emphasis> and is explained in <xref linkend=\"performance-fetching\"/>."
msgstr "Si vous ne connaissez par les identifiants des objets que vous recherchez, vous avez besoin d'une requête. Hibernate supporte un langage de requêtes orientées objet facile à utiliser mais puissant. Pour la création de requêtes par programmation, Hibernate supporte une fonction de requêtage sophistiqué Criteria et Example (QBC et QBE). Vous pouvez aussi exprimez votre requête dans le SQL natif de votre base de données, avec un support optionnel d'Hibernate pour la conversion des ensembles de résultats en objets."

#: index.docbook:219
msgid "Querying"
msgstr "Exécution de requêtes"

#: index.docbook:221
msgid "If you don't know the identifiers of the objects you are looking for, you need a query. Hibernate supports an easy-to-use but powerful object oriented query language (HQL). For programmatic query creation, Hibernate supports a sophisticated Criteria and Example query feature (QBC and QBE). You may also express your query in the native SQL of your database, with optional support from Hibernate for result set conversion into objects."
msgstr "Les requêtes HQL et SQL natives sont représentées avec une instance de <literal>org.hibernate.Query</literal>. L'interface offre des méthodes pour la liaison des paramètres, la gestion des ensembles de resultats, et pour l'exécution de la requête réelle. Vous obtenez toujours une <literal>Query</literal> en utilisant la <literal>Session</literal> courante :"

#: index.docbook:231
msgid "Executing queries"
msgstr ""
      "<![CDATA[List cats = session.createQuery(\n"
      "    \"from Cat as cat where cat.birthdate < ?\")\n"
      "    .setDate(0, date)\n"
      "    .list();\n"
      "\n"
      "List mothers = session.createQuery(\n"
      "    \"select mother from Cat as cat join cat.mother as mother where cat.name = ?\")\n"
      "    .setString(0, name)\n"
      "    .list();\n"
      "\n"
      "List kittens = session.createQuery(\n"
      "    \"from Cat as cat where cat.mother = ?\")\n"
      "    .setEntity(0, pk)\n"
      "    .list();\n"
      "\n"
      "Cat mother = (Cat) session.createQuery(\n"
      "    \"select cat.mother from Cat as cat where cat = ?\")\n"
      "    .setEntity(0, izi)\n"
      "    .uniqueResult();]]>"

#: index.docbook:233
msgid "HQL and native SQL queries are represented with an instance of <literal>org.hibernate.Query</literal>. This interface offers methods for parameter binding, result set handling, and for the execution of the actual query. You always obtain a <literal>Query</literal> using the current <literal>Session</literal>:"
msgstr "Une requête est généralement exécutée en invoquant <literal>list()</literal>, le résultat de la requête sera chargée complètement dans une collection en mémoire. Les intances d'entités recupérées par une requête sont dans un état persistant. La méthode <literal>uniqueResult()</literal> offre un raccourci si vous savez que votre requête retournera seulement un seul objet."

#: index.docbook:240
msgid ""
      "<![CDATA[List cats = session.createQuery(\n"
      "    \"from Cat as cat where cat.birthdate < ?\")\n"
      "    .setDate(0, date)\n"
      "    .list();\n"
      "\n"
      "List mothers = session.createQuery(\n"
      "    \"select mother from Cat as cat join cat.mother as mother where cat.name = ?\")\n"
      "    .setString(0, name)\n"
      "    .list();\n"
      "\n"
      "List kittens = session.createQuery(\n"
      "    \"from Cat as cat where cat.mother = ?\")\n"
      "    .setEntity(0, pk)\n"
      "    .list();\n"
      "\n"
      "Cat mother = (Cat) session.createQuery(\n"
      "    \"select cat.mother from Cat as cat where cat = ?\")\n"
      "    .setEntity(0, izi)\n"
      "    .uniqueResult();]]\n"
      "\n"
      "Query mothersWithKittens = (Cat) session.createQuery(\n"
      "    \"select mother from Cat as mother left join fetch mother.kittens\");\n"
      "Set uniqueMothers = new HashSet(mothersWithKittens.list());]]>"
msgstr "Itération de résultats"

#: index.docbook:242
msgid "A query is usually executed by invoking <literal>list()</literal>, the result of the query will be loaded completely into a collection in memory. Entity instances retrieved by a query are in persistent state. The <literal>uniqueResult()</literal> method offers a shortcut if you know your query will only return a single object. Note that queries that make use of eager fetching of collections usually return duplicates of the root objects (but with their collections initialized). You can filter these duplicates simply through a <literal>Set</literal>."
msgstr "Occasionnellement, vous pourriez être capable d'obtenir de meilleures performances en exécutant la requête avec la méthode <literal>iterate()</literal>. Ce sera généralement seulement le cas si vous espérez que les intances réelles d'entité retournées par la requête soient déjà chargées dans la session ou le cache de second niveau. Si elles ne sont pas cachées, <literal>iterate()</literal> sera plus lent que <literal>list()</literal> et pourrait nécessiter plusieurs accès à la base de données pour une simple requête, généralement <emphasis>1</emphasis> pour le select initial qui retourne seulement les identifiants, et <emphasis>n</emphasis> selects supplémentaires pour initialiser les instances réelles."

#: index.docbook:254
msgid "Iterating results"
msgstr ""
      "<![CDATA[// fetch ids\n"
      "Iterator iter = sess.createQuery(\"from eg.Qux q order by q.likeliness\").iterate();\n"
      "while ( iter.hasNext() ) {\n"
      "    Qux qux = (Qux) iter.next();  // fetch the object\n"
      "    // something we couldnt express in the query\n"
      "    if ( qux.calculateComplicatedAlgorithm() ) {\n"
      "        // delete the current instance\n"
      "        iter.remove();\n"
      "        // dont need to process the rest\n"
      "        break;\n"
      "    }\n"
      "}]]>"

#: index.docbook:256
msgid "Occasionally, you might be able to achieve better performance by executing the query using the <literal>iterate()</literal> method. This will only usually be the case if you expect that the actual entity instances returned by the query will already be in the session or second-level cache. If they are not already cached, <literal>iterate()</literal> will be slower than <literal>list()</literal> and might require many database hits for a simple query, usually <emphasis>1</emphasis> for the initial select which only returns identifiers, and <emphasis>n</emphasis> additional selects to initialize the actual instances."
msgstr "Requêtes qui retournent des tuples"

#: index.docbook:268
msgid ""
      "<![CDATA[// fetch ids\n"
      "Iterator iter = sess.createQuery(\"from eg.Qux q order by q.likeliness\").iterate();\n"
      "while ( iter.hasNext() ) {\n"
      "    Qux qux = (Qux) iter.next();  // fetch the object\n"
      "    // something we couldnt express in the query\n"
      "    if ( qux.calculateComplicatedAlgorithm() ) {\n"
      "        // delete the current instance\n"
      "        iter.remove();\n"
      "        // dont need to process the rest\n"
      "        break;\n"
      "    }\n"
      "}]]>"
msgstr "Les requêtes d'Hibernate retournent parfois des tuples d'objets, auquel cas chaque tuple est retourné comme un tableau :"

#: index.docbook:272
msgid "Queries that return tuples"
msgstr ""
      "<![CDATA[Iterator kittensAndMothers = sess.createQuery(\n"
      "            \"select kitten, mother from Cat kitten join kitten.mother mother\")\n"
      "            .list()\n"
      "            .iterator();\n"
      "\n"
      "while ( kittensAndMothers.hasNext() ) {\n"
      "    Object[] tuple = (Object[]) kittensAndMothers.next();\n"
      "    Cat kitten = (Cat) tuple[0];\n"
      "    Cat mother = (Cat) tuple[1];\n"
      "    ....\n"
      "}]]>"

#: index.docbook:274
msgid "Hibernate queries sometimes return tuples of objects, in which case each tuple is returned as an array:"
msgstr "Résultats scalaires"

#: index.docbook:279
msgid ""
      "<![CDATA[Iterator kittensAndMothers = sess.createQuery(\n"
      "            \"select kitten, mother from Cat kitten join kitten.mother mother\")\n"
      "            .list()\n"
      "            .iterator();\n"
      "\n"
      "while ( kittensAndMothers.hasNext() ) {\n"
      "    Object[] tuple = (Object[]) kittensAndMothers.next();\n"
      "    Cat kitten = (Cat) tuple[0];\n"
      "    Cat mother = (Cat) tuple[1];\n"
      "    ....\n"
      "}]]>"
msgstr "Des requêtes peuvent spécifier une propriété d'une classe dans la clause <literal>select</literal>. Elles peuvent même appeler des fonctions d'aggrégat SQL. Les propriétés ou les aggrégats sont considérés comme des résultats \"scalaires\" (et pas des entités dans un état persistant)."

#: index.docbook:284
msgid "Scalar results"
msgstr ""
      "<![CDATA[Iterator results = sess.createQuery(\n"
      "        \"select cat.color, min(cat.birthdate), count(cat) from Cat cat \" +\n"
      "        \"group by cat.color\")\n"
      "        .list()\n"
      "        .iterator();\n"
      "\n"
      "while ( results.hasNext() ) {\n"
      "    Object[] row = (Object[]) results.next();\n"
      "    Color type = (Color) row[0];\n"
      "    Date oldest = (Date) row[1];\n"
      "    Integer count = (Integer) row[2];\n"
      "    .....\n"
      "}]]>"

#: index.docbook:286
msgid "Queries may specify a property of a class in the <literal>select</literal> clause. They may even call SQL aggregate functions. Properties or aggregates are considered \"scalar\" results (and not entities in persistent state)."
msgstr "Lier des paramètres"

#: index.docbook:292
msgid ""
      "<![CDATA[Iterator results = sess.createQuery(\n"
      "        \"select cat.color, min(cat.birthdate), count(cat) from Cat cat \" +\n"
      "        \"group by cat.color\")\n"
      "        .list()\n"
      "        .iterator();\n"
      "\n"
      "while ( results.hasNext() ) {\n"
      "    Object[] row = (Object[]) results.next();\n"
      "    Color type = (Color) row[0];\n"
      "    Date oldest = (Date) row[1];\n"
      "    Integer count = (Integer) row[2];\n"
      "    .....\n"
      "}]]>"
msgstr "Des méthodes de <literal>Query</literal> sont fournies pour lier des valeurs à des paramètres nommés ou à des paramètres de style JDBC <literal>?</literal>. <emphasis>Contrairement à JDBC, les numéros des paramètres d'Hibernate commencent à zéro.</emphasis> Les paramètres nommés sont des identifiants de la forme <literal>:nom</literal> dans la chaîne de caractères de la requête. Les avantages des paramètres nommés sont :"

#: index.docbook:297
msgid "Bind parameters"
msgstr "les paramètres nommés sont insensibles à l'ordre de leur place dans la chaîne de la requête"

#: index.docbook:299
msgid "Methods on <literal>Query</literal> are provided for binding values to named parameters or JDBC-style <literal>?</literal> parameters. <emphasis>Contrary to JDBC, Hibernate numbers parameters from zero.</emphasis> Named parameters are identifiers of the form <literal>:name</literal> in the query string. The advantages of named parameters are:"
msgstr "ils peuvent apparaître plusieurs fois dans la même requête"

#: index.docbook:309
msgid "named parameters are insensitive to the order they occur in the query string"
msgstr "ils sont auto-documentés"

#: index.docbook:315
msgid "they may occur multiple times in the same query"
msgstr ""
      "<![CDATA[//paramètre nomme (préféré)\n"
      "Query q = sess.createQuery(\"from DomesticCat cat where cat.name = :name\");\n"
      "q.setString(\"name\", \"Fritz\");\n"
      "Iterator cats = q.iterate();]]>"

#: index.docbook:320
msgid "they are self-documenting"
msgstr ""
      "<![CDATA[//paramètre positionnel\n"
      "Query q = sess.createQuery(\"from DomesticCat cat where cat.name = ?\");\n"
      "q.setString(0, \"Izi\");\n"
      "Iterator cats = q.iterate();]]>"

#: index.docbook:326
msgid ""
      "<![CDATA[//named parameter (preferred)\n"
      "Query q = sess.createQuery(\"from DomesticCat cat where cat.name = :name\");\n"
      "q.setString(\"name\", \"Fritz\");\n"
      "Iterator cats = q.iterate();]]>"
msgstr ""
      "<![CDATA[//liste de paramètres nommés\n"
      "List names = new ArrayList();\n"
      "names.add(\"Izi\");\n"
      "names.add(\"Fritz\");\n"
      "Query q = sess.createQuery(\"from DomesticCat cat where cat.name in (:namesList)\");\n"
      "q.setParameterList(\"namesList\", names);\n"
      "List cats = q.list();]]>"

#: index.docbook:328
msgid ""
      "<![CDATA[//positional parameter\n"
      "Query q = sess.createQuery(\"from DomesticCat cat where cat.name = ?\");\n"
      "q.setString(0, \"Izi\");\n"
      "Iterator cats = q.iterate();]]>"
msgstr "Pagination"

#: index.docbook:330
msgid ""
      "<![CDATA[//named parameter list\n"
      "List names = new ArrayList();\n"
      "names.add(\"Izi\");\n"
      "names.add(\"Fritz\");\n"
      "Query q = sess.createQuery(\"from DomesticCat cat where cat.name in (:namesList)\");\n"
      "q.setParameterList(\"namesList\", names);\n"
      "List cats = q.list();]]>"
msgstr "Si vous avez besoin de spécifier des liens sur votre ensemble de résultats (le nombre maximum de lignes que vous voulez récupérez et/ou la première ligne que vous voulez récupérer) vous devriez utiliser des méthodes de l'interface <literal>Query</literal> :"

#: index.docbook:335
msgid "Pagination"
msgstr ""
      "<![CDATA[Query q = sess.createQuery(\"from DomesticCat cat\");\n"
      "q.setFirstResult(20);\n"
      "q.setMaxResults(10);\n"
      "List cats = q.list();]]>"

#: index.docbook:337
msgid "If you need to specify bounds upon your result set (the maximum number of rows you want to retrieve and / or the first row you want to retrieve) you should use methods of the <literal>Query</literal> interface:"
msgstr "Hibernate sait comment traduite cette requête de limite en SQL natif pour votre SGBD."

#: index.docbook:343
msgid ""
      "<![CDATA[Query q = sess.createQuery(\"from DomesticCat cat\");\n"
      "q.setFirstResult(20);\n"
      "q.setMaxResults(10);\n"
      "List cats = q.list();]]>"
msgstr "Itération \"scrollable\""

#: index.docbook:345
msgid "Hibernate knows how to translate this limit query into the native SQL of your DBMS."
msgstr "Si votre connecteur JDBC supporte les <literal>ResultSet</literal>s \"scrollables\", l'interface <literal>Query</literal> peut être utilisée pour obtenir un objet <literal>ScrollableResults</literal>, lequel permet une navigation flexible dans les résultats de la requête."

#: index.docbook:353
msgid "Scrollable iteration"
msgstr ""
      "<![CDATA[Query q = sess.createQuery(\"select cat.name, cat from DomesticCat cat \" +\n"
      "                            \"order by cat.name\");\n"
      "ScrollableResults cats = q.scroll();\n"
      "if ( cats.first() ) {\n"
      "\n"
      "    // trouve le premier nom sur chaque page d'une liste alphabétique de noms de chats\n"
      "    firstNamesOfPages = new ArrayList();\n"
      "    do {\n"
      "        String name = cats.getString(0);\n"
      "        firstNamesOfPages.add(name);\n"
      "    }\n"
      "    while ( cats.scroll(PAGE_SIZE) );\n"
      "\n"
      "    // Maintenant, obtiens la première page de chats\n"
      "    pageOfCats = new ArrayList();\n"
      "    cats.beforeFirst();\n"
      "    int i=0;\n"
      "    while( ( PAGE_SIZE > i++ ) && cats.next() ) pageOfCats.add( cats.get(1) );\n"
      "\n"
      "}\n"
      "cats.close()]]>"

#: index.docbook:355
msgid "If your JDBC driver supports scrollable <literal>ResultSet</literal>s, the <literal>Query</literal> interface may be used to obtain a <literal>ScrollableResults</literal> object, which allows flexible navigation of the query results."
msgstr "Notez qu'une connexion ouverte (et un curseur) est requise pour cette fonctionnalité, utilisez <literal>setMaxResult()</literal>/<literal>setFirstResult()</literal> si vous avez besoin d'une fonctionnalité de pagination hors ligne."

#: index.docbook:362
msgid ""
      "<![CDATA[Query q = sess.createQuery(\"select cat.name, cat from DomesticCat cat \" +\n"
      "                            \"order by cat.name\");\n"
      "ScrollableResults cats = q.scroll();\n"
      "if ( cats.first() ) {\n"
      "\n"
      "    // find the first name on each page of an alphabetical list of cats by name\n"
      "    firstNamesOfPages = new ArrayList();\n"
      "    do {\n"
      "        String name = cats.getString(0);\n"
      "        firstNamesOfPages.add(name);\n"
      "    }\n"
      "    while ( cats.scroll(PAGE_SIZE) );\n"
      "\n"
      "    // Now get the first page of cats\n"
      "    pageOfCats = new ArrayList();\n"
      "    cats.beforeFirst();\n"
      "    int i=0;\n"
      "    while( ( PAGE_SIZE > i++ ) && cats.next() ) pageOfCats.add( cats.get(1) );\n"
      "\n"
      "}\n"
      "cats.close()]]>"
msgstr "Externaliser des requêtes nommées"

#: index.docbook:364
msgid "Note that an open database connection (and cursor) is required for this functionality, use <literal>setMaxResult()</literal>/<literal>setFirstResult()</literal> if you need offline pagination functionality."
msgstr "Vous pouvez aussi définir des requêtes nommées dans le document de mapping. (Souvenez-vous d'utiliser une section <literal>CDATA</literal> si votre requête contient des caractères qui pourraient être interprétés comme des éléments XML.)"

#: index.docbook:373
msgid "Externalizing named queries"
msgstr ""
      "<![CDATA[<query name=\"eg.DomesticCat.by.name.and.minimum.weight\"><![CDATA[\n"
      "    from eg.DomesticCat as cat\n"
      "        where cat.name = ?\n"
      "        and cat.weight > ?\n"
      "] ]></query>]]>"

#: index.docbook:375
msgid "You may also define named queries in the mapping document. (Remember to use a <literal>CDATA</literal> section if your query contains characters that could be interpreted as markup.)"
msgstr "La liaison de paramètres et l'exécution sont fait par programmation :"

#: index.docbook:381
msgid ""
      "<![CDATA[<query name=\"ByNameAndMaximumWeight\"><![CDATA[\n"
      "    from eg.DomesticCat as cat\n"
      "        where cat.name = ?\n"
      "        and cat.weight > ?\n"
      "] ]></query>]]>"
msgstr ""
      "<![CDATA[Query q = sess.getNamedQuery(\"eg.DomesticCat.by.name.and.minimum.weight\");\n"
      "q.setString(0, name);\n"
      "q.setInt(1, minWeight);\n"
      "List cats = q.list();]]>"

#: index.docbook:383
msgid "Parameter binding and executing is done programatically:"
msgstr "Notez que le code réel du programme est indépendant du langage de requête qui est utilisé, vous pouvez aussi définir des requêtes SQL nativez dans les méta-données, ou migrer des requêtes existantes vers Hibernate en les plaçant dans les fichiers de mapping."

#: index.docbook:387
msgid ""
      "<![CDATA[Query q = sess.getNamedQuery(\"ByNameAndMaximumWeight\");\n"
      "q.setString(0, name);\n"
      "q.setInt(1, minWeight);\n"
      "List cats = q.list();]]>"
msgstr "Filtrer des collections"

#: index.docbook:389
msgid "Note that the actual program code is independent of the query language that is used, you may also define native SQL queries in metadata, or migrate existing queries to Hibernate by placing them in mapping files."
msgstr "Un <emphasis>filtre</emphasis> de collection est un type spécial de requête qui peut être appliqué à une collection persistante ou à un tableau. La chaîne de requête peut se référer à <literal>this</literal>, correspondant à l'élément de la collection courant."

#: index.docbook:395
msgid "Also note that a query declaration inside a <literal>&lt;hibernate-mapping&gt;</literal> element requires a global unique name for the query, while a query declaration inside a <literal>&lt;class&gt;</literal> element is made unique automatically by prepending the fully qualified name of the class, for example <literal>eg.Cat.ByNameAndMaximumWeight</literal>."
msgstr ""
      "<![CDATA[Collection blackKittens = session.createFilter(\n"
      "    pk.getKittens(),\n"
      "    \"where this.color = ?\")\n"
      "    .setParameter( Color.BLACK, Hibernate.custom(ColorUserType.class) )\n"
      "    .list()\n"
      ");]]>"

#: index.docbook:408
msgid "Filtering collections"
msgstr "La collection retournée est considérée comme un bag, et c'est une copie de la collection donnée. La collection originale n'est pas modifiée (c'est contraire à l'implication du nom \"filtre\"; mais cohérent avec le comportement attendu)."

#: index.docbook:409
msgid "A collection <emphasis>filter</emphasis> is a special type of query that may be applied to a persistent collection or array. The query string may refer to <literal>this</literal>, meaning the current collection element."
msgstr "Observez que les filtres ne nécessitent pas une clause <literal>from</literal> (bien qu'ils puissent en avoir une si besoin est). Les filtres ne sont pas limités à retourner des éléments de la collection eux-mêmes."

#: index.docbook:415
msgid ""
      "<![CDATA[Collection blackKittens = session.createFilter(\n"
      "    pk.getKittens(), \n"
      "    \"where this.color = ?\")\n"
      "    .setParameter( Color.BLACK, Hibernate.custom(ColorUserType.class) )\n"
      "    .list()\n"
      ");]]>"
msgstr ""
      "<![CDATA[Collection blackKittenMates = session.createFilter(\n"
      "    pk.getKittens(),\n"
      "    \"select this.mate where this.color = eg.Color.BLACK.intValue\")\n"
      "    .list();]]>"

#: index.docbook:417
msgid "The returned collection is considered a bag, and it's a copy of the given collection. The original collection is not modified (this is contrary to the implication of the name \"filter\", but consistent with expected behavior)."
msgstr "Même une requête de filtre vide est utile, par exemple pour charger un sous-ensemble d'éléments dans une énorme collection :"

#: index.docbook:423
msgid "Observe that filters do not require a <literal>from</literal> clause (though they may have one if required). Filters are not limited to returning the collection elements themselves."
msgstr ""
      "<![CDATA[Collection tenKittens = session.createFilter(\n"
      "    mother.getKittens(), \"\")\n"
      "    .setFirstResult(0).setMaxResults(10)\n"
      "    .list();]]>"

#: index.docbook:428
msgid ""
      "<![CDATA[Collection blackKittenMates = session.createFilter(\n"
      "    pk.getKittens(), \n"
      "    \"select this.mate where this.color = eg.Color.BLACK.intValue\")\n"
      "    .list();]]>"
msgstr "Requêtes Criteria"

#: index.docbook:430
msgid "Even an empty filter query is useful, e.g. to load a subset of elements in a huge collection:"
msgstr "HQL est extrêmement puissant mais certains développeurs préfèrent construire des requêtes dynamiquement, en utilisant l'API orientée objet, plutôt que construire des chaînes de requêtes. Hibernate fournit une API intuitive de requête <literal>Criteria</literal> pour ces cas :"

#: index.docbook:435
msgid ""
      "<![CDATA[Collection tenKittens = session.createFilter(\n"
      "    mother.getKittens(), \"\")\n"
      "    .setFirstResult(0).setMaxResults(10)\n"
      "    .list();]]>"
msgstr ""
      "<![CDATA[Criteria crit = session.createCriteria(Cat.class);\n"
      "crit.add( Restrictions.eq( \"color\", eg.Color.BLACK ) );\n"
      "crit.setMaxResults(10);\n"
      "List cats = crit.list();]]>"

#: index.docbook:440
msgid "Criteria queries"
msgstr "Les APIs <literal>Criteria</literal> et <literal>Example</literal> associé sont traitées plus en détail dans <xref linkend=\"querycriteria\"/>."

#: index.docbook:442
msgid "HQL is extremely powerful but some developers prefer to build queries dynamically, using an object-oriented API, rather than building query strings. Hibernate provides an intuitive <literal>Criteria</literal> query API for these cases:"
msgstr "Requêtes en SQL natif"

#: index.docbook:448
msgid ""
      "<![CDATA[Criteria crit = session.createCriteria(Cat.class);\n"
      "crit.add( Restrictions.eq( \"color\", eg.Color.BLACK ) );\n"
      "crit.setMaxResults(10);\n"
      "List cats = crit.list();]]>"
msgstr "Vous pouvez exprimer une requête en SQL, en utilisant <literal>createSQLQuery()</literal> et laisser Hibernate s'occuper du mapping des résultats vers des objets. Notez que vous pouvez n'importe quand appeler <literal>session.connection()</literal> et utiliser directement la <literal>Connection</literal> JDBC. Si vous choisissez d'utiliser l'API Hibernate, vous devez mettre les alias SQL entre accolades :"

#: index.docbook:450
msgid "The <literal>Criteria</literal> and the associated <literal>Example</literal> API are discussed in more detail in <xref linkend=\"querycriteria\"/>."
msgstr ""
      "<![CDATA[List cats = session.createSQLQuery(\"SELECT {cat.*} FROM CAT {cat} WHERE ROWNUM<10\")\n"
      "    .addEntity(\"cat\", Cat.class)\n"
      ".list();]]>"

#: index.docbook:458
msgid "Queries in native SQL"
msgstr ""
      "<![CDATA[List cats = session.createSQLQuery(\n"
      "    \"SELECT {cat}.ID AS {cat.id}, {cat}.SEX AS {cat.sex}, \" +\n"
      "           \"{cat}.MATE AS {cat.mate}, {cat}.SUBCLASS AS {cat.class}, ... \" +\n"
      "    \"FROM CAT {cat} WHERE ROWNUM<10\")\n"
      "    .addEntity(\"cat\", Cat.class)\n"
      ".list()]]>"

#: index.docbook:460
msgid "You may express a query in SQL, using <literal>createSQLQuery()</literal> and let Hibernate take care of the mapping from result sets to objects. Note that you may at any time call <literal>session.connection()</literal> and use the JDBC <literal>Connection</literal> directly. If you chose to use the Hibernate API, you must enclose SQL aliases in braces:"
msgstr "Les requêtes SQL peuvent contenir des paramètres nommés et positionnels, comme des requêtes Hibernate. Plus d'informations à propos des requêtes SQL natives dans Hibernate peuvent être trouvées dans <xref linkend=\"querysql\"/>."

#: index.docbook:468
msgid ""
      "<![CDATA[List cats = session.createSQLQuery(\"SELECT {cat.*} FROM CAT {cat} WHERE ROWNUM<10\")\n"
      "    .addEntity(\"cat\", Cat.class)\n"
      ".list();]]>"
msgstr "Modifier des objets persistants"

#: index.docbook:470
msgid ""
      "<![CDATA[List cats = session.createSQLQuery(\n"
      "    \"SELECT {cat}.ID AS {cat.id}, {cat}.SEX AS {cat.sex}, \" +\n"
      "           \"{cat}.MATE AS {cat.mate}, {cat}.SUBCLASS AS {cat.class}, ... \" +\n"
      "    \"FROM CAT {cat} WHERE ROWNUM<10\")\n"
      "    .addEntity(\"cat\", Cat.class)\n"
      ".list()]]>"
msgstr "Les <emphasis>instances persistantes transactionnelles</emphasis> (c'est-à-dire des objets chargés, sauvegardés, créés ou requêtés par la <literal>Session</literal>) peuvent être manipulées par l'application et n'importe quel changement vers l'état persistant sera persisté lorsque la <literal>Session</literal> est <emphasis>\"flushée\"</emphasis> (traité plus tard dans ce chapitre). Il n'y a pas besoin d'appeler une méthode particulière (comme <literal>update()</literal>, qui a un but différent) pour rendre vos modifications persistantes. Donc la manière la plus directe de mettre à jour l'état d'un objet est de le charger avec <literal>load()</literal>, et puis le manipuler directement, tant que la <literal>Session</literal> est ouverte :"

#: index.docbook:472
msgid "SQL queries may contain named and positional parameters, just like Hibernate queries. More information about native SQL queries in Hibernate can be found in <xref linkend=\"querysql\"/>."
msgstr ""
      "<![CDATA[DomesticCat cat = (DomesticCat) sess.load( Cat.class, new Long(69) );\n"
      "cat.setName(\"PK\");\n"
      "sess.flush();  // changes to cat are automatically detected and persisted]]>"

#: index.docbook:483
msgid "Modifying persistent objects"
msgstr "Parfois ce modèle de programmation est inefficace puisqu'il nécessiterait un <literal>SELECT</literal> SQL (pour charger l'objet) et un <literal>UPDATE</literal> SQL (pour persister son état mis à jour) dans la même session. Aussi Hibernate offre une autre approche, en utilisant des instances détachées."

#: index.docbook:485
msgid "<emphasis>Transactional persistent instances</emphasis> (ie. objects loaded, saved, created or queried by the <literal>Session</literal>) may be manipulated by the application and any changes to persistent state will be persisted when the <literal>Session</literal> is <emphasis>flushed</emphasis> (discussed later in this chapter). There is no need to call a particular method (like <literal>update()</literal>, which has a different purpose) to make your modifications persistent. So the most straightforward way to update the state of an object is to <literal>load()</literal> it, and then manipulate it directly, while the <literal>Session</literal> is open:"
msgstr "Notez que Hibernate n'offre par sa propre API pour l'exécution directe d'expressions <literal>UPDATE</literal> ou <literal>DELETE</literal>. Hibernate est un service de <emphasis>gestion d'état</emphasis>, vous n'avez pas à penser aux <emphasis>expressions</emphasis> pour l'utiliser. JDBC est une API parfaite pour exécuter des expressions SQL, vous pouvez obtenir une <literal>Connection</literal> JDBC n'importe quand en appelant <literal>session.connection()</literal>. En outre, la notion d'opérations de masse entre en conflit avec le mapping objet/relationnel pour les applications orientées processus de transactions en ligne. Les futures versions d'Hibernate peuvent cependant fournir des fonctions d'opération de masse. Voir <xref linkend=\"batch\"/> pour les astuces possibles d'opérations groupées."

#: index.docbook:496
msgid ""
      "<![CDATA[DomesticCat cat = (DomesticCat) sess.load( Cat.class, new Long(69) );\n"
      "cat.setName(\"PK\");\n"
      "sess.flush();  // changes to cat are automatically detected and persisted]]>"
msgstr "Modifier des objets détachés"

#: index.docbook:498
msgid "Sometimes this programming model is inefficient since it would require both an SQL <literal>SELECT</literal> (to load an object) and an SQL <literal>UPDATE</literal> (to persist its updated state) in the same session. Therefore Hibernate offers an alternate approach, using detached instances."
msgstr "Beaucoup d'applications ont besoin de récupérer un objet dans une transaction, l'envoyer à la couche interfacée avec l'utilisateur pour les manipulations, puis sauvegarder les changements dans une nouvelle transaction. Les applications qui utilisent cette approche dans un environnement à haute concurrence utilisent généralement des données versionnées pour assurer l'isolation pour les \"longues\" unités de travail."

#: index.docbook:506
msgid "Note that Hibernate does not offer its own API for direct execution of <literal>UPDATE</literal> or <literal>DELETE</literal> statements. Hibernate is a <emphasis>state management</emphasis> service, you don't have to think in <emphasis>statements</emphasis> to use it. JDBC is a perfect API for executing SQL statements, you can get a JDBC <literal>Connection</literal> at any time by calling <literal>session.connection()</literal>. Furthermore, the notion of mass operations conflicts with object/relational mapping for online transaction processing-oriented applications. Future versions of Hibernate may however provide special mass operation functions. See <xref linkend=\"batch\"/> for some possible batch operation tricks."
msgstr "Hibernate supporte ce modèle en permettant pour le réattachement d'instances détachées l'utilisation des méthodes <literal>Session.update()</literal> ou <literal>Session.merge()</literal> :"

#: index.docbook:521
msgid "Modifying detached objects"
msgstr ""
      "<![CDATA[// dans la première session\n"
      "Cat cat = (Cat) firstSession.load(Cat.class, catId);\n"
      "Cat potentialMate = new Cat();\n"
      "firstSession.save(potentialMate);\n"
      "\n"
      "// dans une couche plus haute de l'application\n"
      "cat.setMate(potentialMate);\n"
      "\n"
      "// plus tard, dans une nouvelle session\n"
      "secondSession.update(cat);  // update cat\n"
      "secondSession.update(mate); // update mate]]>"

#: index.docbook:523
msgid "Many applications need to retrieve an object in one transaction, send it to the UI layer for manipulation, then save the changes in a new transaction. Applications that use this kind of approach in a high-concurrency environment usually use versioned data to ensure isolation for the \"long\" unit of work."
msgstr "Si le <literal>Cat</literal> avec l'identifiant <literal>catId</literal> avait déjà été chargé par <literal>secondSession</literal> lorsque l'application a essayé de le réattacher, une exception aurait été levée."

#: index.docbook:530
msgid "Hibernate supports this model by providing for reattachment of detached instances using the <literal>Session.update()</literal> or <literal>Session.merge()</literal> methods:"
msgstr "Utilisez <literal>update()</literal> si vous êtes sure que la session ne contient pas déjà une instance persistante avec le même identifiant, et <literal>merge()</literal> si vous voulez fusionner vos modifications n'importe quand sans considérer l'état de la session. En d'autres mots, <literal>update()</literal> est généralement la première méthode que vous devriez appeler dans une session fraîche, pour s'assurer que le réattachement de vos instances détachées est la première opération qui est exécutée."

#: index.docbook:536
msgid ""
      "<![CDATA[// in the first session\n"
      "Cat cat = (Cat) firstSession.load(Cat.class, catId);\n"
      "Cat potentialMate = new Cat();\n"
      "firstSession.save(potentialMate);\n"
      "\n"
      "// in a higher layer of the application\n"
      "cat.setMate(potentialMate);\n"
      "\n"
      "// later, in a new session\n"
      "secondSession.update(cat);  // update cat\n"
      "secondSession.update(mate); // update mate]]>"
msgstr "L'application devrait individuellement <literal>update()</literal> (NdT : mettre à jour) les instances détachées accessibles depuis l'instance détachée donnée si et <emphasis>seulement</emphasis> si elle veut que leur état soit aussi mis à jour. Ceci peut être automatisé bien sûr, en utilisant la <emphasis>persistance transitive</emphasis>, voir <xref linkend=\"objectstate-transitive\"/>."

#: index.docbook:538
msgid "If the <literal>Cat</literal> with identifier <literal>catId</literal> had already been loaded by <literal>secondSession</literal> when the application tried to reattach it, an exception would have been thrown."
msgstr "La méthode <literal>lock()</literal> permet aussi à une application de réassocier un objet avec une nouvelle session. Pourtant, l'instance détachée doit être non modifiée !"

#: index.docbook:544
msgid "Use <literal>update()</literal> if you are sure that the session does not contain an already persistent instance with the same identifier, and <literal>merge()</literal> if you want to merge your modifications at any time without consideration of the state of the session. In other words, <literal>update()</literal> is usually the first method you would call in a fresh session, ensuring that reattachment of your detached instances is the first operation that is executed."
msgstr ""
      "<![CDATA[//réassocie :\n"
      "sess.lock(fritz, LockMode.NONE);\n"
      "//fait une vérification de version, puis réassocie :\n"
      "sess.lock(izi, LockMode.READ);\n"
      "//fait une vérification de version, en utilisant SELECT ... FOR UPDATE, puis réassocie :\n"
      "sess.lock(pk, LockMode.UPGRADE);]]>"

#: index.docbook:553
msgid "The application should individually <literal>update()</literal> detached instances reachable from the given detached instance if and <emphasis>only</emphasis> if it wants their state also updated. This can be automated of course, using <emphasis>transitive persistence</emphasis>, see <xref linkend=\"objectstate-transitive\"/>."
msgstr "Notez que <literal>lock()</literal> peut être utilisé avec différents <literal>LockMode</literal>s, voir la documentation de l'API documentation et le chapitre sur la gestion des transactions pour plus d'informations. Le réattachement n'est pas le seul cas d'utilisation pour <literal>lock()</literal>."

#: index.docbook:560
msgid "The <literal>lock()</literal> method also allows an application to reassociate an object with a new session. However, the detached instance has to be unmodified!"
msgstr "D'autres modèles pour de longues unités de travail sont traités dans <xref linkend=\"transactions-optimistic\"/>."

#: index.docbook:565
msgid ""
      "<![CDATA[//just reassociate:\n"
      "sess.lock(fritz, LockMode.NONE);\n"
      "//do a version check, then reassociate:\n"
      "sess.lock(izi, LockMode.READ);\n"
      "//do a version check, using SELECT ... FOR UPDATE, then reassociate:\n"
      "sess.lock(pk, LockMode.UPGRADE);]]>"
msgstr "Détection automatique d'un état"

#: index.docbook:567
msgid "Note that <literal>lock()</literal> can be used with various <literal>LockMode</literal>s, see the API documentation and the chapter on transaction handling for more information. Reattachment is not the only usecase for <literal>lock()</literal>."
msgstr "Les utilisateurs d'Hibernate ont demandé une méthode dont l'intention générale serait soit de sauvegarder une instance éphémère en générant un nouvel identifiant, soit mettre à jour/réattacher les instances détachées associées à l'identifiant courant. La méthode <literal>saveOrUpdate()</literal> implémente cette fonctionnalité."

#: index.docbook:574
msgid "Other models for long units of work are discussed in <xref linkend=\"transactions-optimistic\"/>."
msgstr ""
      "<![CDATA[// dans la première session\n"
      "Cat cat = (Cat) firstSession.load(Cat.class, catID);\n"
      "\n"
      "// dans une partie plus haute de l'application\n"
      "Cat mate = new Cat();\n"
      "cat.setMate(mate);\n"
      "\n"
      "// plus tard, dans une nouvelle session\n"
      "secondSession.saveOrUpdate(cat);   // met à jour un état existant (cat a un identifiant non-null)\n"
      "secondSession.saveOrUpdate(mate);  // sauvegarde les nouvelles instances (mate a un identiant null)]]>"

#: index.docbook:581
msgid "Automatic state detection"
msgstr "L'usage et la sémantique de <literal>saveOrUpdate()</literal> semble être confuse pour les nouveaux utilisateurs. Premièrement, aussi longtemps que vous n'essayez pas d'utiliser des instances d'une session dans une autre, vous ne devriez pas avoir besoin d'utiliser <literal>update()</literal>, <literal>saveOrUpdate()</literal>, ou <literal>merge()</literal>. Certaines applications n'utiliseront jamais ces méthodes."

#: index.docbook:583
msgid "Hibernate users have requested a general purpose method that either saves a transient instance by generating a new identifier or updates/reattaches the detached instances associated with its current identifier. The <literal>saveOrUpdate()</literal> method implements this functionality."
msgstr "Généralement <literal>update()</literal> ou <literal>saveOrUpdate()</literal> sont utilisées dans le scénario suivant :"

#: index.docbook:590
msgid ""
      "<![CDATA[// in the first session\n"
      "Cat cat = (Cat) firstSession.load(Cat.class, catID);\n"
      "\n"
      "// in a higher tier of the application\n"
      "Cat mate = new Cat();\n"
      "cat.setMate(mate);\n"
      "\n"
      "// later, in a new session\n"
      "secondSession.saveOrUpdate(cat);   // update existing state (cat has a non-null id)\n"
      "secondSession.saveOrUpdate(mate);  // save the new instance (mate has a null id)]]>"
msgstr "l'application charge un objet dans la première session"

#: index.docbook:592
msgid "The usage and semantics of <literal>saveOrUpdate()</literal> seems to be confusing for new users. Firstly, so long as you are not trying to use instances from one session in another new session, you should not need to use <literal>update()</literal>, <literal>saveOrUpdate()</literal>, or <literal>merge()</literal>. Some whole applications will never use either of these methods."
msgstr "l'objet est passé à la couche utilisateur"

#: index.docbook:600
msgid "Usually <literal>update()</literal> or <literal>saveOrUpdate()</literal> are used in the following scenario:"
msgstr "certaines modifications sont effectuées sur l'objet"

#: index.docbook:607
msgid "the application loads an object in the first session"
msgstr "l'objet est retourné à la couche logique métier"

#: index.docbook:612
msgid "the object is passed up to the UI tier"
msgstr "l'application persiste ces modifications en appelant <literal>update()</literal> dans une seconde sessin"

#: index.docbook:617
msgid "some modifications are made to the object"
msgstr "<literal>saveOrUpdate()</literal> s'utilise dans le cas suivant :"

#: index.docbook:622
msgid "the object is passed back down to the business logic tier"
msgstr "si l'objet est déjà persistant dans cette session, ne rien faire"

#: index.docbook:627
msgid "the application persists these modifications by calling <literal>update()</literal> in a second session"
msgstr "si un autre objet associé à la session a le même identifiant, lever une exception"

#: index.docbook:634
msgid "<literal>saveOrUpdate()</literal> does the following:"
msgstr "si l'objet n'a pas de propriété d'identifiant, appeler <literal>save()</literal>"

#: index.docbook:640
msgid "if the object is already persistent in this session, do nothing"
msgstr "si l'identifiant de l'objet a une valeur assignée à un objet nouvellement instancié, appeler <literal>save()</literal>"

#: index.docbook:645
msgid "if another object associated with the session has the same identifier, throw an exception"
msgstr "si l'objet est versionné (par <literal>&lt;version&gt;</literal> ou <literal>&lt;timestamp&gt;</literal>), et la valeur de la propriété de version est la même valeur que celle assignée à un objet nouvellement instancié, appeler <literal>save()</literal>"

#: index.docbook:651
msgid "if the object has no identifier property, <literal>save()</literal> it"
msgstr "sinon mettre à jour l'objet avec <literal>update()</literal>"

#: index.docbook:656
msgid "if the object's identifier has the value assigned to a newly instantiated object, <literal>save()</literal> it"
msgstr "et <literal>merge()</literal> est très différent :"

#: index.docbook:662
msgid "if the object is versioned (by a <literal>&lt;version&gt;</literal> or <literal>&lt;timestamp&gt;</literal>), and the version property value is the same value assigned to a newly instantiated object, <literal>save()</literal> it"
msgstr "s'il y a une instance persistante avec le même identifiant couramment associée à la session, copier l'état de l'objet donné dans l'instance persistante"

#: index.docbook:670
msgid "otherwise <literal>update()</literal> the object"
msgstr "s'il n'y a pas d'instance persistante associée à cette session, essayer de le charger à partir de la base de données, ou créer une nouvelle instance persistante"

#: index.docbook:676
msgid "and <literal>merge()</literal> is very different:"
msgstr "l'instance persistante est retournée"

#: index.docbook:682
msgid "if there is a persistent instance with the same identifier currently associated with the session, copy the state of the given object onto the persistent instance"
msgstr "l'instance donnée ne devient pas associée à la session, elle reste détachée"

#: index.docbook:689
msgid "if there is no persistent instance currently associated with the session, try to load it from the database, or create a new persistent instance"
msgstr "Suppression d'objets persistants"

#: index.docbook:695
msgid "the persistent instance is returned"
msgstr "<literal>Session.delete()</literal> supprimera l'état d'un objet de la base de données. Bien sûr, votre application pourrait encore conserver une référence vers un objet effacé. Il est mieux de penser à <literal>delete()</literal> comme rendant une instance persistante éphémère."

#: index.docbook:700
msgid "the given instance does not become associated with the session, it remains detached"
msgstr "<![CDATA[sess.delete(cat);]]>"

#: index.docbook:710
msgid "Deleting persistent objects"
msgstr "Vous pouvez effacer des objets dans l'ordre que vous voulez, sans risque de violations de contrainte de clef étrangère. Il est encore possible de violer une contrainte <literal>NOT NULL</literal> sur une colonne de clef étrangère en effaçant des objets dans le mauvais ordre, par exemple si vous effacer le parent, mais oubliez d'effacer les enfants."

#: index.docbook:712
msgid "<literal>Session.delete()</literal> will remove an object's state from the database. Of course, your application might still hold a reference to a deleted object. It's best to think of <literal>delete()</literal> as making a persistent instance transient."
msgstr "Réplication d'objets entre deux entrepôts de données"

#: index.docbook:719
msgid "<![CDATA[sess.delete(cat);]]>"
msgstr "Il est occasionnellement utile de pouvoir prendre un graphe d'instances persistantes et de les rendre persistantes dans un entrepôt différent, sans regénérer les valeurs des identifiants."

#: index.docbook:721
msgid "You may delete objects in any order you like, without risk of foreign key constraint violations. It is still possible to violate a <literal>NOT NULL</literal> constraint on a foreign key column by deleting objects in the wrong order, e.g. if you delete the parent, but forget to delete the children."
msgstr ""
      "<![CDATA[//récupère un cat de la base de données\n"
      "Session session1 = factory1.openSession();\n"
      "Transaction tx1 = session1.beginTransaction();\n"
      "Cat cat = session1.get(Cat.class, catId);\n"
      "tx1.commit();\n"
      "session1.close();\n"
      "\n"
      "// réconcilie la seconde base de données\n"
      "Session session2 = factory2.openSession();\n"
      "Transaction tx2 = session2.beginTransaction();\n"
      "session2.replicate(cat, ReplicationMode.LATEST_VERSION);\n"
      "tx2.commit();\n"
      "session2.close();]]>"

#: index.docbook:732
msgid "Replicating object between two different datastores"
msgstr "Le <literal>ReplicationMode</literal> détermine comment <literal>replicate()</literal> traitera les conflits avec les lignes existantes dans la base de données."

#: index.docbook:734
msgid "It is occasionally useful to be able to take a graph of persistent instances and make them persistent in a different datastore, without regenerating identifier values."
msgstr "<literal>ReplicationMode.IGNORE</literal> - ignore l'objet s'il y a une ligne existante dans la base de données avec le même identifiant"

#: index.docbook:740
msgid ""
      "<![CDATA[//retrieve a cat from one database\n"
      "Session session1 = factory1.openSession();\n"
      "Transaction tx1 = session1.beginTransaction();\n"
      "Cat cat = session1.get(Cat.class, catId);\n"
      "tx1.commit();\n"
      "session1.close();\n"
      "\n"
      "//reconcile with a second database\n"
      "Session session2 = factory2.openSession();\n"
      "Transaction tx2 = session2.beginTransaction();\n"
      "session2.replicate(cat, ReplicationMode.LATEST_VERSION);\n"
      "tx2.commit();\n"
      "session2.close();]]>"
msgstr "<literal>ReplicationMode.OVERWRITE</literal> - écrase n'importe quelle ligne existante dans la base de données avec le même identifiant"

#: index.docbook:742
msgid "The <literal>ReplicationMode</literal> determines how <literal>replicate()</literal> will deal with conflicts with existing rows in the database."
msgstr "<literal>ReplicationMode.EXCEPTION</literal> - lève une exception s'il y une ligne dans la base de données avec le même identifiant"

#: index.docbook:749
msgid "<literal>ReplicationMode.IGNORE</literal> - ignore the object when there is an existing database row with the same identifier"
msgstr "<literal>ReplicationMode.LATEST_VERSION</literal> - écrase la ligne si son numéro de version est plus petit que le numéro de version de l'objet, ou ignore l'objet sinon"

#: index.docbook:755
msgid "<literal>ReplicationMode.OVERWRITE</literal> - overwrite any existing database row with the same identifier"
msgstr "Les cas d'utilisation de cette fonctionnalité incluent la réconciliation de données entrées dans différentes base de données, l'extension des informations de configuration du système durant une mise à jour du produit, retour en arrière sur les changements effectués durant des transactions non-ACID, et plus."

#: index.docbook:761
msgid "<literal>ReplicationMode.EXCEPTION</literal> - throw an exception if there is an existing database row with the same identifier"
msgstr "Flush de la session"

#: index.docbook:767
msgid "<literal>ReplicationMode.LATEST_VERSION</literal> - overwrite the row if its version number is earlier than the version number of the object, or ignore the object otherwise"
msgstr "De temps en temps la <literal>Session</literal> exécutera les expressions SQL requises pour syncrhoniser l'état de la connexion JDBC avec l'état des objets retenus en mémoire. Ce processus, <emphasis>flush</emphasis>, arrive par défaut aux points suivants :"

#: index.docbook:775
msgid "Usecases for this feature include reconciling data entered into different database instances, upgrading system configuration information during product upgrades, rolling back changes made during non-ACID transactions and more."
msgstr "lors de certaines exécutions de requête"

#: index.docbook:784
msgid "Flushing the Session"
msgstr "lors d'un appel à <literal>org.hibernate.Transaction.commit()</literal>"

#: index.docbook:786
msgid "From time to time the <literal>Session</literal> will execute the SQL statements needed to synchronize the JDBC connection's state with the state of objects held in memory. This process, <emphasis>flush</emphasis>, occurs by default at the following points"
msgstr "lors d'un appel à <literal>Session.flush()</literal>"

#: index.docbook:795
msgid "before some query executions"
msgstr "Les expressions SQL sont effectuées dans l'ordre suivant :"

#: index.docbook:800
msgid "from <literal>org.hibernate.Transaction.commit()</literal>"
msgstr "insertion des entités, dans le même ordre que celui des objets correspondants sauvegardés par l'appel à <literal>Session.save()</literal>"

#: index.docbook:805
msgid "from <literal>Session.flush()</literal>"
msgstr "mise à jours des entités"

#: index.docbook:811
msgid "The SQL statements are issued in the following order"
msgstr "suppression des collections"

#: index.docbook:817
msgid "all entity insertions, in the same order the corresponding objects were saved using <literal>Session.save()</literal>"
msgstr "suppression, mise à jour et insertion des éléments des collections"

#: index.docbook:823
msgid "all entity updates"
msgstr "insertion des collections"

#: index.docbook:828
msgid "all collection deletions"
msgstr "suppression des entités, dans le même ordre que celui des objets correspondants qui ont été supprimés par l'appel à <literal>Session.delete()</literal>"

#: index.docbook:833
msgid "all collection element deletions, updates and insertions"
msgstr "(Une exception est que des objets utilisant la génération <literal>native</literal> d'identifiants sont insérés lorsqu'ils sont sauvegardés.)"

#: index.docbook:838
msgid "all collection insertions"
msgstr "Excepté lorsque vous appelez <literal>flush()</literal> explicitement, il n'y absolument aucune garantie à propos de <emphasis>quand</emphasis> la <literal>Session</literal> exécute les appels JDBC, seulement sur l'<emphasis>ordre</emphasis> dans lequel ils sont exécutés. Cependant, Hibernate garantit que <literal>Query.list(..)</literal> ne retournera jamais de données périmées, ni des données fausses."

#: index.docbook:843
msgid "all entity deletions, in the same order the corresponding objects were deleted using <literal>Session.delete()</literal>"
msgstr "Il est possible de changer le comportement par défaut, donc que le flush se produise moins fréquemment. La classe <literal>FlushMode</literal> définit trois modes différents : flush seulement lors du commit (et seulement quand l'API <literal>Transaction</literal> d'Hibernate est utilisée), flush automatiquement en utilisant la procédure expliquée, ou jamais de flush à moins que <literal>flush()</literal> soit appelée explicitement. Le dernier mode est utile pour l'exécution de longues unités de travail, où une <literal>Session</literal> est gardée ouverte et déconnectée pour un long moment (voir <xref linkend=\"transactions-optimistic-longsession\"/>)."

#: index.docbook:850
msgid "(An exception is that objects using <literal>native</literal> ID generation are inserted when they are saved.)"
msgstr ""
      "<![CDATA[sess = sf.openSession();\n"
      "Transaction tx = sess.beginTransaction();\n"
      "sess.setFlushMode(FlushMode.COMMIT); // permet aux requêtes de retourner un état périmé\n"
      "\n"
      "Cat izi = (Cat) sess.load(Cat.class, id);\n"
      "izi.setName(iznizi);\n"
      "\n"
      "// pourrait retourner des données périmées\n"
      "sess.find(\"from Cat as cat left outer join cat.kittens kitten\");\n"
      "\n"
      "// le changement pour izi n'est pas flushé !\n"
      "...\n"
      "tx.commit(); // le flush se produit]]>"

#: index.docbook:855
msgid "Except when you explicity <literal>flush()</literal>, there are absolutely no guarantees about <emphasis>when</emphasis> the <literal>Session</literal> executes the JDBC calls, only the <emphasis>order</emphasis> in which they are executed. However, Hibernate does guarantee that the <literal>Query.list(..)</literal> will never return stale data; nor will they return the wrong data."
msgstr "Durant le flush, une exception peut se produire (par exemple, si une opération de la DML viole une contrainte). Puisque les exceptions de gestion impliquent une certaine compréhension du comportement transactionnel d'Hibernate, nous le traitons dans <xref linkend=\"transactions\"/>."

#: index.docbook:863
msgid "It is possible to change the default behavior so that flush occurs less frequently. The <literal>FlushMode</literal> class defines three different modes: only flush at commit time (and only when the Hibernate <literal>Transaction</literal> API is used), flush automatically using the explained routine, or never flush unless <literal>flush()</literal> is called explicitly. The last mode is useful for long running units of work, where a <literal>Session</literal> is kept open and disconnected for a long time (see <xref linkend=\"transactions-optimistic-longsession\"/>)."
msgstr "Persistance transitive"

#: index.docbook:873
msgid ""
      "<![CDATA[sess = sf.openSession();\n"
      "Transaction tx = sess.beginTransaction();\n"
      "sess.setFlushMode(FlushMode.COMMIT); // allow queries to return stale state\n"
      "\n"
      "Cat izi = (Cat) sess.load(Cat.class, id);\n"
      "izi.setName(iznizi);\n"
      "\n"
      "// might return stale data\n"
      "sess.find(\"from Cat as cat left outer join cat.kittens kitten\");\n"
      "\n"
      "// change to izi is not flushed!\n"
      "...\n"
      "tx.commit(); // flush occurs\n"
      "sess.close();]]>"
msgstr "Il est assez pénible de sauvegarder, supprimer, ou réattacher des objets un par un, surtout si vous traitez un graphe d'objets associés. Un cas habituel est une relation parent/enfant. Considérez l'exemple suivant :"

#: index.docbook:875
msgid "During flush, an exception might occur (e.g. if a DML operation violates a constraint). Since handling exceptions involves some understanding of Hibernate's transactional behavior, we discuss it in <xref linkend=\"transactions\"/>."
msgstr "Si les enfants de la relation parent/enfant étaient des types de valeur (par exemple, une collection d'adresses ou de chaînes de caractères), leur cycle de vie dépendraient du parent et aucune action ne serait requise pour \"cascader\" facilement les changements d'état. Si le parent est sauvegardé, les objets enfants de type de valeur sont sauvegardés également, si le parent est supprimé, les enfants sont supprimés, etc. Ceci fonctionne même pour des opérations telles que la suppression d'un enfant de la collection ; Hibernate détectera cela et, puisque les objets de type de valeur ne peuvent pas avoir des références partagées, supprimera l'enfant de la base de données."

#: index.docbook:884
msgid "Transitive persistence"
msgstr "Maintenant considérez le même scénario avec un parent et dont les objets enfants sont des entités, et non des types de valeur (par exemple, des catégories et des objets, ou un parent et des chatons). Les entités ont leur propre cycle de vie, supportent les références partagées (donc supprimer une entité de la collection ne signifie pas qu'elle peut être supprimée), et il n'y a par défaut pas de cascade d'état d'une entité vers n'importe quelle entité associée. Hibernate n'implémente pas la <emphasis>persistance par accessibilité</emphasis> par défaut."

#: index.docbook:886
msgid "It is quite cumbersome to save, delete, or reattach individual objects, especially if you deal with a graph of associated objects. A common case is a parent/child relationship. Consider the following example:"
msgstr "Pour chaque opération basique de la session d'Hibernate - incluant <literal>persist(), merge(), saveOrUpdate(), delete(), lock(), refresh(), evict(), replicate()</literal> - il y a un style de cascade correspondant. Respectivement, les styles de cascade s'appellent <literal>persist, merge, save-update, delete, lock, refresh, evict, replicate</literal>. Si vous voulez qu'une opération soit cascadée le long d'une association, vous devez l'indiquer dans le document de mapping. Par exemple :"

#: index.docbook:892
msgid "If the children in a parent/child relationship would be value typed (e.g. a collection of addresses or strings), their life cycle would depend on the parent and no further action would be required for convenient \"cascading\" of state changes. When the parent is saved, the value-typed child objects are saved as well, when the parent is deleted, the children will be deleted, etc. This even works for operations such as the removal of a child from the collection; Hibernate will detect this and, since value-typed objects can't have shared references, delete the child from the database."
msgstr "<![CDATA[<one-to-one name=\"person\" cascade=\"persist\"/>]]>"

#: index.docbook:903
msgid "Now consider the same scenario with parent and child objects being entities, not value-types (e.g. categories and items, or parent and child cats). Entities have their own life cycle, support shared references (so removing an entity from the collection does not mean it can be deleted), and there is by default no cascading of state from one entity to any other associated entities. Hibernate does not implement <emphasis>persistence by reachability</emphasis> by default."
msgstr "Les styles de cascade peuvent être combinés :"

#: index.docbook:912
msgid "For each basic operation of the Hibernate session - including <literal>persist(), merge(), saveOrUpdate(), delete(), lock(), refresh(), evict(), replicate()</literal> - there is a corresponding cascade style. Respectively, the cascade styles are named <literal>create, merge, save-update, delete, lock, refresh, evict, replicate</literal>. If you want an operation to be cascaded along an association, you must indicate that in the mapping document. For example:"
msgstr "<![CDATA[<one-to-one name=\"person\" cascade=\"persist,delete,lock\"/>]]>"

#: index.docbook:921
msgid "<![CDATA[<one-to-one name=\"person\" cascade=\"persist\"/>]]>"
msgstr "Vous pouvez même utiliser <literal>cascade=\"all\"</literal> pour spécifier que <emphasis>toutes</emphasis> les opérations devraient être cascadées le long de l'association. La valeur par défaut <literal>cascade=\"none\"</literal> spécifie qu'aucune opération ne sera cascadée."

#: index.docbook:923
msgid "Cascade styles my be combined:"
msgstr "Une style de cascade spécial, <literal>delete-orphan</literal>, s'applique seulement aux associations un-vers-plusieurs, et indique que l'opération <literal>delete()</literal> devrait être appliquée à n'importe quel enfant qui est supprimé de l'association."

#: index.docbook:927
msgid "<![CDATA[<one-to-one name=\"person\" cascade=\"persist,delete,lock\"/>]]>"
msgstr "Recommandations :"

#: index.docbook:929
msgid "You may even use <literal>cascade=\"all\"</literal> to specify that <emphasis>all</emphasis> operations should be cascaded along the association. The default <literal>cascade=\"none\"</literal> specifies that no operations are to be cascaded."
msgstr "Cela n'a généralement aucun sens d'activer la cascade sur une association <literal>&lt;many-to-one&gt;</literal> ou <literal>&lt;many-to-many&gt;</literal>. Les cascades sont souvent utiles pour des associations <literal>&lt;one-to-one&gt;</literal> et <literal>&lt;one-to-many&gt;</literal>."

#: index.docbook:935
msgid "A special cascade style, <literal>delete-orphan</literal>, applies only to one-to-many associations, and indicates that the <literal>delete()</literal> operation should be applied to any child object that is removed from the association."
msgstr "Si la durée de vie de l'objet enfant est liée à la durée de vie de l'objet parent, faites en un <emphasis>objet du cycle de vie</emphasis> en spécifiant <literal>cascade=\"all,delete-orphan\"</literal>."

#: index.docbook:942
msgid "Recommendations:"
msgstr "Sinon, vous pourriez ne pas avoir besoin de cascade du tout. Mais si vous pensez que vous travaillerez souvent avec le parent et les enfants ensemble dans la même transaction, et que vous voulez vous éviter quelques frappes, considérez l'utilisation de <literal>cascade=\"persist,merge,save-update\"</literal>."

#: index.docbook:948
msgid "It doesn't usually make sense to enable cascade on a <literal>&lt;many-to-one&gt;</literal> or <literal>&lt;many-to-many&gt;</literal> association. Cascade is often useful for <literal>&lt;one-to-one&gt;</literal> and <literal>&lt;one-to-many&gt;</literal> associations."
msgstr "Mapper une association (soit une simple association valuée, soit une collection) avec <literal>cascade=\"all\"</literal> marque l'association comme une relation de style <emphasis>parent/enfant</emphasis> où la sauvegarde/mise à jour/suppression du parent entraîne la sauvegarde/mise à jour/suppression de l'enfant ou des enfants."

#: index.docbook:956
msgid "If the child object's lifespan is bounded by the lifespan of the parent object, make it a <emphasis>life cycle object</emphasis> by specifying <literal>cascade=\"all,delete-orphan\"</literal>."
msgstr "En outre, une simple référence à un enfant d'un parent persistant aura pour conséquence la sauvegarde/mise à jour de l'enfant. Cette métaphore est cependant incomplète. Un enfant qui devient non référencé par son parent <emphasis>n'est pas</emphasis> automatiquement supprimée, excepté dans le cas d'une association <literal>&lt;one-to-many&gt;</literal> mappée avec <literal>cascade=\"delete-orphan\"</literal>. La sémantique précise des opérations de cascade pour une relation parent/enfant est la suivante :"

#: index.docbook:963
msgid "Otherwise, you might not need cascade at all. But if you think that you will often be working with the parent and children together in the same transaction, and you want to save yourself some typing, consider using <literal>cascade=\"persist,merge,save-update\"</literal>."
msgstr "Si un parent est passé à <literal>persist()</literal>, tous les enfant sont passés à <literal>persist()</literal>"

#: index.docbook:971
msgid "Mapping an association (either a single valued association, or a collection) with <literal>cascade=\"all\"</literal> marks the association as a <emphasis>parent/child</emphasis> style relationship where save/update/delete of the parent results in save/update/delete of the child or children."
msgstr "Si un parent est passé à <literal>merge()</literal>, tous les enfants sont passés à <literal>merge()</literal>"

#: index.docbook:977
msgid "Futhermore, a mere reference to a child from a persistent parent will result in save/update of the child. This metaphor is incomplete, however. A child which becomes unreferenced by its parent is <emphasis>not</emphasis> automatically deleted, except in the case of a <literal>&lt;one-to-many&gt;</literal> association mapped with <literal>cascade=\"delete-orphan\"</literal>. The precise semantics of cascading operations for a parent/child relationship are as follows:"
msgstr "Si un parent est passé à <literal>save()</literal>, <literal>update()</literal> ou <literal>saveOrUpdate()</literal>, tous les enfants sont passés à <literal>saveOrUpdate()</literal>"

#: index.docbook:988
msgid "If a parent is passed to <literal>persist()</literal>, all children are passed to <literal>persist()</literal>"
msgstr "Si un enfant détaché ou éphémère devient référencé par un parent persistant, il est passé à <literal>saveOrUpdate()</literal>"

#: index.docbook:994
msgid "If a parent is passed to <literal>merge()</literal>, all children are passed to <literal>merge()</literal>"
msgstr "Si un parent est supprimé, tous les enfants sont passés à <literal>delete()</literal>"

#: index.docbook:1000
msgid "If a parent is passed to <literal>save()</literal>, <literal>update()</literal> or <literal>saveOrUpdate()</literal>, all children are passed to <literal>saveOrUpdate()</literal>"
msgstr "Si un enfant est déréférencé par un parent persistant, <emphasis>rien de spécial n'arrive</emphasis> - l'application devrait explicitement supprimer l'enfant si nécessaire - à moins que <literal>cascade=\"delete-orphan\"</literal> soit paramétré, au quel cas l'enfant \"orphelin\" est supprimé."

#: index.docbook:1006
msgid "If a transient or detached child becomes referenced by a persistent parent, it is passed to <literal>saveOrUpdate()</literal>"
msgstr "Enfin, la cascade des opérations peut être effectuée sur un graphe donné lors de l'<emphasis>appel de l'opération</emphasis> or lors du <emphasis>flush</emphasis> suivant. Toutes les opérations, lorsque cascadées, le sont sur toutes les entités associées atteignables lorsque l'opétation est exécutée. Cependant <literal>save-upate</literal> et <literal>delete-orphan</literal> sont cascadées à toutes les entités associées atteignables lors du flush de la <literal>Session</literal>."

#: index.docbook:1012
msgid "If a parent is deleted, all children are passed to <literal>delete()</literal>"
msgstr "Utilisation des méta-données"

#: index.docbook:1017
msgid "If a child is dereferenced by a persistent parent, <emphasis>nothing special happens</emphasis> - the application should explicitly delete the child if necessary - unless <literal>cascade=\"delete-orphan\"</literal>, in which case the \"orphaned\" child is deleted."
msgstr "Hibernate requiert un modèle de méta-niveau très riche de toutes les entités et types valués. De temps en temps, ce modèle est très utile à l'application elle même. Par exemple, l'application pourrait utiliser les méta-données d'Hibernate pour implémenter un algorithme de copie en profondeur \"intelligent\" qui comprendrait quels objets devraient copiés (par exemple les types de valeur mutables) et lesquels ne devraient pas l'être (par exemple les types de valeurs immutables et, possiblement, les entités associées)."

#: index.docbook:1026
msgid "Finally, note that cascading of operations can be applied to an object graph at <emphasis>call time</emphasis> or at <emphasis>flush time</emphasis>. All operations, if enabled, are cascaded to associated entities reachable when the operation is executed. However, <literal>save-upate</literal> and <literal>delete-orphan</literal> are transitive for all associated entities reachable during flush of the <literal>Session</literal>."
msgstr "Hibernate expose les méta-données via les interfaces <literal>ClassMetadata</literal> et <literal>CollectionMetadata</literal> et la hiérarchie <literal>Type</literal>. Les instances des interfaces de méta-données peuvent être obtenues à partir de la <literal>SessionFactory</literal>."

#: index.docbook:1038
msgid "Using metadata"
msgstr ""
      "<![CDATA[Cat fritz = ......;\n"
      "ClassMetadata catMeta = sessionfactory.getClassMetadata(Cat.class);\n"
      "\n"
      "Object[] propertyValues = catMeta.getPropertyValues(fritz);\n"
      "String[] propertyNames = catMeta.getPropertyNames();\n"
      "Type[] propertyTypes = catMeta.getPropertyTypes();\n"
      "\n"
      "// récupère une Map de toutes les propriétés qui ne sont pas des collections ou des associations\n"
      "Map namedValues = new HashMap();\n"
      "for ( int i=0; i<propertyNames.length; i++ ) {\n"
      "    if ( !propertyTypes[i].isEntityType() && !propertyTypes[i].isCollectionType() ) {\n"
      "        namedValues.put( propertyNames[i], propertyValues[i] );\n"
      "    }\n"
      "}]]>"

#: index.docbook:1040
msgid "Hibernate requires a very rich meta-level model of all entity and value types. From time to time, this model is very useful to the application itself. For example, the application might use Hibernate's metadata to implement a \"smart\" deep-copy algorithm that understands which objects should be copied (eg. mutable value types) and which should not (eg. immutable value types and, possibly, associated entities)."
msgstr ""

#: index.docbook:1047
msgid "Hibernate exposes metadata via the <literal>ClassMetadata</literal> and <literal>CollectionMetadata</literal> interfaces and the <literal>Type</literal> hierarchy. Instances of the metadata interfaces may be obtained from the <literal>SessionFactory</literal>."
msgstr ""

#: index.docbook:1054
msgid ""
      "<![CDATA[Cat fritz = ......;\n"
      "ClassMetadata catMeta = sessionfactory.getClassMetadata(Cat.class);\n"
      "\n"
      "Object[] propertyValues = catMeta.getPropertyValues(fritz);\n"
      "String[] propertyNames = catMeta.getPropertyNames();\n"
      "Type[] propertyTypes = catMeta.getPropertyTypes();\n"
      "\n"
      "// get a Map of all properties which are not collections or associations\n"
      "Map namedValues = new HashMap();\n"
      "for ( int i=0; i<propertyNames.length; i++ ) {\n"
      "    if ( !propertyTypes[i].isEntityType() && !propertyTypes[i].isCollectionType() ) {\n"
      "        namedValues.put( propertyNames[i], propertyValues[i] );\n"
      "    }\n"
      "}]]>"
msgstr ""

msgid "ROLES_OF_TRANSLATORS"
msgstr "<!--TRANS:ROLES_OF_TRANSLATORS-->"

msgid "CREDIT_FOR_TRANSLATORS"
msgstr "<!--TRANS:CREDIT_FOR_TRANSLATORS-->"

