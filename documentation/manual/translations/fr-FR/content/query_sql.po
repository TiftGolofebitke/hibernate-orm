#, fuzzy
msgid ""
msgstr ""
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Content-Type: text/plain; charset=utf-8\n"
#: index.docbook:5
msgid "Native SQL"
msgstr "SQL natif"

#: index.docbook:7
msgid "You may also express queries in the native SQL dialect of your database. This is useful if you want to utilize database specific features such as query hints or the <literal>CONNECT</literal> keyword in Oracle. It also provides a clean migration path from a direct SQL/JDBC based application to Hibernate."
msgstr "Vous pouvez aussi écrire vos requêtes dans le dialecte SQL natif de votre base de données. Ceci est utile si vous souhaitez utiliser les fonctionnalités spécifiques de votre base de données comme le mot clé <literal>CONNECT</literal> d'Oracle. Cette fonctionnalité offre par ailleurs un moyen de migration plus propre et doux d'une application basée sur SQL/JDBC vers une application Hibernate."

#: index.docbook:13
msgid "Hibernate3 allows you to specify handwritten SQL (including stored procedures) for all create, update, delete, and load operations."
msgstr "Hibernate3 vous permet de spécifier du SQL écrit à la main (incluant les procédures stockées) pour toutes les opérations de création, mise à jour, suppression et chargement."

#: index.docbook:17
msgid "Using a <literal>SQLQuery</literal>"
msgstr "Utiliser une <literal>SQLQuery</literal>"

#: index.docbook:19
msgid "Execution of native SQL queries is controlled via the <literal>SQLQuery</literal> interface, which is obtained by calling <literal>Session.createSQLQuery()</literal>. The following describes how to use this API for querying."
msgstr "L'exécution des requêtes en SQL natif est contrôlée par l'interface <literal>SQLQuery</literal>, laquelle est obtenue en appelant <literal>Session.createSQLQuery()</literal>. Dans des cas extrêmement simples, nous pouvons utiliser la forme suivante :"

#: index.docbook:25
msgid "Scalar queries"
msgstr ""
      "List cats = sess.createSQLQuery(\"select * from cats\")\n"
      "    .addEntity(Cat.class)\n"
      "    .list();"

#: index.docbook:27
msgid "The most basic SQL query is to get a list of scalars (values)."
msgstr "Cette requête a spécifié :"

#: index.docbook:30
msgid ""
      "<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\").list();\n"
      "sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE FROM CATS\").list();\n"
      "]]>"
msgstr "la requête SQL"

#: index.docbook:32
msgid "These will both return a List of Object arrays (Object[]) with scalar values for each column in the CATS table. Hibernate will use ResultSetMetadata to deduce the actual order and types of the returned scalar values."
msgstr "l'entité retournée par la requête"

#: index.docbook:37
msgid "To avoid the overhead of using <literal>ResultSetMetadata</literal> or simply to be more explicit in what is returned one can use <literal>addScalar()</literal>."
msgstr "Ici, les noms de colonne des résultats sont supposés être les mêmes que les noms de colonne spécifiés dans le document de mapping. Cela peut être problématique pour des requêtes SQL qui joignent de multiple tables, puisque les mêmes noms de colonne peuvent apparaître dans plus d'une table. La forme suivante n'est pas vulnérable à la duplication des noms de colonne :"

#: index.docbook:41
msgid ""
      "<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\")\n"
      " .addScalar(\"ID\", Hibernate.LONG)\n"
      " .addScalar(\"NAME\", Hibernate.STRING)\n"
      " .addScalar(\"BIRTHDATE\", Hibernate.DATE)\n"
      "]]>"
msgstr ""
      "List cats = sess.createSQLQuery(\"select {cat.*} from cats cat\")\n"
      "    .addEntity(\"cat\", Cat.class)\n"
      "    .list();"

#: index.docbook:43, index.docbook:89, index.docbook:170, index.docbook:321
msgid "This query specified:"
msgstr "Cette requête a spécifié :"

#: index.docbook:47, index.docbook:93, index.docbook:325
msgid "the SQL query string"
msgstr "la requête SQL, avec un paramètre fictif pour Hibernate pour injecter les alias de colonne"

#: index.docbook:51
msgid "the columns and types to return"
msgstr "l'entité retournée par la requête, et son alias de table SQL"

#: index.docbook:55
msgid "This will still return Object arrays, but now it will not use <literal>ResultSetMetdata</literal> but will instead explicitly get the ID, NAME and BIRTHDATE column as respectively a Long, String and a Short from the underlying resultset. This also means that only these three columns will be returned, even though the query is using <literal>*</literal> and could return more than the three listed columns."
msgstr "La méthode <literal>addEntity()</literal> associe l'alias de la table SQL avec la classe de l'entité retournée, et détermine la forme de l'ensemble des résultats de la requête."

#: index.docbook:63
msgid "It is possible to leave out the type information for all or some of the scalars."
msgstr "La méthode <literal>addJoin()</literal> peut être utilisée pour charger des associations vers d'autres entités et collections."

#: index.docbook:66
msgid ""
      "<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\")\n"
      " .addScalar(\"ID\", Hibernate.LONG)\n"
      " .addScalar(\"NAME\")\n"
      " .addScalar(\"BIRTHDATE\")\n"
      "]]>"
msgstr ""
      "List cats = sess.createSQLQuery(\n"
      "        \"select {cat.*}, {kitten.*} from cats cat, cats kitten where kitten.mother = cat.id\"\n"
      "    )\n"
      "    .addEntity(\"cat\", Cat.class)\n"
      "    .addJoin(\"kitten\", \"cat.kittens\")\n"
      "    .list();"

#: index.docbook:68
msgid "This is essentially the same query as before, but now <literal>ResultSetMetaData</literal> is used to decide the type of NAME and BIRTHDATE where as the type of ID is explicitly specified."
msgstr "Une requête SQL native pourrait retourner une simple valeur scalaire ou une combinaison de scalaires et d'entités."

#: index.docbook:72
msgid "How the java.sql.Types returned from ResultSetMetaData is mapped to Hibernate types is controlled by the Dialect. If a specific type is not mapped or does not result in the expected type it is possible to customize it via calls to <literal>registerHibernateType</literal> in the Dialect."
msgstr ""
      "Double max = (Double) sess.createSQLQuery(\"select max(cat.weight) as maxWeight from cats cat\")\n"
      "        .addScalar(\"maxWeight\", Hibernate.DOUBLE);\n"
      "        .uniqueResult();"

#: index.docbook:80
msgid "Entity queries"
msgstr "Vous pouvez alternativement décrire les informations de mapping des résultats dans vos fichiers hbm et les utiliser pour vos requêtes."

#: index.docbook:82
msgid "The above queries were all about returning scalar values, basically returning the \"raw\" values from the resultset. The following shows how to get entity objects from a native sql query via <literal>addEntity()</literal>."
msgstr ""
      "List cats = sess.createSQLQuery(\n"
      "        \"select {cat.*}, {kitten.*} from cats cat, cats kitten where kitten.mother = cat.id\"\n"
      "    )\n"
      "    .setResultSetMapping(\"catAndKitten\")\n"
      "    .list();"

#: index.docbook:87
msgid ""
      "<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\").addEntity(Cat.class);\n"
      "sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE FROM CATS\").addEntity(Cat.class);\n"
      "]]>"
msgstr "Alias et références de propriété"

#: index.docbook:97
msgid "the entity returned by the query"
msgstr ""
      "String sql = \"select cat.originalId as {cat.id}, \" +\n"
      "    \"cat.mateid as {cat.mate}, cat.sex as {cat.sex}, \" +\n"
      "    \"cat.weight*10 as {cat.weight}, cat.name as {cat.name} \" +\n"
      "    \"from cat_log cat where {cat.mate} = :catId\"\n"
      "\n"
      "List loggedCats = sess.createSQLQuery(sql)\n"
      "    .addEntity(\"cat\", Cat.class)\n"
      "    .setLong(\"catId\", catId)\n"
      "    .list();"

#: index.docbook:101
msgid "Assuming that Cat is mapped as a class with the columns ID, NAME and BIRTHDATE the above queries will both return a List where each element is a Cat entity."
msgstr "<emphasis>À noter :</emphasis> si vous listez chaque propriété explicitement, vous devez inclure toutes les propriétés de la classe <emphasis>et ses sous-classes</emphasis> !"

#: index.docbook:105
msgid "If the entity is mapped with a <literal>many-to-one</literal> to another entity it is required to also return this when performing the native query, otherwise a database specific \"column not found\" error will occur. The additional columns will automatically be returned when using the * notation, but we prefer to be explicit as in the following example for a <literal>many-to-one</literal> to a <literal>Dog</literal>:"
msgstr "La table suivante montre les différentes possibilités d'utilisation de l'injection d'alias. À noter : les noms des alias dans le résultat sont des exemples, chaque alias aura un nom unique et probablement différent lors de l'utilisation."

#: index.docbook:113
msgid ""
      "<![CDATA[sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE, DOG_ID FROM CATS\").addEntity(Cat.class);\n"
      "]]>"
msgstr "Noms d'injection d'alias"

#: index.docbook:115
msgid "This will allow cat.getDog() to function properly."
msgstr "Description"

#: index.docbook:119
msgid "Handling associations and collections"
msgstr "Syntaxe"

#: index.docbook:121
msgid "It is possible to eagerly join in the <literal>Dog</literal> to avoid the possible extra roundtrip for initializing the proxy. This is done via the <literal>addJoin()</literal> method, which allows you to join in an association or collection."
msgstr "Exemple"

#: index.docbook:126
msgid ""
      "<![CDATA[sess.createSQLQuery(\"SELECT c.ID, NAME, BIRTHDATE, DOG_ID, D_ID, D_NAME FROM CATS c, DOGS d WHERE c.DOG_ID = d.D_ID\")\n"
      " .addEntity(\"cat\", Cat.class)\n"
      " .addJoin(\"cat.dog\");\n"
      "]]>"
msgstr "Une simple propriété"

#: index.docbook:128
msgid "In this example the returned <literal>Cat</literal>'s will have their <literal>dog</literal> property fully initialized without any extra roundtrip to the database. Notice that we added a alias name (\"cat\") to be able to specify the target property path of the join. It is possible to do the same eager joining for collections, e.g. if the <literal>Cat</literal> had a one-to-many to <literal>Dog</literal> instead."
msgstr "{[aliasname].[propertyname]}"

#: index.docbook:136
msgid ""
      "<![CDATA[sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE, D_ID, D_NAME, CAT_ID FROM CATS c, DOGS d WHERE c.ID = d.CAT_ID\")\n"
      " .addEntity(\"cat\", Cat.class)\n"
      " .addJoin(\"cat.dogs\");\n"
      "]]>"
msgstr "A_NAME as {item.name}"

#: index.docbook:138
msgid "At this stage we are reaching the limits of what is possible with native queries without starting to enhance the sql queries to make them usable in Hibernate; the problems starts to arise when returning multiple entities of the same type or when the default alias/column names are not enough."
msgstr "Une propriété composée"

#: index.docbook:146
msgid "Returning multiple entities"
msgstr "{[aliasname].[componentname].[propertyname]}"

#: index.docbook:148
msgid "Until now the result set column names are assumed to be the same as the column names specified in the mapping document. This can be problematic for SQL queries which join multiple tables, since the same column names may appear in more than one table."
msgstr "CURRENCY as {item.amount.currency}, VALUE as {item.amount.value}"

#: index.docbook:153
msgid "Column alias injection is needed in the following query (which most likely will fail):"
msgstr "Discriminant d'une entité"

#: index.docbook:156
msgid ""
      "<![CDATA[sess.createSQLQuery(\"SELECT c.*, m.*  FROM CATS c, CATS m WHERE c.MOTHER_ID = c.ID\")\n"
      " .addEntity(\"cat\", Cat.class)\n"
      " .addEntity(\"mother\", Cat.class)\n"
      "]]>"
msgstr "{[aliasname].class}"

#: index.docbook:158
msgid "The intention for this query is to return two Cat instances per row, a cat and its mother. This will fail since there is a conflict of names since they are mapped to the same column names and on some databases the returned column aliases will most likely be on the form \"c.ID\", \"c.NAME\", etc. which are not equal to the columns specificed in the mappings (\"ID\" and \"NAME\")."
msgstr "DISC as {item.class}"

#: index.docbook:165
msgid "The following form is not vulnerable to column name duplication:"
msgstr "Toutes les propriétés d'une entité"

#: index.docbook:168
msgid ""
      "<![CDATA[sess.createSQLQuery(\"SELECT {cat.*}, {mother.*}  FROM CATS c, CATS m WHERE c.MOTHER_ID = c.ID\")\n"
      " .addEntity(\"cat\", Cat.class)\n"
      " .addEntity(\"mother\", Cat.class)\n"
      "]]>"
msgstr "{[aliasname].*}"

#: index.docbook:174
msgid "the SQL query string, with placeholders for Hibernate to inject column aliases"
msgstr "Une clef de collection"

#: index.docbook:179
msgid "the entities returned by the query"
msgstr "{[aliasname].key}"

#: index.docbook:183
msgid "The {cat.*} and {mother.*} notation used above is a shorthand for \"all properties\". Alternatively, you may list the columns explicity, but even in this case we let Hibernate inject the SQL column aliases for each property. The placeholder for a column alias is just the property name qualified by the table alias. In the following example, we retrieve Cats and their mothers from a different table (cat_log) to the one declared in the mapping metadata. Notice that we may even use the property aliases in the where clause if we like."
msgstr "ORGID as {coll.key}"

#: index.docbook:192
msgid ""
      "<![CDATA[String sql = \"SELECT ID as {c.id}, NAME as {c.name}, \" + \n"
      "         \"BIRTHDATE as {c.birthDate}, MOTHER_ID as {c.mother}, {mother.*} \" +\n"
      "         \"FROM CAT_LOG c, CAT_LOG m WHERE {c.mother} = c.ID\";\n"
      "\n"
      "List loggedCats = sess.createSQLQuery(sql)\n"
      "        .addEntity(\"cat\", Cat.class)\n"
      "        .addEntity(\"mother\", Cat.class).list()\n"
      "]]>"
msgstr "L'identifiant d'une collection"

#: index.docbook:195
msgid "Alias and property references"
msgstr "{[aliasname].id}"

#: index.docbook:197
msgid "For most cases the above alias injection is needed, but for queries relating to more complex mappings like composite properties, inheritance discriminators, collections etc. there are some specific aliases to use to allow Hibernate to inject the proper aliases."
msgstr "EMPID as {coll.id}"

#: index.docbook:202
msgid "The following table shows the different possibilities of using the alias injection. Note: the alias names in the result are examples, each alias will have a unique and probably different name when used."
msgstr "L'élément d'une collection"

#: index.docbook:208
msgid "Alias injection names"
msgstr "{[aliasname].element}"

#: index.docbook:219
msgid "Description"
msgstr "XID as {coll.element}"

#: index.docbook:221
msgid "Syntax"
msgstr "Propriété de l'élément dans la collection"

#: index.docbook:223
msgid "Example"
msgstr "{[aliasname].element.[propertyname]}"

#: index.docbook:229
msgid "A simple property"
msgstr "NAME as {coll.element.name}"

#: index.docbook:231
msgid "{[aliasname].[propertyname]"
msgstr "Toutes les propriétés de l'élément dans la collection"

#: index.docbook:233
msgid "A_NAME as {item.name}"
msgstr "{[aliasname].element.*}"

#: index.docbook:237
msgid "A composite property"
msgstr "{coll.element.*}"

#: index.docbook:239
msgid "{[aliasname].[componentname].[propertyname]}"
msgstr "Toutes les propriétés de la collection"

#: index.docbook:241
msgid "CURRENCY as {item.amount.currency}, VALUE as {item.amount.value}"
msgstr "{[aliasname].*}"

#: index.docbook:246
msgid "Discriminator of an entity"
msgstr "{coll.*}"

#: index.docbook:248
msgid "{[aliasname].class}"
msgstr "Requêtes SQL nommées"

#: index.docbook:250
msgid "DISC as {item.class}"
msgstr "Les requêtes SQL nommées peuvent être définies dans le document de mapping et appelées exactement de la même manière qu'un requête HQL nommée. Dans ce cas, nous <emphasis>n'avons pas besoin</emphasis> d'appeler <literal>addEntity()</literal>."

#: index.docbook:254
msgid "All properties of an entity"
msgstr ""
      "&lt;sql-query name=\"persons\"&gt;\n"
      "    &lt;return alias=\"person\" class=\"eg.Person\"/&gt;\n"
      "    SELECT person.NAME AS {person.name},\n"
      "           person.AGE AS {person.age},\n"
      "           person.SEX AS {person.sex}\n"
      "    FROM PERSON person\n"
      "    WHERE person.NAME LIKE :namePattern\n"
      "&lt;/sql-query&gt;"

#: index.docbook:256, index.docbook:304
msgid "{[aliasname].*}"
msgstr ""
      "List people = sess.getNamedQuery(\"persons\")\n"
      "    .setString(\"namePattern\", namePattern)\n"
      "    .setMaxResults(50)\n"
      "    .list();"

#: index.docbook:258
msgid "{item.*}"
msgstr "Les éléments <literal>&lt;return-join&gt;</literal> et <literal>&lt;load-collection&gt;</literal> sont respectivement utilisés pour lier des associations et définir des requêtes qui initialisent des collections."

#: index.docbook:262
msgid "A collection key"
msgstr ""
      "&lt;sql-query name=\"personsWith\"&gt;\n"
      "    &lt;return alias=\"person\" class=\"eg.Person\"/&gt;\n"
      "    &lt;return-join alias=\"address\" property=\"person.mailingAddress\"/&gt;\n"
      "    SELECT person.NAME AS {person.name},\n"
      "           person.AGE AS {person.age},\n"
      "           person.SEX AS {person.sex},\n"
      "           address.STREET AS {address.street},\n"
      "           address.CITY AS {address.city},\n"
      "           address.STATE AS {address.state},\n"
      "           address.ZIP AS {address.zip}\n"
      "    FROM PERSON person\n"
      "    JOIN ADDRESS address\n"
      "        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'\n"
      "    WHERE person.NAME LIKE :namePattern\n"
      "&lt;/sql-query&gt;"

#: index.docbook:264
msgid "{[aliasname].key}"
msgstr "Une requête SQL nommée peut retourner une valeur scalaire. Vous devez spécifier l'alias de colonne et le type Hibernate utilisant l'élément <literal>&lt;return-scalar&gt;</literal> :"

#: index.docbook:266
msgid "ORGID as {coll.key}"
msgstr ""
      "&lt;sql-query name=\"mySqlQuery\"&gt;\n"
      "    &lt;return-scalar column=\"name\" type=\"string\"/&gt;\n"
      "    &lt;return-scalar column=\"age\" type=\"long\"/&gt;\n"
      "    SELECT p.NAME AS name,\n"
      "           p.AGE AS age,\n"
      "    FROM PERSON p WHERE p.NAME LIKE 'Hiber%'\n"
      "&lt;/sql-query&gt;"

#: index.docbook:270
msgid "The id of an collection"
msgstr "Vous pouvez externaliser les informations de mapping des résultats dans un élément <literal>&lt;resultset&gt;</literal> pour soit les réutiliser dans différentes requêtes nommées, soit à travers l'API <literal>setResultSetMapping()</literal>."

#: index.docbook:272
msgid "{[aliasname].id}"
msgstr ""
      "&lt;resultset name=\"personAddress\"&gt;\n"
      "    &lt;return alias=\"person\" class=\"eg.Person\"/&gt;\n"
      "    &lt;return-join alias=\"address\" property=\"person.mailingAddress\"/&gt;\n"
      "&lt;/resultset&gt;\n"
      "\n"
      "&lt;sql-query name=\"personsWith\" resultset-ref=\"personAddress\"&gt;\n"
      "    SELECT person.NAME AS {person.name},\n"
      "           person.AGE AS {person.age},\n"
      "           person.SEX AS {person.sex},\n"
      "           address.STREET AS {address.street},\n"
      "           address.CITY AS {address.city},\n"
      "           address.STATE AS {address.state},\n"
      "           address.ZIP AS {address.zip}\n"
      "    FROM PERSON person\n"
      "    JOIN ADDRESS address\n"
      "        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'\n"
      "    WHERE person.NAME LIKE :namePattern\n"
      "&lt;/sql-query&gt;"

#: index.docbook:274
msgid "EMPID as {coll.id}"
msgstr "Utilisation de return-property pour spécifier explicitement les noms des colonnes/alias"

#: index.docbook:278
msgid "The element of an collection"
msgstr "Avec <literal>&lt;return-property&gt;</literal> vous pouvez explicitement dire à Hibernate quels alias de colonne utiliser, plutot que d'employer la syntaxe <literal>{}</literal> pour laisser Hibernate injecter ses propres alias."

#: index.docbook:280
msgid "{[aliasname].element}"
msgstr ""
      "&lt;sql-query name=\"mySqlQuery\"&gt;\n"
      "    &lt;return alias=\"person\" class=\"eg.Person\"&gt;\n"
      "        &lt;return-property name=\"name\" column=\"myName\"/&gt;\n"
      "        &lt;return-property name=\"age\" column=\"myAge\"/&gt;\n"
      "        &lt;return-property name=\"sex\" column=\"mySex\"/&gt;\n"
      "    &lt;/return&gt;\n"
      "    SELECT person.NAME AS myName,\n"
      "           person.AGE AS myAge,\n"
      "           person.SEX AS mySex,\n"
      "    FROM PERSON person WHERE person.NAME LIKE :name\n"
      "&lt;/sql-query&gt;"

#: index.docbook:282
msgid "XID as {coll.element}"
msgstr "<literal>&lt;return-property&gt;</literal> fonctionne aussi avec de multiple colonnes. Cela résout une limitation de la syntaxe <literal>{}</literal> qui ne peut pas permettre une bonne granularité des propriétés multi-colonnes."

#: index.docbook:286
msgid "roperty of the element in the collection"
msgstr ""
      "&lt;sql-query name=\"organizationCurrentEmployments\"&gt;\n"
      "    &lt;return alias=\"emp\" class=\"Employment\"&gt;\n"
      "        &lt;return-property name=\"salary\"&gt;\n"
      "            &lt;return-column name=\"VALUE\"/&gt;\n"
      "            &lt;return-column name=\"CURRENCY\"/&gt;\n"
      "        &lt;/return-property&gt;\n"
      "        &lt;return-property name=\"endDate\" column=\"myEndDate\"/&gt;\n"
      "    &lt;/return&gt;\n"
      "        SELECT EMPLOYEE AS {emp.employee}, EMPLOYER AS {emp.employer},\n"
      "        STARTDATE AS {emp.startDate}, ENDDATE AS {emp.endDate},\n"
      "        REGIONCODE as {emp.regionCode}, EID AS {emp.id}, VALUE, CURRENCY\n"
      "        FROM EMPLOYMENT\n"
      "        WHERE EMPLOYER = :id AND ENDDATE IS NULL\n"
      "        ORDER BY STARTDATE ASC\n"
      "&lt;/sql-query&gt;"

#: index.docbook:288
msgid "{[aliasname].element.[propertyname]}"
msgstr "Notez que dans cet exemple nous avons utilisé <literal>&lt;return-property&gt;</literal> en combinaison avec la syntaxe <literal>{}</literal> pour l'injection. Cela autorise les utilisateurs à choisir comment ils veulent référencer les colonnes et les propriétés."

#: index.docbook:290
msgid "NAME as {coll.element.name}"
msgstr "Si votre mapping a un discriminant vous devez utiliser <literal>&lt;return-discriminator&gt;</literal> pour spécifier la colonne discriminante."

#: index.docbook:294
msgid "All properties of the element in the collection"
msgstr "Utilisation de procédures stockées pour les requêtes"

#: index.docbook:296
msgid "{[aliasname].element.*}"
msgstr "Hibernate 3 introduit le support des requêtes via procédures stockées et les fonctions. La documentation suivante est valable pour les deux. Les procédures stockées/fonctions doivent retourner l'ensemble de résultats en tant que premier paramètre sortant (NdT: \"out-parameter\") pour être capable de fonctionner avec Hibernate. Un exemple d'une telle procédure stockée en Oracle 9 et version supérieure :"

#: index.docbook:298
msgid "{coll.element.*}"
msgstr ""
      "CREATE OR REPLACE FUNCTION selectAllEmployments\n"
      "    RETURN SYS_REFCURSOR\n"
      "AS\n"
      "    st_cursor SYS_REFCURSOR;\n"
      "BEGIN\n"
      "    OPEN st_cursor FOR\n"
      " SELECT EMPLOYEE, EMPLOYER,\n"
      " STARTDATE, ENDDATE,\n"
      " REGIONCODE, EID, VALUE, CURRENCY\n"
      " FROM EMPLOYMENT;\n"
      "      RETURN  st_cursor;\n"
      " END;"

#: index.docbook:302
msgid "All properties of the the collection"
msgstr "Pour utiliser cette requête dans Hibernate vous avez besoin de la mapper via une requête nommée."

#: index.docbook:306
msgid "{coll.*}"
msgstr "Notez que les procédures stockées retournent, pour le moment, seulement des scalaires et des entités. <literal>&lt;return-join&gt;</literal> et <literal>&lt;load-collection&gt;</literal> ne sont pas supportés."

#: index.docbook:315
msgid "Returning non-managed entities"
msgstr "Règles/limitations lors de l'utilisation des procédures stockées"

#: index.docbook:317
msgid "It is possible to apply a ResultTransformer to native sql queries. Allowing it to e.g. return non-managed entities."
msgstr "Pur utiliser des procédures stockées avec Hibernate, les procédures doivent suivre certaines règles. Si elles ne suivent pas ces règles, elles ne sont pas utilisables avec Hibernate. Si vous voulez encore utiliser ces procédures vous devez les exécuter via <literal>session.connection()</literal>. Les règles sont différentes pour chaque base de données, puisque les vendeurs de base de données ont des sémantiques/syntaxes différentes pour les procédures stockées."

#: index.docbook:319
msgid ""
      "<![CDATA[sess.createSQLQuery(\"SELECT NAME, BIRTHDATE FROM CATS\")\n"
      "        .setResultTransformer(Transformers.aliasToBean(CatDTO.class))]]>"
msgstr "Les requêtes de procédures stockées ne peuvent pas être paginées avec <literal>setFirstResult()/setMaxResults()</literal>."

#: index.docbook:329
msgid "a result transformer"
msgstr "Pour Sybase ou MS SQL server les règles suivantes s'appliquent :"

#: index.docbook:333
msgid "The above query will return a list of <literal>CatDTO</literal> which has been instantiated and injected the values of NAME and BIRTHNAME into its corresponding properties or fields."
msgstr "La procédure doit retourner un ensemble de résultats. Notez que comme ces serveurs peuvent retourner de multiples ensembles de résultats et mettre à jour des compteurs, Hibernate itérera les résultats et prendra le premier résultat qui est un ensemble de résultat comme valeur de retour. Tout le reste sera ignoré."

#: index.docbook:340
msgid "Handling inheritance"
msgstr "Si vous pouvez activer <literal>SET NOCOUNT ON</literal> dans votre procédure, elle sera probablement plus efficace, mais ce n'est pas une obligation."

#: index.docbook:342
msgid "Native sql queries which query for entities that is mapped as part of an inheritance must include all properties for the baseclass and all it subclasses."
msgstr "SQL personnalisé pour créer, mettre à jour et effacer"

#: index.docbook:348
msgid "Parameters"
msgstr "Hibernate3 peut utiliser des expression SQL personnalisées pour des opérations de création, de mise à jour, et de suppression. Les objets persistants les classes et les collections dans Hibernate contiennent déjà un ensemble de chaînes de caractères générées lors de la configuration (insertsql, deletesql, updatesql, etc). Les tages de mapping <literal>&lt;sql-insert&gt;</literal>, <literal>&lt;sql-delete&gt;</literal>, et <literal>&lt;sql-update&gt;</literal> surchargent ces chaînes de caractères :"

#: index.docbook:350
msgid "Native sql queries support positional as well as named parameters:"
msgstr ""
      "&lt;class name=\"Person\"&gt;\n"
      "    &lt;id name=\"id\"&gt;\n"
      "        &lt;generator class=\"increment\"/&gt;\n"
      "    &lt;/id&gt;\n"
      "    &lt;property name=\"name\" not-null=\"true\"/&gt;\n"
      "    &lt;sql-insert&gt;INSERT INTO PERSON (NAME, ID) VALUES ( UPPER(?), ? )&lt;/sql-insert&gt;\n"
      "    &lt;sql-update&gt;UPDATE PERSON SET NAME=UPPER(?) WHERE ID=?&lt;/sql-update&gt;\n"
      "    &lt;sql-delete&gt;DELETE FROM PERSON WHERE ID=?&lt;/sql-delete&gt;\n"
      "&lt;/class&gt;"

#: index.docbook:353
msgid ""
      "<![CDATA[Query query = sess.createSQLQuery(\"SELECT * FROM CATS WHERE NAME like ?\").addEntity(Cat.class);\n"
      "List pusList = query.setString(0, \"Pus%\").list();\n"
      "     \n"
      "query = sess.createSQLQuery(\"SELECT * FROM CATS WHERE NAME like :name\").addEntity(Cat.class);\n"
      "List pusList = query.setString(\"name\", \"Pus%\").list();          ]]>"
msgstr "Le SQL est directement exécuté dans votre base de données, donc vous êtes libre d'utiliser le dialecte que vous souhaitez. Cela réduira bien sûr la portabilité de votre mapping si vous utilisez du SQL spécifique à votre base de données."

#: index.docbook:361
msgid "Named SQL queries"
msgstr "Les procédures stockées sont supportées si l'attribut <literal>callable</literal> est paramétré :"

#: index.docbook:363
msgid "Named SQL queries may be defined in the mapping document and called in exactly the same way as a named HQL query. In this case, we do <emphasis>not</emphasis> need to call <literal>addEntity()</literal>."
msgstr ""
      "&lt;class name=\"Person\"&gt;\n"
      "    &lt;id name=\"id\"&gt;\n"
      "        &lt;generator class=\"increment\"/&gt;\n"
      "    &lt;/id&gt;\n"
      "    &lt;property name=\"name\" not-null=\"true\"/&gt;\n"
      "    &lt;sql-insert callable=\"true\"&gt;{call createPerson (?, ?)}&lt;/sql-insert&gt;\n"
      "    &lt;sql-delete callable=\"true\"&gt;{? = call deletePerson (?)}&lt;/sql-delete&gt;\n"
      "    &lt;sql-update callable=\"true\"&gt;{? = call updatePerson (?, ?)}&lt;/sql-update&gt;\n"
      "&lt;/class&gt;"

#: index.docbook:368
msgid ""
      "<![CDATA[<sql-query name=\"persons\">\n"
      "    <return alias=\"person\" class=\"eg.Person\"/>\n"
      "    SELECT person.NAME AS {person.name},\n"
      "           person.AGE AS {person.age},\n"
      "           person.SEX AS {person.sex}\n"
      "    FROM PERSON person\n"
      "    WHERE person.NAME LIKE :namePattern\n"
      "</sql-query>]]>"
msgstr "L'ordre des paramètres positionnels est actuellement vital, car ils doivent être dans la même séquence qu'Hibernate les attend."

#: index.docbook:370
msgid ""
      "<![CDATA[List people = sess.getNamedQuery(\"persons\")\n"
      "    .setString(\"namePattern\", namePattern)\n"
      "    .setMaxResults(50)\n"
      "    .list();]]>"
msgstr "Vous pouvez voir l'ordre attendu en activant les journaux de debug pour le niveau <literal>org.hibernate.persister.entity</literal> level. Avec ce niveau activé, Hibernate imprimera le SQL statique qui est utilisé pour créer, mettre à jour, supprimer, etc. des entités. (Pour voir la séquence attendue, rappelez-vous de ne pas inclure votre SQL personnalisé dans les fichiers de mapping de manière à surcharger le SQL statique généré par Hibernate.)"

#: index.docbook:372
msgid "The <literal>&lt;return-join&gt;</literal> and <literal>&lt;load-collection&gt;</literal> elements are used to join associations and define queries which initialize collections, respectively."
msgstr "Les procédures stockées sont dans la plupart des cas (lire : il vaut mieux le faire) requises pour retourner le nombre de lignes insérées/mises à jour/supprimées, puisque Hibernate fait quelques vérifications de succès lors de l'exécution de l'expression. Hibernate inscrit toujours la première expression comme un paramètre de sortie numérique pour les opérations CUD :"

#: index.docbook:377
msgid ""
      "<![CDATA[<sql-query name=\"personsWith\">\n"
      "    <return alias=\"person\" class=\"eg.Person\"/>\n"
      "    <return-join alias=\"address\" property=\"person.mailingAddress\"/>\n"
      "    SELECT person.NAME AS {person.name},\n"
      "           person.AGE AS {person.age},\n"
      "           person.SEX AS {person.sex},\n"
      "           address.STREET AS {address.street},\n"
      "           address.CITY AS {address.city},\n"
      "           address.STATE AS {address.state},\n"
      "           address.ZIP AS {address.zip}\n"
      "    FROM PERSON person\n"
      "    JOIN ADDRESS address\n"
      "        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'\n"
      "    WHERE person.NAME LIKE :namePattern\n"
      "</sql-query>]]>"
msgstr ""
      "CREATE OR REPLACE FUNCTION updatePerson (uid IN NUMBER, uname IN VARCHAR2)\n"
      "    RETURN NUMBER IS\n"
      "BEGIN\n"
      "\n"
      "    update PERSON\n"
      "    set\n"
      "        NAME = uname,\n"
      "    where\n"
      "        ID = uid;\n"
      "\n"
      "    return SQL%ROWCOUNT;\n"
      "\n"
      "END updatePerson;"

#: index.docbook:379
msgid "A named SQL query may return a scalar value. You must declare the column alias and Hibernate type using the <literal>&lt;return-scalar&gt;</literal> element:"
msgstr "SQL personnalisé pour le chargement"

#: index.docbook:383
msgid ""
      "<![CDATA[<sql-query name=\"mySqlQuery\">\n"
      "    <return-scalar column=\"name\" type=\"string\"/>\n"
      "    <return-scalar column=\"age\" type=\"long\"/>\n"
      "    SELECT p.NAME AS name,\n"
      "           p.AGE AS age,\n"
      "    FROM PERSON p WHERE p.NAME LIKE 'Hiber%'\n"
      "</sql-query>]]>"
msgstr "Vous pouvez aussi déclarer vos propres requêtes SQL (ou HQL) pour le chargement d'entité :"

#: index.docbook:385
msgid "You can externalize the resultset mapping informations in a <literal>&lt;resultset&gt;</literal> element to either reuse them accross several named queries or through the <literal>setResultSetMapping()</literal> API."
msgstr ""
      "&lt;sql-query name=\"person\"&gt;\n"
      "    &lt;return alias=\"pers\" class=\"Person\" lock-mode=\"upgrade\"/&gt;\n"
      "    SELECT NAME AS {pers.name}, ID AS {pers.id}\n"
      "    FROM PERSON\n"
      "    WHERE ID=?\n"
      "    FOR UPDATE\n"
      "&lt;/sql-query&gt;"

#: index.docbook:390
msgid ""
      "<![CDATA[<resultset name=\"personAddress\">\n"
      "    <return alias=\"person\" class=\"eg.Person\"/>\n"
      "    <return-join alias=\"address\" property=\"person.mailingAddress\"/>\n"
      "</resultset>\n"
      "\n"
      "<sql-query name=\"personsWith\" resultset-ref=\"personAddress\">\n"
      "    SELECT person.NAME AS {person.name},\n"
      "           person.AGE AS {person.age},\n"
      "           person.SEX AS {person.sex},\n"
      "           address.STREET AS {address.street},\n"
      "           address.CITY AS {address.city},\n"
      "           address.STATE AS {address.state},\n"
      "           address.ZIP AS {address.zip}\n"
      "    FROM PERSON person\n"
      "    JOIN ADDRESS address\n"
      "        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'\n"
      "    WHERE person.NAME LIKE :namePattern\n"
      "</sql-query>]]>"
msgstr "Ceci est juste une déclaration de requête nommée, comme vu plus tôt. Vous pouvez référencer cette requête nommée dans un mapping de classe :"

#: index.docbook:392
msgid "You can alternatively use the resultset mapping information in your hbm files directly in java code."
msgstr ""
      "&lt;class name=\"Person\"&gt;\n"
      "    &lt;id name=\"id\"&gt;\n"
      "        &lt;generator class=\"increment\"/&gt;\n"
      "    &lt;/id&gt;\n"
      "    &lt;property name=\"name\" not-null=\"true\"/&gt;\n"
      "    &lt;loader query-ref=\"person\"/&gt;\n"
      "&lt;/class&gt;"

#: index.docbook:395
msgid ""
      "<![CDATA[List cats = sess.createSQLQuery(\n"
      "        \"select {cat.*}, {kitten.*} from cats cat, cats kitten where kitten.mother = cat.id\"\n"
      "    )\n"
      "    .setResultSetMapping(\"catAndKitten\")\n"
      "    .list();]]>"
msgstr "Ceci fonctionne même avec des procédures stockées."

#: index.docbook:398
msgid "Using return-property to explicitly specify column/alias names"
msgstr "Vous pouvez même définir une requête pour le chargement d'une collection :"

#: index.docbook:401
msgid "With <literal>&lt;return-property&gt;</literal> you can explicitly tell Hibernate what column aliases to use, instead of using the <literal>{}</literal>-syntax to let Hibernate inject its own aliases."
msgstr ""
      "&lt;set name=\"employments\" inverse=\"true\"&gt;\n"
      "    &lt;key/&gt;\n"
      "    &lt;one-to-many class=\"Employment\"/&gt;\n"
      "    &lt;loader query-ref=\"employments\"/&gt;\n"
      "&lt;/set&gt;"

#: index.docbook:406
msgid ""
      "<![CDATA[<sql-query name=\"mySqlQuery\">\n"
      "    <return alias=\"person\" class=\"eg.Person\">\n"
      "        <return-property name=\"name\" column=\"myName\"/>\n"
      "        <return-property name=\"age\" column=\"myAge\"/>\n"
      "        <return-property name=\"sex\" column=\"mySex\"/>\n"
      "    </return>\n"
      "    SELECT person.NAME AS myName,\n"
      "           person.AGE AS myAge,\n"
      "           person.SEX AS mySex,\n"
      "    FROM PERSON person WHERE person.NAME LIKE :name\n"
      "</sql-query>\n"
      "]]>"
msgstr ""
      "&lt;sql-query name=\"employments\"&gt;\n"
      "    &lt;load-collection alias=\"emp\" role=\"Person.employments\"/&gt;\n"
      "    SELECT {emp.*}\n"
      "    FROM EMPLOYMENT emp\n"
      "    WHERE EMPLOYER = :id\n"
      "    ORDER BY STARTDATE ASC, EMPLOYEE ASC\n"
      "&lt;/sql-query&gt;"

#: index.docbook:408
msgid "<literal>&lt;return-property&gt;</literal> also works with multiple columns. This solves a limitation with the <literal>{}</literal>-syntax which can not allow fine grained control of multi-column properties."
msgstr "Vous pourriez même définir un chargeur d'entité qui charge une collection par jointure :"

#: index.docbook:413
msgid ""
      "<![CDATA[<sql-query name=\"organizationCurrentEmployments\">\n"
      "    <return alias=\"emp\" class=\"Employment\">\n"
      "        <return-property name=\"salary\">\n"
      "            <return-column name=\"VALUE\"/>\n"
      "            <return-column name=\"CURRENCY\"/>\n"
      "        </return-property>\n"
      "        <return-property name=\"endDate\" column=\"myEndDate\"/>\n"
      "    </return>\n"
      "        SELECT EMPLOYEE AS {emp.employee}, EMPLOYER AS {emp.employer},\n"
      "        STARTDATE AS {emp.startDate}, ENDDATE AS {emp.endDate},\n"
      "        REGIONCODE as {emp.regionCode}, EID AS {emp.id}, VALUE, CURRENCY\n"
      "        FROM EMPLOYMENT\n"
      "        WHERE EMPLOYER = :id AND ENDDATE IS NULL\n"
      "        ORDER BY STARTDATE ASC\n"
      "</sql-query>]]>"
msgstr ""
      "&lt;sql-query name=\"person\"&gt;\n"
      "    &lt;return alias=\"pers\" class=\"Person\"/&gt;\n"
      "    &lt;return-join alias=\"emp\" property=\"pers.employments\"/&gt;\n"
      "    SELECT NAME AS {pers.*}, {emp.*}\n"
      "    FROM PERSON pers\n"
      "    LEFT OUTER JOIN EMPLOYMENT emp\n"
      "        ON pers.ID = emp.PERSON_ID\n"
      "    WHERE ID=?\n"
      "&lt;/sql-query&gt;"

#: index.docbook:415
msgid "Notice that in this example we used <literal>&lt;return-property&gt;</literal> in combination with the <literal>{}</literal>-syntax for injection. Allowing users to choose how they want to refer column and properties."
msgstr ""

#: index.docbook:420
msgid "If your mapping has a discriminator you must use <literal>&lt;return-discriminator&gt;</literal> to specify the discriminator column."
msgstr ""

#: index.docbook:426
msgid "Using stored procedures for querying"
msgstr ""

#: index.docbook:428
msgid "Hibernate 3 introduces support for queries via stored procedures and functions. Most of the following documentation is equivalent for both. The stored procedure/function must return a resultset as the first out-parameter to be able to work with Hibernate. An example of such a stored function in Oracle 9 and higher is as follows:"
msgstr ""

#: index.docbook:434
msgid ""
      "<![CDATA[CREATE OR REPLACE FUNCTION selectAllEmployments\n"
      "    RETURN SYS_REFCURSOR\n"
      "AS\n"
      "    st_cursor SYS_REFCURSOR;\n"
      "BEGIN\n"
      "    OPEN st_cursor FOR\n"
      " SELECT EMPLOYEE, EMPLOYER,\n"
      " STARTDATE, ENDDATE,\n"
      " REGIONCODE, EID, VALUE, CURRENCY\n"
      " FROM EMPLOYMENT;\n"
      "      RETURN  st_cursor;\n"
      " END;]]>"
msgstr ""

#: index.docbook:436
msgid "To use this query in Hibernate you need to map it via a named query."
msgstr ""

#: index.docbook:439
msgid ""
      "<![CDATA[<sql-query name=\"selectAllEmployees_SP\" callable=\"true\">\n"
      "    <return alias=\"emp\" class=\"Employment\">\n"
      "        <return-property name=\"employee\" column=\"EMPLOYEE\"/>\n"
      "        <return-property name=\"employer\" column=\"EMPLOYER\"/>\n"
      "        <return-property name=\"startDate\" column=\"STARTDATE\"/>\n"
      "        <return-property name=\"endDate\" column=\"ENDDATE\"/>\n"
      "        <return-property name=\"regionCode\" column=\"REGIONCODE\"/>\n"
      "        <return-property name=\"id\" column=\"EID\"/>\n"
      "        <return-property name=\"salary\">\n"
      "            <return-column name=\"VALUE\"/>\n"
      "            <return-column name=\"CURRENCY\"/>\n"
      "        </return-property>\n"
      "    </return>\n"
      "    { ? = call selectAllEmployments() }\n"
      "</sql-query>]]>"
msgstr ""

#: index.docbook:441
msgid "Notice stored procedures currently only return scalars and entities. <literal>&lt;return-join&gt;</literal> and <literal>&lt;load-collection&gt;</literal> are not supported."
msgstr ""

#: index.docbook:446
msgid "Rules/limitations for using stored procedures"
msgstr ""

#: index.docbook:448
msgid "To use stored procedures with Hibernate the procedures/functions have to follow some rules. If they do not follow those rules they are not usable with Hibernate. If you still want to use these procedures you have to execute them via <literal>session.connection()</literal>. The rules are different for each database, since database vendors have different stored procedure semantics/syntax."
msgstr ""

#: index.docbook:455
msgid "Stored procedure queries can't be paged with <literal>setFirstResult()/setMaxResults()</literal>."
msgstr ""

#: index.docbook:458
msgid "Recommended call form is standard SQL92: <literal>{ ? = call functionName(&lt;parameters&gt;) }</literal> or <literal>{ ? = call procedureName(&lt;parameters&gt;}</literal>. Native call syntax is not supported."
msgstr ""

#: index.docbook:463
msgid "For Oracle the following rules apply:"
msgstr ""

#: index.docbook:467
msgid "A function must return a result set. The first parameter of a procedure must be an <literal>OUT</literal> that returns a result set. This is done by using a <literal>SYS_REFCURSOR</literal> type in Oracle 9 or 10. In Oracle you need to define a <literal>REF CURSOR</literal> type, see Oracle literature."
msgstr ""

#: index.docbook:476
msgid "For Sybase or MS SQL server the following rules apply:"
msgstr ""

#: index.docbook:480
msgid "The procedure must return a result set. Note that since these servers can/will return multiple result sets and update counts, Hibernate will iterate the results and take the first result that is a result set as its return value. Everything else will be discarded."
msgstr ""

#: index.docbook:488
msgid "If you can enable <literal>SET NOCOUNT ON</literal> in your procedure it will probably be more efficient, but this is not a requirement."
msgstr ""

#: index.docbook:498
msgid "Custom SQL for create, update and delete"
msgstr ""

#: index.docbook:500
msgid "Hibernate3 can use custom SQL statements for create, update, and delete operations. The class and collection persisters in Hibernate already contain a set of configuration time generated strings (insertsql, deletesql, updatesql etc.). The mapping tags <literal>&lt;sql-insert&gt;</literal>, <literal>&lt;sql-delete&gt;</literal>, and <literal>&lt;sql-update&gt;</literal> override these strings:"
msgstr ""

#: index.docbook:508
msgid ""
      "<![CDATA[<class name=\"Person\">\n"
      "    <id name=\"id\">\n"
      "        <generator class=\"increment\"/>\n"
      "    </id>\n"
      "    <property name=\"name\" not-null=\"true\"/>\n"
      "    <sql-insert>INSERT INTO PERSON (NAME, ID) VALUES ( UPPER(?), ? )</sql-insert>\n"
      "    <sql-update>UPDATE PERSON SET NAME=UPPER(?) WHERE ID=?</sql-update>\n"
      "    <sql-delete>DELETE FROM PERSON WHERE ID=?</sql-delete>\n"
      "</class>]]>"
msgstr ""

#: index.docbook:510
msgid "The SQL is directly executed in your database, so you are free to use any dialect you like. This will of course reduce the portability of your mapping if you use database specific SQL."
msgstr ""

#: index.docbook:514
msgid "Stored procedures are supported if the <literal>callable</literal> attribute is set:"
msgstr ""

#: index.docbook:517
msgid ""
      "<![CDATA[<class name=\"Person\">\n"
      "    <id name=\"id\">\n"
      "        <generator class=\"increment\"/>\n"
      "    </id>\n"
      "    <property name=\"name\" not-null=\"true\"/>\n"
      "    <sql-insert callable=\"true\">{call createPerson (?, ?)}</sql-insert>\n"
      "    <sql-delete callable=\"true\">{? = call deletePerson (?)}</sql-delete>\n"
      "    <sql-update callable=\"true\">{? = call updatePerson (?, ?)}</sql-update>\n"
      "</class>]]>"
msgstr ""

#: index.docbook:519
msgid "The order of the positional parameters are currently vital, as they must be in the same sequence as Hibernate expects them."
msgstr ""

#: index.docbook:522
msgid "You can see the expected order by enabling debug logging for the <literal>org.hibernate.persister.entity</literal> level. With this level enabled Hibernate will print out the static SQL that is used to create, update, delete etc. entities. (To see the expected sequence, remember to not include your custom SQL in the mapping files as that will override the Hibernate generated static sql.)"
msgstr ""

#: index.docbook:529
msgid "The stored procedures are in most cases (read: better do it than not) required to return the number of rows inserted/updated/deleted, as Hibernate has some runtime checks for the success of the statement. Hibernate always registers the first statement parameter as a numeric output parameter for the CUD operations:"
msgstr ""

#: index.docbook:535
msgid ""
      "<![CDATA[CREATE OR REPLACE FUNCTION updatePerson (uid IN NUMBER, uname IN VARCHAR2)\n"
      "    RETURN NUMBER IS\n"
      "BEGIN\n"
      "\n"
      "    update PERSON\n"
      "    set\n"
      "        NAME = uname,\n"
      "    where\n"
      "        ID = uid;\n"
      "\n"
      "    return SQL%ROWCOUNT;\n"
      "\n"
      "END updatePerson;]]>"
msgstr ""

#: index.docbook:539
msgid "Custom SQL for loading"
msgstr ""

#: index.docbook:541
msgid "You may also declare your own SQL (or HQL) queries for entity loading:"
msgstr ""

#: index.docbook:544
msgid ""
      "<![CDATA[<sql-query name=\"person\">\n"
      "    <return alias=\"pers\" class=\"Person\" lock-mode=\"upgrade\"/>\n"
      "    SELECT NAME AS {pers.name}, ID AS {pers.id}\n"
      "    FROM PERSON\n"
      "    WHERE ID=?\n"
      "    FOR UPDATE\n"
      "</sql-query>]]>"
msgstr ""

#: index.docbook:546
msgid "This is just a named query declaration, as discussed earlier. You may reference this named query in a class mapping:"
msgstr ""

#: index.docbook:549
msgid ""
      "<![CDATA[<class name=\"Person\">\n"
      "    <id name=\"id\">\n"
      "        <generator class=\"increment\"/>\n"
      "    </id>\n"
      "    <property name=\"name\" not-null=\"true\"/>\n"
      "    <loader query-ref=\"person\"/>\n"
      "</class>]]>"
msgstr ""

#: index.docbook:551
msgid "This even works with stored procedures."
msgstr ""

#: index.docbook:553
msgid "You may even define a query for collection loading:"
msgstr ""

#: index.docbook:555
msgid ""
      "<![CDATA[<set name=\"employments\" inverse=\"true\">\n"
      "    <key/>\n"
      "    <one-to-many class=\"Employment\"/>\n"
      "    <loader query-ref=\"employments\"/>\n"
      "</set>]]>"
msgstr ""

#: index.docbook:557
msgid ""
      "<![CDATA[<sql-query name=\"employments\">\n"
      "    <load-collection alias=\"emp\" role=\"Person.employments\"/>\n"
      "    SELECT {emp.*}\n"
      "    FROM EMPLOYMENT emp\n"
      "    WHERE EMPLOYER = :id\n"
      "    ORDER BY STARTDATE ASC, EMPLOYEE ASC\n"
      "</sql-query>]]>"
msgstr ""

#: index.docbook:559
msgid "You could even define an entity loader that loads a collection by join fetching:"
msgstr ""

#: index.docbook:562
msgid ""
      "<![CDATA[<sql-query name=\"person\">\n"
      "    <return alias=\"pers\" class=\"Person\"/>\n"
      "    <return-join alias=\"emp\" property=\"pers.employments\"/>\n"
      "    SELECT NAME AS {pers.*}, {emp.*}\n"
      "    FROM PERSON pers\n"
      "    LEFT OUTER JOIN EMPLOYMENT emp\n"
      "        ON pers.ID = emp.PERSON_ID\n"
      "    WHERE ID=?\n"
      "</sql-query>]]>"
msgstr ""

msgid "ROLES_OF_TRANSLATORS"
msgstr "<!--TRANS:ROLES_OF_TRANSLATORS-->"

msgid "CREDIT_FOR_TRANSLATORS"
msgstr "<!--TRANS:CREDIT_FOR_TRANSLATORS-->"

