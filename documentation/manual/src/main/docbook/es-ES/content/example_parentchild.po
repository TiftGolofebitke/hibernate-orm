msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2007-10-25 07:47+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: example_parentchild.xml:5
#, no-c-format
msgid "Example: Parent/Child"
msgstr "Ejemplo: Padre/Hijo"

#. Tag: para
#: example_parentchild.xml:7
#, no-c-format
msgid ""
"One of the very first things that new users try to do with Hibernate is to "
"model a parent / child type relationship. There are two different approaches "
"to this. For various reasons the most convenient approach, especially for "
"new users, is to model both <literal>Parent</literal> and <literal>Child</"
"literal> as entity classes with a <literal>&lt;one-to-many&gt;</literal> "
"association from <literal>Parent</literal> to <literal>Child</literal>. (The "
"alternative approach is to declare the <literal>Child</literal> as a "
"<literal>&lt;composite-element&gt;</literal>.) Now, it turns out that "
"default semantics of a one to many association (in Hibernate) are much less "
"close to the usual semantics of a parent / child relationship than those of "
"a composite element mapping. We will explain how to use a "
"<emphasis>bidirectional one to many association with cascades</emphasis> to "
"model a parent / child relationship efficiently and elegantly. It's not at "
"all difficult!"
msgstr ""
"Una de las primerísimas cosas que los usuarios nuevos intentan hacer con "
"Hibernate es modelar una relación de tipo padre / hijo. Para esto hay dos "
"enfoques diferentes. Por varias razones, el enfoque más conveniente, "
"especialmente para usuarios nuevos, es modelar tanto <literal>Parent</"
"literal> como <literal>Child</literal> como clases de entidad con una "
"asociación <literal>&lt;one-to-many&gt;</literal> desde <literal>Parent</"
"literal> a <literal>Child</literal>. (El enfoque alternativo es declarar el "
"<literal>Child</literal> como un <literal>&lt;composite-element&gt;</"
"literal>.) Ahora, resulta que la semántica por defecto de una asociación uno "
"a muchos (en Hibernate) es mucho menos cercana a la semántica usual de una "
"relación padre / hijo que aquellas de un mapeo de elementos compuestos. "
"Explicaremos cómo usar una <emphasis>asociación uno a muchos bidireccional "
"con tratamiento en cascada</emphasis> para modelar una relación padre / hijo "
"eficiente y elegantemente. ¡No es para nada difícil!"

#. Tag: title
#: example_parentchild.xml:21
#, no-c-format
msgid "A note about collections"
msgstr "Una nota sobre las colecciones"

#. Tag: para
#: example_parentchild.xml:23
#, no-c-format
msgid ""
"Hibernate collections are considered to be a logical part of their owning "
"entity; never of the contained entities. This is a crucial distinction! It "
"has the following consequences:"
msgstr ""
"Se considera que las colecciones de Hibernate son una parte lógica de la "
"entidad que las posee; nunca de las entidades contenidas. ¡Esta es una "
"distinción crucial! Esto tiene las siguientes consecuencias:"

#. Tag: para
#: example_parentchild.xml:30
#, no-c-format
msgid ""
"When we remove / add an object from / to a collection, the version number of "
"the collection owner is incremented."
msgstr ""
"Cuando se quita / añade un objeto desde / a una colección, se incrementa el "
"número de versión del dueño de la colección."

#. Tag: para
#: example_parentchild.xml:36
#, no-c-format
msgid ""
"If an object that was removed from a collection is an instance of a value "
"type (eg, a composite element), that object will cease to be persistent and "
"its state will be completely removed from the database. Likewise, adding a "
"value type instance to the collection will cause its state to be immediately "
"persistent."
msgstr ""
"Si un objeto que fue quitado de una colección es una instancia de un tipo de "
"valor (por ejemplo, un elemento compuesto), ese objeta cesará de ser "
"persistente y su estado será completamente quitado de la base de datos. "
"Asimismo, añadir una instancia de tipo de valor a la colección causará que "
"su estado sea inmediatamente persistente."

#. Tag: para
#: example_parentchild.xml:44
#, no-c-format
msgid ""
"On the other hand, if an entity is removed from a collection (a one-to-many "
"or many-to-many association), it will not be deleted, by default. This "
"behaviour is completely consistent - a change to the internal state of "
"another entity should not cause the associated entity to vanish! Likewise, "
"adding an entity to a collection does not cause that entity to become "
"persistent, by default."
msgstr ""
"Por otro lado, si se quita una entidad de una colección (una asociación uno-"
"a-muchos o muchos-a-muchos), no será borrado, por defecto. Este "
"comportamiento es completamente consistente. ¡Un cambio en el estado interno "
"de otra entidad no hace desaparecer la entidad asociada! Asimismo, añadir "
"una entidad a una colección no causa que la entidad se vuelva persistente, "
"por defecto."

#. Tag: para
#: example_parentchild.xml:54
#, no-c-format
msgid ""
"Instead, the default behaviour is that adding an entity to a collection "
"merely creates a link between the two entities, while removing it removes "
"the link. This is very appropriate for all sorts of cases. Where it is not "
"appropriate at all is the case of a parent / child relationship, where the "
"life of the child is bound to the life cycle of the parent."
msgstr ""
"En cambio, el comportamiento por defecto es que al añadir una entidad a una "
"colección se crea meramente un enlace entre las dos entidades, mientras que "
"al quitarla se quita el enlace. Esto es muy apropiado para todos los tipos "
"de casos. Donde no es para nada apropiado es en el caso de una relación "
"padre / hijo. donde la vida del hijo está ligada al ciclo de vida del padre."

#. Tag: title
#: example_parentchild.xml:64
#, no-c-format
msgid "Bidirectional one-to-many"
msgstr "Uno-a-muchos bidirectional"

#. Tag: para
#: example_parentchild.xml:66
#, no-c-format
msgid ""
"Suppose we start with a simple <literal>&lt;one-to-many&gt;</literal> "
"association from <literal>Parent</literal> to <literal>Child</literal>."
msgstr ""
"Supón que empezamos con una asociación simple <literal>&lt;one-to-many&gt;</"
"literal> desde <literal>Parent</literal> a <literal>Child</literal>."

#. Tag: programlisting
#: example_parentchild.xml:71
#, no-c-format
msgid ""
"<![CDATA[<set name=\"children\">\n"
"    <key column=\"parent_id\"/>\n"
"    <one-to-many class=\"Child\"/>\n"
"</set>]]>"
msgstr ""

#. Tag: para
#: example_parentchild.xml:73
#, no-c-format
msgid "If we were to execute the following code"
msgstr "Si ejecutásemos el siguiente código"

#. Tag: programlisting
#: example_parentchild.xml:77
#, no-c-format
msgid ""
"<![CDATA[Parent p = .....;\n"
"Child c = new Child();\n"
"p.getChildren().add(c);\n"
"session.save(c);\n"
"session.flush();]]>"
msgstr ""

#. Tag: para
#: example_parentchild.xml:79
#, no-c-format
msgid "Hibernate would issue two SQL statements:"
msgstr "Hibernate publicaría dos sentencias SQL:"

#. Tag: para
#: example_parentchild.xml:85
#, no-c-format
msgid ""
"an <literal>INSERT</literal> to create the record for <literal>c</literal>"
msgstr ""
"un <literal>INSERT</literal> para crear el registro de <literal>c</literal>"

#. Tag: para
#: example_parentchild.xml:88
#, no-c-format
msgid ""
"an <literal>UPDATE</literal> to create the link from <literal>p</literal> to "
"<literal>c</literal>"
msgstr ""
"un <literal>UPDATE</literal> para crear el enlace desde <literal>p</literal> "
"a <literal>c</literal>"

#. Tag: para
#: example_parentchild.xml:95
#, no-c-format
msgid ""
"This is not only inefficient, but also violates any <literal>NOT NULL</"
"literal> constraint on the <literal>parent_id</literal> column. We can fix "
"the nullability constraint violation by specifying <literal>not-null=\"true"
"\"</literal> in the collection mapping:"
msgstr ""
"Esto no es sólo ineficiente, sino que además viola cualquier restricción "
"<literal>NOT NULL</literal> en la columna <literal>parent_id</literal>. "
"Podemos reparar la violación de restricción de nulabilidad especificando "
"<literal>not-null=\"true\"</literal> en el mapeo de la colección:"

#. Tag: programlisting
#: example_parentchild.xml:101
#, no-c-format
msgid ""
"<![CDATA[<set name=\"children\">\n"
"    <key column=\"parent_id\" not-null=\"true\"/>\n"
"    <one-to-many class=\"Child\"/>\n"
"</set>]]>"
msgstr ""

#. Tag: para
#: example_parentchild.xml:103
#, no-c-format
msgid "However, this is not the recommended solution."
msgstr "Sin embargo, esta no es la solución recomendada."

#. Tag: para
#: example_parentchild.xml:106
#, no-c-format
msgid ""
"The underlying cause of this behaviour is that the link (the foreign key "
"<literal>parent_id</literal>) from <literal>p</literal> to <literal>c</"
"literal> is not considered part of the state of the <literal>Child</literal> "
"object and is therefore not created in the <literal>INSERT</literal>. So the "
"solution is to make the link part of the <literal>Child</literal> mapping."
msgstr ""
"El caso subyacente de este comportamiento es que el enlace (la clave foránea "
"<literal>parent_id</literal>) de <literal>p</literal> a <literal>c</literal> "
"no es considerado parte del estado del objeto <literal>Child</literal> y por "
"lo tanto no es creada en el <literal>INSERT</literal>. De modo que la "
"solución es hacer el enlace parte del mapeo del <literal>Child</literal>."

#. Tag: programlisting
#: example_parentchild.xml:113
#, no-c-format
msgid ""
"<![CDATA[<many-to-one name=\"parent\" column=\"parent_id\" not-null=\"true\"/"
">]]>"
msgstr ""

#. Tag: para
#: example_parentchild.xml:115
#, no-c-format
msgid ""
"(We also need to add the <literal>parent</literal> property to the "
"<literal>Child</literal> class.)"
msgstr ""
"(Necesitamos además añadir la propiedad <literal>parent</literal> a la clase "
"<literal>Child</literal>.)"

#. Tag: para
#: example_parentchild.xml:119
#, no-c-format
msgid ""
"Now that the <literal>Child</literal> entity is managing the state of the "
"link, we tell the collection not to update the link. We use the "
"<literal>inverse</literal> attribute."
msgstr ""
"Ahora que la entidad <literal>Child</literal> está gestionando el estado del "
"enlace, le decimos a la colección que no actualice el enlace. Usamos el "
"atributo <literal>inverse</literal>."

#. Tag: programlisting
#: example_parentchild.xml:124
#, no-c-format
msgid ""
"<![CDATA[<set name=\"children\" inverse=\"true\">\n"
"    <key column=\"parent_id\"/>\n"
"    <one-to-many class=\"Child\"/>\n"
"</set>]]>"
msgstr ""

#. Tag: para
#: example_parentchild.xml:126
#, no-c-format
msgid "The following code would be used to add a new <literal>Child</literal>"
msgstr ""
"El siguiente código podría ser usado para añadir un nuevo <literal>Child</"
"literal>"

#. Tag: programlisting
#: example_parentchild.xml:130
#, no-c-format
msgid ""
"<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
"Child c = new Child();\n"
"c.setParent(p);\n"
"p.getChildren().add(c);\n"
"session.save(c);\n"
"session.flush();]]>"
msgstr ""

#. Tag: para
#: example_parentchild.xml:132
#, no-c-format
msgid "And now, only one SQL <literal>INSERT</literal> would be issued!"
msgstr "Y ahora, ¡Sólo se publicaría un <literal>INSERT</literal> de SQL!"

#. Tag: para
#: example_parentchild.xml:136
#, no-c-format
msgid ""
"To tighten things up a bit, we could create an <literal>addChild()</literal> "
"method of <literal>Parent</literal>."
msgstr ""
"Para ajustar un poco más las cosas, podríamos crear un método "
"<literal>addChild()</literal> en <literal>Parent</literal>."

#. Tag: programlisting
#: example_parentchild.xml:141
#, no-c-format
msgid ""
"<![CDATA[public void addChild(Child c) {\n"
"    c.setParent(this);\n"
"    children.add(c);\n"
"}]]>"
msgstr ""

#. Tag: para
#: example_parentchild.xml:143
#, no-c-format
msgid "Now, the code to add a <literal>Child</literal> looks like"
msgstr "Ahora, el código para añadir un <literal>Child</literal> se ve así"

#. Tag: programlisting
#: example_parentchild.xml:147
#, no-c-format
msgid ""
"<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
"Child c = new Child();\n"
"p.addChild(c);\n"
"session.save(c);\n"
"session.flush();]]>"
msgstr ""

#. Tag: title
#: example_parentchild.xml:152
#, no-c-format
msgid "Cascading life cycle"
msgstr "Ciclo de vida en cascada"

#. Tag: para
#: example_parentchild.xml:154
#, no-c-format
msgid ""
"The explicit call to <literal>save()</literal> is still annoying. We will "
"address this by using cascades."
msgstr ""
"La llamada explícita a <literal>save()</literal> es aún molesta. Apuntaremos "
"a esto usando tratamientos en cascada."

#. Tag: programlisting
#: example_parentchild.xml:159
#, no-c-format
msgid ""
"<![CDATA[<set name=\"children\" inverse=\"true\" cascade=\"all\">\n"
"    <key column=\"parent_id\"/>\n"
"    <one-to-many class=\"Child\"/>\n"
"</set>]]>"
msgstr ""

#. Tag: para
#: example_parentchild.xml:161
#, no-c-format
msgid "This simplifies the code above to"
msgstr "Esto simplifica el código anterior a"

#. Tag: programlisting
#: example_parentchild.xml:165
#, no-c-format
msgid ""
"<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
"Child c = new Child();\n"
"p.addChild(c);\n"
"session.flush();]]>"
msgstr ""

#. Tag: para
#: example_parentchild.xml:167
#, no-c-format
msgid ""
"Similarly, we don't need to iterate over the children when saving or "
"deleting a <literal>Parent</literal>. The following removes <literal>p</"
"literal> and all its children from the database."
msgstr ""
"Similarmente, no necesitamos iterar los hijos al salvar o borrar un "
"<literal>Parent</literal>. Lo siguiente quita <literal>p</literal> y todos "
"sus hijos de la base de datos."

#. Tag: programlisting
#: example_parentchild.xml:172
#, no-c-format
msgid ""
"<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
"session.delete(p);\n"
"session.flush();]]>"
msgstr ""

#. Tag: para
#: example_parentchild.xml:174
#, no-c-format
msgid "However, this code"
msgstr "Sin embargo, este código"

#. Tag: programlisting
#: example_parentchild.xml:178
#, no-c-format
msgid ""
"<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
"Child c = (Child) p.getChildren().iterator().next();\n"
"p.getChildren().remove(c);\n"
"c.setParent(null);\n"
"session.flush();]]>"
msgstr ""

#. Tag: para
#: example_parentchild.xml:180
#, no-c-format
msgid ""
"will not remove <literal>c</literal> from the database; it will ony remove "
"the link to <literal>p</literal> (and cause a <literal>NOT NULL</literal> "
"constraint violation, in this case). You need to explicitly <literal>delete()"
"</literal> the <literal>Child</literal>."
msgstr ""
"no quitará <literal>c</literal> de la base de datos; sólo quitará el enlace "
"a <literal>p</literal> (y causará una violación a una restricción "
"<literal>NOT NULL</literal>). Necesitas borrar el hijo explícitamente "
"llamando a <literal>delete()</literal>."

#. Tag: programlisting
#: example_parentchild.xml:186
#, no-c-format
msgid ""
"<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
"Child c = (Child) p.getChildren().iterator().next();\n"
"p.getChildren().remove(c);\n"
"session.delete(c);\n"
"session.flush();]]>"
msgstr ""

#. Tag: para
#: example_parentchild.xml:188
#, no-c-format
msgid ""
"Now, in our case, a <literal>Child</literal> can't really exist without its "
"parent. So if we remove a <literal>Child</literal> from the collection, we "
"really do want it to be deleted. For this, we must use <literal>cascade="
"\"all-delete-orphan\"</literal>."
msgstr ""
"Ahora, en nuestro caso, un <literal>Child</literal> no puede existir "
"realmente sin su padre. De modo que si quitamos un <literal>Child</literal> "
"de la colección, realmente queremos que sea borrado. Para esto, debemos usar "
"<literal>cascade=\"all-delete-orphan\"</literal>."

#. Tag: programlisting
#: example_parentchild.xml:194
#, no-c-format
msgid ""
"<![CDATA[<set name=\"children\" inverse=\"true\" cascade=\"all-delete-orphan"
"\">\n"
"    <key column=\"parent_id\"/>\n"
"    <one-to-many class=\"Child\"/>\n"
"</set>]]>"
msgstr ""

#. Tag: para
#: example_parentchild.xml:196
#, no-c-format
msgid ""
"Note: even though the collection mapping specifies <literal>inverse=\"true"
"\"</literal>, cascades are still processed by iterating the collection "
"elements. So if you require that an object be saved, deleted or updated by "
"cascade, you must add it to the collection. It is not enough to simply call "
"<literal>setParent()</literal>."
msgstr ""
"Nota: aunque el mapeo de la colección especifique <literal>inverse=\"true\"</"
"literal>, el tratamiento en cascada se procesa aún al iterar los elementos "
"de colección. De modo que si requieres que un objeto sea salvado, borrado o "
"actualizado en cascada, debes añadirlo a la colección. No es suficiente con "
"simplemente llamar a <literal>setParent()</literal>."

#. Tag: title
#: example_parentchild.xml:206
#, no-c-format
msgid "Cascades and <literal>unsaved-value</literal>"
msgstr "Tratamiento en cascada y <literal>unsaved-value</literal>"

#. Tag: para
#: example_parentchild.xml:208
#, no-c-format
msgid ""
"Suppose we loaded up a <literal>Parent</literal> in one <literal>Session</"
"literal>, made some changes in a UI action and wish to persist these changes "
"in a new session by calling <literal>update()</literal>. The "
"<literal>Parent</literal> will contain a collection of childen and, since "
"cascading update is enabled, Hibernate needs to know which children are "
"newly instantiated and which represent existing rows in the database. Lets "
"assume that both <literal>Parent</literal> and <literal>Child</literal> have "
"genenerated identifier properties of type <literal>Long</literal>. Hibernate "
"will use the identifier and version/timestamp property value to determine "
"which of the children are new. (See <xref linkend=\"objectstate-saveorupdate"
"\"/>.) <emphasis>In Hibernate3, it is no longer necessary to specify an "
"<literal>unsaved-value</literal> explicitly.</emphasis>"
msgstr ""
"Supón que hemos cargado un <literal>Parent</literal> en una "
"<literal>Session</literal>, hemos hecho algunos cambios en una acción de UI "
"y deseamos hacer persistentes estos cambios en una nueva sesión llamando a "
"<literal>update()</literal>. El <literal>Parent</literal> contendrá una "
"colección de hijos y, ya que está habilitado el tratamiento en cascada, "
"Hibernate necesita saber qué hijos están recién instanciados y cuáles "
"representan filas existentes en la base de datos. Asumamos que tanto "
"<literal>Parent</literal> como <literal>Child</literal> tienen propiedades "
"identificadoras generadas de tipo <literal>Long</literal>. Hibernate usará "
"el identificador y el valor de la propiedad de versión/timestamp para "
"determinar cuáles de los hijos son nuevos. (Ver <xref linkend=\"objectstate-"
"saveorupdate\"/>.) <emphasis>En Hibernate3, no es más necesario especificar "
"un <literal>unsaved-value</literal> explícitamente.</emphasis>"

#. Tag: para
#: example_parentchild.xml:220
#, no-c-format
msgid ""
"The following code will update <literal>parent</literal> and <literal>child</"
"literal> and insert <literal>newChild</literal>."
msgstr ""
"The following code will update <literal>parent</literal> and <literal>child</"
"literal> and insert <literal>newChild</literal>."

#. Tag: programlisting
#: example_parentchild.xml:225
#, no-c-format
msgid ""
"<![CDATA[//parent and child were both loaded in a previous session\n"
"parent.addChild(child);\n"
"Child newChild = new Child();\n"
"parent.addChild(newChild);\n"
"session.update(parent);\n"
"session.flush();]]>"
msgstr ""

#. Tag: para
#: example_parentchild.xml:227
#, no-c-format
msgid ""
"Well, that's all very well for the case of a generated identifier, but what "
"about assigned identifiers and composite identifiers? This is more "
"difficult, since Hibernate can't use the identifier property to distinguish "
"between a newly instantiated object (with an identifier assigned by the "
"user) and an object loaded in a previous session. In this case, Hibernate "
"will either use the timestamp or version property, or will actually query "
"the second-level cache or, worst case, the database, to see if the row "
"exists."
msgstr ""
"Bueno, todo eso está muy bien para el caso de un identificador generado, "
"pero ¿qué de los identificadores asignados y de los identificadores "
"compuestos? Esto es más difícil, ya que Hibernate no puede usar la propiedad "
"identificadora para distinguir entre un objeto recién instanciado (con un "
"identificador asignado por el usuario) y un objeto cargado en una sesión "
"previa. En este caso, Hibernate bien usará la propiedad de versión o "
"timestamp, o bien consultará realmente el caché de segundo nivel, o bien, en "
"el peor de los casos, la base de datos, para ver si existe la fila."

#. Tag: title
#: example_parentchild.xml:260
#, no-c-format
msgid "Conclusion"
msgstr "Conclusión"

#. Tag: para
#: example_parentchild.xml:262
#, no-c-format
msgid ""
"There is quite a bit to digest here and it might look confusing first time "
"around. However, in practice, it all works out very nicely. Most Hibernate "
"applications use the parent / child pattern in many places."
msgstr ""
"Hay que resumir un poco aquí y podría parecer confuso a la primera vez. Sin "
"embargo, en la práctica, todo funciona muy agradablemente. La mayoría de las "
"aplicaciones de Hibernate usan el patrón padre / hijo en muchos sitios."

#. Tag: para
#: example_parentchild.xml:267
#, no-c-format
msgid ""
"We mentioned an alternative in the first paragraph. None of the above issues "
"exist in the case of <literal>&lt;composite-element&gt;</literal> mappings, "
"which have exactly the semantics of a parent / child relationship. "
"Unfortunately, there are two big limitations to composite element classes: "
"composite elements may not own collections, and they should not be the child "
"of any entity other than the unique parent."
msgstr ""
"Hemos mencionado una alternativa en el primer párrafo. Ninguno de los temas "
"anteriores existe en el caso de los mapeos <literal>&lt;composite-element&gt;"
"</literal>, que tienen exactamente la semántica de una relación padre / "
"hijo. Desafortunadamente, hay dos grandes limitaciones para las clases de "
"elementos compuestos: los elementos compuestos no pueden poseer sus propias "
"colecciones, y no deben ser el hijo de cualquier otra entidad que no sea su "
"padre único."
