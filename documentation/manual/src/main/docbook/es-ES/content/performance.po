msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2007-10-25 07:47+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: performance.xml:5
#, no-c-format
msgid "Improving performance"
msgstr "Mejorando el rendimiento"

#. Tag: title
#: performance.xml:8
#, no-c-format
msgid "Fetching strategies"
msgstr "Estrategias de recuperación"

#. Tag: para
#: performance.xml:10
#, no-c-format
msgid ""
"A <emphasis>fetching strategy</emphasis> is the strategy Hibernate will use "
"for retrieving associated objects if the application needs to navigate the "
"association. Fetch strategies may be declared in the O/R mapping metadata, "
"or over-ridden by a particular HQL or <literal>Criteria</literal> query."
msgstr ""
"Una <emphasis>estrategia de recuperación</emphasis> es la estrategia que "
"usará Hibernate para recuperar los objetos asociados cuando la aplicación "
"necesite navegar la asociación. Las estrategias de recuperación pueden ser "
"declaradas en los metadatos de mapeo O/R, o sobrescritas por una consulta "
"HQL o <literal>Criteria</literal> en particular."

#. Tag: para
#: performance.xml:17
#, no-c-format
msgid "Hibernate3 defines the following fetching strategies:"
msgstr "Hibernate3 define las siguientes estrategias de recuperación:"

#. Tag: para
#: performance.xml:23
#, no-c-format
msgid ""
"<emphasis>Join fetching</emphasis> - Hibernate retrieves the associated "
"instance or collection in the same <literal>SELECT</literal>, using an "
"<literal>OUTER JOIN</literal>."
msgstr ""
"<emphasis>Recuperación por unión (join fetching)</emphasis> - Hibernate "
"recupera la instancia asociada o colección en la misma <literal>SELECT</"
"literal>, usando una <literal>OUTER JOIN</literal>."

#. Tag: para
#: performance.xml:30
#, no-c-format
msgid ""
"<emphasis>Select fetching</emphasis> - a second <literal>SELECT</literal> is "
"used to retrieve the associated entity or collection. Unless you explicitly "
"disable lazy fetching by specifying <literal>lazy=\"false\"</literal>, this "
"second select will only be executed when you actually access the association."
msgstr ""
"<emphasis>Recuperación por selección (select fetching)</emphasis> - se usa "
"una segunda <literal>SELECT</literal> para recuperar la entidad asociada o "
"colección. A menos que deshabilites explícitamente la recuperación perezosa "
"especificando <literal>lazy=\"false\"</literal>, la segunda selección sólo "
"será ejecutada cuando realmente accedas a la asociación."

#. Tag: para
#: performance.xml:39
#, no-c-format
msgid ""
"<emphasis>Subselect fetching</emphasis> - a second <literal>SELECT</literal> "
"is used to retrieve the associated collections for all entities retrieved in "
"a previous query or fetch. Unless you explicitly disable lazy fetching by "
"specifying <literal>lazy=\"false\"</literal>, this second select will only "
"be executed when you actually access the association."
msgstr ""
"<emphasis>Recuperación por subselección (subselect fetching)</emphasis> - se "
"usa una segunda <literal>SELECT</literal> para recuperar las colecciones "
"asociadas de todas las entidades recuperadas en una consulta o recuperación "
"previa. A menos que deshabilites explícitamente la recuperación perezosa "
"especificando <literal>lazy=\"false\"</literal>, esta segunda selección sólo "
"será ejecutada cuando realmente accedas a la asociación."

#. Tag: para
#: performance.xml:48
#, no-c-format
msgid ""
"<emphasis>Batch fetching</emphasis> - an optimization strategy for select "
"fetching - Hibernate retrieves a batch of entity instances or collections in "
"a single <literal>SELECT</literal>, by specifying a list of primary keys or "
"foreign keys."
msgstr ""
"<emphasis>Recuperación en lote</emphasis> - una estrategia de optimización "
"para la recuperación por selección - Hibernate recupera un lote de "
"instancias de entidad o colecciones en una sola <literal>SELECT</literal>, "
"especificando una lista de claves primarias o de claves foráneas."

#. Tag: para
#: performance.xml:57
#, no-c-format
msgid "Hibernate also distinguishes between:"
msgstr "Hibernate también distingue entre:"

#. Tag: para
#: performance.xml:63
#, no-c-format
msgid ""
"<emphasis>Immediate fetching</emphasis> - an association, collection or "
"attribute is fetched immediately, when the owner is loaded."
msgstr ""
"<emphasis>Recuperación inmediata</emphasis> - una asociación, colección o "
"atributo es recuperado inmediatamente, cuando el dueño es cargado."

#. Tag: para
#: performance.xml:69
#, no-c-format
msgid ""
"<emphasis>Lazy collection fetching</emphasis> - a collection is fetched when "
"the application invokes an operation upon that collection. (This is the "
"default for collections.)"
msgstr ""
"<emphasis>Recuperación perezosa de colecciones</emphasis> - se recupera una "
"colección cuando la aplicación invoca una operación sobre la colección. "
"(Esto es por defecto para las colecciones.)"

#. Tag: para
#: performance.xml:76
#, no-c-format
msgid ""
"<emphasis>\"Extra-lazy\" collection fetching</emphasis> - individual "
"elements of the collection are accessed from the database as needed. "
"Hibernate tries not to fetch the whole collection into memory unless "
"absolutely needed (suitable for very large collections)"
msgstr ""
"<emphasis>\"Extra-lazy\" collection fetching</emphasis> - individual "
"elements of the collection are accessed from the database as needed. "
"Hibernate tries not to fetch the whole collection into memory unless "
"absolutely needed (suitable for very large collections)"

#. Tag: para
#: performance.xml:84
#, no-c-format
msgid ""
"<emphasis>Proxy fetching</emphasis> - a single-valued association is fetched "
"when a method other than the identifier getter is invoked upon the "
"associated object."
msgstr ""
"<emphasis>Proxy fetching</emphasis> - a single-valued association is fetched "
"when a method other than the identifier getter is invoked upon the "
"associated object."

#. Tag: para
#: performance.xml:91
#, no-c-format
msgid ""
"<emphasis>\"No-proxy\" fetching</emphasis> - a single-valued association is "
"fetched when the instance variable is accessed. Compared to proxy fetching, "
"this approach is less lazy (the association is fetched even when only the "
"identifier is accessed) but more transparent, since no proxy is visible to "
"the application. This approach requires buildtime bytecode instrumentation "
"and is rarely necessary."
msgstr ""
"<emphasis>Recuperación por proxy</emphasis> - se recupera una asociación "
"monovaluada cuando se invoca un método que no sea el getter del "
"identificador sobre el objeto asociado."

#. Tag: para
#: performance.xml:101
#, no-c-format
msgid ""
"<emphasis>Lazy attribute fetching</emphasis> - an attribute or single valued "
"association is fetched when the instance variable is accessed. This approach "
"requires buildtime bytecode instrumentation and is rarely necessary."
msgstr ""
"<emphasis>Recuperación perezosa de atributos</emphasis> - se recupera un "
"atributo o una asociación monovaluada cuando se accede a la variable de "
"instancia (requiere instrumentación del bytecode en tiempo de ejecución). "
"Este enfoque es raramente necesario."

#. Tag: para
#: performance.xml:110
#, no-c-format
msgid ""
"We have two orthogonal notions here: <emphasis>when</emphasis> is the "
"association fetched, and <emphasis>how</emphasis> is it fetched (what SQL is "
"used). Don't confuse them! We use <literal>fetch</literal> to tune "
"performance. We may use <literal>lazy</literal> to define a contract for "
"what data is always available in any detached instance of a particular class."
msgstr ""
"Aquí tenemos dos nociones ortogonales: <emphasis>cuándo</emphasis> se "
"recupera la aplicación, y <emphasis>cómo</emphasis> es recuperada (qué SQL "
"es usado). ¡No las confundas! Usamos <literal>fetch</literal> para afinar el "
"rendimiento. Podemos usar <literal>lazy</literal> para definir un contrato "
"sobre qué datos están siempre disponibles en cualquier instancia separada de "
"una clase en particular."

#. Tag: title
#: performance.xml:119
#, no-c-format
msgid "Working with lazy associations"
msgstr "Trabajando con asociaciones perezosas"

#. Tag: para
#: performance.xml:121
#, no-c-format
msgid ""
"By default, Hibernate3 uses lazy select fetching for collections and lazy "
"proxy fetching for single-valued associations. These defaults make sense for "
"almost all associations in almost all applications."
msgstr ""
"Por defecto, Hibernate3 usa una recuperación perezosa por selección para "
"colecciones y una recuperación por proxy perezosa para asociaciones "
"monovaluadas. Estas políticas por defecto tienen sentido para casi todas las "
"asociaciones en casi todas las aplicaciones."

#. Tag: para
#: performance.xml:127
#, no-c-format
msgid ""
"<emphasis>Note:</emphasis> if you set <literal>hibernate."
"default_batch_fetch_size</literal>, Hibernate will use the batch fetch "
"optimization for lazy fetching (this optimization may also be enabled at a "
"more granular level)."
msgstr ""
"<emphasis>Nota:</emphasis> si estableces <literal>hibernate."
"default_batch_fetch_size</literal>, Hibernate usará la optimización de "
"recuperación en lotes para recuperación perezosa (esta optimización también "
"puede ser habilitada a un nivel más granularizado)."

#. Tag: para
#: performance.xml:134
#, no-c-format
msgid ""
"However, lazy fetching poses one problem that you must be aware of. Access "
"to a lazy association outside of the context of an open Hibernate session "
"will result in an exception. For example:"
msgstr ""
"Sin embargo, la recuperación perezosa plantea un problema del que tienes que "
"estar al tanto. Acceder a una asociación perezosa fuera del contexto de una "
"sesión de Hibernate abierta resultará en una excepción. Por ejemplo:"

#. Tag: programlisting
#: performance.xml:140
#, no-c-format
msgid ""
"<![CDATA[s = sessions.openSession();\n"
"Transaction tx = s.beginTransaction();\n"
"            \n"
"User u = (User) s.createQuery(\"from User u where u.name=:userName\")\n"
"    .setString(\"userName\", userName).uniqueResult();\n"
"Map permissions = u.getPermissions();\n"
"\n"
"tx.commit();\n"
"s.close();\n"
"\n"
"Integer accessLevel = (Integer) permissions.get(\"accounts\");  // Error!]]>"
msgstr ""

#. Tag: para
#: performance.xml:142
#, no-c-format
msgid ""
"Since the permissions collection was not initialized when the "
"<literal>Session</literal> was closed, the collection will not be able to "
"load its state. <emphasis>Hibernate does not support lazy initialization for "
"detached objects</emphasis>. The fix is to move the code that reads from the "
"collection to just before the transaction is committed."
msgstr ""
"Ya que la colección de permisos no fue inicializada cuando se cerró la "
"<literal>Session</literal>, la colección no será capaz de cargar su estado. "
"<emphasis>Hibernate no soporta la inicialización perezosa de objetos "
"separados</emphasis>. La solución es mover el código que lee de la colección "
"a justo antes que la transacción sea comprometida."

#. Tag: para
#: performance.xml:150
#, no-c-format
msgid ""
"Alternatively, we could use a non-lazy collection or association, by "
"specifying <literal>lazy=\"false\"</literal> for the association mapping. "
"However, it is intended that lazy initialization be used for almost all "
"collections and associations. If you define too many non-lazy associations "
"in your object model, Hibernate will end up needing to fetch the entire "
"database into memory in every transaction!"
msgstr ""
"Alternativamente, podríamos usar una colección no perezosa o asociación, "
"especificando <literal>lazy=\"false\"</literal> para el mapeo de asociación. "
"Sin embargo, está pensado que la inicialización perezosa sea usada para casi "
"todas las colecciones y asociaciones. ¡Si defines demasiadas asociaciones no "
"perezosas en tu modelo de objetos, Hibernate terminará necesitando recuperar "
"la base de datos entera en cada transacción!"

#. Tag: para
#: performance.xml:159
#, no-c-format
msgid ""
"On the other hand, we often want to choose join fetching (which is non-lazy "
"by nature) instead of select fetching in a particular transaction. We'll now "
"see how to customize the fetching strategy. In Hibernate3, the mechanisms "
"for choosing a fetch strategy are identical for single-valued associations "
"and collections."
msgstr ""
"Por otro lado, frecuentemente necesitamos elegir la recuperación por unión "
"(que es no perezosa por naturaleza) en vez de la recuperación por selección "
"en una transacción en particular. Veremos ahora cómo personalizar la "
"estrategia de recuperación. En Hibernate3, los mecanismos para elegir una "
"estrategia de recuperación son idénticas a las de las asociaciones "
"monovaluadas y colecciones."

#. Tag: title
#: performance.xml:170
#, no-c-format
msgid "Tuning fetch strategies"
msgstr "Afinando las estrategias de recuperación"

#. Tag: para
#: performance.xml:172
#, no-c-format
msgid ""
"Select fetching (the default) is extremely vulnerable to N+1 selects "
"problems, so we might want to enable join fetching in the mapping document:"
msgstr ""
"La recuperación por selección (la preestablecida) es extremadamente "
"vulnerable a problemas de selección N+1, de modo querríamos habilitar la "
"recuperación por unión (join fetching) en el documento de mapeo:"

#. Tag: programlisting
#: performance.xml:177
#, no-c-format
msgid ""
"<![CDATA[<set name=\"permissions\" \n"
"            fetch=\"join\">\n"
"    <key column=\"userId\"/>\n"
"    <one-to-many class=\"Permission\"/>\n"
"</set]]>"
msgstr ""

#. Tag: programlisting
#: performance.xml:179
#, no-c-format
msgid "<![CDATA[<many-to-one name=\"mother\" class=\"Cat\" fetch=\"join\"/>]]>"
msgstr ""

#. Tag: para
#: performance.xml:181
#, no-c-format
msgid ""
"The <literal>fetch</literal> strategy defined in the mapping document "
"affects:"
msgstr ""
"La estrategia de recuperación definida en el documento de mapeo afecta a:"

#. Tag: para
#: performance.xml:187
#, no-c-format
msgid "retrieval via <literal>get()</literal> or <literal>load()</literal>"
msgstr ""
"las recuperaciones vía <literal>get()</literal> o <literal>load()</literal>"

#. Tag: para
#: performance.xml:192
#, no-c-format
msgid "retrieval that happens implicitly when an association is navigated"
msgstr ""
"las recuperaciones que ocurren implícitamente cuando se navega una "
"asociación (recuperación perezosa)"

#. Tag: para
#: performance.xml:197
#, no-c-format
msgid "<literal>Criteria</literal> queries"
msgstr "las consultas de <literal>Criteria</literal>"

#. Tag: para
#: performance.xml:202
#, no-c-format
msgid "HQL queries if <literal>subselect</literal> fetching is used"
msgstr "HQL queries if <literal>subselect</literal> fetching is used"

#. Tag: para
#: performance.xml:208
#, no-c-format
msgid ""
"No matter what fetching strategy you use, the defined non-lazy graph is "
"guaranteed to be loaded into memory. Note that this might result in several "
"immediate selects being used to execute a particular HQL query."
msgstr ""
"No matter what fetching strategy you use, the defined non-lazy graph is "
"guaranteed to be loaded into memory. Note that this might result in several "
"immediate selects being used to execute a particular HQL query."

#. Tag: para
#: performance.xml:214
#, no-c-format
msgid ""
"Usually, we don't use the mapping document to customize fetching. Instead, "
"we keep the default behavior, and override it for a particular transaction, "
"using <literal>left join fetch</literal> in HQL. This tells Hibernate to "
"fetch the association eagerly in the first select, using an outer join. In "
"the <literal>Criteria</literal> query API, you would use "
"<literal>setFetchMode(FetchMode.JOIN)</literal>."
msgstr ""
"Usualmente, no usamos el documento de mapeo para personalizar la "
"recuperación. En cambio, mantenemos el comportamiento por defecto, y lo "
"sobrescribimos para una transacción en particular, usando <literal>left join "
"fetch</literal> en HQL. Esto le dice a Hibernate que recupere la asociación "
"tempranamente en la primera selección, usando una unión externa. En la API "
"de consulta de <literal>Criteria</literal>, usarías <literal>setFetchMode"
"(FetchMode.JOIN)</literal>."

#. Tag: para
#: performance.xml:223
#, no-c-format
msgid ""
"If you ever feel like you wish you could change the fetching strategy used "
"by <literal>get()</literal> or <literal>load()</literal>, simply use a "
"<literal>Criteria</literal> query, for example:"
msgstr ""
"Si acaso lo deseases, podrías cambiar la estrategia de recuperación usada "
"por <literal>get()</literal> or <literal>load()</literal>; simplemente usa "
"una consulta <literal>Criteria</literal>, por ejemplo:"

#. Tag: programlisting
#: performance.xml:229
#, no-c-format
msgid ""
"<![CDATA[User user = (User) session.createCriteria(User.class)\n"
"                .setFetchMode(\"permissions\", FetchMode.JOIN)\n"
"                .add( Restrictions.idEq(userId) )\n"
"                .uniqueResult();]]>"
msgstr ""

#. Tag: para
#: performance.xml:231
#, no-c-format
msgid ""
"(This is Hibernate's equivalent of what some ORM solutions call a \"fetch "
"plan\".)"
msgstr ""
"(Esto es el equivalente de Hibernate de lo que otras soluciones ORM llaman "
"un \"plan de recuperación\".)"

#. Tag: para
#: performance.xml:235
#, no-c-format
msgid ""
"A completely different way to avoid problems with N+1 selects is to use the "
"second-level cache."
msgstr ""
"Una forma completamente diferente de evitar problemas con selecciones N+1 es "
"usar el caché de segundo nivel."

#. Tag: title
#: performance.xml:243
#, no-c-format
msgid "Single-ended association proxies"
msgstr "Proxies de asociaciones de un solo extremo"

#. Tag: para
#: performance.xml:245
#, no-c-format
msgid ""
"Lazy fetching for collections is implemented using Hibernate's own "
"implementation of persistent collections. However, a different mechanism is "
"needed for lazy behavior in single-ended associations. The target entity of "
"the association must be proxied. Hibernate implements lazy initializing "
"proxies for persistent objects using runtime bytecode enhancement (via the "
"excellent CGLIB library)."
msgstr ""
"La recuperación perezosa de colecciones está implementada usando la "
"implementación de colecciones persistentes propia de Hibernate. Sin embargo, "
"se necesita un mecanismo diferente para un comportamiento perezoso en las "
"asociaciones de un solo extremo. La entidad objetivo de la asociación debe "
"ser tratada con proxies. Hibernate implementa proxies de inicialización "
"perezosa para objetos persistentes usando mejora del bytecode en tiempo de "
"ejecución (por medio de la excelente biblioteca CGLIB)."

#. Tag: para
#: performance.xml:253
#, no-c-format
msgid ""
"By default, Hibernate3 generates proxies (at startup) for all persistent "
"classes and uses them to enable lazy fetching of <literal>many-to-one</"
"literal> and <literal>one-to-one</literal> associations."
msgstr ""
"Por defecto, Hibernate3 genera proxies (en el arranque) para todas las "
"clases persistentes y los usa para habilitar la recuperación perezosa de "
"asociaciones <literal>muchos-a-uno</literal> y <literal>uno-a-uno</literal>."

#. Tag: para
#: performance.xml:259
#, no-c-format
msgid ""
"The mapping file may declare an interface to use as the proxy interface for "
"that class, with the <literal>proxy</literal> attribute. By default, "
"Hibernate uses a subclass of the class. <emphasis>Note that the proxied "
"class must implement a default constructor with at least package visibility. "
"We recommend this constructor for all persistent classes!</emphasis>"
msgstr ""
"El fichero de mapeo puede declarar una interface a usar como interface de "
"proxy para esa clase, con el atributo <literal>proxy</literal>. Por defecto, "
"Hibernate usa una subclase de la clase. <emphasis>Nota que la clase tratada "
"con proxies debe implementar un constructor por defecto con al menos "
"visibilidad de paquete. ¡Recomendamos este constructor para todas las clases "
"persistentes!</emphasis>"

#. Tag: para
#: performance.xml:266
#, no-c-format
msgid ""
"There are some gotchas to be aware of when extending this approach to "
"polymorphic classes, eg."
msgstr ""
"Hay algunos puntos a tener en cuenta al extender este enfoque a clases "
"polimórficas, por ejemplo."

#. Tag: programlisting
#: performance.xml:271
#, no-c-format
msgid ""
"<![CDATA[<class name=\"Cat\" proxy=\"Cat\">\n"
"    ......\n"
"    <subclass name=\"DomesticCat\">\n"
"        .....\n"
"    </subclass>\n"
"</class>]]>"
msgstr ""

#. Tag: para
#: performance.xml:273
#, no-c-format
msgid ""
"Firstly, instances of <literal>Cat</literal> will never be castable to "
"<literal>DomesticCat</literal>, even if the underlying instance is an "
"instance of <literal>DomesticCat</literal>:"
msgstr ""
"Primero, las instancias de <literal>Cat</literal> nunca serán objeto de un "
"cast a <literal>DomesticCat</literal>, incluso aunque la instancia "
"subyacente sea instancia de <literal>DomesticCat</literal>:"

#. Tag: programlisting
#: performance.xml:279
#, no-c-format
msgid ""
"<![CDATA[Cat cat = (Cat) session.load(Cat.class, id);  // instantiate a "
"proxy (does not hit the db)\n"
"if ( cat.isDomesticCat() ) {                  // hit the db to initialize "
"the proxy\n"
"    DomesticCat dc = (DomesticCat) cat;       // Error!\n"
"    ....\n"
"}]]>"
msgstr ""

#. Tag: para
#: performance.xml:281
#, no-c-format
msgid "Secondly, it is possible to break proxy <literal>==</literal>."
msgstr ""
"Segundo, es posible romper con el operador <literal>==</literal> de un proxy."

#. Tag: programlisting
#: performance.xml:285
#, no-c-format
msgid ""
"<![CDATA[Cat cat = (Cat) session.load(Cat.class, id);            // "
"instantiate a Cat proxy\n"
"DomesticCat dc = \n"
"        (DomesticCat) session.load(DomesticCat.class, id);  // acquire new "
"DomesticCat proxy!\n"
"System.out.println(cat==dc);                            // false]]>"
msgstr ""

#. Tag: para
#: performance.xml:287
#, no-c-format
msgid ""
"However, the situation is not quite as bad as it looks. Even though we now "
"have two references to different proxy objects, the underlying instance will "
"still be the same object:"
msgstr ""
"Sin embargo, la situación no en absoluta tan mala como parece. Aunque "
"tenemos ahora dos referencias a objetos proxy diferentes, la instancia "
"subyacente será aún el mismo objeto:"

#. Tag: programlisting
#: performance.xml:292
#, no-c-format
msgid ""
"<![CDATA[cat.setWeight(11.0);  // hit the db to initialize the proxy\n"
"System.out.println( dc.getWeight() );  // 11.0]]>"
msgstr ""

#. Tag: para
#: performance.xml:294
#, no-c-format
msgid ""
"Third, you may not use a CGLIB proxy for a <literal>final</literal> class or "
"a class with any <literal>final</literal> methods."
msgstr ""
"Tercero, no debes usar un proxy CGLIB para una clase <literal>final</"
"literal> o una clase con algún método <literal>final</literal>."

#. Tag: para
#: performance.xml:299
#, no-c-format
msgid ""
"Finally, if your persistent object acquires any resources upon instantiation "
"(eg. in initializers or default constructor), then those resources will also "
"be acquired by the proxy. The proxy class is an actual subclass of the "
"persistent class."
msgstr ""
"Finalmente, si tu objeto persistente adquiere cualquier recurso bajo "
"instanciación (por ejemplo, en inicializadores o constructores por defecto), "
"entonces esos recursos serán adquiridos también por el proxy. La clase del "
"proxy es una subclase real de la clase persistente."

#. Tag: para
#: performance.xml:305
#, no-c-format
msgid ""
"These problems are all due to fundamental limitations in Java's single "
"inheritance model. If you wish to avoid these problems your persistent "
"classes must each implement an interface that declares its business methods. "
"You should specify these interfaces in the mapping file. eg."
msgstr ""
"Estos problemas se deben a limitaciones fundamentales en el modelo de "
"herencia única de Java. Si deseas evitar estos problemas cada una de tus "
"clases persistentes deben implementar una interface que declare sus métodos "
"de negocio. Debes especificar estas interfaces en el fichero de mapeo. Por "
"ejemplo:"

#. Tag: programlisting
#: performance.xml:311
#, no-c-format
msgid ""
"<![CDATA[<class name=\"CatImpl\" proxy=\"Cat\">\n"
"    ......\n"
"    <subclass name=\"DomesticCatImpl\" proxy=\"DomesticCat\">\n"
"        .....\n"
"    </subclass>\n"
"</class>]]>"
msgstr ""

#. Tag: para
#: performance.xml:313
#, no-c-format
msgid ""
"where <literal>CatImpl</literal> implements the interface <literal>Cat</"
"literal> and <literal>DomesticCatImpl</literal> implements the interface "
"<literal>DomesticCat</literal>. Then proxies for instances of <literal>Cat</"
"literal> and <literal>DomesticCat</literal> may be returned by <literal>load"
"()</literal> or <literal>iterate()</literal>. (Note that <literal>list()</"
"literal> does not usually return proxies.)"
msgstr ""
"donde <literal>CatImpl</literal> implementa la interface <literal>Cat</"
"literal> y <literal>DomesticCatImpl</literal> implementa la interface "
"<literal>DomesticCat</literal>. Entonces <literal>load()</literal> o "
"<literal>iterate()</literal> pueden devolver instancias de <literal>Cat</"
"literal> y <literal>DomesticCat</literal>. (Nota que <literal>list()</"
"literal> usualmente no devuelve proxies.)"

#. Tag: programlisting
#: performance.xml:321
#, no-c-format
msgid ""
"<![CDATA[Cat cat = (Cat) session.load(CatImpl.class, catid);\n"
"Iterator iter = session.createQuery(\"from CatImpl as cat where cat."
"name='fritz'\").iterate();\n"
"Cat fritz = (Cat) iter.next();]]>"
msgstr ""

#. Tag: para
#: performance.xml:323
#, no-c-format
msgid ""
"Relationships are also lazily initialized. This means you must declare any "
"properties to be of type <literal>Cat</literal>, not <literal>CatImpl</"
"literal>."
msgstr ""
"Las relaciones también son inicializadas perezosamente. Esto significa que "
"debes declarar cualquier propiedad como de tipo <literal>Cat</literal>, no "
"<literal>CatImpl</literal>."

#. Tag: para
#: performance.xml:328
#, no-c-format
msgid ""
"Certain operations do <emphasis>not</emphasis> require proxy initialization"
msgstr ""
"Ciertas operaciones <emphasis>no</emphasis> requieren inicialización de "
"proxies."

#. Tag: para
#: performance.xml:334
#, no-c-format
msgid ""
"<literal>equals()</literal>, if the persistent class does not override "
"<literal>equals()</literal>"
msgstr ""
"<literal>equals()</literal>, si la clase persistente no sobrescribe "
"<literal>equals()</literal>"

#. Tag: para
#: performance.xml:340
#, no-c-format
msgid ""
"<literal>hashCode()</literal>, if the persistent class does not override "
"<literal>hashCode()</literal>"
msgstr ""
"<literal>hashCode()</literal>, si la clase persistente no sobrescribe "
"<literal>hashCode()</literal>"

#. Tag: para
#: performance.xml:346
#, no-c-format
msgid "The identifier getter method"
msgstr "El método getter del identificador"

#. Tag: para
#: performance.xml:352
#, no-c-format
msgid ""
"Hibernate will detect persistent classes that override <literal>equals()</"
"literal> or <literal>hashCode()</literal>."
msgstr ""
"Hibernate detectará las clase persistentes que sobrescriban <literal>equals()"
"</literal> o <literal>hashCode()</literal>."

#. Tag: para
#: performance.xml:357
#, no-c-format
msgid ""
"By choosing <literal>lazy=\"no-proxy\"</literal> instead of the default "
"<literal>lazy=\"proxy\"</literal>, we can avoid the problems associated with "
"typecasting. However, we will require buildtime bytecode instrumentation, "
"and all operations will result in immediate proxy initialization."
msgstr ""
"UNTRANSLATED!!! By choosing <literal>lazy=\"no-proxy\"</literal> instead of "
"the default <literal>lazy=\"proxy\"</literal>, we can avoid the problems "
"associated with typecasting. However, we will require buildtime bytecode "
"instrumentation, and all operations will result in immediate proxy "
"initialization."

#. Tag: title
#: performance.xml:367
#, no-c-format
msgid "Initializing collections and proxies"
msgstr "Inicializando colecciones y proxies"

#. Tag: para
#: performance.xml:369
#, no-c-format
msgid ""
"A <literal>LazyInitializationException</literal> will be thrown by Hibernate "
"if an uninitialized collection or proxy is accessed outside of the scope of "
"the <literal>Session</literal>, ie. when the entity owning the collection or "
"having the reference to the proxy is in the detached state."
msgstr ""
"Una <literal>LazyInitializationException</literal> será lanzada por "
"Hibernate si una colección o proxy sin inicializar es accedido fuera del "
"ámbito de la <literal>Session</literal>, es decir, cuando la entidad que "
"posee la colección o que tiene la referencia al proxy esté en el estado "
"separada."

#. Tag: para
#: performance.xml:375
#, no-c-format
msgid ""
"Sometimes we need to ensure that a proxy or collection is initialized before "
"closing the <literal>Session</literal>. Of course, we can alway force "
"initialization by calling <literal>cat.getSex()</literal> or <literal>cat."
"getKittens().size()</literal>, for example. But that is confusing to readers "
"of the code and is not convenient for generic code."
msgstr ""
"A veces necesitamos asegurarnos que un proxy o colección esté inicializado "
"antes de cerrar la <literal>Session</literal>. Por supuesto, siempre podemos "
"forzar la inicialización llamando a <literal>cat.getSex()</literal> o "
"<literal>cat.getKittens().size()</literal>, por ejemplo. Pero esto es "
"confuso a lectores del código y no es conveniente para código genérico."

#. Tag: para
#: performance.xml:382
#, no-c-format
msgid ""
"The static methods <literal>Hibernate.initialize()</literal> and "
"<literal>Hibernate.isInitialized()</literal> provide the application with a "
"convenient way of working with lazily initialized collections or proxies. "
"<literal>Hibernate.initialize(cat)</literal> will force the initialization "
"of a proxy, <literal>cat</literal>, as long as its <literal>Session</"
"literal> is still open. <literal>Hibernate.initialize( cat.getKittens() )</"
"literal> has a similar effect for the collection of kittens."
msgstr ""
"Los métodos estáticos <literal>Hibernate.initialize()</literal> y "
"<literal>Hibernate.isInitialized()</literal> proveen a la aplicación de una "
"forma conveniente de trabajar con colecciones o proxies inicializados "
"perezosamente. <literal>Hibernate.initialize(cat)</literal> forzará la "
"inicialización de un proxy, <literal>cat</literal>, en tanto su "
"<literal>Session</literal> esté todavía abierta. <literal>Hibernate."
"initialize( cat.getKittens() )</literal> tiene un efecto similar para la "
"colección de gatitos."

#. Tag: para
#: performance.xml:391
#, no-c-format
msgid ""
"Another option is to keep the <literal>Session</literal> open until all "
"needed collections and proxies have been loaded. In some application "
"architectures, particularly where the code that accesses data using "
"Hibernate, and the code that uses it are in different application layers or "
"different physical processes, it can be a problem to ensure that the "
"<literal>Session</literal> is open when a collection is initialized. There "
"are two basic ways to deal with this issue:"
msgstr ""
"Otra opción es mantener la <literal>Session</literal> abierta hasta que "
"todas las colecciones y proxies necesarios hayan sido cargados. En algunas "
"arquitecturas de aplicación, particularmente en aquellas donde el código que "
"accede a los datos usando Hibernate, y el código que los usa están en capas "
"de aplicación diferentes o procesos físicos diferentes, puede ser un "
"problema asegurar que la <literal>Session</literal> esté abierta cuando se "
"inicializa una colección. Existen dos formas básicas de tratar este tema:"

#. Tag: para
#: performance.xml:402
#, no-c-format
msgid ""
"In a web-based application, a servlet filter can be used to close the "
"<literal>Session</literal> only at the very end of a user request, once the "
"rendering of the view is complete (the <emphasis>Open Session in View</"
"emphasis> pattern). Of course, this places heavy demands on the correctness "
"of the exception handling of your application infrastructure. It is vitally "
"important that the <literal>Session</literal> is closed and the transaction "
"ended before returning to the user, even when an exception occurs during "
"rendering of the view. See the Hibernate Wiki for examples of this \"Open "
"Session in View\" pattern."
msgstr ""
"En una aplicación basada web, puede usarse un filtro de servlets para cerrar "
"la <literal>Session</literal> sólo bien al final de una petición de usuario, "
"una vez que el rendering de la vista esté completa (el patrón "
"<emphasis>Sesión Abierta en Vista (Open Session in View)</emphasis>). Por "
"supuesto, estos sitios requieren una fuerte demanda de corrección del manejo "
"de excepciones de tu infraestructura de aplicación. Es de una importancia "
"vital que la <literal>Session</literal> esté cerrada y la transacción "
"terminada antes de volver al usuario, incluso cuando ocurra una excepción "
"durante el rendering de la página. Para este enfoque, el filtro de servlet "
"tiene que ser capaz de accceder la <literal>Session</literal>. Recomendamos "
"que se use una variable <literal>ThreadLocal</literal> para tener la "
"<literal>Session</literal> actual (ver el capítulo 1, <xref linkend="
"\"quickstart-playingwithcats\"/>, para una implementación de ejemplo)."

#. Tag: para
#: performance.xml:415
#, no-c-format
msgid ""
"In an application with a separate business tier, the business logic must "
"\"prepare\" all collections that will be needed by the web tier before "
"returning. This means that the business tier should load all the data and "
"return all the data already initialized to the presentation/web tier that is "
"required for a particular use case. Usually, the application calls "
"<literal>Hibernate.initialize()</literal> for each collection that will be "
"needed in the web tier (this call must occur before the session is closed) "
"or retrieves the collection eagerly using a Hibernate query with a "
"<literal>FETCH</literal> clause or a <literal>FetchMode.JOIN</literal> in "
"<literal>Criteria</literal>. This is usually easier if you adopt the "
"<emphasis>Command</emphasis> pattern instead of a <emphasis>Session Facade</"
"emphasis>."
msgstr ""
"En una aplciación con una grada de negocios separada, la lógica de negocio "
"debe \"preparar\" todas las colecciones que se vayan a necesitar por la "
"grada web antes de volver. Esto significa que la grada de negocios debe "
"cargar todos los datos y devolver a la grada de presentación web todos los "
"datos que se requieran para un caso de uso en particular ya inicializados. "
"Usualmente, la aplicación llama a <literal>Hibernate.initialize()</literal> "
"para cada colección que se necesitará en la grada web (esta llamada debe "
"ocurrir antes que la sesión sea cerrada) o recupera la colección "
"tempranamente usando una consulta de Hibernate con una cláusula "
"<literal>FETCH</literal> o una <literal>FetchMode.JOIN</literal> en "
"<literal>Criteria</literal>. Esto es usualmente más fácil si adoptas el "
"patrón <emphasis>Comando</emphasis> en vez de un <emphasis>Fachada de "
"Sesión</emphasis>."

#. Tag: para
#: performance.xml:430
#, no-c-format
msgid ""
"You may also attach a previously loaded object to a new <literal>Session</"
"literal> with <literal>merge()</literal> or <literal>lock()</literal> before "
"accessing uninitialized collections (or other proxies). No, Hibernate does "
"not, and certainly <emphasis>should</emphasis> not do this automatically, "
"since it would introduce ad hoc transaction semantics!"
msgstr ""
"Puedes también adjuntar un objeto cargado previamente a una nueva "
"<literal>Session</literal> con <literal>merge()</literal> o <literal>lock()</"
"literal> antes de acceder a colecciones no inicializadas (u otros proxies). "
"¡No, Hibernate no, y ciertamente <emphasis>no debe</emphasis> hacer esto "
"automáticamente, ya que introduciría semánticas de transacción ad hoc!"

#. Tag: para
#: performance.xml:440
#, no-c-format
msgid ""
"Sometimes you don't want to initialize a large collection, but still need "
"some information about it (like its size) or a subset of the data."
msgstr ""
"A veces no quieres inicializar una colección grande, pero necesitas aún "
"alguna informacion sobre ella (como su tamaño) o un subconjunto de los datos."

#. Tag: para
#: performance.xml:445
#, no-c-format
msgid ""
"You can use a collection filter to get the size of a collection without "
"initializing it:"
msgstr ""
"Puedes usar un filtro de colecciones para obtener el tamaño de una colección "
"sin inicializarla:"

#. Tag: programlisting
#: performance.xml:449
#, no-c-format
msgid ""
"<![CDATA[( (Integer) s.createFilter( collection, \"select count(*)\" ).list"
"().get(0) ).intValue()]]>"
msgstr ""

#. Tag: para
#: performance.xml:451
#, no-c-format
msgid ""
"The <literal>createFilter()</literal> method is also used to efficiently "
"retrieve subsets of a collection without needing to initialize the whole "
"collection:"
msgstr ""
"El método <literal>createFilter()</literal> se usa también para recuperar "
"eficientemente subconjuntos de una colección sin necesidad de inicializar "
"toda la colección:"

#. Tag: programlisting
#: performance.xml:456
#, no-c-format
msgid ""
"<![CDATA[s.createFilter( lazyCollection, \"\").setFirstResult(0)."
"setMaxResults(10).list();]]>"
msgstr ""

#. Tag: title
#: performance.xml:461
#, no-c-format
msgid "Using batch fetching"
msgstr "Usando recuperación en lotes"

#. Tag: para
#: performance.xml:463
#, no-c-format
msgid ""
"Hibernate can make efficient use of batch fetching, that is, Hibernate can "
"load several uninitialized proxies if one proxy is accessed (or collections. "
"Batch fetching is an optimization of the lazy select fetching strategy. "
"There are two ways you can tune batch fetching: on the class and the "
"collection level."
msgstr ""
"Hibernate puede hacer un uso eficiente de la recuperación en lotes, esto es, "
"Hibernate puede cargar muchos proxies sin inicializar si se accede a un "
"proxy (o colecciones). La recuperación en lotes es una optimización de la "
"estrategia de recuperación por selección perezosa. Hay dos formas en que "
"puedes afinar la recuperación en lotes: a nivel de la clase o de la "
"colección."

#. Tag: para
#: performance.xml:469
#, no-c-format
msgid ""
"Batch fetching for classes/entities is easier to understand. Imagine you "
"have the following situation at runtime: You have 25 <literal>Cat</literal> "
"instances loaded in a <literal>Session</literal>, each <literal>Cat</"
"literal> has a reference to its <literal>owner</literal>, a <literal>Person</"
"literal>. The <literal>Person</literal> class is mapped with a proxy, "
"<literal>lazy=\"true\"</literal>. If you now iterate through all cats and "
"call <literal>getOwner()</literal> on each, Hibernate will by default "
"execute 25 <literal>SELECT</literal> statements, to retrieve the proxied "
"owners. You can tune this behavior by specifying a <literal>batch-size</"
"literal> in the mapping of <literal>Person</literal>:"
msgstr ""
"La recuperación en lotes para clases/entidades es más fácil de entender. "
"Imagina que tienes la siguiente situación en tiempo de ejecución: Tienes 25 "
"instancias de <literal>Cat</literal> cargadas en una <literal>Session</"
"literal>, cada <literal>Cat</literal> tiene una referencia a su "
"<literal>owner</literal>, una <literal>Person</literal>. La clase "
"<literal>Person</literal> está mapeada con un proxy, <literal>lazy=\"true\"</"
"literal>. Si ahora iteras a través de todos los gatos y llamas a "
"<literal>getOwner()</literal> para cada uno, Hibernate por defecto ejecutará "
"25 sentencias <literal>SELECT</literal> para traer los dueños tratados con "
"proxies. Puedes afinar este comportamiento especificando un <literal>batch-"
"size</literal> en el mapeo de <literal>Person</literal>:"

#. Tag: programlisting
#: performance.xml:479
#, no-c-format
msgid "<![CDATA[<class name=\"Person\" batch-size=\"10\">...</class>]]>"
msgstr ""

#. Tag: para
#: performance.xml:481
#, no-c-format
msgid ""
"Hibernate will now execute only three queries, the pattern is 10, 10, 5."
msgstr "Hibernate ahora ejecutará sólo tres consultas, el patrón es 10, 10, 5."

#. Tag: para
#: performance.xml:485
#, no-c-format
msgid ""
"You may also enable batch fetching of collections. For example, if each "
"<literal>Person</literal> has a lazy collection of <literal>Cat</literal>s, "
"and 10 persons are currently loaded in the <literal>Sesssion</literal>, "
"iterating through all persons will generate 10 <literal>SELECT</literal>s, "
"one for every call to <literal>getCats()</literal>. If you enable batch "
"fetching for the <literal>cats</literal> collection in the mapping of "
"<literal>Person</literal>, Hibernate can pre-fetch collections:"
msgstr ""
"También puedes habilitar la recuperación en lotes para colecciones. Por "
"ejemplo, si cada <literal>Person</literal> tiene una colección perezosa de "
"<literal>Cat</literal>s, y hay 10 personas actualmente cargadas en la "
"<literal>Session</literal>, iterar a través de las 10 personas generará 10 "
"<literal>SELECT</literal>s, una para cada llamada a <literal>getCats()</"
"literal>. Si habilitas la recuperación en lotes para la colección de "
"<literal>cats</literal> en el mapeo de <literal>Person</literal>, Hibernate "
"puede recuperar por adelantado las colecciones:"

#. Tag: programlisting
#: performance.xml:494
#, no-c-format
msgid ""
"<![CDATA[<class name=\"Person\">\n"
"    <set name=\"cats\" batch-size=\"3\">\n"
"        ...\n"
"    </set>\n"
"</class>]]>"
msgstr ""

#. Tag: para
#: performance.xml:496
#, no-c-format
msgid ""
"With a <literal>batch-size</literal> of 3, Hibernate will load 3, 3, 3, 1 "
"collections in four <literal>SELECT</literal>s. Again, the value of the "
"attribute depends on the expected number of uninitialized collections in a "
"particular <literal>Session</literal>."
msgstr ""
"Con un <literal>batch-size</literal> de 3, Hibernate cargará 3, 3, 3, 1 "
"colecciones en cuatro <literal>SELECT</literal>s. Una vez más, el valor del "
"atributo depende del número esperado de colecciones sin inicializar en una "
"<literal>Session</literal> en particular."

#. Tag: para
#: performance.xml:502
#, no-c-format
msgid ""
"Batch fetching of collections is particularly useful if you have a nested "
"tree of items, ie. the typical bill-of-materials pattern. (Although a "
"<emphasis>nested set</emphasis> or a <emphasis>materialized path</emphasis> "
"might be a better option for read-mostly trees.)"
msgstr ""
"La recuperación de coleccione en lotes es particularmente útil si tienes un "
"árbol anidado de ítems, es decir, el típico patrón de cuenta de materiales. "
"(Aunque un <emphasis>conjunto anidado</emphasis> o una <emphasis>ruta "
"materializada</emphasis> podría ser una mejor opción para árboles que sean "
"de lectura en la mayoría de los casos.)"

#. Tag: title
#: performance.xml:511
#, no-c-format
msgid "Using subselect fetching"
msgstr "Usando recuperación por subselección"

#. Tag: para
#: performance.xml:513
#, no-c-format
msgid ""
"If one lazy collection or single-valued proxy has to be fetched, Hibernate "
"loads all of them, re-running the original query in a subselect. This works "
"in the same way as batch-fetching, without the piecemeal loading."
msgstr ""
"Si una colección perezosa o proxy monovaluado tiene que ser recuperado, "
"Hibernate los carga a todos, volviendo a ejecutar la consulta original en "
"una subselección. Esto funciona de la misma forma que la recuperación en "
"lotes, sin carga fragmentaria."

#. Tag: title
#: performance.xml:524
#, no-c-format
msgid "Using lazy property fetching"
msgstr "Usando recuperación perezosa de propiedades"

#. Tag: para
#: performance.xml:526
#, no-c-format
msgid ""
"Hibernate3 supports the lazy fetching of individual properties. This "
"optimization technique is also known as <emphasis>fetch groups</emphasis>. "
"Please note that this is mostly a marketing feature, as in practice, "
"optimizing row reads is much more important than optimization of column "
"reads. However, only loading some properties of a class might be useful in "
"extreme cases, when legacy tables have hundreds of columns and the data "
"model can not be improved."
msgstr ""
"Hibernate3 soporta la recuperación perezosa de propiedades individuales. "
"Esta técnica de optimización es también conocida como <emphasis>grupos de "
"recuperación (fetch groups)</emphasis>. Por favor, nota que éste es "
"mayormente un aspecto de marketing, ya que en la práctica, optimizar "
"lecturas de filas es mucho más importante que la optimización de lectura de "
"columnas. Sin embargo, cargar sólo algunas propiedades de una clase podría "
"ser útil en casos extremos, cuando tablas heredadas tienen cientos de "
"columnas y el modelo de datos no puede ser mejorado."

#. Tag: para
#: performance.xml:535
#, no-c-format
msgid ""
"To enable lazy property loading, set the <literal>lazy</literal> attribute "
"on your particular property mappings:"
msgstr ""
"Para habilitar la carga perezosa de propiedades, establece el atributo "
"<literal>lazy</literal> en tus mapeos de propiedades:"

#. Tag: programlisting
#: performance.xml:540
#, no-c-format
msgid ""
"<![CDATA[<class name=\"Document\">\n"
"       <id name=\"id\">\n"
"        <generator class=\"native\"/>\n"
"    </id>\n"
"    <property name=\"name\" not-null=\"true\" length=\"50\"/>\n"
"    <property name=\"summary\" not-null=\"true\" length=\"200\" lazy=\"true"
"\"/>\n"
"    <property name=\"text\" not-null=\"true\" length=\"2000\" lazy=\"true\"/"
">\n"
"</class>]]>"
msgstr ""

#. Tag: para
#: performance.xml:542
#, no-c-format
msgid ""
"Lazy property loading requires buildtime bytecode instrumentation! If your "
"persistent classes are not enhanced, Hibernate will silently ignore lazy "
"property settings and fall back to immediate fetching."
msgstr ""
"¡La carga perezosa de propiedades requiere la instrumentación del bytecode "
"en tiempo de construcción! Si tus clases persistentes no son mejoradas, "
"Hibernate ignorará silenciosamente la configuración perezosa de propiedades "
"y caerá en recuperación inmediata."

#. Tag: para
#: performance.xml:548
#, no-c-format
msgid "For bytecode instrumentation, use the following Ant task:"
msgstr "Para la instrumentación del bytecode, usa la siguiente tarea Ant:"

#. Tag: programlisting
#: performance.xml:552
#, no-c-format
msgid ""
"<![CDATA[<target name=\"instrument\" depends=\"compile\">\n"
"    <taskdef name=\"instrument\" classname=\"org.hibernate.tool.instrument."
"InstrumentTask\">\n"
"        <classpath path=\"${jar.path}\"/>\n"
"        <classpath path=\"${classes.dir}\"/>\n"
"        <classpath refid=\"lib.class.path\"/>\n"
"    </taskdef>\n"
"\n"
"    <instrument verbose=\"true\">\n"
"        <fileset dir=\"${testclasses.dir}/org/hibernate/auction/model\">\n"
"            <include name=\"*.class\"/>\n"
"        </fileset>\n"
"    </instrument>\n"
"</target>]]>"
msgstr ""

#. Tag: para
#: performance.xml:554
#, no-c-format
msgid ""
"A different (better?) way to avoid unnecessary column reads, at least for "
"read-only transactions is to use the projection features of HQL or Criteria "
"queries. This avoids the need for buildtime bytecode processing and is "
"certainly a prefered solution."
msgstr ""
"Una forma diferente (¿mejor?) de evitar lecturas innecesarias de columnas, "
"al menos para transacciones de sólo lectura es usar las funcionalidades de "
"proyección de consultas HQL o Criteria. Esto evita la necesidad de procesar "
"el bytecode en tiempo de construcción y ciertamente es una solución "
"preferida."

#. Tag: para
#: performance.xml:561
#, no-c-format
msgid ""
"You may force the usual eager fetching of properties using <literal>fetch "
"all properties</literal> in HQL."
msgstr ""
"Puedes forzar la usual recuperación temprana de propiedades usando "
"<literal>fetch all properties</literal> en HQL."

#. Tag: title
#: performance.xml:571
#, no-c-format
msgid "The Second Level Cache"
msgstr "El Caché de Segundo Nivel"

#. Tag: para
#: performance.xml:573
#, no-c-format
msgid ""
"A Hibernate <literal>Session</literal> is a transaction-level cache of "
"persistent data. It is possible to configure a cluster or JVM-level "
"(<literal>SessionFactory</literal>-level) cache on a class-by-class and "
"collection-by-collection basis. You may even plug in a clustered cache. Be "
"careful. Caches are never aware of changes made to the persistent store by "
"another application (though they may be configured to regularly expire "
"cached data)."
msgstr ""
"Una <literal>Session</literal> de Hibernate es una caché de datos "
"persistentes a nivel de transacción. Es posible configurar un cluster o "
"caché a nivel de JVM (a nivel de <literal>SessionFactory</literal>) sobre "
"una base de clase-a-clase o colección-a-colección. Puedes incluso enchufar "
"una caché en cluster. Sé cuidadoso. Las cachés nunca están al tanto de los "
"cambios hechos por otra aplicación al almacén persistente (aunque pueden ser "
"configurados para expirar regularmente los datos en caché)."

#. Tag: para
#: performance.xml:581
#, no-c-format
msgid ""
"You have the option to tell Hibernate which caching implementation to use by "
"specifying the name of a class that implements <literal>org.hibernate.cache."
"CacheProvider</literal> using the property <literal>hibernate.cache."
"provider_class</literal>. Hibernate comes bundled with a number of built-in "
"integrations with open-source cache providers (listed below); additionally, "
"you could implement your own and plug it in as outlined above. Note that "
"versions prior to 3.2 defaulted to use EhCache as the default cache "
"provider; that is no longer the case as of 3.2."
msgstr ""
"Por defecto, Hibernate usa EHCache para caching a nivel de JVM. (El soporte "
"a JCS ahora está despreciado y será quitado en una futura versión de "
"Hibernate.) Puedes elegir una implementación diferente estableciendo el "
"nombre de una clase que implemente <literal>org.hibernate.cache."
"CacheProvider</literal> usando la propiedad <literal>hibernate.cache."
"provider_class</literal>."

#. Tag: title
#: performance.xml:592
#, no-c-format
msgid "Cache Providers"
msgstr "Proveedores de Caché"

#. Tag: entry
#: performance.xml:601 performance.xml:774
#, no-c-format
msgid "Cache"
msgstr "Caché"

#. Tag: entry
#: performance.xml:602
#, no-c-format
msgid "Provider class"
msgstr "clase del Provedor"

#. Tag: entry
#: performance.xml:603
#, no-c-format
msgid "Type"
msgstr "Tipo"

#. Tag: entry
#: performance.xml:604
#, no-c-format
msgid "Cluster Safe"
msgstr "Cluster Seguro"

#. Tag: entry
#: performance.xml:605
#, no-c-format
msgid "Query Cache Supported"
msgstr "Caché de Consultas Soportado"

#. Tag: entry
#: performance.xml:610 performance.xml:783
#, no-c-format
msgid "Hashtable (not intended for production use)"
msgstr "Hashtable (no pensado para uso en producción)"

#. Tag: literal
#: performance.xml:611
#, no-c-format
msgid "org.hibernate.cache.HashtableCacheProvider"
msgstr "org.hibernate.cache.HashtableCacheProvider"

#. Tag: entry
#: performance.xml:612
#, no-c-format
msgid "memory"
msgstr "memoria"

#. Tag: entry
#: performance.xml:614 performance.xml:621 performance.xml:628
#: performance.xml:784 performance.xml:785 performance.xml:786
#: performance.xml:791 performance.xml:792 performance.xml:793
#: performance.xml:798 performance.xml:799 performance.xml:800
#: performance.xml:805 performance.xml:806 performance.xml:812
#: performance.xml:815
#, no-c-format
msgid "<entry>yes</entry>"
msgstr ""

#. Tag: entry
#: performance.xml:617 performance.xml:790
#, no-c-format
msgid "EHCache"
msgstr "EHCache"

#. Tag: literal
#: performance.xml:618
#, no-c-format
msgid "org.hibernate.cache.EhCacheProvider"
msgstr "org.hibernate.cache.EhCacheProvider"

#. Tag: entry
#: performance.xml:619 performance.xml:626
#, no-c-format
msgid "memory, disk"
msgstr "memoria, disco"

#. Tag: entry
#: performance.xml:624 performance.xml:797
#, no-c-format
msgid "OSCache"
msgstr "OSCache"

#. Tag: literal
#: performance.xml:625
#, no-c-format
msgid "org.hibernate.cache.OSCacheProvider"
msgstr "org.hibernate.cache.OSCacheProvider"

#. Tag: entry
#: performance.xml:631 performance.xml:804
#, no-c-format
msgid "SwarmCache"
msgstr "SwarmCache"

#. Tag: literal
#: performance.xml:632
#, no-c-format
msgid "org.hibernate.cache.SwarmCacheProvider"
msgstr "org.hibernate.cache.SwarmCacheProvider"

#. Tag: entry
#: performance.xml:633
#, no-c-format
msgid "clustered (ip multicast)"
msgstr "clusterizado (ip multicast)"

#. Tag: entry
#: performance.xml:634
#, no-c-format
msgid "yes (clustered invalidation)"
msgstr "sí (invalidación en cluster)"

#. Tag: entry
#: performance.xml:638 performance.xml:811
#, fuzzy, no-c-format
msgid "JBoss TreeCache"
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"TreeCache de JBoss\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"JBoss TreeCache"

#. Tag: literal
#: performance.xml:639
#, no-c-format
msgid "org.hibernate.cache.TreeCacheProvider"
msgstr "org.hibernate.cache.TreeCacheProvider"

#. Tag: entry
#: performance.xml:640
#, no-c-format
msgid "clustered (ip multicast), transactional"
msgstr "clusterizado (ip multicast), transaccional"

#. Tag: entry
#: performance.xml:641
#, no-c-format
msgid "yes (replication)"
msgstr "sí (replicación)"

#. Tag: entry
#: performance.xml:642
#, no-c-format
msgid "yes (clock sync req.)"
msgstr "sí (requiere sincronización de reloj)"

#. Tag: title
#: performance.xml:649
#, no-c-format
msgid "Cache mappings"
msgstr "Mapeos de caché"

#. Tag: para
#: performance.xml:651
#, no-c-format
msgid ""
"The <literal>&lt;cache&gt;</literal> element of a class or collection "
"mapping has the following form:"
msgstr ""
"El elemento <literal>&lt;cache&gt;</literal> de una mapeo de clase o "
"colección tiene la siguiente forma:"

#. Tag: programlisting
#: performance.xml:662
#, no-c-format
msgid ""
"<![CDATA[<cache \n"
"    usage=\"transactional|read-write|nonstrict-read-write|read-only\"\n"
"    region=\"RegionName\"\n"
"    include=\"all|non-lazy\"\n"
"/>]]>"
msgstr ""

#. Tag: para
#: performance.xml:665
#, no-c-format
msgid ""
"<literal>usage</literal> (required) specifies the caching strategy: "
"<literal>transactional</literal>, <literal>read-write</literal>, "
"<literal>nonstrict-read-write</literal> or <literal>read-only</literal>"
msgstr ""
"<literal>usage</literal> especifica la estrategia de caching: "
"<literal>transactional</literal>, <literal>read-write</literal>, "
"<literal>nonstrict-read-write</literal> o <literal>read-only</literal>"

#. Tag: para
#: performance.xml:674
#, no-c-format
msgid ""
"<literal>region</literal> (optional, defaults to the class or collection "
"role name) specifies the name of the second level cache region"
msgstr ""
"<literal>region</literal> (optional, defaults to the class or collection "
"role name) specifies the name of the second level cache region"

#. Tag: para
#: performance.xml:681
#, no-c-format
msgid ""
"<literal>include</literal> (optional, defaults to <literal>all</literal>) "
"<literal>non-lazy</literal> specifies that properties of the entity mapped "
"with <literal>lazy=\"true\"</literal> may not be cached when attribute-level "
"lazy fetching is enabled"
msgstr ""
"<literal>include</literal> (optional, defaults to <literal>all</literal>) "
"<literal>non-lazy</literal> specifies that properties of the entity mapped "
"with <literal>lazy=\"true\"</literal> may not be cached when attribute-level "
"lazy fetching is enabled"

#. Tag: para
#: performance.xml:691
#, no-c-format
msgid ""
"Alternatively (preferrably?), you may specify <literal>&lt;class-cache&gt;</"
"literal> and <literal>&lt;collection-cache&gt;</literal> elements in "
"<literal>hibernate.cfg.xml</literal>."
msgstr ""
"Alternativamente (¿preferiblemente?), puedes especificar los elementos "
"<literal>&lt;class-cache&gt;</literal> y <literal>&lt;collection-cache&gt;</"
"literal> en <literal>hibernate.cfg.xml</literal>."

#. Tag: para
#: performance.xml:696
#, no-c-format
msgid ""
"The <literal>usage</literal> attribute specifies a <emphasis>cache "
"concurrency strategy</emphasis>."
msgstr ""
"El atributo <literal>usage</literal> especifica una <emphasis>estrategia de "
"concurrencia al caché</emphasis>."

#. Tag: title
#: performance.xml:703
#, no-c-format
msgid "Strategy: read only"
msgstr "Estrategia: sólo lectura (read only)"

#. Tag: para
#: performance.xml:705
#, no-c-format
msgid ""
"If your application needs to read but never modify instances of a persistent "
"class, a <literal>read-only</literal> cache may be used. This is the "
"simplest and best performing strategy. It's even perfectly safe for use in a "
"cluster."
msgstr ""
"Si tu aplicación necesita leer pero nunca modificar las instancias de una "
"clase persistente, puede usarse un caché <literal>read-only</literal>. Esta "
"es la mejor y más simple estrategia. Es incluso perfectamente segura de usar "
"en un cluster."

#. Tag: programlisting
#: performance.xml:711
#, no-c-format
msgid ""
"<![CDATA[<class name=\"eg.Immutable\" mutable=\"false\">\n"
"    <cache usage=\"read-only\"/>\n"
"    ....\n"
"</class>]]>"
msgstr ""

#. Tag: title
#: performance.xml:717
#, no-c-format
msgid "Strategy: read/write"
msgstr "Estrategia: lectura/escritura (read/write)"

#. Tag: para
#: performance.xml:719
#, no-c-format
msgid ""
"If the application needs to update data, a <literal>read-write</literal> "
"cache might be appropriate. This cache strategy should never be used if "
"serializable transaction isolation level is required. If the cache is used "
"in a JTA environment, you must specify the property <literal>hibernate."
"transaction.manager_lookup_class</literal>, naming a strategy for obtaining "
"the JTA <literal>TransactionManager</literal>. In other environments, you "
"should ensure that the transaction is completed when <literal>Session.close()"
"</literal> or <literal>Session.disconnect()</literal> is called. If you wish "
"to use this strategy in a cluster, you should ensure that the underlying "
"cache implementation supports locking. The built-in cache providers do "
"<emphasis>not</emphasis>."
msgstr ""
"Si la aplicación necesita actualizar datos, un caché <literal>read-write</"
"literal> podría ser apropiado. Esta estrategia de caché nunca debe ser usada "
"si se requiere nivel de aislamiento serializable de transacciones. Si el "
"caché es usado en un entorno JTA, debes especificar la propiedad "
"<literal>hibernate.transaction.manager_lookup_class</literal>, mencionando "
"una estrategia para obtener el <literal>TransactionManager</literal> de JTA. "
"En otros entornos, debes asegurarte que la transacción esté completada "
"cuando se llame a <literal>Session.close()</literal> o <literal>Session."
"disconnect()</literal>. Si deseas usar esta estrategia en un cluster, debes "
"asegurarte que la implementación de caché subyacente soporta bloqueos. Los "
"provedores de caché internos predeterminados <emphasis>no</emphasis> no lo "
"soportan."

#. Tag: programlisting
#: performance.xml:730
#, no-c-format
msgid ""
"<![CDATA[<class name=\"eg.Cat\" .... >\n"
"    <cache usage=\"read-write\"/>\n"
"    ....\n"
"    <set name=\"kittens\" ... >\n"
"        <cache usage=\"read-write\"/>\n"
"        ....\n"
"    </set>\n"
"</class>]]>"
msgstr ""

#. Tag: title
#: performance.xml:735
#, no-c-format
msgid "Strategy: nonstrict read/write"
msgstr "Estrategia: lectura/escritura no estricta (nonstrict read/write)"

#. Tag: para
#: performance.xml:737
#, no-c-format
msgid ""
"If the application only occasionally needs to update data (ie. if it is "
"extremely unlikely that two transactions would try to update the same item "
"simultaneously) and strict transaction isolation is not required, a "
"<literal>nonstrict-read-write</literal> cache might be appropriate. If the "
"cache is used in a JTA environment, you must specify <literal>hibernate."
"transaction.manager_lookup_class</literal>. In other environments, you "
"should ensure that the transaction is completed when <literal>Session.close()"
"</literal> or <literal>Session.disconnect()</literal> is called."
msgstr ""
"Si la aplicación necesita sólo ocasionalmente actualizar datos (es decir, es "
"extremadamente inprobable que dos transacciones intenten actualizar el mismo "
"ítem simultáneamente) y no se requiere de un aislamiento de transacciones "
"estricto, un caché <literal>nonstrict-read-write</literal> podría ser "
"apropiado. Si se usa el caché en un entorno JTA, debes especificar "
"<literal>hibernate.transaction.manager_lookup_class</literal>. En otros "
"entornos, debes asegurarte que la transacción se haya completado cuando se "
"llame a <literal>Session.close()</literal> o <literal>Session.disconnect()</"
"literal>."

#. Tag: title
#: performance.xml:749
#, no-c-format
msgid "Strategy: transactional"
msgstr "Estrategia: transaccional"

#. Tag: para
#: performance.xml:751
#, no-c-format
msgid ""
"The <literal>transactional</literal> cache strategy provides support for "
"fully transactional cache providers such as JBoss TreeCache. Such a cache "
"may only be used in a JTA environment and you must specify "
"<literal>hibernate.transaction.manager_lookup_class</literal>."
msgstr ""
"La estrategia de caché <literal>transactional</literal> brinda soporte a "
"provedores de cachés completamente transaccionales como TreeCache de JBoss. "
"Un caché así, puede sólo ser usado en un entorno JTA y debes especificar "
"<literal>hibernate.transaction.manager_lookup_class</literal>."

#. Tag: para
#: performance.xml:759
#, no-c-format
msgid ""
"None of the cache providers support all of the cache concurrency strategies. "
"The following table shows which providers are compatible with which "
"concurrency strategies."
msgstr ""
"Ninguno de los provedores de caché soporta todas las estrategias de "
"concurrencia al caché. La siguiente tabla muestra qué provedores son "
"compatibles con qué estrategias de concurrencia."

#. Tag: title
#: performance.xml:765
#, no-c-format
msgid "Cache Concurrency Strategy Support"
msgstr "Soporte a Estrategia de Concurrencia a Caché"

#. Tag: entry
#: performance.xml:775
#, no-c-format
msgid "read-only"
msgstr "read-only"

#. Tag: entry
#: performance.xml:776
#, no-c-format
msgid "nonstrict-read-write"
msgstr "nonstrict-read-write"

#. Tag: entry
#: performance.xml:777
#, no-c-format
msgid "read-write"
msgstr "read-write"

#. Tag: entry
#: performance.xml:778
#, no-c-format
msgid "transactional"
msgstr "transactional"

#. Tag: title
#: performance.xml:824
#, no-c-format
msgid "Managing the caches"
msgstr "Gestionando los cachés"

#. Tag: para
#: performance.xml:826
#, no-c-format
msgid ""
"Whenever you pass an object to <literal>save()</literal>, <literal>update()</"
"literal> or <literal>saveOrUpdate()</literal> and whenever you retrieve an "
"object using <literal>load()</literal>, <literal>get()</literal>, "
"<literal>list()</literal>, <literal>iterate()</literal> or <literal>scroll()"
"</literal>, that object is added to the internal cache of the "
"<literal>Session</literal>."
msgstr ""
"Siempre que pases un objeto a <literal>save()</literal>, <literal>update()</"
"literal> o <literal>saveOrUpdate()</literal> y siempre que recuperes un "
"objeto usando <literal>load()</literal>, <literal>get()</literal>, "
"<literal>list()</literal>, <literal>iterate()</literal> o <literal>scroll()</"
"literal>, ese objeto es agregado al caché interno de la <literal>Session</"
"literal>."

#. Tag: para
#: performance.xml:833
#, no-c-format
msgid ""
"When <literal>flush()</literal> is subsequently called, the state of that "
"object will be synchronized with the database. If you do not want this "
"synchronization to occur or if you are processing a huge number of objects "
"and need to manage memory efficiently, the <literal>evict()</literal> method "
"may be used to remove the object and its collections from the first-level "
"cache."
msgstr ""
"Cuando subsecuentemente se llame a <literal>flush()</literal>, el estado de "
"ese objeto será sincronizado con la base de datos. Si no quieres que ocurra "
"esta sincronización o si estás procesando un número enorme de objetos y "
"necesitas gestionar la memoria eficientemente, puede usarse el método "
"<literal>evict()</literal> para quitar el objeto y sus colecciones del caché "
"de primer nivel."

#. Tag: programlisting
#: performance.xml:841
#, no-c-format
msgid ""
"<![CDATA[ScrollableResult cats = sess.createQuery(\"from Cat as cat\").scroll"
"(); //a huge result set\n"
"while ( cats.next() ) {\n"
"    Cat cat = (Cat) cats.get(0);\n"
"    doSomethingWithACat(cat);\n"
"    sess.evict(cat);\n"
"}]]>"
msgstr ""

#. Tag: para
#: performance.xml:843
#, no-c-format
msgid ""
"The <literal>Session</literal> also provides a <literal>contains()</literal> "
"method to determine if an instance belongs to the session cache."
msgstr ""
"La <literal>Session</literal> también provee un método <literal>contains()</"
"literal> para determinar si una instancia pertenece al caché de la sesión."

#. Tag: para
#: performance.xml:848
#, no-c-format
msgid ""
"To completely evict all objects from the session cache, call "
"<literal>Session.clear()</literal>"
msgstr ""
"Para desahuciar (evict) todos los objetos del caché de sesión, llama a "
"<literal>Session.clear()</literal>."

#. Tag: para
#: performance.xml:852
#, no-c-format
msgid ""
"For the second-level cache, there are methods defined on "
"<literal>SessionFactory</literal> for evicting the cached state of an "
"instance, entire class, collection instance or entire collection role."
msgstr ""
"Para el caché de segundo nivel, hay métodos definidos en "
"<literal>SessionFactory</literal> para desahuciar el estado en caché de una "
"instancia, clase entera, instancia de colección o rol enter de colección."

#. Tag: programlisting
#: performance.xml:858
#, no-c-format
msgid ""
"<![CDATA[sessionFactory.evict(Cat.class, catId); //evict a particular Cat\n"
"sessionFactory.evict(Cat.class);  //evict all Cats\n"
"sessionFactory.evictCollection(\"Cat.kittens\", catId); //evict a particular "
"collection of kittens\n"
"sessionFactory.evictCollection(\"Cat.kittens\"); //evict all kitten "
"collections]]>"
msgstr ""

#. Tag: para
#: performance.xml:860
#, no-c-format
msgid ""
"The <literal>CacheMode</literal> controls how a particular session interacts "
"with the second-level cache."
msgstr ""
"El <literal>CacheMode</literal> controla cómo una sesión en particular "
"interactúa con el caché de segundo nivel."

#. Tag: para
#: performance.xml:867
#, no-c-format
msgid ""
"<literal>CacheMode.NORMAL</literal> - read items from and write items to the "
"second-level cache"
msgstr ""
"<literal>CacheMode.NORMAL</literal> - lee ítems desde y escribe ítems hacia "
"el caché de segundo nivel"

#. Tag: para
#: performance.xml:872
#, no-c-format
msgid ""
"<literal>CacheMode.GET</literal> - read items from the second-level cache, "
"but don't write to the second-level cache except when updating data"
msgstr ""
"<literal>CacheMode.GET</literal> - lee ítems del caché de segundo nivel, "
"pero no escribe al caché de segundo nivel excepto al actualizar datos"

#. Tag: para
#: performance.xml:878
#, no-c-format
msgid ""
"<literal>CacheMode.PUT</literal> - write items to the second-level cache, "
"but don't read from the second-level cache"
msgstr ""
"<literal>CacheMode.PUT</literal> - escribe ítems al caché de segundo nivel, "
"pero no lee del caché de segundo nivel"

#. Tag: para
#: performance.xml:884
#, no-c-format
msgid ""
"<literal>CacheMode.REFRESH</literal> - write items to the second-level "
"cache, but don't read from the second-level cache, bypass the effect of "
"<literal>hibernate.cache.use_minimal_puts</literal>, forcing a refresh of "
"the second-level cache for all items read from the database"
msgstr ""
"<literal>CacheMode.REFRESH</literal> - escribe ítems al caché de segundo "
"nivel, pero no lee del caché de segundo nivel, saltándose el efecto de "
"<literal>hibernate.cache.use_minimal_puts</literal>, forzando un refresco "
"del caché de segundo nivel para todos los ítems leídos de la base de datos"

#. Tag: para
#: performance.xml:892
#, no-c-format
msgid ""
"To browse the contents of a second-level or query cache region, use the "
"<literal>Statistics</literal> API:"
msgstr ""
"Para navegar por los contenidos de una región de caché de segundo nivel o de "
"consultas, usa la API de <literal>Statistics</literal>:"

#. Tag: programlisting
#: performance.xml:897
#, no-c-format
msgid ""
"<![CDATA[Map cacheEntries = sessionFactory.getStatistics()\n"
"        .getSecondLevelCacheStatistics(regionName)\n"
"        .getEntries();]]>"
msgstr ""

#. Tag: para
#: performance.xml:899
#, no-c-format
msgid ""
"You'll need to enable statistics, and, optionally, force Hibernate to keep "
"the cache entries in a more human-understandable format:"
msgstr ""
"Necesitarás habilitar las estadísticas y, opcionalmente, forzar a Hibernate "
"para que guarde las entradas del caché en un formato más entendible por "
"humanos:"

#. Tag: programlisting
#: performance.xml:904
#, no-c-format
msgid ""
"<![CDATA[hibernate.generate_statistics true\n"
"hibernate.cache.use_structured_entries true]]>"
msgstr ""

#. Tag: title
#: performance.xml:909
#, no-c-format
msgid "The Query Cache"
msgstr "El Caché de Consultas"

#. Tag: para
#: performance.xml:911
#, no-c-format
msgid ""
"Query result sets may also be cached. This is only useful for queries that "
"are run frequently with the same parameters. To use the query cache you must "
"first enable it:"
msgstr ""
"Los conjuntos resultado de consultas también pueden tratarse en caché. Esto "
"sólo es útil para consultas que se ejecutan frecuentemente con los mismos "
"parámetros. Para usar el caché de consultas primero debes habilitarlo:"

#. Tag: programlisting
#: performance.xml:916
#, no-c-format
msgid "<![CDATA[hibernate.cache.use_query_cache true]]>"
msgstr ""

#. Tag: para
#: performance.xml:918
#, no-c-format
msgid ""
"This setting causes the creation of two new cache regions - one holding "
"cached query result sets (<literal>org.hibernate.cache.StandardQueryCache</"
"literal>), the other holding timestamps of the most recent updates to "
"queryable tables (<literal>org.hibernate.cache.UpdateTimestampsCache</"
"literal>). Note that the query cache does not cache the state of the actual "
"entities in the result set; it caches only identifier values and results of "
"value type. So the query cache should always be used in conjunction with the "
"second-level cache."
msgstr ""
"Esta configuración causa la creación de dos nuevas regiones de caché - una "
"teniendo en caché conjuntos resultado de consulta (<literal>org.hibernate."
"cache.StandardQueryCache</literal>), el otro teniendo timestamps de las "
"actualizaciones más recientes a tablas consultables (<literal>org.hibernate."
"cache.UpdateTimestampsCache</literal>). Nota que el caché de consultas no "
"pone en caché el estado de las entidades reales en el conjunto resultado; "
"sólo tiene en caché valores indentificadores y resultados de tipo de valor. "
"De modo que el caché de consultas siempre debe ser usado en conjunción con "
"el caché de segundo nivel."

#. Tag: para
#: performance.xml:928
#, no-c-format
msgid ""
"Most queries do not benefit from caching, so by default queries are not "
"cached. To enable caching, call <literal>Query.setCacheable(true)</literal>. "
"This call allows the query to look for existing cache results or add its "
"results to the cache when it is executed."
msgstr ""
"La mayoría de consultas no se benefician del tratamiento en caché, de modo "
"que por defecto las consultas no son tratadas en caché. Para habilitar el "
"tratamiento en caché, llama a <literal>Query.setCacheable(true)</literal>. "
"Esta llamada permite a la consulta buscar resultados existentes en caché o "
"agregar sus resultados al caché cuando se ejecuta."

#. Tag: para
#: performance.xml:935
#, no-c-format
msgid ""
"If you require fine-grained control over query cache expiration policies, "
"you may specify a named cache region for a particular query by calling "
"<literal>Query.setCacheRegion()</literal>."
msgstr ""
"Si requieres un control finamente granularizado sobre las políticas de "
"expiración del caché de consultas, puedes especificar una región de caché "
"con nombre para una consulta en particular llamando a <literal>Query."
"setCacheRegion()</literal>."

#. Tag: programlisting
#: performance.xml:941
#, no-c-format
msgid ""
"<![CDATA[List blogs = sess.createQuery(\"from Blog blog where blog.blogger "
"= :blogger\")\n"
"    .setEntity(\"blogger\", blogger)\n"
"    .setMaxResults(15)\n"
"    .setCacheable(true)\n"
"    .setCacheRegion(\"frontpages\")\n"
"    .list();]]>"
msgstr ""

#. Tag: para
#: performance.xml:943
#, no-c-format
msgid ""
"If the query should force a refresh of its query cache region, you should "
"call <literal>Query.setCacheMode(CacheMode.REFRESH)</literal>. This is "
"particularly useful in cases where underlying data may have been updated via "
"a separate process (i.e., not modified through Hibernate) and allows the "
"application to selectively refresh particular query result sets. This is a "
"more efficient alternative to eviction of a query cache region via "
"<literal>SessionFactory.evictQueries()</literal>."
msgstr ""
"Si la consulta debe forzar un refresco de si región del caché de consultas, "
"debes llamar a <literal>Query.setCacheMode(CacheMode.REFRESH)</literal>. "
"Esto es particularmente útil en casos donde los datos subyacentes pueden "
"haber sido actualizados por medio de un proceso separado (es decir, no "
"modificados a través de Hibernate) y permite a la aplicación refrescar "
"selectivamente conjuntos resultado de consultas en particular. Esto es una "
"alternativa más eficient al desahuciamiento de una región del caché de "
"consultas vía <literal>SessionFactory.evictQueries()</literal>."

#. Tag: title
#: performance.xml:955
#, no-c-format
msgid "Understanding Collection performance"
msgstr "Entendiendo el rendimiento de Colecciones"

#. Tag: para
#: performance.xml:957
#, no-c-format
msgid ""
"We've already spent quite some time talking about collections. In this "
"section we will highlight a couple more issues about how collections behave "
"at runtime."
msgstr ""
"Ya hemos llevado un buen tiempo hablando sobre colecciones. En esta sección "
"resaltaremos un par de temas más sobre cómo las colecciones se comportan en "
"tiempo de ejecución."

#. Tag: title
#: performance.xml:964
#, no-c-format
msgid "Taxonomy"
msgstr "Taxonomia"

#. Tag: para
#: performance.xml:966
#, no-c-format
msgid "Hibernate defines three basic kinds of collections:"
msgstr "Hibernate define tres tipos básicos de colecciones:"

#. Tag: para
#: performance.xml:970
#, no-c-format
msgid "collections of values"
msgstr "colecciones de valores"

#. Tag: para
#: performance.xml:973
#, no-c-format
msgid "one to many associations"
msgstr "asociaciones uno a muchos"

#. Tag: para
#: performance.xml:976
#, no-c-format
msgid "many to many associations"
msgstr "asociaciones muchos a muchos"

#. Tag: para
#: performance.xml:980
#, no-c-format
msgid ""
"This classification distinguishes the various table and foreign key "
"relationships but does not tell us quite everything we need to know about "
"the relational model. To fully understand the relational structure and "
"performance characteristics, we must also consider the structure of the "
"primary key that is used by Hibernate to update or delete collection rows. "
"This suggests the following classification:"
msgstr ""
"Esta clasificación distingue las varias tablas y relaciones de clave foránea "
"pero no nos dice absolutamente todo lo que necesitamos saber sobre el modelo "
"relacional. Para entender completamente la estructura relacional y las "
"características de rendimiento, debemos considerar la estructura de la clave "
"primaria que es usada por Hibernate para actualizar o borrar filas de "
"colección. Esto sugiere la siguiente clasificación:"

#. Tag: para
#: performance.xml:991
#, no-c-format
msgid "indexed collections"
msgstr "colecciones indexadas"

#. Tag: para
#: performance.xml:994
#, no-c-format
msgid "sets"
msgstr "conjuntos (sets)"

#. Tag: para
#: performance.xml:997
#, no-c-format
msgid "bags"
msgstr "bolsas (bags)"

#. Tag: para
#: performance.xml:1001
#, no-c-format
msgid ""
"All indexed collections (maps, lists, arrays) have a primary key consisting "
"of the <literal>&lt;key&gt;</literal> and <literal>&lt;index&gt;</literal> "
"columns. In this case collection updates are usually extremely efficient - "
"the primary key may be efficiently indexed and a particular row may be "
"efficiently located when Hibernate tries to update or delete it."
msgstr ""
"Todas las colecciones indexadas (mapas, listas, arrays) tienen una clave "
"primaria consistente de las columnas <literal>&lt;key&gt;</literal> y "
"<literal>&lt;index&gt;</literal>. En este caso las actualizaciones de "
"colecciones son usualmente extremadamente eficientes. La clave primaria "
"puede ser indexada fácilmente y una fila en particular puede ser localizada "
"cuando Hibernate intenta actualizarla o borrarla."

#. Tag: para
#: performance.xml:1009
#, no-c-format
msgid ""
"Sets have a primary key consisting of <literal>&lt;key&gt;</literal> and "
"element columns. This may be less efficient for some types of collection "
"element, particularly composite elements or large text or binary fields; the "
"database may not be able to index a complex primary key as efficently. On "
"the other hand, for one to many or many to many associations, particularly "
"in the case of synthetic identifiers, it is likely to be just as efficient. "
"(Side-note: if you want <literal>SchemaExport</literal> to actually create "
"the primary key of a <literal>&lt;set&gt;</literal> for you, you must "
"declare all columns as <literal>not-null=\"true\"</literal>.)"
msgstr ""
"Los conjuntos (sets) tienen una clave primaria consistente en <literal>&lt;"
"key&gt;</literal> y columnas de elemento. Esto puede ser menos eficiente "
"para algunos tipos de elemento de colección, particularmente elementos "
"compuestos o texto largo, o campos binarios. La base de datos puede no ser "
"capaz de indexar una clave primaria compleja eficientemente. Por otra parte, "
"para asociaciones uno a muchos o muchos a muchos, particularmente en el caso "
"de identificadores sintéticos, es probable que sólo sea tan eficiente. (Nota "
"al márgen: si quieres que <literal>SchemaExport</literal> realmente cree la "
"clave primaria de un <literal>&lt;set&gt;</literal> por ti, debes declarar "
"todas las columnas como <literal>not-null=\"true\"</literal>.)"

#. Tag: para
#: performance.xml:1020
#, no-c-format
msgid ""
"<literal>&lt;idbag&gt;</literal> mappings define a surrogate key, so they "
"are always very efficient to update. In fact, they are the best case."
msgstr ""
"Los mapeos de <literal>&lt;idbag&gt;</literal> definen una clave delegada, "
"de modo que siempre resulten eficientes de actualizar. De hecho, son el "
"mejor caso."

#. Tag: para
#: performance.xml:1025
#, no-c-format
msgid ""
"Bags are the worst case. Since a bag permits duplicate element values and "
"has no index column, no primary key may be defined. Hibernate has no way of "
"distinguishing between duplicate rows. Hibernate resolves this problem by "
"completely removing (in a single <literal>DELETE</literal>) and recreating "
"the collection whenever it changes. This might be very inefficient."
msgstr ""
"Los bags son el peor caso. Ya que un bag permite valores de elementos "
"duplicados y no tiene ninguna columna índice, no puede definirse ninguna "
"clave primaria. Hibernate no tiene forma de distinguir entre filas "
"duplicadas. Hibernate resuelve este problema quitando completamente (en un "
"solo <literal>DELETE</literal>) y recreando la colección siempre que cambia. "
"Esto podría ser muy ineficiente."

#. Tag: para
#: performance.xml:1033
#, no-c-format
msgid ""
"Note that for a one-to-many association, the \"primary key\" may not be the "
"physical primary key of the database table - but even in this case, the "
"above classification is still useful. (It still reflects how Hibernate "
"\"locates\" individual rows of the collection.)"
msgstr ""
"Nota que para una asociación uno-a-muchos, la \"clave primaria\" puede no "
"ser la clave primaria física de la tabla de base de datos; pero incluso en "
"este caso, la clasificación anterior es útil todavía. (Aún refleja cómo "
"Hibernate \"localiza\" filas individuales de la colección.)"

#. Tag: title
#: performance.xml:1043
#, no-c-format
msgid ""
"Lists, maps, idbags and sets are the most efficient collections to update"
msgstr ""
"Las listas, mapas, idbags y conjuntos son las colecciones más eficientes de "
"actualizar"

#. Tag: para
#: performance.xml:1045
#, no-c-format
msgid ""
"From the discussion above, it should be clear that indexed collections and "
"(usually) sets allow the most efficient operation in terms of adding, "
"removing and updating elements."
msgstr ""
"Desde la discusión anterior, debe quedar claro que las colecciones indexadas "
"y (usualmente) los conjuntos permiten la operación más eficiente en términos "
"de añadir, quitar y actualizar elementos."

#. Tag: para
#: performance.xml:1051
#, no-c-format
msgid ""
"There is, arguably, one more advantage that indexed collections have over "
"sets for many to many associations or collections of values. Because of the "
"structure of a <literal>Set</literal>, Hibernate doesn't ever "
"<literal>UPDATE</literal> a row when an element is \"changed\". Changes to a "
"<literal>Set</literal> always work via <literal>INSERT</literal> and "
"<literal>DELETE</literal> (of individual rows). Once again, this "
"consideration does not apply to one to many associations."
msgstr ""
"Hay, discutiblemente, una ventaja más que las colecciones indexadas tienen "
"sobre otros conjuntos para las asociaciones muchos a muchos o colecciones de "
"valores. Debido a la estructura de un <literal>Set</literal>, Hibernate ni "
"siquiera actualiza una fila con <literal>UPDATE</literal> cuando se \"cambia"
"\" un elemento. Los cambios a un <literal>Set</literal> siempre funcionan "
"por medio de <literal>INSERT</literal> y <literal>DELETE</literal> (de filas "
"individuales). Una vez más, esta consideración no se aplica a las "
"asociaciones uno a muchos."

#. Tag: para
#: performance.xml:1060
#, no-c-format
msgid ""
"After observing that arrays cannot be lazy, we would conclude that lists, "
"maps and idbags are the most performant (non-inverse) collection types, with "
"sets not far behind. Sets are expected to be the most common kind of "
"collection in Hibernate applications. This is because the \"set\" semantics "
"are most natural in the relational model."
msgstr ""
"Después de observar que los arrays no pueden ser perezosos, podríamos "
"concluir que las listas, mapas e idbags son los tipos más eficientes de "
"colecciones (no inversas), con los conjuntos (sets) no muy por detrás. Se "
"espera que los sets sean el tipo más común de colección en las aplicaciones "
"de Hibernate. Esto es debido a que la semántica de los sets es la más "
"natural en el modelo relacional."

#. Tag: para
#: performance.xml:1068
#, no-c-format
msgid ""
"However, in well-designed Hibernate domain models, we usually see that most "
"collections are in fact one-to-many associations with <literal>inverse=\"true"
"\"</literal>. For these associations, the update is handled by the many-to-"
"one end of the association, and so considerations of collection update "
"performance simply do not apply."
msgstr ""
"Sin embargo, en modelos de dominio de Hibernate bien dieñados, usualmente "
"vemos que la mayoría de las colecciones son de hecho asociaciones uno-a-"
"muchos con <literal>inverse=\"true\"</literal>. Para estas asociaciones, la "
"actualización es manejada por el extremo muchos-a-uno de la asociación, y "
"las consideraciones de este tipo sobre el rendimiento de actualización de "
"colecciones simplemente no se aplican."

#. Tag: title
#: performance.xml:1078
#, no-c-format
msgid "Bags and lists are the most efficient inverse collections"
msgstr "Los Bags y las listas son las colecciones inversas más eficientes"

#. Tag: para
#: performance.xml:1080
#, no-c-format
msgid ""
"Just before you ditch bags forever, there is a particular case in which bags "
"(and also lists) are much more performant than sets. For a collection with "
"<literal>inverse=\"true\"</literal> (the standard bidirectional one-to-many "
"relationship idiom, for example) we can add elements to a bag or list "
"without needing to initialize (fetch) the bag elements! This is because "
"<literal>Collection.add()</literal> or <literal>Collection.addAll()</"
"literal> must always return true for a bag or <literal>List</literal> "
"(unlike a <literal>Set</literal>). This can make the following common code "
"much faster."
msgstr ""
"Justo antes que tires a la zanja los bags para siempre, hay un caso en "
"particular en el que los bags son muchos más eficientes que los conjuntos. "
"Para una colección con <literal>inverse=\"true\"</literal> (el idioma "
"estándar de relaciones uno-a-muchos bidireccionales, por ejemplo) ¡podemos "
"añadir elementos a un bag o lista sin necesidad de inicializar (fetch) los "
"elementos del bag! Esto se debe a que <literal>Collection.add()</literal> o "
"<literal>Collection.addAll()</literal> siempre deben devolver true para un "
"bag o <literal>List</literal> (no como un <literal>Set</literal>). Esto "
"puede hacer el siguiente código común mucho más rápido."

#. Tag: programlisting
#: performance.xml:1090
#, no-c-format
msgid ""
"<![CDATA[Parent p = (Parent) sess.load(Parent.class, id);\n"
"Child c = new Child();\n"
"c.setParent(p);\n"
"p.getChildren().add(c);  //no need to fetch the collection!\n"
"sess.flush();]]>"
msgstr ""

#. Tag: title
#: performance.xml:1095
#, no-c-format
msgid "One shot delete"
msgstr "Borrado de un solo tiro"

#. Tag: para
#: performance.xml:1097
#, no-c-format
msgid ""
"Occasionally, deleting collection elements one by one can be extremely "
"inefficient. Hibernate isn't completely stupid, so it knows not to do that "
"in the case of an newly-empty collection (if you called <literal>list.clear()"
"</literal>, for example). In this case, Hibernate will issue a single "
"<literal>DELETE</literal> and we are done!"
msgstr ""
"Ocasionalmente, borrar los elementos de una colección uno a uno puede ser "
"extremadamente ineficiente. Hibernate no es completamente estúpido, de modo "
"que sabe no hacer eso, en el caso de una colección nueva-vacía (si has "
"llamado a <literal>list.clear()</literal>, por ejemplo). En este caso, "
"Hibernate publicará una sola <literal>DELETE</literal>, ¡y listo!"

#. Tag: para
#: performance.xml:1104
#, no-c-format
msgid ""
"Suppose we add a single element to a collection of size twenty and then "
"remove two elements. Hibernate will issue one <literal>INSERT</literal> "
"statement and two <literal>DELETE</literal> statements (unless the "
"collection is a bag). This is certainly desirable."
msgstr ""
"Supón que añadimos un solo elemento a una colección de tamaño veinte y luego "
"quitamos dos elementos. Hibernate publicará una sentencia <literal>INSERT</"
"literal> y dos sentencias <literal>DELETE</literal> (a menos que la "
"colección sea un bag). Esto es ciertamente deseable."

#. Tag: para
#: performance.xml:1110
#, no-c-format
msgid ""
"However, suppose that we remove eighteen elements, leaving two and then add "
"thee new elements. There are two possible ways to proceed"
msgstr ""
"Sin embargo, supón que quitamos dieciocho elementos, dejando dos y luego "
"añadimos tres nuevos elementos. Hay dos formas posibles de proceder"

#. Tag: para
#: performance.xml:1117
#, no-c-format
msgid "delete eighteen rows one by one and then insert three rows"
msgstr "borrar dieciocho filas una a una y luego insertar tres filas"

#. Tag: para
#: performance.xml:1120
#, no-c-format
msgid ""
"remove the whole collection (in one SQL <literal>DELETE</literal>) and "
"insert all five current elements (one by one)"
msgstr ""
"quitar toda la colección (en un solo <literal>DELETE</literal> de SQL) e "
"insertar todos los cinco elementos actuales (uno a uno)"

#. Tag: para
#: performance.xml:1125
#, no-c-format
msgid ""
"Hibernate isn't smart enough to know that the second option is probably "
"quicker in this case. (And it would probably be undesirable for Hibernate to "
"be that smart; such behaviour might confuse database triggers, etc.)"
msgstr ""
"Hibernate no es lo suficientemente inteligente para saber que la segunda "
"opción es probablemente más rápida en este caso. (Y que sería probablemente "
"indeseable para Hibernate ser tan inteligente; este comportamiento podría "
"confundir a disparadores de base de datos, etc.)"

#. Tag: para
#: performance.xml:1131
#, no-c-format
msgid ""
"Fortunately, you can force this behaviour (ie. the second strategy) at any "
"time by discarding (ie. dereferencing) the original collection and returning "
"a newly instantiated collection with all the current elements. This can be "
"very useful and powerful from time to time."
msgstr ""
"Afortunadamente, puedes forzar este comportamiento (es decir, la segunda "
"estrategia) en cualquier momento descartando (es decir, desreferenciando) la "
"colección original y devolviendo una colección nuevamente instanciada con "
"todos los elementos actuales. Esto puede ser muy útil y potente de vez en "
"cuando."

#. Tag: para
#: performance.xml:1137
#, no-c-format
msgid ""
"Of course, one-shot-delete does not apply to collections mapped "
"<literal>inverse=\"true\"</literal>."
msgstr ""
"Por supuesto, el borrado-de-un-solo-tiro no se aplica a colecciones mapeadas "
"<literal>inverse=\"true\"</literal>."

#. Tag: title
#: performance.xml:1146
#, no-c-format
msgid "Monitoring performance"
msgstr "Monitoreando el rendimiento"

#. Tag: para
#: performance.xml:1148
#, no-c-format
msgid ""
"Optimization is not much use without monitoring and access to performance "
"numbers. Hibernate provides a full range of figures about its internal "
"operations. Statistics in Hibernate are available per "
"<literal>SessionFactory</literal>."
msgstr ""
"La optimización no es de mucho uso sin el monitoreo y el acceso a números de "
"rendimiento. Hibernate provee un rango completo de figuras sobre sus "
"operaciones internas. Las estadísticas en Hibernate están disponibles por "
"<literal>SessionFactory</literal>."

#. Tag: title
#: performance.xml:1155
#, no-c-format
msgid "Monitoring a SessionFactory"
msgstr "Monitoreando una SessionFactory"

#. Tag: para
#: performance.xml:1157
#, no-c-format
msgid ""
"You can access <literal>SessionFactory</literal> metrics in two ways. Your "
"first option is to call <literal>sessionFactory.getStatistics()</literal> "
"and read or display the <literal>Statistics</literal> yourself."
msgstr ""
"Puedes acceder a las métricas de <literal>SessionFactory</literal> de dos "
"formas. Tu primera opción es llamar a <literal>sessionFactory.getStatistics()"
"</literal> y leer o mostrar por pantalla la <literal>Statistics</literal> "
"por ti mismo."

#. Tag: para
#: performance.xml:1163
#, no-c-format
msgid ""
"Hibernate can also use JMX to publish metrics if you enable the "
"<literal>StatisticsService</literal> MBean. You may enable a single MBean "
"for all your <literal>SessionFactory</literal> or one per factory. See the "
"following code for minimalistic configuration examples:"
msgstr ""
"Hibernate puede también usar JMX para publicar las métricas si habilitas el "
"MBean <literal>StatisticsService</literal>. Puede habilitar un solo MBean "
"para todas tus <literal>SessionFactory</literal> o una por fábrica. Mira el "
"siguiente código para ejemplos de configuración minimalistas:"

#. Tag: programlisting
#: performance.xml:1170
#, no-c-format
msgid ""
"<![CDATA[// MBean service registration for a specific SessionFactory\n"
"Hashtable tb = new Hashtable();\n"
"tb.put(\"type\", \"statistics\");\n"
"tb.put(\"sessionFactory\", \"myFinancialApp\");\n"
"ObjectName on = new ObjectName(\"hibernate\", tb); // MBean object name\n"
"\n"
"StatisticsService stats = new StatisticsService(); // MBean implementation\n"
"stats.setSessionFactory(sessionFactory); // Bind the stats to a "
"SessionFactory\n"
"server.registerMBean(stats, on); // Register the Mbean on the server]]>"
msgstr ""

#. Tag: programlisting
#: performance.xml:1173
#, no-c-format
msgid ""
"<![CDATA[// MBean service registration for all SessionFactory's\n"
"Hashtable tb = new Hashtable();\n"
"tb.put(\"type\", \"statistics\");\n"
"tb.put(\"sessionFactory\", \"all\");\n"
"ObjectName on = new ObjectName(\"hibernate\", tb); // MBean object name\n"
"\n"
"StatisticsService stats = new StatisticsService(); // MBean implementation\n"
"server.registerMBean(stats, on); // Register the MBean on the server]]>"
msgstr ""

#. Tag: para
#: performance.xml:1175
#, no-c-format
msgid ""
"TODO: This doesn't make sense: In the first case, we retrieve and use the "
"MBean directly. In the second one, we must give the JNDI name in which the "
"session factory is held before using it. Use <literal>hibernateStatsBean."
"setSessionFactoryJNDIName(\"my/JNDI/Name\")</literal>"
msgstr ""
"POR HACER: Esto no tiene sentido: En el primer caso, recuperamos y usamos el "
"MBean directamente. En el segundo, debemos proporcionar el nombre JNDI en el "
"que se guarda la fábrica de sesiones antes de usarlo. Usa "
"<literal>hibernateStatsBean.setSessionFactoryJNDIName(\"my/JNDI/Name\")</"
"literal>"

#. Tag: para
#: performance.xml:1180
#, no-c-format
msgid ""
"You can (de)activate the monitoring for a <literal>SessionFactory</literal>"
msgstr ""
"Puedes (des)activar el monitoreo de una <literal>SessionFactory</literal>"

#. Tag: para
#: performance.xml:1185
#, no-c-format
msgid ""
"at configuration time, set <literal>hibernate.generate_statistics</literal> "
"to <literal>false</literal>"
msgstr ""
"en tiempo de configuración, establece <literal>hibernate."
"generate_statistics</literal> a <literal>false</literal>"

#. Tag: para
#: performance.xml:1192
#, no-c-format
msgid ""
"at runtime: <literal>sf.getStatistics().setStatisticsEnabled(true)</literal> "
"or <literal>hibernateStatsBean.setStatisticsEnabled(true)</literal>"
msgstr ""
"en tiempo de ejecución: <literal>sf.getStatistics().setStatisticsEnabled"
"(true)</literal> o <literal>hibernateStatsBean.setStatisticsEnabled(true)</"
"literal>"

#. Tag: para
#: performance.xml:1199
#, no-c-format
msgid ""
"Statistics can be reset programatically using the <literal>clear()</literal> "
"method. A summary can be sent to a logger (info level) using the "
"<literal>logSummary()</literal> method."
msgstr ""
"Las estadísticas pueden ser reajustadas programáticamente usando el método "
"<literal>clear()</literal>. Puede enviarse un resumen a un logger (nivel "
"info) usando el método <literal>logSummary()</literal>."

#. Tag: title
#: performance.xml:1208
#, no-c-format
msgid "Metrics"
msgstr "Métricas"

#. Tag: para
#: performance.xml:1210
#, no-c-format
msgid ""
"Hibernate provides a number of metrics, from very basic to the specialized "
"information only relevant in certain scenarios. All available counters are "
"described in the <literal>Statistics</literal> interface API, in three "
"categories:"
msgstr ""
"Hibernate provee un número de métricas, desde información muy básica a la "
"especializada sólo relevante en ciertos escenarios. Todos los contadores "
"disponibles se describen en la API de la interface <literal>Statistics</"
"literal>, en tres categorías:"

#. Tag: para
#: performance.xml:1217
#, no-c-format
msgid ""
"Metrics related to the general <literal>Session</literal> usage, such as "
"number of open sessions, retrieved JDBC connections, etc."
msgstr ""
"Métricas relacionadas al uso general de <literal>Session</literal> usage, "
"tales como número de sesiones abiertas, conexiones JDBC recuperadas, etc,"

#. Tag: para
#: performance.xml:1223
#, no-c-format
msgid ""
"Metrics related to he entities, collections, queries, and caches as a whole "
"(aka global metrics),"
msgstr ""
"Métricas relacionadas a las entidades, colecciones, consultas, y cachés como "
"un todo. (también conocidas como métricas globales)."

#. Tag: para
#: performance.xml:1229
#, no-c-format
msgid ""
"Detailed metrics related to a particular entity, collection, query or cache "
"region."
msgstr ""
"Métricas detalladas relacionadas a una entidad, colección, consulta o región "
"de caché en particular."

#. Tag: para
#: performance.xml:1236
#, no-c-format
msgid ""
"For exampl,e you can check the cache hit, miss, and put ratio of entities, "
"collections and queries, and the average time a query needs. Beware that the "
"number of milliseconds is subject to approximation in Java. Hibernate is "
"tied to the JVM precision, on some platforms this might even only be "
"accurate to 10 seconds."
msgstr ""
"Por ejemplo, puedes comprobar el acceso, pérdida, y radio de colocación de "
"entidades, colecciones y consultas en el caché, y el tiempo promedio que "
"necesita una consulta. Ten en cuenta que el número de milisegundos está "
"sujeto a aproximación en Java. Hibernate está pegado a la precisión de la "
"JVM, en algunas plataformas esto podría incuso ser tener sólo una exactitud "
"de 10 segundos."

#. Tag: para
#: performance.xml:1243
#, no-c-format
msgid ""
"Simple getters are used to access the global metrics (i.e. not tied to a "
"particular entity, collection, cache region, etc.). You can access the "
"metrics of a particular entity, collection or cache region through its name, "
"and through its HQL or SQL representation for queries. Please refer to the "
"<literal>Statistics</literal>, <literal>EntityStatistics</literal>, "
"<literal>CollectionStatistics</literal>, "
"<literal>SecondLevelCacheStatistics</literal>, and <literal>QueryStatistics</"
"literal> API Javadoc for more information. The following code shows a simple "
"example:"
msgstr ""
"Se usan getters simples para acceder a las métricas globales (es decir, no "
"pegadas a una entidad, colección, región de caché, etc, en particular). "
"Puedes acceder a las métricas de una entidad, colección, región de caché en "
"particular a través de su nombre, y a través de su representación HQL o SQL "
"para las consultas. Por favor refiérete al Javadoc de la API de "
"<literal>Statistics</literal>, <literal>EntityStatistics</literal>, "
"<literal>CollectionStatistics</literal>, "
"<literal>SecondLevelCacheStatistics</literal>, y <literal>QueryStatistics</"
"literal> para más información. El siguiente código muestra un ejemplo "
"sencillo:"

#. Tag: programlisting
#: performance.xml:1253
#, no-c-format
msgid ""
"<![CDATA[Statistics stats = HibernateUtil.sessionFactory.getStatistics();\n"
"\n"
"double queryCacheHitCount  = stats.getQueryCacheHitCount();\n"
"double queryCacheMissCount = stats.getQueryCacheMissCount();\n"
"double queryCacheHitRatio =\n"
"  queryCacheHitCount / (queryCacheHitCount + queryCacheMissCount);\n"
"\n"
"log.info(\"Query Hit ratio:\" + queryCacheHitRatio);\n"
"\n"
"EntityStatistics entityStats =\n"
"  stats.getEntityStatistics( Cat.class.getName() );\n"
"long changes =\n"
"        entityStats.getInsertCount()\n"
"        + entityStats.getUpdateCount()\n"
"        + entityStats.getDeleteCount();\n"
"log.info(Cat.class.getName() + \" changed \" + changes + \"times\"  );]]>"
msgstr ""

#. Tag: para
#: performance.xml:1255
#, no-c-format
msgid ""
"To work on all entities, collections, queries and region caches, you can "
"retrieve the list of names of entities, collections, queries and region "
"caches with the following methods: <literal>getQueries()</literal>, "
"<literal>getEntityNames()</literal>, <literal>getCollectionRoleNames()</"
"literal>, and <literal>getSecondLevelCacheRegionNames()</literal>."
msgstr ""
"Para trabajar sobre todas las entidades, colecciones, consultas y regiones "
"de cachés, puedes recuperar la lista de nombres de entidades, colecciones, "
"consultas y regiones de cachés con los siguientes métodos: "
"<literal>getQueries()</literal>, <literal>getEntityNames()</literal>, "
"<literal>getCollectionRoleNames()</literal>, y "
"<literal>getSecondLevelCacheRegionNames()</literal>."

#~ msgid "yes"
#~ msgstr "sí"
