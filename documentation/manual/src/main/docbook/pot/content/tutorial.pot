msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2007-10-19 10:35-0500\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: tutorial.xml:7(title) 
msgid "Introduction to Hibernate"
msgstr ""

#: tutorial.xml:10(title) 
msgid "Preface"
msgstr ""

#: tutorial.xml:12(para) 
msgid "This chapter is an introductory tutorial for new users of Hibernate. We start with a simple command line application using an in-memory database and develop it in easy to understand steps."
msgstr ""

#: tutorial.xml:18(para) 
msgid "This tutorial is intended for new users of Hibernate but requires Java and SQL knowledge. It is based on a tutorial by Michael Gloegl, the third-party libraries we name are for JDK 1.4 and 5.0. You might need others for JDK 1.3."
msgstr ""

#: tutorial.xml:24(para) 
msgid "The source code for the tutorial is included in the distribution in the <literal>doc/reference/tutorial/</literal> directory."
msgstr ""

#: tutorial.xml:32(title) 
msgid "Part 1 - The first Hibernate Application"
msgstr ""

#: tutorial.xml:34(para) 
msgid "First, we'll create a simple console-based Hibernate application. We use an Java database (HSQL DB), so we do not have to install any database server."
msgstr ""

#: tutorial.xml:39(para) 
msgid "Let's assume we need a small database application that can store events we want to attend, and information about the hosts of these events."
msgstr ""

#: tutorial.xml:44(para) 
msgid "The first thing we do, is set up our development directory and put all the Java libraries we need into it. Download the Hibernate distribution from the Hibernate website. Extract the package and place all required libraries found in <literal>/lib</literal> into into the <literal>/lib</literal> directory of your new development working directory. It should look like this:"
msgstr ""

#: tutorial.xml:65(para) 
msgid "This is the minimum set of required libraries (note that we also copied hibernate3.jar, the main archive) for Hibernate <emphasis>at the time of writing</emphasis>. The Hibernate release you are using might require more or less libraries. See the <literal>README.txt</literal> file in the <literal>lib/</literal> directory of the Hibernate distribution for more information about required and optional third-party libraries. (Actually, Log4j is not required but preferred by many developers.)"
msgstr ""

#: tutorial.xml:74(para) 
msgid "Next we create a class that represents the event we want to store in database."
msgstr ""

#: tutorial.xml:79(title) 
msgid "The first class"
msgstr ""

#: tutorial.xml:81(para) 
msgid "Our first persistent class is a simple JavaBean class with some properties:"
msgstr ""

#: tutorial.xml:122(para) 
msgid "You can see that this class uses standard JavaBean naming conventions for property getter and setter methods, as well as private visibility for the fields. This is a recommended design - but not required. Hibernate can also access fields directly, the benefit of accessor methods is robustness for refactoring. The no-argument constructor is required to instantiate an object of this class through reflection."
msgstr ""

#: tutorial.xml:130(para) 
msgid "The <literal>id</literal> property holds a unique identifier value for a particular event. All persistent entity classes (there are less important dependent classes as well) will need such an identifier property if we want to use the full feature set of Hibernate. In fact, most applications (esp. web applications) need to distinguish objects by identifier, so you should consider this a feature rather than a limitation. However, we usually don't manipulate the identity of an object, hence the setter method should be private. Only Hibernate will assign identifiers when an object is saved. You can see that Hibernate can access public, private, and protected accessor methods, as well as (public, private, protected) fields directly. The choice is up to you and you can match it to fit your application design."
msgstr ""

#: tutorial.xml:142(para) 
msgid "The no-argument constructor is a requirement for all persistent classes; Hibernate has to create objects for you, using Java Reflection. The constructor can be private, however, package visibility is required for runtime proxy generation and efficient data retrieval without bytecode instrumentation."
msgstr ""

#: tutorial.xml:149(para) 
msgid "Place this Java source file in a directory called <literal>src</literal> in the development folder, and in its correct package. The directory should now look like this:"
msgstr ""

#: tutorial.xml:161(para) 
msgid "In the next step, we tell Hibernate about this persistent class."
msgstr ""

#: tutorial.xml:168(title) 
msgid "The mapping file"
msgstr ""

#: tutorial.xml:170(para) 
msgid "Hibernate needs to know how to load and store objects of the persistent class. This is where the Hibernate mapping file comes into play. The mapping file tells Hibernate what table in the database it has to access, and what columns in that table it should use."
msgstr ""

#: tutorial.xml:177(para) 
msgid "The basic structure of a mapping file looks like this:"
msgstr ""

#: tutorial.xml:190(para) 
msgid "Note that the Hibernate DTD is very sophisticated. You can use it for auto-completion of XML mapping elements and attributes in your editor or IDE. You also should open up the DTD file in your text editor - it's the easiest way to get an overview of all elements and attributes and to see the defaults, as well as some comments. Note that Hibernate will not load the DTD file from the web, but first look it up from the classpath of the application. The DTD file is included in <literal>hibernate3.jar</literal> as well as in the <literal>src/</literal> directory of the Hibernate distribution."
msgstr ""

#: tutorial.xml:201(para) 
msgid "We will omit the DTD declaration in future examples to shorten the code. It is of course not optional."
msgstr ""

#: tutorial.xml:206(para) 
msgid "Between the two <literal>hibernate-mapping</literal> tags, include a <literal>class</literal> element. All persistent entity classes (again, there might be dependent classes later on, which are not first-class entities) need such a mapping, to a table in the SQL database:"
msgstr ""

#: tutorial.xml:221(para) 
msgid "So far we told Hibernate how to persist and load object of class <literal>Event</literal> to the table <literal>EVENTS</literal>, each instance represented by a row in that table. Now we continue with a mapping of the unique identifier property to the tables primary key. In addition, as we don't want to care about handling this identifier, we configure Hibernate's identifier generation strategy for a surrogate primary key column:"
msgstr ""

#: tutorial.xml:239(para) 
msgid "The <literal>id</literal> element is the declaration of the identifer property, <literal>name=\"id\"</literal> declares the name of the Java property - Hibernate will use the getter and setter methods to access the property. The column attribute tells Hibernate which column of the <literal>EVENTS</literal> table we use for this primary key. The nested <literal>generator</literal> element specifies the identifier generation strategy, in this case we used <literal>native</literal>, which picks the best strategy depending on the configured database (dialect). Hibernate supports database generated, globally unique, as well as application assigned identifiers (or any strategy you have written an extension for)."
msgstr ""

#: tutorial.xml:252(para) 
msgid "Finally we include declarations for the persistent properties of the class in the mapping file. By default, no properties of the class are considered persistent:"
msgstr ""

#: tutorial.xml:271(para) 
msgid "Just as with the <literal>id</literal> element, the <literal>name</literal> attribute of the <literal>property</literal> element tells Hibernate which getter and setter methods to use. So, in this case, Hibernate will look for <literal>getDate()/setDate()</literal>, as well as <literal>getTitle()/setTitle()</literal>."
msgstr ""

#: tutorial.xml:278(para) 
msgid "Why does the <literal>date</literal> property mapping include the <literal>column</literal> attribute, but the <literal>title</literal> doesn't? Without the <literal>column</literal> attribute Hibernate by default uses the property name as the column name. This works fine for <literal>title</literal>. However, <literal>date</literal> is a reserved keyword in most database, so we better map it to a different name."
msgstr ""

#: tutorial.xml:287(para) 
msgid "The next interesting thing is that the <literal>title</literal> mapping also lacks a <literal>type</literal> attribute. The types we declare and use in the mapping files are not, as you might expect, Java data types. They are also not SQL database types. These types are so called <emphasis>Hibernate mapping types</emphasis>, converters which can translate from Java to SQL data types and vice versa. Again, Hibernate will try to determine the correct conversion and mapping type itself if the <literal>type</literal> attribute is not present in the mapping. In some cases this automatic detection (using Reflection on the Java class) might not have the default you expect or need. This is the case with the <literal>date</literal> property. Hibernate can't know if the property (which is of <literal>java.util.Date</literal>) should map to a SQL <literal>date</literal>, <literal>timestamp</literal>, or <literal>time</literal> column. We preserve full date and time information by mapping the property with a <literal>timestamp</literal> converter."
msgstr ""

#: tutorial.xml:303(para) 
msgid "This mapping file should be saved as <literal>Event.hbm.xml</literal>, right in the directory next to the <literal>Event</literal> Java class source file. The naming of mapping files can be arbitrary, however the <literal>hbm.xml</literal> suffix is a convention in the Hibernate developer community. The directory structure should now look like this:"
msgstr ""

#: tutorial.xml:319(para) 
msgid "We continue with the main configuration of Hibernate."
msgstr ""

#: tutorial.xml:326(title) 
msgid "Hibernate configuration"
msgstr ""

#: tutorial.xml:328(para) 
msgid "We now have a persistent class and its mapping file in place. It is time to configure Hibernate. Before we do this, we will need a database. HSQL DB, a java-based SQL DBMS, can be downloaded from the HSQL DB website(http://hsqldb.org/). Actually, you only need the <literal>hsqldb.jar</literal> from this download. Place this file in the <literal>lib/</literal> directory of the development folder."
msgstr ""

#: tutorial.xml:336(para) 
msgid "Create a directory called <literal>data</literal> in the root of the development directory - this is where HSQL DB will store its data files. Now start the database by running <literal>java -classpath ../lib/hsqldb.jar org.hsqldb.Server</literal> in this data directory. You can see it start up and bind to a TCP/IP socket, this is where our application will connect later. If you want to start with a fresh database during this tutorial, shutdown HSQL DB (press <literal>CTRL + C</literal> in the window), delete all files in the <literal>data/</literal> directory, and start HSQL DB again."
msgstr ""

#: tutorial.xml:346(para) 
msgid "Hibernate is the layer in your application which connects to this database, so it needs connection information. The connections are made through a JDBC connection pool, which we also have to configure. The Hibernate distribution contains several open source JDBC connection pooling tools, but will use the Hibernate built-in connection pool for this tutorial. Note that you have to copy the required library into your classpath and use different connection pooling settings if you want to use a production-quality third party JDBC pooling software."
msgstr ""

#: tutorial.xml:356(para) 
msgid "For Hibernate's configuration, we can use a simple <literal>hibernate.properties</literal> file, a slightly more sophisticated <literal>hibernate.cfg.xml</literal> file, or even complete programmatic setup. Most users prefer the XML configuration file:"
msgstr ""

#: tutorial.xml:401(para) 
msgid "Note that this XML configuration uses a different DTD. We configure Hibernate's <literal>SessionFactory</literal> - a global factory responsible for a particular database. If you have several databases, use several <literal>&lt;session-factory&gt;</literal> configurations, usually in several configuration files (for easier startup)."
msgstr ""

#: tutorial.xml:409(para) 
msgid "The first four <literal>property</literal> elements contain the necessary configuration for the JDBC connection. The dialect <literal>property</literal> element specifies the particular SQL variant Hibernate generates. Hibernate's automatic session management for persistence contexts will come in handy as you will soon see. The <literal>hbm2ddl.auto</literal> option turns on automatic generation of database schemas - directly into the database. This can of course also be turned off (by removing the config option) or redirected to a file with the help of the <literal>SchemaExport</literal> Ant task. Finally, we add the mapping file(s) for persistent classes to the configuration."
msgstr ""

#: tutorial.xml:422(para) 
msgid "Copy this file into the source directory, so it will end up in the root of the classpath. Hibernate automatically looks for a file called <literal>hibernate.cfg.xml</literal> in the root of the classpath, on startup."
msgstr ""

#: tutorial.xml:431(title) 
msgid "Building with Ant"
msgstr ""

#: tutorial.xml:433(para) 
msgid "We'll now build the tutorial with Ant. You will need to have Ant installed - get it from the <ulink url=\"http://ant.apache.org/bindownload.cgi\">Ant download page</ulink>. How to install Ant will not be covered here. Please refer to the <ulink url=\"http://ant.apache.org/manual/index.html\">Ant manual</ulink>. After you have installed Ant, we can start to create the buildfile. It will be called <literal>build.xml</literal> and placed directly in the development directory."
msgstr ""

#: tutorial.xml:442(para) 
msgid "A basic build file looks like this:"
msgstr ""

#: tutorial.xml:479(para) 
msgid "This will tell Ant to add all files in the lib directory ending with <literal>.jar</literal> to the classpath used for compilation. It will also copy all non-Java source files to the target directory, e.g. configuration and Hibernate mapping files. If you now run Ant, you should get this output:"
msgstr ""

#: tutorial.xml:501(title) 
msgid "Startup and helpers"
msgstr ""

#: tutorial.xml:503(para) 
msgid "It's time to load and store some <literal>Event</literal> objects, but first we have to complete the setup with some infrastructure code. We have to startup Hibernate. This startup includes building a global <literal>SessionFactory</literal> object and to store it somewhere for easy access in application code. A <literal>SessionFactory</literal> can open up new <literal>Session</literal>'s. A <literal>Session</literal> represents a single-threaded unit of work, the <literal>SessionFactory</literal> is a thread-safe global object, instantiated once."
msgstr ""

#: tutorial.xml:513(para) 
msgid "We'll create a <literal>HibernateUtil</literal> helper class which takes care of startup and makes accessing a <literal>SessionFactory</literal> convenient. Let's have a look at the implementation:"
msgstr ""

#: tutorial.xml:545(para) 
msgid "This class does not only produce the global <literal>SessionFactory</literal> in its static initializer (called once by the JVM when the class is loaded), but also hides the fact that it uses a static singleton. It might as well lookup the <literal>SessionFactory</literal> from JNDI in an application server."
msgstr ""

#: tutorial.xml:552(para) 
msgid "If you give the <literal>SessionFactory</literal> a name in your configuration file, Hibernate will in fact try to bind it to JNDI after it has been built. To avoid this code completely you could also use JMX deployment and let the JMX-capable container instantiate and bind a <literal>HibernateService</literal> to JNDI. These advanced options are discussed in the Hibernate reference documentation."
msgstr ""

#: tutorial.xml:561(para) 
msgid "Place <literal>HibernateUtil.java</literal> in the development source directory, in a package next to <literal>events</literal>:"
msgstr ""

#: tutorial.xml:579(para) 
msgid "This should again compile without problems. We finally need to configure a logging system - Hibernate uses commons logging and leaves you the choice between Log4j and JDK 1.4 logging. Most developers prefer Log4j: copy <literal>log4j.properties</literal> from the Hibernate distribution (it's in the <literal>etc/</literal> directory) to your <literal>src</literal> directory, next to <literal>hibernate.cfg.xml</literal>. Have a look at the example configuration and change the settings if you like to have more verbose output. By default, only Hibernate startup message are shown on stdout."
msgstr ""

#: tutorial.xml:589(para) 
msgid "The tutorial infrastructure is complete - and we are ready to do some real work with Hibernate."
msgstr ""

#: tutorial.xml:597(title) 
msgid "Loading and storing objects"
msgstr ""

#: tutorial.xml:599(para) 
msgid "Finally, we can use Hibernate to load and store objects. We write an <literal>EventManager</literal> class with a <literal>main()</literal> method:"
msgstr ""

#: tutorial.xml:640(para) 
msgid "We create a new <literal>Event</literal> object, and hand it over to Hibernate. Hibernate now takes care of the SQL and executes <literal>INSERT</literal>s on the database. Let's have a look at the <literal>Session</literal> and <literal>Transaction</literal>-handling code before we run this."
msgstr ""

#: tutorial.xml:647(para) 
msgid "A <literal>Session</literal> is a single unit of work. For now we'll keep things simple and assume a one-to-one granularity between a Hibernate <literal>Session</literal> and a database transaction. To shield our code from the actual underlying transaction system (in this case plain JDBC, but it could also run with JTA) we use the <literal>Transaction</literal> API that is available on the Hibernate <literal>Session</literal>."
msgstr ""

#: tutorial.xml:655(para) 
msgid "What does <literal>sessionFactory.getCurrentSession()</literal> do? First, you can call it as many times and anywhere you like, once you get hold of your <literal>SessionFactory</literal> (easy thanks to <literal>HibernateUtil</literal>). The <literal>getCurrentSession()</literal> method always returns the \"current\" unit of work. Remember that we switched the configuration option for this mechanism to \"thread\" in <literal>hibernate.cfg.xml</literal>? Hence, the current unit of work is bound to the current Java thread that executes our application. However, this is not the full picture, you also have to consider scope, when a unit of work begins and when it ends."
msgstr ""

#: tutorial.xml:666(para) 
msgid "A <literal>Session</literal> begins when it is first needed, when the first call to <literal>getCurrentSession()</literal> is made. It is then bound by Hibernate to the current thread. When the transaction ends, either through commit or rollback, Hibernate automatically unbinds the <literal>Session</literal> from the thread and closes it for you. If you call <literal>getCurrentSession()</literal> again, you get a new <literal>Session</literal> and can start a new unit of work. This <emphasis>thread-bound</emphasis> programming model is the most popular way of using Hibernate, as it allows flexible layering of your code (transaction demarcation code can be separated from data access code, we'll do this later in this tutorial)."
msgstr ""

#: tutorial.xml:677(para) 
msgid "Related to the unit of work scope, should the Hibernate <literal>Session</literal> be used to execute one or several database operations? The above example uses one <literal>Session</literal> for one operation. This is pure coincidence, the example is just not complex enough to show any other approach. The scope of a Hibernate <literal>Session</literal> is flexible but you should never design your application to use a new Hibernate <literal>Session</literal> for <emphasis>every</emphasis> database operation. So even if you see it a few more times in the following (very trivial) examples, consider <emphasis>session-per-operation</emphasis> an anti-pattern. A real (web) application is shown later in this tutorial."
msgstr ""

#: tutorial.xml:688(para) 
msgid "Have a look at <xref linkend=\"transactions\"/> for more information about transaction handling and demarcation. We also skipped any error handling and rollback in the previous example."
msgstr ""

#: tutorial.xml:694(para) 
msgid "To run this first routine we have to add a callable target to the Ant build file:"
msgstr ""

#: tutorial.xml:705(para) 
msgid "The value of the <literal>action</literal> argument is set on the command line when calling the target:"
msgstr ""

#: tutorial.xml:712(para) 
msgid "You should see, after compilation, Hibernate starting up and, depending on your configuration, lots of log output. At the end you will find the following line:"
msgstr ""

#: tutorial.xml:719(para) 
msgid "This is the <literal>INSERT</literal> executed by Hibernate, the question marks represent JDBC bind parameters. To see the values bound as arguments, or to reduce the verbosity of the log, check your <literal>log4j.properties</literal>."
msgstr ""

#: tutorial.xml:725(para) 
msgid "Now we'd like to list stored events as well, so we add an option to the main method:"
msgstr ""

#: tutorial.xml:741(para) 
msgid "We also add a new <literal>listEvents() method</literal>:"
msgstr ""

#: tutorial.xml:758(para) 
msgid "What we do here is use an HQL (Hibernate Query Language) query to load all existing <literal>Event</literal> objects from the database. Hibernate will generate the appropriate SQL, send it to the database and populate <literal>Event</literal> objects with the data. You can create more complex queries with HQL, of course."
msgstr ""

#: tutorial.xml:765(para) 
msgid "Now, to execute and test all of this, follow these steps:"
msgstr ""

#: tutorial.xml:771(para) 
msgid "Run <literal>ant run -Daction=store</literal> to store something into the database and, of course, to generate the database schema before through hbm2ddl."
msgstr ""

#: tutorial.xml:777(para) 
msgid "Now disable hbm2ddl by commenting out the property in your <literal>hibernate.cfg.xml</literal> file. Usually you only leave it turned on in continous unit testing, but another run of hbm2ddl would <emphasis>drop</emphasis> everything you have stored - the <literal>create</literal> configuration setting actually translates into \"drop all tables from the schema, then re-create all tables, when the SessionFactory is build\"."
msgstr ""

#: tutorial.xml:787(para) 
msgid "If you now call Ant with <literal>-Daction=list</literal>, you should see the events you have stored so far. You can of course also call the <literal>store</literal> action a few times more."
msgstr ""

#: tutorial.xml:793(para) 
msgid "Note: Most new Hibernate users fail at this point and we see questions about <emphasis>Table not found</emphasis> error messages regularly. However, if you follow the steps outlined above you will not have this problem, as hbm2ddl creates the database schema on the first run, and subsequent application restarts will use this schema. If you change the mapping and/or database schema, you have to re-enable hbm2ddl once again."
msgstr ""

#: tutorial.xml:806(title) 
msgid "Part 2 - Mapping associations"
msgstr ""

#: tutorial.xml:808(para) 
msgid "We mapped a persistent entity class to a table. Let's build on this and add some class associations. First we'll add people to our application, and store a list of events they participate in."
msgstr ""

#: tutorial.xml:814(title) 
msgid "Mapping the Person class"
msgstr ""

#: tutorial.xml:816(para) 
msgid "The first cut of the <literal>Person</literal> class is simple:"
msgstr ""

#: tutorial.xml:835(para) 
msgid "Create a new mapping file called <literal>Person.hbm.xml</literal> (don't forget the DTD reference at the top):"
msgstr ""

#: tutorial.xml:853(para) 
msgid "Finally, add the new mapping to Hibernate's configuration:"
msgstr ""

#: tutorial.xml:860(para) 
msgid "We'll now create an association between these two entities. Obviously, persons can participate in events, and events have participants. The design questions we have to deal with are: directionality, multiplicity, and collection behavior."
msgstr ""

#: tutorial.xml:870(title) 
msgid "A unidirectional Set-based association"
msgstr ""

#: tutorial.xml:872(para) 
msgid "We'll add a collection of events to the <literal>Person</literal> class. That way we can easily navigate to the events for a particular person, without executing an explicit query - by calling <literal>aPerson.getEvents()</literal>. We use a Java collection, a <literal>Set</literal>, because the collection will not contain duplicate elements and the ordering is not relevant for us."
msgstr ""

#: tutorial.xml:879(para) 
msgid "We need a unidirectional, many-valued associations, implemented with a <literal>Set</literal>. Let's write the code for this in the Java classes and then map it:"
msgstr ""

#: tutorial.xml:897(para) 
msgid "Before we map this association, think about the other side. Clearly, we could just keep this unidirectional. Or, we could create another collection on the <literal>Event</literal>, if we want to be able to navigate it bi-directional, i.e. <literal>anEvent.getParticipants()</literal>. This is not necessary, from a functional perspective. You could always execute an explicit query to retrieve the participants for a particular event. This is a design choice left to you, but what is clear from this discussion is the multiplicity of the association: \"many\" valued on both sides, we call this a <emphasis>many-to-many</emphasis> association. Hence, we use Hibernate's many-to-many mapping:"
msgstr ""

#: tutorial.xml:923(para) 
msgid "Hibernate supports all kinds of collection mappings, a <literal>&lt;set&gt;</literal> being most common. For a many-to-many association (or <emphasis>n:m</emphasis> entity relationship), an association table is needed. Each row in this table represents a link between a person and an event. The table name is configured with the <literal>table</literal> attribute of the <literal>set</literal> element. The identifier column name in the association, for the person's side, is defined with the <literal>&lt;key&gt;</literal> element, the column name for the event's side with the <literal>column</literal> attribute of the <literal>&lt;many-to-many&gt;</literal>. You also have to tell Hibernate the class of the objects in your collection (correct: the class on the other side of the collection of references)."
msgstr ""

#: tutorial.xml:935(para) 
msgid "The database schema for this mapping is therefore:"
msgstr ""

#: tutorial.xml:956(title) 
msgid "Working the association"
msgstr ""

#: tutorial.xml:958(para) 
msgid "Let's bring some people and events together in a new method in <literal>EventManager</literal>:"
msgstr ""

#: tutorial.xml:975(para) 
msgid "After loading a <literal>Person</literal> and an <literal>Event</literal>, simply modify the collection using the normal collection methods. As you can see, there is no explicit call to <literal>update()</literal> or <literal>save()</literal>, Hibernate automatically detects that the collection has been modified and needs to be updated. This is called <emphasis>automatic dirty checking</emphasis>, and you can also try it by modifying the name or the date property of any of your objects. As long as they are in <emphasis>persistent</emphasis> state, that is, bound to a particular Hibernate <literal>Session</literal> (i.e. they have been just loaded or saved in a unit of work), Hibernate monitors any changes and executes SQL in a write-behind fashion. The process of synchronizing the memory state with the database, usually only at the end of a unit of work, is called <emphasis>flushing</emphasis>. In our code, the unit of work ends with a commit (or rollback) of the database transaction - as defined by the <literal>thread</literal> configuration option for the <literal>CurrentSessionContext</literal> class."
msgstr ""

#: tutorial.xml:990(para) 
msgid "You might of course load person and event in different units of work. Or you modify an object outside of a <literal>Session</literal>, when it is not in persistent state (if it was persistent before, we call this state <emphasis>detached</emphasis>). You can even modify a collection when it is detached:"
msgstr ""

#: tutorial.xml:1025(para) 
msgid "The call to <literal>update</literal> makes a detached object persistent again, you could say it binds it to a new unit of work, so any modifications you made to it while detached can be saved to the database. This includes any modifications (additions/deletions) you made to a collection of that entity object."
msgstr ""

#: tutorial.xml:1032(para) 
msgid "Well, this is not much use in our current situation, but it's an important concept you can design into your own application. For now, complete this exercise by adding a new action to the <literal>EventManager</literal>'s main method and call it from the command line. If you need the identifiers of a person and an event - the <literal>save()</literal> method returns it (you might have to modify some of the previous methods to return that identifier):"
msgstr ""

#: tutorial.xml:1047(para) 
msgid "This was an example of an association between two equally important classes, two entities. As mentioned earlier, there are other classes and types in a typical model, usually \"less important\". Some you have already seen, like an <literal>int</literal> or a <literal>String</literal>. We call these classes <emphasis>value types</emphasis>, and their instances <emphasis>depend</emphasis> on a particular entity. Instances of these types don't have their own identity, nor are they shared between entities (two persons don't reference the same <literal>firstname</literal> object, even if they have the same first name). Of course, value types can not only be found in the JDK (in fact, in a Hibernate application all JDK classes are considered value types), but you can also write dependent classes yourself, <literal>Address</literal> or <literal>MonetaryAmount</literal>, for example."
msgstr ""

#: tutorial.xml:1060(para) 
msgid "You can also design a collection of value types. This is conceptually very different from a collection of references to other entities, but looks almost the same in Java."
msgstr ""

#: tutorial.xml:1068(title) 
msgid "Collection of values"
msgstr ""

#: tutorial.xml:1070(para) 
msgid "We add a collection of value typed objects to the <literal>Person</literal> entity. We want to store email addresses, so the type we use is <literal>String</literal>, and the collection is again a <literal>Set</literal>:"
msgstr ""

#: tutorial.xml:1085(para) 
msgid "The mapping of this <literal>Set</literal>:"
msgstr ""

#: tutorial.xml:1094(para) 
msgid "The difference compared with the earlier mapping is the <literal>element</literal> part, which tells Hibernate that the collection does not contain references to another entity, but a collection of elements of type <literal>String</literal> (the lowercase name tells you it's a Hibernate mapping type/converter). Once again, the <literal>table</literal> attribute of the <literal>set</literal> element determines the table name for the collection. The <literal>key</literal> element defines the foreign-key column name in the collection table. The <literal>column</literal> attribute in the <literal>element</literal> element defines the column name where the <literal>String</literal> values will actually be stored."
msgstr ""

#: tutorial.xml:1104(para) 
msgid "Have a look at the updated schema:"
msgstr ""

#: tutorial.xml:1122(para) 
msgid "You can see that the primary key of the collection table is in fact a composite key, using both columns. This also implies that there can't be duplicate email addresses per person, which is exactly the semantics we need for a set in Java."
msgstr ""

#: tutorial.xml:1128(para) 
msgid "You can now try and add elements to this collection, just like we did before by linking persons and events. It's the same code in Java:"
msgstr ""

#: tutorial.xml:1146(para) 
msgid "This time we didnt' use a <emphasis>fetch</emphasis> query to initialize the collection. Hence, the call to its getter method will trigger an additional select to initialize it, so we can add an element to it. Monitor the SQL log and try to optimize this with an eager fetch."
msgstr ""

#: tutorial.xml:1156(title) 
msgid "Bi-directional associations"
msgstr ""

#: tutorial.xml:1158(para) 
msgid "Next we are going to map a bi-directional association - making the association between person and event work from both sides in Java. Of course, the database schema doesn't change, we still have many-to-many multiplicity. A relational database is more flexible than a network programming language, so it doesn't need anything like a navigation direction - data can be viewed and retrieved in any possible way."
msgstr ""

#: tutorial.xml:1166(para) 
msgid "First, add a collection of participants to the <literal>Event</literal> Event class:"
msgstr ""

#: tutorial.xml:1180(para) 
msgid "Now map this side of the association too, in <literal>Event.hbm.xml</literal>."
msgstr ""

#: tutorial.xml:1189(para) 
msgid "As you see, these are normal <literal>set</literal> mappings in both mapping documents. Notice that the column names in <literal>key</literal> and <literal>many-to-many</literal> are swapped in both mapping documents. The most important addition here is the <literal>inverse=\"true\"</literal> attribute in the <literal>set</literal> element of the <literal>Event</literal>'s collection mapping."
msgstr ""

#: tutorial.xml:1197(para) 
msgid "What this means is that Hibernate should take the other side - the <literal>Person</literal> class - when it needs to find out information about the link between the two. This will be a lot easier to understand once you see how the bi-directional link between our two entities is created ."
msgstr ""

#: tutorial.xml:1206(title) 
msgid "Working bi-directional links"
msgstr ""

#: tutorial.xml:1208(para) 
msgid "First, keep in mind that Hibernate does not affect normal Java semantics. How did we create a link between a <literal>Person</literal> and an <literal>Event</literal> in the unidirectional example? We added an instance of <literal>Event</literal> to the collection of event references, of an instance of <literal>Person</literal>. So, obviously, if we want to make this link working bi-directional, we have to do the same on the other side - adding a <literal>Person</literal> reference to the collection in an <literal>Event</literal>. This \"setting the link on both sides\" is absolutely necessary and you should never forget doing it."
msgstr ""

#: tutorial.xml:1218(para) 
msgid "Many developers program defensive and create link management methods to correctly set both sides, e.g. in <literal>Person</literal>:"
msgstr ""

#: tutorial.xml:1241(para) 
msgid "Notice that the get and set methods for the collection are now protected - this allows classes in the same package and subclasses to still access the methods, but prevents everybody else from messing with the collections directly (well, almost). You should probably do the same with the collection on the other side."
msgstr ""

#: tutorial.xml:1248(para) 
msgid "What about the <literal>inverse</literal> mapping attribute? For you, and for Java, a bi-directional link is simply a matter of setting the references on both sides correctly. Hibernate however doesn't have enough information to correctly arrange SQL <literal>INSERT</literal> and <literal>UPDATE</literal> statements (to avoid constraint violations), and needs some help to handle bi-directional associations properly. Making one side of the association <literal>inverse</literal> tells Hibernate to basically ignore it, to consider it a <emphasis>mirror</emphasis> of the other side. That's all that is necessary for Hibernate to work out all of the issues when transformation a directional navigation model to a SQL database schema. The rules you have to remember are straightforward: All bi-directional associations need one side as <literal>inverse</literal>. In a one-to-many association it has to be the many-side, in many-to-many association you can pick either side, there is no difference."
msgstr ""

#: tutorial.xml:1263(para) 
msgid "Let's turn this into a small web application."
msgstr ""

#: tutorial.xml:1270(title) 
msgid "Part 3 - The EventManager web application"
msgstr ""

#: tutorial.xml:1272(para) 
msgid "A Hibernate web application uses <literal>Session</literal> and <literal>Transaction</literal> almost like a standalone application. However, some common patterns are useful. We now write an <literal>EventManagerServlet</literal>. This servlet can list all events stored in the database, and it provides an HTML form to enter new events."
msgstr ""

#: tutorial.xml:1280(title) 
msgid "Writing the basic servlet"
msgstr ""

#: tutorial.xml:1282(para) 
msgid "Create a new class in your source directory, in the <literal>events</literal> package:"
msgstr ""

#: tutorial.xml:1296(para) 
msgid "The servlet handles HTTP <literal>GET</literal> requests only, hence, the method we implement is <literal>doGet()</literal>:"
msgstr ""

#: tutorial.xml:1326(para) 
msgid "The pattern we are applying here is called <emphasis>session-per-request</emphasis>. When a request hits the servlet, a new Hibernate <literal>Session</literal> is opened through the first call to <literal>getCurrentSession()</literal> on the <literal>SessionFactory</literal>. Then a database transaction is started-all data access as to occur inside a transaction, no matter if data is read or written (we don't use the auto-commit mode in applications)."
msgstr ""

#: tutorial.xml:1335(para) 
msgid "Do <emphasis>not</emphasis> use a new Hibernate <literal>Session</literal> for every database operation. Use one Hibernate <literal>Session</literal> that is scoped to the whole request. Use <literal>getCurrentSession()</literal>, so that it is automatically bound to the current Java thread."
msgstr ""

#: tutorial.xml:1342(para) 
msgid "Next, the possible actions of the request are processed and the response HTML is rendered. We'll get to that part soon."
msgstr ""

#: tutorial.xml:1347(para) 
msgid "Finally, the unit of work ends when processing and rendering is complete. If any problem occured during processing or rendering, an exception will be thrown and the database transaction rolled back. This completes the <literal>session-per-request</literal> pattern. Instead of the transaction demarcation code in every servlet you could also write a servlet filter. See the Hibernate website and Wiki for more information about this pattern, called <emphasis>Open Session in View</emphasis>-you'll need it as soon as you consider rendering your view in JSP, not in a servlet."
msgstr ""

#: tutorial.xml:1361(title) 
msgid "Processing and rendering"
msgstr ""

#: tutorial.xml:1363(para) 
msgid "Let's implement the processing of the request and rendering of the page."
msgstr ""

#: tutorial.xml:1394(para) 
msgid "Granted, this coding style with a mix of Java and HTML would not scale in a more complex application-keep in mind that we are only illustrating basic Hibernate concepts in this tutorial. The code prints an HTML header and a footer. Inside this page, an HTML form for event entry and a list of all events in the database are printed. The first method is trivial and only outputs HTML:"
msgstr ""

#: tutorial.xml:1412(para) 
msgid "The <literal>listEvents()</literal> method uses the Hibernate <literal>Session</literal> bound to the current thread to execute a query:"
msgstr ""

#: tutorial.xml:1440(para) 
msgid "Finally, the <literal>store</literal> action is dispatched to the <literal>createAndStoreEvent()</literal> method, which also uses the <literal>Session</literal> of the current thread:"
msgstr ""

#: tutorial.xml:1455(para) 
msgid "That's it, the servlet is complete. A request to the servlet will be processed in a single <literal>Session</literal> and <literal>Transaction</literal>. As earlier in the standalone application, Hibernate can automatically bind these ojects to the current thread of execution. This gives you the freedom to layer your code and access the <literal>SessionFactory</literal> in any way you like. Usually you'd use a more sophisticated design and move the data access code into data access objects (the DAO pattern). See the Hibernate Wiki for more examples."
msgstr ""

#: tutorial.xml:1469(title) 
msgid "Deploying and testing"
msgstr ""

#: tutorial.xml:1471(para) 
msgid "To deploy this application you have to create a web archive, a WAR. Add the following Ant target to your <literal>build.xml</literal>:"
msgstr ""

#: tutorial.xml:1486(para) 
msgid "This target creates a file called <literal>hibernate-tutorial.war</literal> in your project directory. It packages all libraries and the <literal>web.xml</literal> descriptor, which is expected in the base directory of your project:"
msgstr ""

#: tutorial.xml:1509(para) 
msgid "Before you compile and deploy the web application, note that an additional library is required: <literal>jsdk.jar</literal>. This is the Java servlet development kit, if you don't have this library already, get it from the Sun website and copy it to your library directory. However, it will be only used for compliation and excluded from the WAR package."
msgstr ""

#: tutorial.xml:1517(para) 
msgid "To build and deploy call <literal>ant war</literal> in your project directory and copy the <literal>hibernate-tutorial.war</literal> file into your Tomcat <literal>webapp</literal> directory. If you don't have Tomcat installed, download it and follow the installation instructions. You don't have to change any Tomcat configuration to deploy this application though."
msgstr ""

#: tutorial.xml:1525(para) 
msgid "Once deployed and Tomcat is running, access the application at <literal>http://localhost:8080/hibernate-tutorial/eventmanager</literal>. Make sure you watch the Tomcat log to see Hibernate initialize when the first request hits your servlet (the static initializer in <literal>HibernateUtil</literal> is called) and to get the detailed output if any exceptions occurs."
msgstr ""

#: tutorial.xml:1538(title) 
msgid "Summary"
msgstr ""

#: tutorial.xml:1540(para) 
msgid "This tutorial covered the basics of writing a simple standalone Hibernate application and a small web application."
msgstr ""

#: tutorial.xml:1545(para) 
msgid "If you already feel confident with Hibernate, continue browsing through the reference documentation table of contents for topics you find interesting - most asked are transactional processing (<xref linkend=\"transactions\"/>), fetch performance (<xref linkend=\"performance\"/>), or the usage of the API (<xref linkend=\"objectstate\"/>) and the query features (<xref linkend=\"objectstate-querying\"/>)."
msgstr ""

#: tutorial.xml:1553(para) 
msgid "Don't forget to check the Hibernate website for more (specialized) tutorials."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2.
#: tutorial.xml:0(None) 
msgid "translator-credits"
msgstr ""

