msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2007-10-19 10:29-0500\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: best_practices.xml:5(title) 
msgid "Best Practices"
msgstr ""

#: best_practices.xml:9(term) 
msgid "Write fine-grained classes and map them using <literal>&lt;component&gt;</literal>."
msgstr ""

#: best_practices.xml:11(para) 
msgid "Use an <literal>Address</literal> class to encapsulate <literal>street</literal>, <literal>suburb</literal>, <literal>state</literal>, <literal>postcode</literal>. This encourages code reuse and simplifies refactoring."
msgstr ""

#: best_practices.xml:19(term) 
msgid "Declare identifier properties on persistent classes."
msgstr ""

#: best_practices.xml:21(para) 
msgid "Hibernate makes identifier properties optional. There are all sorts of reasons why you should use them. We recommend that identifiers be 'synthetic' (generated, with no business meaning)."
msgstr ""

#: best_practices.xml:29(term) 
msgid "Identify natural keys."
msgstr ""

#: best_practices.xml:31(para) 
msgid "Identify natural keys for all entities, and map them using <literal>&lt;natural-id&gt;</literal>. Implement <literal>equals()</literal> and <literal>hashCode()</literal> to compare the properties that make up the natural key."
msgstr ""

#: best_practices.xml:39(term) 
msgid "Place each class mapping in its own file."
msgstr ""

#: best_practices.xml:41(para) 
msgid "Don't use a single monolithic mapping document. Map <literal>com.eg.Foo</literal> in the file <literal>com/eg/Foo.hbm.xml</literal>. This makes particularly good sense in a team environment."
msgstr ""

#: best_practices.xml:49(term) 
msgid "Load mappings as resources."
msgstr ""

#: best_practices.xml:51(para) 
msgid "Deploy the mappings along with the classes they map."
msgstr ""

#: best_practices.xml:57(term) 
msgid "Consider externalising query strings."
msgstr ""

#: best_practices.xml:59(para) 
msgid "This is a good practice if your queries call non-ANSI-standard SQL functions. Externalising the query strings to mapping files will make the application more portable."
msgstr ""

#: best_practices.xml:67(term) 
msgid "Use bind variables."
msgstr ""

#: best_practices.xml:69(para) 
msgid "As in JDBC, always replace non-constant values by \"?\". Never use string manipulation to bind a non-constant value in a query! Even better, consider using named parameters in queries."
msgstr ""

#: best_practices.xml:77(term) 
msgid "Don't manage your own JDBC connections."
msgstr ""

#: best_practices.xml:79(para) 
msgid "Hibernate lets the application manage JDBC connections. This approach should be considered a last-resort. If you can't use the built-in connections providers, consider providing your own implementation of <literal>org.hibernate.connection.ConnectionProvider</literal>."
msgstr ""

#: best_practices.xml:87(term) 
msgid "Consider using a custom type."
msgstr ""

#: best_practices.xml:89(para) 
msgid "Suppose you have a Java type, say from some library, that needs to be persisted but doesn't provide the accessors needed to map it as a component. You should consider implementing <literal>org.hibernate.UserType</literal>. This approach frees the application code from implementing transformations to / from a Hibernate type."
msgstr ""

#: best_practices.xml:98(term) 
msgid "Use hand-coded JDBC in bottlenecks."
msgstr ""

#: best_practices.xml:100(para) 
msgid "In performance-critical areas of the system, some kinds of operations might benefit from direct JDBC. But please, wait until you <emphasis>know</emphasis> something is a bottleneck. And don't assume that direct JDBC is necessarily faster. If you need to use direct JDBC, it might be worth opening a Hibernate <literal>Session</literal> and using that JDBC connection. That way you can still use the same transaction strategy and underlying connection provider."
msgstr ""

#: best_practices.xml:110(term) 
msgid "Understand <literal>Session</literal> flushing."
msgstr ""

#: best_practices.xml:112(para) 
msgid "From time to time the Session synchronizes its persistent state with the database. Performance will be affected if this process occurs too often. You may sometimes minimize unnecessary flushing by disabling automatic flushing or even by changing the order of queries and other operations within a particular transaction."
msgstr ""

#: best_practices.xml:121(term) 
msgid "In a three tiered architecture, consider using detached objects."
msgstr ""

#: best_practices.xml:123(para) 
msgid "When using a servlet / session bean architecture, you could pass persistent objects loaded in the session bean to and from the servlet / JSP layer. Use a new session to service each request. Use <literal>Session.merge()</literal> or <literal>Session.saveOrUpdate()</literal> to synchronize objects with the database."
msgstr ""

#: best_practices.xml:132(term) 
msgid "In a two tiered architecture, consider using long persistence contexts."
msgstr ""

#: best_practices.xml:134(para) 
msgid "Database Transactions have to be as short as possible for best scalability. However, it is often neccessary to implement long running <emphasis>application transactions</emphasis>, a single unit-of-work from the point of view of a user. An application transaction might span several client request/response cycles. It is common to use detached objects to implement application transactions. An alternative, extremely appropriate in two tiered architecture, is to maintain a single open persistence contact (session) for the whole life cycle of the application transaction and simply disconnect from the JDBC connection at the end of each request and reconnect at the beginning of the subsequent request. Never share a single session across more than one application transaction, or you will be working with stale data."
msgstr ""

#: best_practices.xml:148(term) 
msgid "Don't treat exceptions as recoverable."
msgstr ""

#: best_practices.xml:150(para) 
msgid "This is more of a necessary practice than a \"best\" practice. When an exception occurs, roll back the <literal>Transaction</literal> and close the <literal>Session</literal>. If you don't, Hibernate can't guarantee that in-memory state accurately represents persistent state. As a special case of this, do not use <literal>Session.load()</literal> to determine if an instance with the given identifier exists on the database; use <literal>Session.get()</literal> or a query instead."
msgstr ""

#: best_practices.xml:160(term) 
msgid "Prefer lazy fetching for associations."
msgstr ""

#: best_practices.xml:162(para) 
msgid "Use eager fetching sparingly. Use proxies and lazy collections for most associations to classes that are not likely to be completely held in the second-level cache. For associations to cached classes, where there is an a extremely high probability of a cache hit, explicitly disable eager fetching using <literal>lazy=\"false\"</literal>. When an join fetching is appropriate to a particular use case, use a query with a <literal>left join fetch</literal>."
msgstr ""

#: best_practices.xml:172(term) 
msgid "Use the <emphasis>open session in view</emphasis> pattern, or a disciplined <emphasis>assembly phase</emphasis> to avoid problems with unfetched data."
msgstr ""

#: best_practices.xml:177(para) 
msgid "Hibernate frees the developer from writing tedious <emphasis>Data Transfer Objects</emphasis> (DTO). In a traditional EJB architecture, DTOs serve dual purposes: first, they work around the problem that entity beans are not serializable; second, they implicitly define an assembly phase where all data to be used by the view is fetched and marshalled into the DTOs before returning control to the presentation tier. Hibernate eliminates the first purpose. However, you will still need an assembly phase (think of your business methods as having a strict contract with the presentation tier about what data is available in the detached objects) unless you are prepared to hold the persistence context (the session) open across the view rendering process. This is not a limitation of Hibernate! It is a fundamental requirement of safe transactional data access."
msgstr ""

#: best_practices.xml:191(term) 
msgid "Consider abstracting your business logic from Hibernate."
msgstr ""

#: best_practices.xml:193(para) 
msgid "Hide (Hibernate) data-access code behind an interface. Combine the <emphasis>DAO</emphasis> and <emphasis>Thread Local Session</emphasis> patterns. You can even have some classes persisted by handcoded JDBC, associated to Hibernate via a <literal>UserType</literal>. (This advice is intended for \"sufficiently large\" applications; it is not appropriate for an application with five tables!)"
msgstr ""

#: best_practices.xml:203(term) 
msgid "Don't use exotic association mappings."
msgstr ""

#: best_practices.xml:205(para) 
msgid "Good usecases for a real many-to-many associations are rare. Most of the time you need additional information stored in the \"link table\". In this case, it is much better to use two one-to-many associations to an intermediate link class. In fact, we think that most associations are one-to-many and many-to-one, you should be careful when using any other association style and ask yourself if it is really neccessary."
msgstr ""

#: best_practices.xml:215(term) 
msgid "Prefer bidirectional associations."
msgstr ""

#: best_practices.xml:217(para) 
msgid "Unidirectional associations are more difficult to query. In a large application, almost all associations must be navigable in both directions in queries."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2.
#: best_practices.xml:0(None) 
msgid "translator-credits"
msgstr ""

