msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2007-10-19 10:32-0500\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: inheritance_mapping.xml:5(title) 
msgid "Inheritance Mapping"
msgstr ""

#: inheritance_mapping.xml:8(title) 
msgid "The Three Strategies"
msgstr ""

#: inheritance_mapping.xml:10(para) 
msgid "Hibernate supports the three basic inheritance mapping strategies:"
msgstr ""

#: inheritance_mapping.xml:16(para) 
msgid "table per class hierarchy"
msgstr ""

#: inheritance_mapping.xml:21(para) inheritance_mapping.xml:456(entry) 
msgid "table per subclass"
msgstr ""

#: inheritance_mapping.xml:26(para) 
msgid "table per concrete class"
msgstr ""

#: inheritance_mapping.xml:32(para) 
msgid "In addition, Hibernate supports a fourth, slightly different kind of polymorphism:"
msgstr ""

#: inheritance_mapping.xml:39(para) 
msgid "implicit polymorphism"
msgstr ""

#: inheritance_mapping.xml:45(para) 
msgid "It is possible to use different mapping strategies for different branches of the same inheritance hierarchy, and then make use of implicit polymorphism to achieve polymorphism across the whole hierarchy. However, Hibernate does not support mixing <literal>&lt;subclass&gt;</literal>, and <literal>&lt;joined-subclass&gt;</literal> and <literal>&lt;union-subclass&gt;</literal> mappings under the same root <literal>&lt;class&gt;</literal> element. It is possible to mix together the table per hierarchy and table per subclass strategies, under the the same <literal>&lt;class&gt;</literal> element, by combining the <literal>&lt;subclass&gt;</literal> and <literal>&lt;join&gt;</literal> elements (see below)."
msgstr ""

#: inheritance_mapping.xml:59(para) 
msgid "It is possible to define <literal>subclass</literal>, <literal>union-subclass</literal>, and <literal>joined-subclass</literal> mappings in separate mapping documents, directly beneath <literal>hibernate-mapping</literal>. This allows you to extend a class hierachy just by adding a new mapping file. You must specify an <literal>extends</literal> attribute in the subclass mapping, naming a previously mapped superclass. Note: Previously this feature made the ordering of the mapping documents important. Since Hibernate3, the ordering of mapping files does not matter when using the extends keyword. The ordering inside a single mapping file still needs to be defined as superclasses before subclasses."
msgstr ""

#: inheritance_mapping.xml:79(title) 
msgid "Table per class hierarchy"
msgstr ""

#: inheritance_mapping.xml:81(para) 
msgid "Suppose we have an interface <literal>Payment</literal>, with implementors <literal>CreditCardPayment</literal>, <literal>CashPayment</literal>, <literal>ChequePayment</literal>. The table per hierarchy mapping would look like:"
msgstr ""

#: inheritance_mapping.xml:107(para) 
msgid "Exactly one table is required. There is one big limitation of this mapping strategy: columns declared by the subclasses, such as <literal>CCTYPE</literal>, may not have <literal>NOT NULL</literal> constraints."
msgstr ""

#: inheritance_mapping.xml:116(title) 
msgid "Table per subclass"
msgstr ""

#: inheritance_mapping.xml:118(para) 
msgid "A table per subclass mapping would look like:"
msgstr ""

#: inheritance_mapping.xml:143(para) 
msgid "Four tables are required. The three subclass tables have primary key associations to the superclass table (so the relational model is actually a one-to-one association)."
msgstr ""

#: inheritance_mapping.xml:152(title) 
msgid "Table per subclass, using a discriminator"
msgstr ""

#: inheritance_mapping.xml:154(para) 
msgid "Note that Hibernate's implementation of table per subclass requires no discriminator column. Other object/relational mappers use a different implementation of table per subclass which requires a type discriminator column in the superclass table. The approach taken by Hibernate is much more difficult to implement but arguably more correct from a relational point of view. If you would like to use a discriminator column with the table per subclass strategy, you may combine the use of <literal>&lt;subclass&gt;</literal> and <literal>&lt;join&gt;</literal>, as follow:"
msgstr ""

#: inheritance_mapping.xml:194(para) 
msgid "The optional <literal>fetch=\"select\"</literal> declaration tells Hibernate not to fetch the <literal>ChequePayment</literal> subclass data using an outer join when querying the superclass."
msgstr ""

#: inheritance_mapping.xml:203(title) 
msgid "Mixing table per class hierarchy with table per subclass"
msgstr ""

#: inheritance_mapping.xml:205(para) 
msgid "You may even mix the table per hierarchy and table per subclass strategies using this approach:"
msgstr ""

#: inheritance_mapping.xml:231(para) 
msgid "For any of these mapping strategies, a polymorphic association to the root <literal>Payment</literal> class is mapped using <literal>&lt;many-to-one&gt;</literal>."
msgstr ""

#: inheritance_mapping.xml:242(title) 
msgid "Table per concrete class"
msgstr ""

#: inheritance_mapping.xml:244(para) 
msgid "There are two ways we could go about mapping the table per concrete class strategy. The first is to use <literal>&lt;union-subclass&gt;</literal>."
msgstr ""

#: inheritance_mapping.xml:267(para) 
msgid "Three tables are involved for the subclasses. Each table defines columns for all properties of the class, including inherited properties."
msgstr ""

#: inheritance_mapping.xml:272(para) 
msgid "The limitation of this approach is that if a property is mapped on the superclass, the column name must be the same on all subclass tables. (We might relax this in a future release of Hibernate.) The identity generator strategy is not allowed in union subclass inheritance, indeed the primary key seed has to be shared accross all unioned subclasses of a hierarchy."
msgstr ""

#: inheritance_mapping.xml:281(para) 
msgid "If your superclass is abstract, map it with <literal>abstract=\"true\"</literal>. Of course, if it is not abstract, an additional table (defaults to <literal>PAYMENT</literal> in the example above) is needed to hold instances of the superclass."
msgstr ""

#: inheritance_mapping.xml:291(title) 
msgid "Table per concrete class, using implicit polymorphism"
msgstr ""

#: inheritance_mapping.xml:293(para) 
msgid "An alternative approach is to make use of implicit polymorphism:"
msgstr ""

#: inheritance_mapping.xml:321(para) 
msgid "Notice that nowhere do we mention the <literal>Payment</literal> interface explicitly. Also notice that properties of <literal>Payment</literal> are mapped in each of the subclasses. If you want to avoid duplication, consider using XML entities (e.g. <literal>[ &lt;!ENTITY allproperties SYSTEM \"allproperties.xml\"&gt; ]</literal> in the <literal>DOCTYPE</literal> declartion and <literal>&amp;allproperties;</literal> in the mapping)."
msgstr ""

#: inheritance_mapping.xml:331(para) 
msgid "The disadvantage of this approach is that Hibernate does not generate SQL <literal>UNION</literal>s when performing polymorphic queries."
msgstr ""

#: inheritance_mapping.xml:336(para) 
msgid "For this mapping strategy, a polymorphic association to <literal>Payment</literal> is usually mapped using <literal>&lt;any&gt;</literal>."
msgstr ""

#: inheritance_mapping.xml:352(title) 
msgid "Mixing implicit polymorphism with other inheritance mappings"
msgstr ""

#: inheritance_mapping.xml:354(para) 
msgid "There is one further thing to notice about this mapping. Since the subclasses are each mapped in their own <literal>&lt;class&gt;</literal> element (and since <literal>Payment</literal> is just an interface), each of the subclasses could easily be part of another inheritance hierarchy! (And you can still use polymorphic queries against the <literal>Payment</literal> interface.)"
msgstr ""

#: inheritance_mapping.xml:390(para) 
msgid "Once again, we don't mention <literal>Payment</literal> explicitly. If we execute a query against the <literal>Payment</literal> interface - for example, <literal>from Payment</literal> - Hibernate automatically returns instances of <literal>CreditCardPayment</literal> (and its subclasses, since they also implement <literal>Payment</literal>), <literal>CashPayment</literal> and <literal>ChequePayment</literal> but not instances of <literal>NonelectronicTransaction</literal>."
msgstr ""

#: inheritance_mapping.xml:405(title) 
msgid "Limitations"
msgstr ""

#: inheritance_mapping.xml:407(para) 
msgid "There are certain limitations to the \"implicit polymorphism\" approach to the table per concrete-class mapping strategy. There are somewhat less restrictive limitations to <literal>&lt;union-subclass&gt;</literal> mappings."
msgstr ""

#: inheritance_mapping.xml:414(para) 
msgid "The following table shows the limitations of table per concrete-class mappings, and of implicit polymorphism, in Hibernate."
msgstr ""

#: inheritance_mapping.xml:420(title) 
msgid "Features of inheritance mappings"
msgstr ""

#: inheritance_mapping.xml:432(entry) 
msgid "Inheritance strategy"
msgstr ""

#: inheritance_mapping.xml:433(entry) 
msgid "Polymorphic many-to-one"
msgstr ""

#: inheritance_mapping.xml:434(entry) 
msgid "Polymorphic one-to-one"
msgstr ""

#: inheritance_mapping.xml:435(entry) 
msgid "Polymorphic one-to-many"
msgstr ""

#: inheritance_mapping.xml:436(entry) 
msgid "Polymorphic many-to-many"
msgstr ""

#: inheritance_mapping.xml:437(literal) 
msgid "load()/get()"
msgstr ""

#: inheritance_mapping.xml:437(entry) 
msgid "Polymorphic <placeholder-1/>"
msgstr ""

#: inheritance_mapping.xml:438(entry) 
msgid "Polymorphic queries"
msgstr ""

#: inheritance_mapping.xml:439(entry) 
msgid "Polymorphic joins"
msgstr ""

#: inheritance_mapping.xml:440(entry) 
msgid "Outer join fetching"
msgstr ""

#: inheritance_mapping.xml:445(entry) 
msgid "table per class-hierarchy"
msgstr ""

#: inheritance_mapping.xml:446(literal) inheritance_mapping.xml:457(literal) inheritance_mapping.xml:468(literal) 
msgid "&lt;many-to-one&gt;"
msgstr ""

#: inheritance_mapping.xml:447(literal) inheritance_mapping.xml:458(literal) inheritance_mapping.xml:469(literal) 
msgid "&lt;one-to-one&gt;"
msgstr ""

#: inheritance_mapping.xml:448(literal) inheritance_mapping.xml:459(literal) inheritance_mapping.xml:470(literal) 
msgid "&lt;one-to-many&gt;"
msgstr ""

#: inheritance_mapping.xml:449(literal) inheritance_mapping.xml:460(literal) inheritance_mapping.xml:471(literal) 
msgid "&lt;many-to-many&gt;"
msgstr ""

#: inheritance_mapping.xml:450(literal) inheritance_mapping.xml:461(literal) inheritance_mapping.xml:472(literal) 
msgid "s.get(Payment.class, id)"
msgstr ""

#: inheritance_mapping.xml:451(literal) inheritance_mapping.xml:462(literal) inheritance_mapping.xml:473(literal) inheritance_mapping.xml:484(literal) 
msgid "from Payment p"
msgstr ""

#: inheritance_mapping.xml:452(literal) inheritance_mapping.xml:463(literal) inheritance_mapping.xml:474(literal) 
msgid "from Order o join o.payment p"
msgstr ""

#: inheritance_mapping.xml:453(emphasis) inheritance_mapping.xml:464(emphasis) inheritance_mapping.xml:475(emphasis) 
msgid "supported"
msgstr ""

#: inheritance_mapping.xml:467(entry) 
msgid "table per concrete-class (union-subclass)"
msgstr ""

#: inheritance_mapping.xml:470(literal) 
msgid "inverse=\"true\""
msgstr ""

#: inheritance_mapping.xml:470(entry) 
msgid "<placeholder-1/> (for <placeholder-2/> only)"
msgstr ""

#: inheritance_mapping.xml:478(entry) 
msgid "table per concrete class (implicit polymorphism)"
msgstr ""

#: inheritance_mapping.xml:479(literal) 
msgid "&lt;any&gt;"
msgstr ""

#: inheritance_mapping.xml:480(emphasis) inheritance_mapping.xml:481(emphasis) inheritance_mapping.xml:485(emphasis) inheritance_mapping.xml:486(emphasis) 
msgid "not supported"
msgstr ""

#: inheritance_mapping.xml:482(literal) 
msgid "&lt;many-to-any&gt;"
msgstr ""

#: inheritance_mapping.xml:483(literal) 
msgid "s.createCriteria(Payment.class).add( Restrictions.idEq(id) ).uniqueResult()"
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2.
#: inheritance_mapping.xml:0(None) 
msgid "translator-credits"
msgstr ""

