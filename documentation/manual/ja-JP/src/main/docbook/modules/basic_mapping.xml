<?xml version="1.0" encoding="Shift_JIS"?>

<chapter id="mapping">
    <title>基本的なO/Rマッピング</title>

    <sect1 id="mapping-declaration" revision="1">
        <title>マッピング定義</title>

        <para>
            オブジェクト/リレーショナルマッピングは通常XMLドキュメントで定義します。
            マッピングドキュメントは、読みやすく手作業で編集しやすいようにデザインされています。
            マッピング言語はJava中心、つまりテーブル定義ではなく永続クラスの定義に基づいて構築されています。
        </para>
        
        <para>
            多くのHibernateユーザはXMLマッピングの記述を手作業で行いますが、
            XDoclet, Middlegen, AndroMDAというようなマッピングドキュメントを生成するツールが
            いくつか存在します。
        </para>

        <para>
            サンプルのマッピングから始めましょう：
        </para>

        <programlisting id="mapping-declaration-ex1" revision="1"><![CDATA[<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC
      "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
          "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">

<hibernate-mapping package="eg">

        <class name="Cat" 
            table="cats"
            discriminator-value="C">
                
                <id name="id">
                        <generator class="native"/>
                </id>

                <discriminator column="subclass" 
                     type="character"/>

                <property name="weight"/>

                <property name="birthdate"
                    type="date" 
                    not-null="true" 
                    update="false"/>

                <property name="color"
                    type="eg.types.ColorUserType"
                    not-null="true"
                    update="false"/>

                <property name="sex"
                    not-null="true" 
                    update="false"/>

                <property name="litterId"
                    column="litterId"
                    update="false"/>

                <many-to-one name="mother"
                    column="mother_id"
                    update="false"/>

                <set name="kittens"
                    inverse="true"
                    order-by="litter_id">
                        <key column="mother_id"/>
                        <one-to-many class="Cat"/>
                </set>

                <subclass name="DomesticCat"
                    discriminator-value="D">

                        <property name="name" 
                            type="string"/>

                </subclass>

        </class>

        <class name="Dog">
                <!-- ここにDog用のマッピング書きます -->
        </class>

</hibernate-mapping>]]></programlisting>

        <para>
             マッピングドキュメントの内容を説明します。。
            ただし、ここではHibernateが実行時に使うドキュメント要素と属性についてのみ説明します。
            マッピングドキュメントは、いくつかのオプション属性と要素を含んでいます（例えば <literal>not-null</literal> 属性）。
            それらはスキーマエクスポートツールが出力するデータベーススキーマに影響を与えるものです。
            
        </para>



        <sect2 id="mapping-declaration-doctype" revision="3">
            <title>Doctype</title>

            <para>
                XMLマッピングでは、お見せしたようなドキュメント型を必ず定義すべきです。
                実際のDTDは、上記のURLの <literal>hibernate-x.x.x/src/org/hibernate</literal> ディレクトリ、 または 
                <literal>hibernate.jar</literal> 内にあります。
                Hibernateは常に、そのクラスパス内でDTDを探し始めます。
                インターネットにあるDTDファイルを探そうとしたなら、
                クラスパスの内容を見て、DTD宣言を確認してください。
            </para>
            
            
            
            <sect3 id="mapping-declaration-entity-resolution">
                <title>
                エンティティ・リゾルバ
                </title>
                <para>
                    前述したように、Hibernateはまずクラスパス内でDTDを解決しようとします。
                    <literal>org.xml.sax.EntityResolver</literal> のカスタム実装を
                    XMLファイルを読み込むためのSAXReaderに登録することによって、DTDを解決します。
                    このカスタムの <literal>EntityResolver</literal> は2つの異なるシステムID名前空間を認識します。
                    
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            <literal>Hibernate名前空間</literal> は、リゾルバが 
                            <literal>http://hibernate.sourceforge.net/</literal> で始まるシステムIDに到達したときに、
                            認識されます。
                            そしてリゾルバは、Hibernateのクラスをロードしたクラスローダを用いて、
                            これらのエンティティを解決しようとします。
                        
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                          <literal>ユーザ名前空間</literal> は、リゾルバが
                          URLプロトコルの <literal>classpath://</literal> を使ったシステムIDに到達したときに、
                          認識されます。そしてリゾルバは、(1)カレントスレッドのコンテキストクラスローダー、
                          または(2)Hibernateのクラスをロードしたクラスローダを使って、
                          これらのエンティティを解決しようとします。
                        
                        </para>
                    </listitem>
                </itemizedlist>
                <para>
                下記は、ユーザ名前空間を使った例です：
                
                </para>
                <programlisting><![CDATA[<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd" [
    <!ENTITY types SYSTEM "classpath://your/domain/types.xml">
]>

<hibernate-mapping package="your.domain">
    <class name="MyEntity">
        <id name="id" type="my-custom-id-type">
            ...
        </id>
    <class>
    &types;
</hibernate-mapping>]]></programlisting>
                <para>
                ここで <literal>types.xml</literal> は <literal>your.domain</literal> パッケージ内のリソースであり、
                カスタム <xref linkend="mapping-types-custom">typedef</xref> を含むます。
                </para>
            </sect3>            
            
            
        </sect2>

        <sect2 id="mapping-declaration-mapping" revision="3">
            <title>hibernate-mapping</title>

            <para>
                この要素にはいくつかオプション属性があります。<literal>schema</literal> 属性と <literal>catalog</literal> 属性は、
                このマッピングが参照するテーブルが、この属性によって指定されたスキーマと(または)カタログに属することを指定します。
                この属性が指定されると、テーブル名は与えられたスキーマ名とカタログ名で修飾されます。これらの属性が指定されていなければ、
                テーブル名は修飾されません。<literal>default-cascade</literal> 属性は、
                <literal>cascade</literal> 属性を指定していないプロパティやコレクションに、
                どのカスケードスタイルを割り当てるかを指定します。
                <literal>auto-import</literal> 属性は、
                クエリ言語内で修飾されていないクラス名を、デフォルトで使えるようにします。
            </para>
 
             <programlistingco>
                 <areaspec>
                     <area id="hm1" coords="2 55"/>
                     <area id="hm2" coords="3 55"/>
                     <area id="hm3" coords="4 55"/>
                     <area id="hm4" coords="5 55"/>
                     <area id="hm5" coords="6 55"/>
                     <area id="hm6" coords="7 55"/>
                     <area id="hm7" coords="8 55"/>
                 </areaspec>
                 <programlisting><![CDATA[<hibernate-mapping
         schema="schemaName"
         catalog="catalogName"
         default-cascade="cascade_style"
         default-access="field|property|ClassName"
         default-lazy="true|false"
         auto-import="true|false"
         package="package.name"
 />]]></programlisting>
                 <calloutlist>
                     <callout arearefs="hm1">
                         <para>
                             <literal>schema</literal>（オプション）：データベーススキーマの名前。
                         </para>
                     </callout>
                     <callout arearefs="hm2">
                         <para>
                             <literal>catalog</literal> （オプション）：データベースカタログの名前。
                         </para>
                     </callout>
                     <callout arearefs="hm3">
                         <para>
                            <literal>default-cascade</literal> （オプション - デフォルトは <literal>none</literal>）：
                             デフォルトのカスケードスタイル。
                         </para>
                     </callout>
                     <callout arearefs="hm4">
                         <para>
                             <literal>default-access</literal> (オプション - デフォルトは <literal>property</literal> ）：
                             Hibernateがプロパティにアクセスする際に採るべき戦略。 <literal>PropertyAccessor</literal> 
                             を実装することでカスタマイズ可能。
                             
                         </para>
                     </callout>
                     <callout arearefs="hm5">
                         <para>
                             <literal>default-lazy</literal> (オプション - デフォルトは <literal>true</literal> )：
                              <literal>lazy</literal> 属性が指定されていないクラスやコレクションマッピングに対するデフォルト値。
                         </para>
                     </callout>
                     <callout arearefs="hm6">
                         <para>
                             <literal>auto-import</literal> （オプション - デフォルトは <literal>true</literal>）：
                             クエリ言語内で、（このマッピング内のクラスの）修飾されていないクラス名を使えるかどうかを指定します。
                         </para>
                     </callout>
                     <callout arearefs="hm7">
                         <para>
                             <literal>package</literal> (オプション): マッピングドキュメント内で修飾されていないクラス名に対して割り当てる、
                             パッケージの接頭辞(prefix)を指定します。
                         </para>
                     </callout>
                 </calloutlist>
             </programlistingco>
             
             <para>
                 （修飾されていない）同じ名前の永続クラスが2つあるなら、
                 <literal>auto-import="false"</literal> を設定すべきです。
                 2つのクラスに”インポートされた”同じ名前を割り当てようとすると、Hibernateは例外を投げます。
             </para>

             <para>
                 <literal>hibernate-mapping</literal> 要素は、最初の例で示したようにいくつかの永続 <literal>&lt;class&gt;</literal> 
                 マッピングをネストできます。
                 しかし、１つのマッピングファイルではただひとつの永続クラス(またはひとつのクラス階層)にマッピングするようにし、
                 さらに永続スーパークラスの後で指定するべきでしょう(いくつかのツールはこのようなマッピングファイルを想定しています)。
                 例えば次のようになります。： <literal>Cat.hbm.xml</literal> ,
                  <literal>Dog.hbm.xml</literal> , または継承を使うなら <literal>Animal.hbm.xml</literal> 。
             </para>
 
        </sect2>

        <sect2 id="mapping-declaration-class" revision="3">
            <title>class</title>

            <para>
                <literal>class</literal> 要素を使って、永続クラスを宣言できます。
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="class1" coords="2 55"/>
                    <area id="class2" coords="3 55" />
                    <area id="class3" coords="4 55"/>
                    <area id="class4" coords="5 55" />
                    <area id="class5" coords="6 55"/>
                    <area id="class6" coords="7 55" />
                    <area id="class7" coords="8 55"/>
                    <area id="class8" coords="9 55" />
                    <area id="class9" coords="10 55" />
                    <area id="class10" coords="11 55"/>
                    <area id="class11" coords="12 55"/>
                    <area id="class12" coords="13 55"/>
                    <area id="class13" coords="14 55"/>
                    <area id="class14" coords="15 55"/>
                    <area id="class15" coords="16 55"/>
                    <area id="class16" coords="17 55"/>
                    <area id="class17" coords="18 55"/>
                    <area id="class18" coords="19 55"/>
                    <area id="class19" coords="20 55"/>
                    <area id="class20" coords="21 55"/>
                    <area id="class21" coords="22 55"/>

                </areaspec>
                <programlisting><![CDATA[<class
        name="ClassName"
        table="tableName"
        discriminator-value="discriminator_value"
        mutable="true|false"
        schema="owner"
        catalog="catalog"
        proxy="ProxyInterface"
        dynamic-update="true|false"
        dynamic-insert="true|false"
        select-before-update="true|false"
        polymorphism="implicit|explicit"
        where="arbitrary sql where condition"
        persister="PersisterClass"
        batch-size="N"
        optimistic-lock="none|version|dirty|all"
        lazy="true|false"
        entity-name="EntityName"
        check="arbitrary sql check condition"
        rowid="rowid"
        subselect="SQL expression"
        abstract="true|false"
        entity-name="EntityName"
        node="element-name"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="class1">
                        <para>
                            <literal>name</literal> (オプション)：永続クラス（またはインターフェイス）の完全修飾Javaクラス名。
                            もしこの属性を指定しなければ、POJOではないエンティティに対するマッピングとして扱われます。
                            
                        </para>
                    </callout>
                    <callout arearefs="class2">
                        <para>
                           <literal>table</literal> (オプション - デフォルトは修飾されていないクラス名)：データベーステーブルの名前
                        </para>
                    </callout>
                    <callout arearefs="class3">
                        <para>
                            <literal>discriminator-value</literal> (オプション - デフォルトはクラス名)：
                            ポリモーフィックな振る舞いに使われる個々のサブクラスを識別するための値。
                            値は <literal>null</literal> か <literal>not null</literal> のいずれかを取ります。
                        </para>
                    </callout>
                    <callout arearefs="class4">
                        <para>
                            <literal>mutable</literal> (オプション、 デフォルトは <literal>true</literal> )：
                            そのクラスのインスタンスが更新可能（または不可能）であることを指定します。
                        </para>
                    </callout>    
                    <callout arearefs="class5">
                        <para>
                            <literal>schema</literal> （オプション）：
                            ルートの <literal>&lt;hibernate-mapping&gt;</literal> 要素で指定されたスキーマ名をオーバーライドします。
                        </para>
                    </callout>                
                    <callout arearefs="class6">
                        <para>
                            <literal>catalog</literal> （オプション）：ルートの <literal>&lt;hibernate-mapping&gt;</literal> 
                            要素で指定されたカタログ名をオーバーライドします。
                        </para>
                    </callout>                
                    <callout arearefs="class7">
                        <para>
                            <literal>proxy</literal> （オプション）：遅延初期化プロキシに使うインターフェイスを指定します。
                            永続化するクラス名そのものを指定することも可能です。
                        </para>
                    </callout>    
                    <callout arearefs="class8">
                        <para>
                            <literal>dynamic-update</literal> （オプション、 デフォルトは <literal>false</literal> ）：
                            値が変更されたカラムだけを含むSQLの <literal>UPDATE</literal> 文を、実行時に生成することを指定します。
                        </para>
                    </callout>    
                    <callout arearefs="class9">
                        <para>
                            <literal>dynamic-insert</literal> （オプション, デフォルトは <literal>false</literal> ）：
                            値がnullではないカラムだけを含むSQLの <literal>INSERT</literal> 文を、実行時に生成することを指定します。
                        </para>
                    </callout>    
                    <callout arearefs="class10">
                        <para>
                            <literal>select-before-update</literal> (オプション, デフォルトは <literal>false</literal>): 
                            オブジェクトが変更されたのが確実でないならば、HibernateがSQLの <literal>UPDATE</literal> を 
                            <emphasis>決して実行しない</emphasis> ことを指定します。
                            ある特定の場合(実際的には、一時オブジェクトが <literal>update()</literal> を使い、
                            新しいセッションと関連付けられた時だけ)、<literal>UPDATE</literal> が実際に必要かどうかを決定するために、
                            Hibernateが余分なSQLの <literal>SELECT</literal> 文を実行することを意味します。
                        </para>
                    </callout>    
                    <callout arearefs="class11">
                        <para>
                            (optional, デフォルトでは <literal>implicit</literal> ): implicit（暗黙）かexplicit（明示）の、
                            どちらのクエリポリモーフィズムを使うか決定します。
                        </para>
                    </callout>    
                    <callout arearefs="class12">
                        <para>
                            <literal>where</literal> （オプション）：
                            このクラスのオブジェクトを検索するときに使用する、任意のSQLの <literal>WHERE</literal>  条件を指定します。
                        </para>
                    </callout>                 
                    <callout arearefs="class13">
                        <para>
                            <literal>persister</literal> （オプション）：カスタム <literal>ClassPersister</literal> を指定します。
                        </para>
                    </callout>                 
                    <callout arearefs="class14">
                        <para>
                            <literal>batch-size</literal> （オプション, デフォルトは <literal>1</literal> ）：
                            識別子でこのクラスのインスタンスを復元するときの「バッチサイズ」を指定します。
                        </para>
                    </callout>                 
                   <callout arearefs="class15">
                        <para>
                            <literal>optimistic-lock</literal> （オプション,デフォルトは <literal>version</literal> ）：
                            楽観ロック戦略を決定します。
                        </para>
                    </callout>    
                    <callout arearefs="class16">
                        <para>
                            <literal>lazy</literal> （オプション）： <literal>lazy="false"</literal> と設定することで、
                            遅延フェッチができなくなります。
                        </para>
                    </callout>    
                    <callout arearefs="class17">
                        <para>
                            <literal>entity-name</literal> （オプション、デフォルトはクラス名）：
                            Hibernate3ではクラスが複数回マッピングでき（場合によっては違うテーブルに対しても）、
                            JavaレベルでMapやXMLで表現されるエンティティマッピングが可能です。
                            これらの場合、エンティティに対して任意の名前を、明示的に付けなくてはなりません。
                            詳しくは <xref linkend="persistent-classes-dynamicmodels"/> と <xref linkend="xml"/> を参照してください。
                        </para>
                    </callout>
                    <callout arearefs="class18">
                        <para>
                            <literal>check</literal> （オプション）：自動的にスキーマを生成するために、
                            複数行の <emphasis>check</emphasis> 制約を生成するSQL式。
                        </para>
                    </callout>
                    <callout arearefs="class19">
                        <para>
                            <literal>rowid</literal> （オプション）：Hibernateは、それをサポートしているデータベースでROWIDと
                            呼ばれるものを使うことができます。
                            例えばOracleを使っているとき、このオプションに <literal>rowid</literal> を設定すれば、
                            Hiberanteはupdateを高速化するために <literal>rowid</literal> という特別なカラムを使うことができます。
                            ROWIDは詳細な実装であり、保存されたタプルの物理的な位置を表しています。
                        </para>
                    </callout>
                    <callout arearefs="class20">
                        <para>
                            <literal>subselect</literal> （オプション）：不変かつ読み取り専用であるエンティティを
                            データベースの副問合せ（subselect）にマッピングします。
                            もし元のテーブルの代わりにビューを持ちたければ有用ですが、
                            そうでないのなら有用ではありません。より詳しい情報は下記を参照してください。
                        </para>
                    </callout>
                    <callout arearefs="class21">
                        <para>
                            <literal>abstract</literal> （オプション）：
                            <literal>&lt;union-subclass&gt;</literal> 階層内の抽象スーパークラスにマークするために使います。
                        </para>
                    </callout>

                </calloutlist>
            </programlistingco>
           
            <para>
                永続クラスの名前にインターフェイスを指定してもまったく問題ありません。
                そのときは <literal>&lt;subclass&gt;</literal> 要素を使って、
                そのインターフェイスを実装するクラスを定義してください。
                <emphasis>static</emphasis> な内部クラスでも永続化できます。
                そのときは標準形式、例えば <literal>eg.Foo$Bar</literal> を使ってクラス名を指定してください。
            </para>

            <para>
                <literal>mutable="false"</literal> 指定をした不変クラスは、
                アプリケーションによる更新や削除が出来ないことがあります。
                これにより、Hibernateがパフォーマンスを少し改善します。
            </para>
            
            <para>
                オプションの <literal>proxy</literal> 属性により、クラスの永続インスタンスの遅延初期化が可能になります。
                Hibernateは最初に、指定したインターフェイスを実装したCGLIBプロキシを返します。
                実際の永続オブジェクトはプロキシのメソッドを呼び出すときにロードします。
                以下の「遅延初期化のためのプロキシ」を参照してください。
            </para>
            
            <para>
                <emphasis>暗黙的</emphasis> ポリモーフィズムとは、次の二つを意味しています。
                一つはクラスのインスタンスが、スーパークラスや実装したインターフェイス、またそのクラスを指定するクエリによって返されることで、
                もう一つはそのクラスのサブクラスのインスタンスが、そのクラス自身を指定したクエリによって返されることです。
                また、<emphasis>明示的</emphasis> ポリモーフィズムとは、次の二つを意味しています。
                一つはクラスのインスタンスが、そのクラスを明示的に指定したクエリによってのみ返されることで、
                もう一つはクラスを指定したクエリが、<literal>&lt;class&gt;</literal> 要素の中で <literal>&lt;subclass&gt;</literal> や 
                <literal>&lt;joined-subclass&gt;</literal> とマッピングされているサブクラスのインスタンスだけを返すことです。
                ほとんどの用途ではデフォルトの <literal>polymorphism="implicit"</literal> が適切です。
                明示的なポリモーフィズムは、2つの違ったクラスが同じテーブルにマッピングされているときに有用です
                （これによってテーブルカラムのサブセットを含む、「軽量な」クラスが可能になります）。
            </para>
            
            <para>
                <literal>persister</literal> 属性を指定することで、クラスの永続化戦略をカスタマイズできます。
                例えば <literal>org.hibernate.persister.EntityPersister</literal> 自身のサブクラスを指定したり、
                また例えばストアドプロシージャコール、フラットファイルへシリアライズ、
                LDAPなどを通した永続性を実装する <literal>org.hibernate.persister.ClassPersister</literal> 
                インターフェイスの完全に新しい実装を提供できます。簡単な例として <literal>org.hibernate.test.CustomPersister</literal> 
                を見てください（これは <literal>Hashtable</literal> の「永続化」です）。
                
            </para>
            
            <para>
                <literal>dynamic-update</literal> と <literal>dynamic-insert</literal> の設定はサブクラスに継承されません。
                そのため <literal>&lt;subclass&gt;</literal> や <literal>&lt;joined-subclass&gt;</literal> 要素を指定することも出来ます。
                これらの設定はパフォーマンスを向上させる事もありますが、落とすこともありますので、慎重に使用してください。
            </para>
            
            <para>
                <literal>select-before-update</literal> の使用は通常パフォーマンスを落とします。
                もし <literal>Session</literal> へ分離インスタンスのグラフを再追加するなら、
                データベース更新のトリガを不必要に呼び出すのを避けるという点で、非常に有用です。
            </para>
            
            <para>
                <literal>dynamic-update</literal> を有効にすれば、楽観ロック戦略を選ぶことになります。
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        <literal>version</literal> バージョン/タイムスタンプカラムをチェックします
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>all</literal> すべてのカラムをチェックします。
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>dirty</literal> 変更したカラムをチェックし、同時更新できるようにします。
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>none</literal> 楽観ロックを使用しません
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                Hibernateで楽観的ロック戦略を使うなら、バージョン/タイムスタンプカラムを使うことを
                 <emphasis> 非常に</emphasis> 強くお勧めします。
                楽観的ロックはパフォーマンスの観点からも最適であり、さらに分離インスタンスへの修正
                （つまり <literal>Session.marge()</literal> が使われるとき）
                を正確に扱うことのできる唯一の戦略でもあります。
            </para>
            
            <para>
                Hibernateのマッピングにとってビューと普通のテーブルの間に違いはなく、
                データベースレベルでは透過的です
                （ただしビューを完全にはサポートしていないDBMSもあります。
                特に、更新のあるビューに対してはそうです）。
                ビューを使いたくても、データベースで作成できないことがあります
                （例えば、レガシースキーマの場合）。
                この場合には、不変かつ読み取り専用のエンティティに与えられたSQLの副問合せ文をマップできます。
            </para>

            <programlisting><![CDATA[<class name="Summary">
    <subselect>
        select item.name, max(bid.amount), count(*)
        from item
        join bid on bid.item_id = item.id
        group by item.name
    </subselect>
    <synchronize table="item"/>
    <synchronize table="bid"/>
    <id name="name"/>
    ...
</class>]]></programlisting>

            <para>
                テーブルをこのエンティティと同期するように定義してください。
                オートフラッシュが確実に起こるように、また導出エンティティに対するクエリが古いデータを
                返さないようにするためです。
                <literal>&lt;subselect&gt;</literal> は属性とネストしたマッピング属性のどちらでも利用できます。
            </para>

        </sect2>

        <sect2 id="mapping-declaration-id" revision="4">
            <title>id</title>

            <para>
                マップされたクラスはデータベーステーブルの主キーカラムを定義 <emphasis>しなければなりません</emphasis> 。
                ほとんどのクラスにはインスタンスのユニークな識別子を保持するJavaBeansスタイルのプロパティもあります。
                <literal>&lt;id&gt;</literal> 要素は、そのプロパティから主キーカラムへのマッピングを定義します。
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="id1" coords="2 70"/>
                    <area id="id2" coords="3 70" />
                    <area id="id3" coords="4 70"/>
                    <area id="id4" coords="5 70" />
                    <area id="id5" coords="6 70" />
                </areaspec>
                <programlisting><![CDATA[<id
        name="propertyName"
        type="typename"
        column="column_name"
        unsaved-value="null|any|none|undefined|id_value"
        access="field|property|ClassName">
        node="element-name|@attribute-name|element/@attribute|."

        <generator class="generatorClass"/>
</id>]]></programlisting>
                <calloutlist>
                    <callout arearefs="id1">
                        <para>
                            <literal>name</literal>（オプション）：識別子プロパティの名前。
                        </para>
                    </callout>
                    <callout arearefs="id2">
                        <para>
                            <literal>type</literal>（オプション）：Hibernateの型を示す名前。
                        </para>
                    </callout>
                    <callout arearefs="id3">
                        <para>
                             <literal>column</literal>（オプション - デフォルトはプロパティ名）：
                            主キーカラムの名前。
                        </para>
                    </callout>
                    <callout arearefs="id4">
                        <para>
                            <literal>unsaved-value</literal>（オプション - デフォルトの値はsensible）：
                            インスタンスが新しくインスタンス化された
                            （セーブされていない）ことを示す、識別子プロパティの値。
                            以前のSessionでセーブまたはロードされた一時的インスタンスと区別するために
                            使います。
                        </para>
                    </callout>            
                   <callout arearefs="id5">
                        <para>
                            <literal>access</literal>（オプション - デフォルトは <literal>property</literal> ）：
                            プロパティの値へアクセスするためにHibernateが使う戦略です。
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            
            <para>
                 <literal>name</literal> 属性がなければ、クラスには識別子プロパティがないものとみなされます。
            </para>
            
            <para>
                <literal>unsaved-value</literal> 属性はHibernate3ではほとんどの場合、必要ではありません。
            </para>

             <para>
                複合キーを持つレガシーデータにアクセスできるように、
                <literal>&lt;composite-id&gt;</literal> という代替のマッピング定義があります。
                しかし他の用途への使用は全くおすすめできません。
            </para>
            
            <sect3 id="mapping-declaration-id-generator" revision="2">
                <title>ジェネレータ</title>

                <para>
                    オプションの <literal>&lt;generator&gt;</literal> 子要素は、
                    永続クラスのインスタンスのユニークな識別子を生成するために使う、Javaクラスを指定します。
                    ジェネレータインスタンスの設定、もしくは初期化にパラメータが必要であれば、<literal>&lt;param&gt;</literal> 
                    要素を使って渡すことができます。
                </para>

                <programlisting><![CDATA[<id name="id" type="long" column="cat_id">
        <generator class="org.hibernate.id.TableHiLoGenerator">
                <param name="table">uid_table</param>
                <param name="column">next_hi_value_column</param>
        </generator>
</id>]]></programlisting>

                <para>
                    すべてのジェネレータは、インターフェイス 
                    <literal>org.hibernate.id.IdentifierGenerator</literal> を実装します。
                    これはとても単純なインターフェイスなので、特別な実装を独自に用意するアプリケーションもあるかもしれません。
                    しかしHibernateは組み込みの実装をいくつも用意しています。
                    組み込みのジェネレータには以下のショートカット名があります：

                    <variablelist>
                        <varlistentry>
                        <term><literal>increment</literal></term>
                        <listitem>
                            <para>
                                <literal>long</literal> , <literal>short</literal> , 
                                <literal>int</literal> 型の識別子を生成します。
                                これらは他のプロセスが同じテーブルにデータを挿入しないときだけユニークです。
                                <emphasis>クラスタ内では使わないでください</emphasis> 。
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>identity</literal></term>
                        <listitem>
                            <para>
                                DB2, MySQL, MS SQL Server, Sybase, HypersonicSQLの識別子カラムを
                                サポートします。
                                返される識別子の型は <literal>long</literal> , <literal>short</literal> , 
                                <literal>int</literal> のいずれかです。
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>sequence</literal></term>
                        <listitem>
                            <para>
                                  DB2, PostgreSQL, Oracle, SAP DB, McKoiのシーケンスや、Interbaseのジェネレータを使用します。
                                  返される識別子の型は <literal>long</literal> , <literal>short</literal> , 
                                <literal>int</literal> のいずれかです。
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>hilo</literal></term>
                        <listitem>
                            <para id="mapping-declaration-id-hilodescription" revision="1">
                                 <literal>long</literal> , <literal>short</literal> , 
                                <literal>int</literal> 型の識別子を効率的に生成するhi/loアルゴリズムを使います。
                                hi値のソースとして、テーブルとカラムを与えます(デフォルトではそれぞれ <literal>hibernate_unique_key</literal> と 
                                <literal>next_hi</literal> )。
                               
                                hi/loアルゴリズムは特定のデータベースに対してのみユニークな識別子を生成します。
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>seqhilo</literal></term>
                        <listitem>
                            <para>
                                <literal>long</literal> , <literal>short</literal> , 
                                <literal>int</literal> 型の識別子を効率的に生成するhi/loアルゴリズムを使います。
                                指定されたデータベースシーケンスを与えます。
                                
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>uuid</literal></term>
                        <listitem>
                            <para>
                                (IPアドレスが使用される)ネットワーク内でユニークな文字列型の識別子を生成するために、
                                128ビットのUUIDアルゴリズムを使用します。UUIDは長さ32の16進数字の文字列としてエンコードされます。
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>guid</literal></term>
                        <listitem>
                            <para>
                                MS SQLサーバとMySQLでデータベースが生成するGUID文字列を使用します。
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>native</literal></term>
                        <listitem>
                            <para>
                                使用するデータベースの性能により <literal>identity</literal> , <literal>sequence</literal> , 
                                <literal>hilo</literal> のいずれかが選ばれます。
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>assigned</literal></term>
                        <listitem>
                            <para>
                                <literal>save()</literal> が呼ばれる前に、
                                アプリケーションがオブジェクトに識別子を代入できるようにします。
                                <literal>&lt;generator&gt;</literal> が指定されていなければ、これがデフォルトの戦略になります。
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>select</literal></term>
                        <listitem>
                            <para>
                                あるユニークキーによる行の選択と主キーの値の復元により、
                                データベーストリガが割り当てた主キーを取得します。
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>foreign</literal></term>
                        <listitem>
                            <para>
                                他の関連オブジェクトの識別子を使います。
                                普通は、<literal>&lt;one-to-one&gt;</literal> 主キー関連と組み合わせて使います。
                            </para>
                        </listitem>
                        </varlistentry>
                    </variablelist>

                </para>
            </sect3>
            
            <sect3 id="mapping-declaration-id-hilo" revision="1">
                <title>Hi/lo アルゴリズム</title>
                <para>
                    <literal>hilo</literal> と <literal>seqhilo</literal> ジェネレータは、
                    識別子生成の代表的なアプローチであるhi/loアルゴリズムの2つの代替実装を提供します。
                    
                    1番目の実装は、次回に利用される"hi"値を保持する「特別な」データベーステーブルを
                    必要とします。
                    2番目の実装は、Oracleスタイルのシーケンスを使います（サポートされている場合）。
                </para>

                <programlisting><![CDATA[<id name="id" type="long" column="cat_id">
        <generator class="hilo">
                <param name="table">hi_value</param>
                <param name="column">next_value</param>
                <param name="max_lo">100</param>
        </generator>
</id>]]></programlisting>

                <programlisting><![CDATA[<id name="id" type="long" column="cat_id">
        <generator class="seqhilo">
                <param name="sequence">hi_value</param>
                <param name="max_lo">100</param>
        </generator>
</id>]]></programlisting>

                <para>
                    残念ながらHibernateへの独自の <literal>Connection</literal> を提供するときには、<literal>hilo</literal> を使えません。
                    HibernateがJTAでリストされている接続を取得するためにアプリケーションサーバーのデータソースを使用しているときには、
                    <literal>hibernate.transaction.manager_lookup_class</literal> を適切に設定しなければなりません。
                </para>
            </sect3>
            
            <sect3 id="mapping-declaration-id-uuid">
                <title>UUID アルゴリズム</title>
                <para>
                    UUIDには以下のものが含まれます：
                    IPアドレス、JVMのスタートアップタイム（4分の1秒の正確さ）、
                    システム時間、（JVMに対してユニークな）カウンタ値。
                    JavaコードからMACアドレスやメモリアドレスを取得することはできないので、
                    JNIが使えないときの最良の方法です。
                </para>
            </sect3>

            <sect3 id="mapping-declaration-id-sequences">
            <title>識別子カラムとシーケンス</title>
                <para>
                    識別子カラムをサポートしているデータベース（DB2, MySQL, Sybase, MS SQL）では、
                    <literal>identity</literal> キー生成を使えます。
                    シーケンスをサポートするデータベース（DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB）では、
                    <literal>sequence</literal> スタイルのキー生成を使えます。
                    どちらの戦略も、新しいオブジェクトを挿入するために、SQLクエリを2つ必要とします。
                </para>

                <programlisting><![CDATA[<id name="id" type="long" column="person_id">
        <generator class="sequence">
                <param name="sequence">person_id_sequence</param>
        </generator>
</id>]]></programlisting>

                <programlisting><![CDATA[<id name="id" type="long" column="person_id" unsaved-value="0">
        <generator class="identity"/>
</id>]]></programlisting>
            
                <para>
                    クロスプラットフォームの開発では、<literal>native</literal> 戦略は 
                    <literal>identity</literal> , <literal>sequence</literal> , 
                    <literal>hilo</literal> 戦略の中から1つを選択しますが、
                    これは使用しているデータベースの能力に依存します。
                </para>
            </sect3>
            
            <sect3 id="mapping-declaration-id-assigned">
                <title>識別子の割り当て</title>
                <para>
                   アプリケーションに識別子を割り当てさせたいのであれば(Hibernateが生成するものではなく）、
                    <literal>assigned</literal> ジェネレータを使うことができます。
                    この特別なジェネレータは、すでにオブジェクトの識別子プロパティに代入された値を
                    識別子に使います。このジェネレータは主キーが代理キーの代わりに自然キーである場合に使用します。
                    <literal>&lt;generator&gt;</literal> 要素を指定しない場合のデフォルトの動作になります。
                </para>
                
                <para>
                    <literal>assigned</literal> ジェネレータを選択すると、
                    Hibernateは <literal>unsaved-value="undefined"</literal> を使用します。
                    そして、バージョンやタイムスタンプのプロパティがない場合や <literal>Interceptor.isUnsaved()</literal> 
                    を定義しなかった場合には、インスタンスが一時的(transient)なものであるのか、
                    またはセッションから分離(detached)したものかどうかを決めるために、データベースを調べます。
                </para>
            </sect3>

            <sect3 id="mapping-declaration-id-select">
                <title>トリガにより割り当てられた主キー</title>
                <para>
                    レガシースキーマのためにのみ指定します(Hibernateはトリガを使ってDDLを生成しません)。
                </para>

                <programlisting><![CDATA[<id name="id" type="long" column="person_id">
        <generator class="select">
                <param name="key">socialSecurityNumber</param>
        </generator>
</id>]]></programlisting>

                <para>
                    上の例の中で、クラスで自然キーとして定義された
                    <literal>socialSecurityNumber</literal> という名前のユニークな値のプロパティと、
                    値がトリガにより生成される <literal>person_id</literal> という名前の代理キーがあります。
                </para>
                
            </sect3>

        </sect2>
        
        <sect2 id="mapping-declaration-compositeid" revision="3">
            <title>composite-id</title>

            <programlisting><![CDATA[<composite-id
        name="propertyName"
        class="ClassName"
        mapped="true|false"
        access="field|property|ClassName">
        node="element-name|."

        <key-property name="propertyName" type="typename" column="column_name"/>
        <key-many-to-one name="propertyName class="ClassName" column="column_name"/>
        ......
</composite-id>]]></programlisting>

            <para>
                複合キーのあるテーブルに対し、
                識別子プロパティとしてクラスの複数のプロパティをマッピングすることができます。
                <literal>&lt;composite-id&gt;</literal> 要素は、子要素として 
                <literal>&lt;key-property&gt;</literal> プロパティマッピングと 
                <literal>&lt;key-many-to-one&gt;</literal> マッピングを受け入れます。
            </para>
            
            <programlisting><![CDATA[<composite-id>
        <key-property name="medicareNumber"/>
        <key-property name="dependent"/>
</composite-id>]]></programlisting>

            <para>
                 複合識別子の等価性を実装するためには、永続クラスが <literal>equals()</literal> と 
                <literal>hashCode()</literal> をオーバーライド <emphasis>しなければなりません</emphasis> 。
                また <literal>Serializable</literal> も実装しなければいけません。
            </para>

            <para>
                残念ながら複合識別子のためのこの方法は、
                永続オブジェクトが自身の識別子であることを意味しています。
                オブジェクト自身を識別子とする以上の便利な「扱い方」はありません。
                複合キーに関連した永続状態を <literal>load()</literal> 出来るようになる前に、
                永続クラス自身をインスタンス化し、識別子プロパティを設定しなければなりません。
                <emphasis> 組み込みの</emphasis> 複合識別子と呼ばれるこのアプローチは、
                本格的なアプリケーションには向いていません。
                
                
            </para>
            
            <para>
                2つ目の方法は <emphasis> マップされた</emphasis> 複合識別子と呼ばれるもので、
                <literal>&lt;composite-id&gt;</literal>エレメント内で指定した識別プロパティが
                永続クラスと分離した識別子クラスの両方に重複して存在します。
            </para>
                
            <programlisting><![CDATA[<composite-id class="MedicareId" mapped="true">
        <key-property name="medicareNumber"/>
        <key-property name="dependent"/>
</composite-id>]]></programlisting>

            <para>
                この例では、複合識別子クラス（ <literal>MedicareId</literal> ）とエンティティクラス自身の両方が、
                <literal>medicareNumber</literal> と <literal>dependent</literal> という名前のプロパティを持ちます。
                識別子クラスは、<literal>equals()</literal> と <literal>hashCode()</literal> をオーバライドし、
                <literal>Serializable</literal> を実装しなくてはなりません。
                この方法には、明らかにコードが重複するという不都合があります。
            </para>
            
            <para>
                次の属性はマッピングした複合識別子を指定するために使用します。
            </para>

            <itemizedlist spacing="compact">
                <listitem>
                    <para>
                        <literal>mapped</literal> (オプション、デフォルトは <literal>false</literal> ):
                        マッピングした複合識別子が使用されることと、包含されたプロパティのマッピングが、
                        エンティティクラスと複合識別子クラスの両方を参照することを示します。
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>class</literal> (オプション,ただしマッピングした複合識別子には必須): 
                        複合識別子として使用するクラス。
                        
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                3つ目のさらに便利な方法は、複合識別子を<xref linkend="components-compositeid"/>内の
                コンポーネントクラスとして実装することです。
                下で記述している属性は、この代替方法にのみ適用されます。
            </para>

            <itemizedlist spacing="compact">
                <listitem>
                    <para>
                        <literal>name</literal> (オプション, このアプローチでは必須): 
                        複合識別子を保持するコンポーネントタイプのプロパティ(9章を参照してください).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>access</literal> (オプション - デフォルトは <literal>property</literal> ): 
                        Hibernateがプロパティの値にアクセスするために使用すべき戦略。
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>class</literal> 
                        （オプション - デフォルトはリフレクションにより決定されるプロパティの型）：
                        複合識別子として使われるコンポーネントのクラス（次の節を見てください）。
                    </para>
                </listitem>
            </itemizedlist>
            
            <para>
                この3つ目の方法は <emphasis> 識別子コンポーネント</emphasis> と呼び、
                ほとんどすべてのアプリケーションに対して推奨する方法です。
            </para>
            
        </sect2>        
        
        <sect2 id="mapping-declaration-discriminator" revision="3">
            <title>discriminator</title>

            <para>
                <literal>&lt;discriminator&gt;</literal> 要素は、
                table-per-class-hierarchyマッピング戦略を使うポリモーフィックな永続化に必要であり、
                テーブルの識別カラムを定義します。
                識別カラムは、ある行に対して永続層がどのサブクラスをインスタンス化するかを
                伝えるマーカー値を含んでいます。
                以下のような型に制限されます： <literal>string</literal> , <literal>character</literal> , 
                <literal>integer</literal>, 
                <literal>byte</literal> , <literal>short</literal> , <literal>boolean</literal> , 
                <literal>yes_no</literal> , <literal>true_false</literal>. 
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="discriminator1" coords="2 60"/>
                    <area id="discriminator2" coords="3 60" />
                    <area id="discriminator3" coords="4 60" />
                    <area id="discriminator4" coords="5 60" />
                    <area id="discriminator5" coords="6 60" />
                </areaspec>
                <programlisting><![CDATA[<discriminator
        column="discriminator_column"
        type="discriminator_type"
        force="true|false"
        insert="true|false"
        formula="arbitrary sql expression"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="discriminator1">
                        <para>
                            <literal>column</literal>（オプション - デフォルトは <literal>class</literal> ）：
                            識別カラムの名前。
                        </para>
                    </callout>
                    <callout arearefs="discriminator2">
                        <para>
                            <literal>type</literal> 
                            （オプション - デフォルトは <literal>string</literal> ）：Hibernateの型を示す名前。
                        </para>
                    </callout>          
                    <callout arearefs="discriminator3">
                        <para>
                            <literal>force</literal> 
                            （オプション - デフォルトは <literal>false</literal> ）：
                            ルートクラスのすべてのインスタンスを検索する場合であっても、
                            Hibernateが使用できる識別カラムの指定を「強制」します。
                        </para>
                    </callout>          
                    <callout arearefs="discriminator4">
                        <para>
                            <literal>insert</literal> 
                            （オプション - デフォルトは <literal>true</literal> ）：
                            もし識別カラムがマッピングする複合識別子の一部ならば、<literal>false</literal> と設定してください。
                            (HibernateにSQLの <literal>INSERT</literal> には含まれないことを知らせる)
                            
                        </para>
                    </callout>
                    <callout arearefs="discriminator5">
                        <para>
                            <literal>formula</literal> (オプション)型が評価されるときに実行される任意のSQL式。
                            コンテンツベースの識別を可能にします。
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                識別カラムの実際の値は、 <literal>&lt;class&gt;</literal> と 
                <literal>&lt;subclass&gt;</literal> 要素の 
                <literal>discriminator-value</literal> 属性で指定されます。
            </para>
            
            <para>
                永続クラスへマッピングされない｢余分な」識別値を持つ行が
                テーブルにあれば、（そのときに限り）<literal>force</literal> 属性は有効です。
                ただし、普通はそういうことはありません。
            </para>

            <para>
                <literal>formula</literal> 属性を使うと、行の型を評価するために任意のSQL式を宣言できます。
            </para>

            <programlisting><![CDATA[<discriminator
    formula="case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end"
    type="integer"/>]]></programlisting>

        </sect2>

        <sect2 id="mapping-declaration-version" revision="4">
            <title>version（オプション）</title>
            
            <para>
                <literal>&lt;version&gt;</literal> 要素はオプションであり、
                テーブルがバージョンデータを含むことを示します。
                これは <emphasis>ロングトランザクション</emphasis>  
                を使うつもりなら、特に役立ちます（以下を見てください）。
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="version1" coords="2 70"/>
                    <area id="version2" coords="3 70"/>
                    <area id="version3" coords="4 70"/>
                    <area id="version4" coords="5 70"/>
                    <area id="version5" coords="6 70"/>
                    <area id="version6" coords="7 70"/>
                    <area id="version7" coords="8 70"/>                    
                </areaspec>
                <programlisting><![CDATA[<version
        column="version_column"
        name="propertyName"
        type="typename"
        access="field|property|ClassName"
        unsaved-value="null|negative|undefined"
        generated="never|always"
        insert="true|false"
        node="element-name|@attribute-name|element/@attribute|."
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="version1">
                        <para>
                            <literal>column</literal>（オプション - デフォルトはプロパティ名）:
                            バージョン番号を保持するカラムの名前。
                        </para>
                    </callout>          
                    <callout arearefs="version2">
                        <para>
                            <literal>name</literal> ：永続クラスのプロパティの名前。
                        </para>
                    </callout>
                    <callout arearefs="version3">
                        <para>
                            <literal>type</literal> 
                            （オプション - デフォルトは <literal>integer</literal> ）：バージョン番号の型。
                        </para>
                    </callout>          
                   <callout arearefs="version4">
                        <para>
                            <literal>access</literal> 
                            （オプション - デフォルトは <literal>property</literal> ）：
                            プロパティの値へのアクセスにHibernateが使う戦略。
                        </para>
                    </callout>
                   <callout arearefs="version5">
                        <para>
                            <literal>unsaved-value</literal> 
                            （オプション - デフォルトは <literal>undefined</literal> ）：
                            インスタンスが新しくインスタンス化されたことを示す
                            （セーブされていないことを示す）バージョンプロパティの値。
                            以前のSessionでセーブまたはロードされた一時的なインスタンスと区別するために
                            使います。
                            （ <literal>undefined</literal> は識別子プロパティの値が使われることを指定します。）
                        </para>
                    </callout>
                    
                    <callout arearefs="version6">
                        <para>
                            <literal>generated</literal> (オプション - デフォルトは <literal>never</literal> ):
                            このバージョンのプロパティの値が、データベースによって生成されたことを指定します。
                            <xref linkend="mapping-generated">生成プロパティ</xref> の議論を見てください。
                        </para>
                    </callout>
                    <callout arearefs="version7">
                        <para>
                            <literal>insert</literal> (オプション - デフォルトは <literal>true</literal> ):
                            SQLのinsert文にバージョン・カラムを含めるべきかどうかを指定します。
                            もしデータベース・カラムのデフォルト値が <literal>0</literal> と定義されるときには、
                            <literal>false</literal> に設定すると良いでしょう。
                        </para>
                    </callout>                    
                </calloutlist>
            </programlistingco>
            
            <para>
                バージョン番号は Hibernateの <literal>long</literal> , <literal>integer</literal> , 
                <literal>short</literal> , <literal>timestamp</literal> , 
                <literal>calendar</literal> 型のいずれかです。
            </para>
            
            <para>
                バージョンやタイムスタンプのプロパティは、分離されたインスタンスに対してnullであってはなりません。
                そのためどのような <literal>unsaved-value</literal> 戦略が指定されても、
                Hibernateはnullのバージョンやタイムスタンプを持ったすべてのインスタンスを、
                一時的なものであると判断します。
                
                 <emphasis> nullを許容するバージョンやタイムスタンプのプロパティを定義することは、
                過渡的に一時オブジェクトとすることを防ぐ簡単な方法です。
                特に識別子の割り当てや複合キーを使用しているときには特に有用です。</emphasis> 
            </para>
        </sect2>
        
        <sect2 id="mapping-declaration-timestamp" revision="4">
            <title>timestamp（オプション）</title>

            <para>
                オプションの <literal>&lt;timestamp&gt;</literal> 要素は、
                テーブルがタイムスタンプデータを含むことを示します。
                これはバージョン付けの代わりの方法として用意されています。
                タイムスタンプはもともと楽観的ロックにおける安全性の低い実装です。
                しかしアプリケーションは異なる用途で使うこともあるかもしれません。
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="timestamp1" coords="2 70"/>
                    <area id="timestamp2" coords="3 70" />
                    <area id="timestamp3" coords="4 70" />
                    <area id="timestamp4" coords="5 70" />
                    <area id="timestamp5" coords="6 70" />
                    <area id="timestamp6" coords="7 70" />                    
                </areaspec>            
                <programlisting><![CDATA[<timestamp
        column="timestamp_column"
        name="propertyName"
        access="field|property|ClassName"
        unsaved-value="null|undefined"
        source="vm|db"
        generated="never|always"
        node="element-name|@attribute-name|element/@attribute|."
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="timestamp1">
                        <para>
                            <literal>column</literal>（オプション - デフォルトはプロパティ名）：
                            タイムスタンプを保持するカラムの名前。
                        </para>
                    </callout>                   
                    <callout arearefs="timestamp2">
                        <para>
                            <literal>name</literal> ：
                            永続クラスであるJava の <literal>Date</literal >型 または 
                            <literal>Timestamp</literal> 型 の、JavaBeansスタイルプロパティの名前。
                        </para>
                    </callout>
                   <callout arearefs="timestamp3">
                        <para>
                            <literal>access</literal>
                            （オプション - デフォルトは <literal>property</literal> ）：
                            プロパティの値へのアクセスにHibernateが使う戦略。
                        </para>
                    </callout>
                   <callout arearefs="timestamp4">
                        <para>
                            <literal>unsaved-value</literal> 
                            （オプション - デフォルトは <literal>null</literal> ）：
                            インスタンスが新しくインスタンス化された
                            （セーブされていない）ことを示すバージョンプロパティの値。
                            以前のSessionでセーブまたはロードされた一時的なインスタンスと
                            区別するために使われます。
                            （ <literal>undefined</literal> と指定すると、
                            識別子プロパティの値が使われます。）
                        </para>
                    </callout>
                    
                    <callout arearefs="timestamp5">
                        <para>
                            <literal>source</literal> (オプション - デフォルトは <literal>vm</literal> ):
                            Hibernateはどこからタイムスタンプの値を取得するべきでしょうか？
                            データベースからでしょうか、現在のJVMからでしょうか？
                            データベースによるタイムスタンプは、Hibernateが"次の値"を決定するために
                            データベースをヒットしなければならないため、オーバヘッドを招きます。
                            しかしクラスタ環境ではJVMから取得するより安全です。
                            データベースの現在のタイムスタンプの取得をサポートする
                            すべての <literal>データベース方言</literal> が知られているわけではないことに
                            注意してください。また一方で、精密さを欠くために、
                            ロックで使用するには安全でないものもあります(例えばOracle 8)。
                        </para>
                    </callout>
                    <callout arearefs="timestamp6">
                        <para>
                            <literal>generated</literal> (オプション - デフォルトは <literal>never</literal> ):
                            このタイムスタンプ・プロパティの値が、データベースによって生成されることを指定します。
                            <xref linkend="mapping-generated">生成プロパティ</xref> を参照してください。
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            
            <para>
                 <literal>&lt;timestamp&gt;</literal> は 
                <literal>&lt;version type="timestamp"&gt;</literal> と等価であることに注意してください。
                <literal>&lt;timestamp source="db"&gt;</literal> は
                <literal>&lt;version type="dbtimestamp"&gt;</literal> と等価であることに注意してください。
            </para>
        </sect2>
        
        <sect2 id="mapping-declaration-property" revision="4">
            <title>property</title>

            <para>
                <literal>&lt;property&gt;</literal> 要素は、クラスの永続的なJavaBeanスタイルのプロパティを定義します。
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="property1" coords="2 70"/>
                    <area id="property2" coords="3 70"/>
                    <area id="property3" coords="4 70"/>
                    <areaset id="property4-5" coords="">
                        <area id="property4" coords='5 70'/>
                        <area id="property5" coords='6 70'/>
                    </areaset>
                    <area id="property6" coords="7 70"/>
                    <area id="property7" coords="8 70"/>
                    <area id="property8" coords="9 70"/>
                    <area id="property9" coords="10 70"/>
                    <area id="property10" coords="11 70"/>
                    <area id="property11" coords="12 70"/>
                    <area id="property12" coords="13 70"/>
                </areaspec>            
                <programlisting><![CDATA[<property
        name="propertyName"
        column="column_name"
        type="typename"
        update="true|false"
        insert="true|false"
        formula="arbitrary SQL expression"
        access="field|property|ClassName"
        lazy="true|false"
        unique="true|false"
        not-null="true|false"
        optimistic-lock="true|false"
        generated="never|insert|always"
        node="element-name|@attribute-name|element/@attribute|."
        index="index_name"
        unique_key="unique_key_id"
        length="L"
        precision="P"
        scale="S"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="property1">
                        <para>
                            <literal>name</literal>：小文字で始まるプロパティ名。
                        </para>
                    </callout>                   
                    <callout arearefs="property2">
                        <para>
                            <literal>column</literal>（オプション - デフォルトはプロパティ名）：
                            マッピングされたデータベーステーブルのカラムの名前。
                            ネストした <literal>&lt;column&gt;</literal> 要素でも指定できます。
                        </para>
                    </callout>
                    <callout arearefs="property3">
                        <para>
                            <literal>type</literal>（オプション）：Hibernateの型を示す名前。
                        </para>
                    </callout>
                    <callout arearefs="property4-5">
                        <para>
                            <literal>update, insert</literal> 
                            （オプション - デフォルトは <literal>true</literal> ）：
                            マッピングされたカラムがSQLの 
                            <literal>UPDATE</literal> や <literal>INSERT</literal> に含まれることを指定します。
                            両方とも <literal>false</literal> に設定すると、
                            同じカラムにマッピングされた他のプロパティやトリガや
                            他のアプリケーションによって初期化された純粋な「導出」プロパティが可能になります。
                        </para>
                    </callout>
                    <callout arearefs="property6">
                        <para>
                            <literal>formula</literal>（オプション）：
                            <emphasis>計算</emphasis> プロパティのための値を定義するSQL式。
                            計算されたプロパティは自身のカラムへのマッピングがありません。
                        </para>
                    </callout>
                    <callout arearefs="property7">
                        <para>
                            <literal>access</literal>（オプション - デフォルトは <literal>property</literal> ）：
                            プロパティの値へのアクセスにHibernateが使う戦略。
                        </para>
                    </callout>
                    <callout arearefs="property8">
                        <para>
                            <literal>lazy</literal> (optional - デフォルトは <literal>false</literal> ):
                           インスタンス変数に最初にアクセスしたときに、プロパティを遅延して取得するよう指定します。
                           (バイトコード実装を作成する時間が必要になります)。
                        </para>
                    </callout>
                    <callout arearefs="property9">
                        <para>
                            <literal>unique</literal> (オプション):カラムにユニーク制約をつけるDDLの生成を可能にします。
                            また、<literal>property-ref</literal> のターゲットとすることもできます。
                        </para>
                    </callout>
                    <callout arearefs="property10">
                        <para>
                            <literal>not-null</literal> (オプション):カラムにnull値を許可するDDLの生成を可能にします。
                        </para>
                    </callout>
                    <callout arearefs="property11">
                        <para>
                            <literal>optimistic-lock</literal> (オプション - デフォルトは <literal>true</literal> ):
                            このプロパティの更新に楽観ロックの取得を要求するかどうかを指定します。
                            言い換えれば、このプロパティがダーティであるときにバージョンを増やすべきかを決定します。
                        </para>
                    </callout>
                    <callout arearefs="property12">
                        <para>
                            <literal>generated</literal> (オプション - デフォルトは <literal>never</literal> ):
                            プロパティの値が、データベースによって生成されたことを指定します。
                            <xref linkend="mapping-generated">生成プロパティ</xref> を参照してください。
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                <emphasis>typename</emphasis> には以下の値が可能です：
            </para>

            <orderedlist spacing="compact">
                <listitem>
                    <para>
                        Hibernateの基本型の名前（例  <literal>integer, string, character,
                        date, timestamp, float, binary, serializable, object, blob</literal> ）。
                    </para>
                </listitem>
                <listitem>
                    <para>
                        デフォルトの基本型のJavaクラス名 （例 <literal>int, float,
                        char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</literal> ）。
                    </para>
                </listitem>
                <listitem>
                    <para>
                        シリアライズ可能なJavaクラスの名前。
                    </para>
                </listitem>
                <listitem>
                    <para>
                        カスタム型のクラス名（例 <literal>com.illflow.type.MyCustomType</literal> ）。
                    </para>
                </listitem>
            </orderedlist>

            <para>
                型を指定しなければ、Hibernateは正しいHibernateの型を推測するために、
                指定されたプロパティに対してリフレクションを使います。
                Hibernateはルール2, 3, 4をその順序に使い、
                getterプロパティの返り値のクラスの名前を解釈しようとします。
                しかしこれで常に十分であるとは限りません。
                場合によっては、<literal>type</literal> 属性が必要な場合があります。
                （例えば <literal>Hibernate.DATE</literal> と <literal>Hibernate.TIMESTAMP</literal> を区別するため、
                またはカスタム型を指定するためなどです。）
            </para>
            
            <para>
                <literal>access</literal> 属性で、
                実行時にHibernateがどのようにプロパティにアクセスするかを制御できます。
                デフォルトではHibernateはプロパティのget/setのペアをコールします。
                <literal>access="field"</literal> と指定すれば、
                Hibernateはリフレクションを使いget/setのペアを介さずに、直接フィールドにアクセスします。
                インターフェイス <literal>org.hibernate.property.PropertyAccessor</literal> を
                実装するクラスを指定することで、プロパティへのアクセスに独自の戦略を指定することができます。
            </para>

            <para>
                特に強力な特徴は生成プロパティです。
                これらのプロパティは当然読み取り専用であり、プロパティの値はロード時に計算されます。
                計算をSQL式として宣言すると、このプロパティは
                インスタンスをロードするSQLクエリの <literal>SELECT</literal> 句のサブクエリに変換されます。
            </para>

        <programlisting><![CDATA[
<property name="totalPrice"
    formula="( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product p
                WHERE li.productId = p.productId
                AND li.customerId = customerId
                AND li.orderNumber = orderNumber )"/>]]></programlisting>

            <para>
                特定のカラム(例では <literal>customerId</literal> がそれにあたります)のエイリアスを宣言することなく、
                エンティティ自身のテーブルを参照できることに注意してください。
                もし属性を使用したくなければ、
                ネストした <literal>&lt;formula&gt;</literal> マッピング要素を使えることにも注意してください。
            </para>

        </sect2>

        <sect2 id="mapping-declaration-manytoone" revision="5">
            <title>many-to-one</title>

            <para>
                他の永続クラスへの通常の関連は <literal>many-to-one</literal> 要素を使って定義します。
                リレーショナルモデルは多対一関連です。
                つまりあるテーブルの外部キーは、ターゲットとなるテーブルの主キーカラムを参照しています。
            </para>

            <programlistingco>
                <areaspec>
                    <area id="manytoone1" coords="2 70"/>
                    <area id="manytoone2" coords="3 70"/>
                    <area id="manytoone3" coords="4 70"/>
                    <area id="manytoone4" coords="5 70"/>
                    <area id="manytoone5" coords="6 70"/>
                    <areaset id="manytoone6-7" coords="">
                        <area id="manytoone6" coords='7 70'/>
                        <area id="manytoone7" coords='8 70'/>
                    </areaset>
                    <area id="manytoone8" coords="9 70"/>
                    <area id="manytoone9" coords="10 70"/>
                    <area id="manytoone10" coords="11 70"/>
                    <area id="manytoone11" coords="12 70"/>
                    <area id="manytoone12" coords="13 70"/>
                    <area id="manytoone13" coords="14 70"/>
                    <area id="manytoone14" coords="15 70"/>
                    <area id="manytoone15" coords="16 70"/>
                    <area id="manytoone16" coords="17 70"/>
                </areaspec>
                <programlisting><![CDATA[<many-to-one
        name="propertyName"
        column="column_name"
        class="ClassName"
        cascade="cascade_style"
        fetch="join|select"
        update="true|false"
        insert="true|false"
        property-ref="propertyNameFromAssociatedClass"
        access="field|property|ClassName"
        unique="true|false"
        not-null="true|false"
        optimistic-lock="true|false"
        lazy="proxy|no-proxy|false"
        not-found="ignore|exception"
        entity-name="EntityName"
        formula="arbitrary SQL expression"
        node="element-name|@attribute-name|element/@attribute|."
        embed-xml="true|false"
        index="index_name"
        unique_key="unique_key_id"
        foreign-key="foreign_key_name"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="manytoone1">
                        <para>
                            <literal>name</literal>：プロパティ名。
                        </para>                    
                    </callout>                   
                    <callout arearefs="manytoone2">
                        <para>
                            <literal>column</literal> (オプション):外部キーカラムの名前。
                            ネストした <literal>&lt;column&gt;</literal> 要素でも指定できます。
                        </para>
                    </callout>
                    <callout arearefs="manytoone3">
                        <para>
                            <literal>class</literal>（オプション - デフォルトは、
                            リフレクションにより決定されるプロパティの型）：関連クラスの名前。
                        </para>
                    </callout>
                    <callout arearefs="manytoone4">
                        <para>
                            <literal>cascade</literal>（オプション）：
                            どの操作を、親オブジェクトから関連オブジェクトへとカスケードさせるかを指定します。
                        </para>                    
                    </callout>
                    <callout arearefs="manytoone5">
                        <para>
                            <literal>fetch</literal> (オプション - デフォルトは <literal>select</literal> ): 
                               外部結合フェッチか順次選択フェッチ（sequential select fetch）を選択します。
                        </para>                    
                    </callout>
                    <callout arearefs="manytoone6-7">
                        <para>
                            <literal>update, insert</literal>（オプション - デフォルトは <literal>true</literal> ）：
                            マッピングされたカラムがSQLの <literal>UPDATE</literal> または 
                            <literal>INSERT</literal> 文に含まれることを指定します。
                            両方とも <literal>false</literal> に設定すると、
                            その値が同じカラムにマッピングされた他のプロパティやトリガや
                            他のアプリケーションによって初期化された純粋な「導出」プロパティが可能になります。
                        </para>                    
                    </callout>
                    <callout arearefs="manytoone8">
                        <para>
                            <literal>property-ref</literal>（オプション）：
                            この外部キーに結合された関連クラスのプロパティ名。
                            何も指定しなければ、関連クラスの主キーが使われます。
                        </para>                
                    </callout>                   
                    <callout arearefs="manytoone9">
                        <para>
                            <literal>access</literal>（オプション - デフォルトは <literal>property</literal> ）：
                            プロパティの値へのアクセスにHibernateが使う戦略。
                        </para>
                    </callout>
                    <callout arearefs="manytoone10">
                        <para>
                            <literal>unique</literal>（オプション）：
                             外部キーカラムに対してユニーク制約をつけたDDLの生成を可能にします。
                             また、<literal>property-ref</literal> のターゲットにすることもできます。
                             これにより関連の多重度を効果的に一対一にします。
                        </para>
                    </callout>
                    <callout arearefs="manytoone11">
                        <para>
                            <literal>not-null</literal> (オプション):外部キーカラムに対して、
                            null値を許可するDDLの生成を可能にします
                        </para>
                    </callout>
                    <callout arearefs="manytoone12">
                        <para>
                            <literal>optimistic-lock</literal> (オプション - デフォルトは <literal>true</literal> ):
                            このプロパティの更新に楽観的ロックの取得を要求するかどうかを指定します。
                            言い換えれば、このプロパティがダーティであるときにバージョンを増やすべきかを決定します。
                        </para>
                    </callout>
                    <callout arearefs="manytoone13">
                        <para>
                            <literal>lazy</literal> (オプション - デフォルトは <literal>proxy</literal> ): 
                            デフォルトでは、多重度１の関連がプロキシとなります。
                            <literal>lazy="no-proxy"</literal> は、インスタンス変数に最初にアクセスしたときに、
                            プロパティを遅延フェッチするよう指定します
                            (ビルド時にバイトコード実装が必要になります)。
                            <literal>lazy="false"</literal> は関連を常に即時にフェッチするよう指定します。
                        </para>
                    </callout>
                    <callout arearefs="manytoone14">
                        <para>
                            <literal>not-found</literal> (オプション - デフォルトは <literal>exception</literal> ):
                            欠落した行を参照する外部キーをどのように扱うかを指定します。
                            <literal>ignore</literal> は欠落した行をnull関連として扱います。
                        </para>
                    </callout>
                    <callout arearefs="manytoone15">
                        <para>
                            <literal>entity-name</literal> (オプション):関連したクラスのエンティティ名。
                        </para>                   
                    </callout>
                </calloutlist>
                    <callout arearefs="manytoone16">
                        <para>
                            <literal>formula</literal> (オプション):
                             <emphasis> 計算された</emphasis> 外部キーに対して値を定義するSQL式
                        </para>
                    </callout>
            </programlistingco>

            <para>
                <literal>cascade</literal> 属性に <literal>none</literal> 以外の意味のある値をを設定すると、
                関連オブジェクトへある操作が伝播することになります。
                意味のある値とはHibernateの基本操作の名前のことで、
                <literal>delete-orphan</literal> と <literal>all</literal> 、操作名をカンマで区切った組み合わせ
                （例えば <literal>cascade="persist,merge,evict"</literal> や
                <literal>cascade="all,delete-orphan"</literal>）、
                またそれだけでなく <literal>persist, merge, delete, save-update, evict, replicate, lock,
                refresh</literal> のことを指します。
                詳しい説明は <xref linkend="objectstate-transitive"/> を見てください。
                値が一つの関連(many-to-oneとone-to-one関連)は、
                単独での削除（orphan delete)をサポートしていないことに注意してください。
            </para>
            
            <para>
                典型的な <literal>many-to-one</literal> 宣言は次のようにシンプルです。：
            </para>

            <programlisting><![CDATA[<many-to-one name="product" class="Product" column="PRODUCT_ID"/>]]></programlisting>
            
            <para>
                <literal>property-ref</literal> 属性は、外部キーが関連付けられたテーブルの、主キーでない
                ユニークキーを参照しているレガシーデータをマップするためにだけ使うべきです。
                これは醜いリレーショナルモデルです。
                例えば <literal>Product</literal> クラスが、
                主キーでないユニークなシリアルナンバーを持っていると仮定してみてください。
                （ <literal>unique</literal> 属性はSchemaExportツールを使ったHibernateのDDL生成を制御します。）
            </para>
            
            <programlisting><![CDATA[<property name="serialNumber" unique="true" type="string" column="SERIAL_NUMBER"/>]]></programlisting>
            
            <para>
                以下のように <literal>OrderItem</literal> に対してマッピングを使えます：
            </para>
            
            <programlisting><![CDATA[<many-to-one name="product" property-ref="serialNumber" column="PRODUCT_SERIAL_NUMBER"/>]]></programlisting>
            
            <para>
                しかし、これは決して推奨できません。
            </para>
            
            <para>
                参照したユニークキーが、関連するエンティティの多数のプロパティから構成される場合、
                指定した <literal>&lt;properties&gt;</literal> 要素内で、参照するプロパティをマッピングするべきです。
            </para>
            
            <para>
                もし参照したユニークキーがコンポーネントのプロパティである場合は、プロパティのパスを指定できます。
            </para>
            
           <programlisting><![CDATA[<many-to-one name="owner" property-ref="identity.ssn" column="OWNER_SSN"/>]]></programlisting>           
            
            
        </sect2>
        

        <sect2 id="mapping-declaration-onetoone" revision="3">
            <title>one-to-one</title>

            <para>
                他の永続クラスへの一対一関連は、<literal>one-to-one</literal> 要素で定義します。
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="onetoone1" coords="2 70"/>
                    <area id="onetoone2" coords="3 70"/>
                    <area id="onetoone3" coords="4 70"/>
                    <area id="onetoone4" coords="5 70"/>
                    <area id="onetoone5" coords="6 70"/>
                    <area id="onetoone6" coords="7 70"/>
                    <area id="onetoone7" coords="8 70"/>
                    <area id="onetoone8" coords="9 70"/>
                    <area id="onetoone9" coords="10 70"/>
                    <area id="onetoone10" coords="11 70"/>
                </areaspec>
                <programlisting><![CDATA[<one-to-one
        name="propertyName"
        class="ClassName"
        cascade="cascade_style"
        constrained="true|false"
        fetch="join|select"
        property-ref="propertyNameFromAssociatedClass"
        access="field|property|ClassName"
        formula="any SQL expression"
        lazy="proxy|no-proxy|false"
        entity-name="EntityName"
        node="element-name|@attribute-name|element/@attribute|."
        embed-xml="true|false"
        foreign-key="foreign_key_name"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="onetoone1">
                        <para>
                            <literal>name</literal>：プロパティ名。
                        </para>                
                    </callout>                   
                    <callout arearefs="onetoone2">
                        <para>
                            <literal>class</literal>（オプション - 
                            デフォルトはリフレクションにより決定されるプロパティの型）：
                            関連クラスの名前。
                        </para>                   
                    </callout>
                    <callout arearefs="onetoone3">
                        <para>
                            <literal>cascade</literal>（オプション）：
                            親オブジェクトから関連オブジェクトへ、どの操作をカスケードするかを指定します。
                        </para>
                    </callout>
                    <callout arearefs="onetoone4">
                        <para>
                            <literal>constrained</literal>（オプション）：
                            マッピングされたテーブルの主キーに対する外部キー制約が、
                            関連クラスのテーブルを参照することを指定します。
                            このオプションは <literal>save()</literal> と 
                            <literal>delete()</literal> がカスケードされる順序に影響し、
                            そして関連がプロキシされるかどうかにも影響します
                            （そしてスキーマエクスポートツールにも使われます）。
                        </para>                  
                    </callout>
                    <callout arearefs="onetoone5">
                        <para>
                            <literal>fetch</literal>（オプション - デフォルトは <literal>select</literal> ）：
                            外部結合フェッチと順次選択フェッチ（sequential select fetch）のどちらかを選択します。
                        </para>
                    </callout>
                    <callout arearefs="onetoone6">
                        <para>
                            <literal>property-ref</literal>（オプション）：
                            このクラスの主キーに結合された関連クラスのプロパティ名。
                            指定されなければ、関連クラスの主キーが使われます。
                        </para>                
                    </callout>                   
                    <callout arearefs="onetoone7">
                        <para>
                            <literal>access</literal>（オプション - デフォルトは <literal>property</literal> ）：
                            プロパティの値へのアクセスにHibernateが使う戦略。
                        </para>
                    </callout>
                    <callout arearefs="onetoone8">
                        <para>
                            <literal>formula</literal> (オプション):
                            ほとんどすべての一対一関連はオーナーのエンティティの主キーへとマッピングされます。
                            これ以外の稀な場合は、
                            他のカラムや、複数のカラム、SQL構文を使った結合するための式を指定できます。
                            （例は <literal>org.hibernate.test.onetooneformula</literal> を参照してください。）
                        </para>
                    </callout>
                    <callout arearefs="onetoone9">
                        <para>
                            <literal>lazy</literal> (オプション - デフォルトは <literal>proxy</literal> ): 
                            デフォルトでは、多重度１の関連がプロキシとなります。
                            <literal>lazy="no-proxy"</literal> は、インスタンス変数に最初にアクセスしたときに、
                            プロパティを遅延フェッチするよう指定します
                            (ビルド時にバイトコード実装が必要になります)。
                            <literal>lazy="false"</literal> は関連を常に即時にフェッチするよう指定します。
                            <emphasis>もし <literal>constrained="false"</literal> ならば、
                            プロキシは使用不可能となり、関連を即時にフェッチすることに注意してください！</emphasis> 
                            
                        </para>
                    </callout>
                    <callout arearefs="onetoone10">
                        <para>
                            <literal>entity-name</literal> (オプション):関連クラスのエンティティ名
                        </para>                   
                    </callout>
                </calloutlist>
            </programlistingco>
        
            <para>
                一対一関連には2種類あります：
            </para>
            <itemizedlist>
            <listitem><para>
                主キー関連
            </para></listitem>
            <listitem><para>
                ユニーク外部キー関連
            </para></listitem>
            </itemizedlist>
            
            <para>
                主キー関連には、特別なテーブルカラムは必要ありません。
                もし2つの行が関連により関係していれば、2つのテーブルは同じ主キーの値を共有します。
                そのため2つのオブジェクトを主キー関連によって関連付けたいのであれば、
                確実に同じ識別子の値を代入しなければなりません。
            </para>
            
            <para>
                 主キー関連を行うためには、以下のマッピングを <literal>Employee</literal> と 
                <literal>Person</literal> のそれぞれに追加してください。
            </para>

            <programlisting><![CDATA[<one-to-one name="person" class="Person"/>]]></programlisting>
            <programlisting><![CDATA[<one-to-one name="employee" class="Employee" constrained="true"/>]]></programlisting>

            <para>
                ここで、PERSONとEMPLOYEEテーブルの関係する行の主キーが同じであることを確実にしなければいけません。
                ここでは、<literal>foreign</literal> という特殊なHibernate識別子生成戦略を使います：
            </para>

            <programlisting><![CDATA[<class name="person" table="PERSON">
    <id name="id" column="PERSON_ID">
        <generator class="foreign">
            <param name="property">employee</param>
        </generator>
    </id>
    ...
    <one-to-one name="employee"
        class="Employee"
        constrained="true"/>
</class>]]></programlisting>

            <para>
                <literal>Employee</literal> インスタンスが、<literal>Person</literal> の 
                <literal>employee</literal> プロパティで参照されるように、
                新しくセーブされた <literal>Person</literal> のインスタンスには同じ主キーの値が代入されます。
                
                新しくセーブする <literal>Person</literal> インスタンスは、
                その <literal>Person</literal> の <literal>employee</literal> プロパティが参照する 
                <literal>Employee</literal> インスタンスとして同じ主キーが割り当てられます。
            </para>

            <para>
                もう1つの方法として、<literal>Employee</literal> から <literal>Person</literal> への
                ユニーク制約を使った外部キー関連は以下のように表現されます：
            </para>
            
            <programlisting><![CDATA[<many-to-one name="person" class="Person" column="PERSON_ID" unique="true"/>]]></programlisting>
            
            <para>
                そしてこの関連は、
                以下の記述を <literal>Person</literal> のマッピングに追加することで双方向にすることができます：
            </para>
            
           <programlisting><![CDATA[<one-to-one name="employee" class="Employee" property-ref="person"/>]]></programlisting>

        </sect2>
        
        <sect2 id="mapping-declaration-naturalid">
            <title>natural-id</title>

            <programlisting><![CDATA[<natural-id mutable="true|false"/>
        <property ... />
        <many-to-one ... />
        ......
</natural-id>]]></programlisting>

            <para>
                主キーとして代理キーの使用を推奨しますが、
                すべてのエンティティに対して自然キーを識別するようにすべきです。
                自然キーはユニークかつ非nullな一つのプロパティ、またはプロパティの連結です。
                不変であればさらに良いです。
                <literal>&lt;natural-id&gt;</literal> 要素内で自然キーのプロパティをマッピングします。
                Hibernateは必然的にユニークかつnull値を許可する制約を生成し、
                こうしてマッピングはより自己記述的になります。
            </para>
            
            <para>
                エンティティの自然キープロパティの比較には、
                <literal>equals()</literal> と <literal>hashCode()</literal> の実装を強くお勧めします。
            </para>

            <para>
                このマッピングは自然主キーを使ったエンティティでの使用を意図していません。
            </para>

            <itemizedlist spacing="compact">
                <listitem>
                    <para>
                        <literal>mutable</literal> (オプション, デフォルトは <literal>false</literal> ): 
                        デフォルトでは、自然識別子プロパティは不変(定数)と想定されています。
                    </para>
                </listitem>
            </itemizedlist>
            
        </sect2>
        
        <sect2 id="mapping-declaration-component" revision="2">
            <title>component, dynamic-component</title>

            <para>
                <literal>&lt;component&gt;</literal> 要素は、
                子オブジェクトのプロパティを親クラスのテーブルのカラムへマッピングします。
                コンポーネントは自分のプロパティ、コンポーネント、コレクションの順に定義できます。
                以下の「コンポーネント」を見てください。
            </para>

            <programlistingco>
                <areaspec>
                    <area id="component1" coords="2 45"/>
                    <area id="component2" coords="3 45"/>
                    <area id="component3" coords="4 45"/>
                    <area id="component4" coords="5 45"/>
                    <area id="component5" coords="6 45"/>
                    <area id="component6" coords="7 45"/>
                    <area id="component7" coords="8 45"/>
                    <area id="component8" coords="9 45"/>
                </areaspec>            
                <programlisting><![CDATA[<component 
        name="propertyName" 
        class="className"
        insert="true|false"
        update="true|false"
        access="field|property|ClassName"
        lazy="true|false"
        optimistic-lock="true|false"
        unique="true|false"
        node="element-name|."
>
        
        <property ...../>
        <many-to-one .... />
        ........
</component>]]></programlisting>
                <calloutlist>
                    <callout arearefs="component1">
                        <para>
                            <literal>name</literal>：プロパティ名。
                        </para>               
                    </callout>                   
                    <callout arearefs="component2">
                        <para>
                            <literal>class</literal> 
                            （オプション - デフォルトはリフレクションにより決定されるプロパティの型）：
                            コンポーネント（子）クラスの名前。
                        </para>                 
                    </callout>
                    <callout arearefs="component3">
                        <para>
                            <literal>insert</literal> ：マッピングされたカラムがSQLの 
                            <literal>INSERT</literal> に現れるようにするどうかを指定します。
                        </para>               
                    </callout>                   
                    <callout arearefs="component4">
                        <para>
                            <literal>update</literal> : マッピングされたカラムがSQL の 
                            <literal>UPDATE</literal> に現れるようにするかどうかを指定します。
                        </para>               
                    </callout>                   
                    <callout arearefs="component5">
                        <para>
                             <literal>access</literal> （オプション - デフォルトは <literal>property</literal> ）：
                            プロパティの値へのアクセスにHibernateが使う戦略。
                        </para>
                    </callout>
                   <callout arearefs="component6">
                        <para>
                            <literal>lazy</literal> (optional - デフォルトは <literal>false</literal> ):
                           インスタンス変数に最初にアクセスしたときに、
                           コンポーネントを遅延してフェッチするよう指定します。
                           (バイトコード実装を作成する時間が必要になります)
                        </para>
                    </callout>
                    <callout arearefs="component7">
                            <para>
                                <literal>optimistic-lock</literal> (オプション - デフォルトは <literal>true</literal> ):
                            このプロパティの更新に、楽観ロックの取得を要求するかどうかを指定します。
                            言い換えれば、このプロパティがダーティであるときにバージョンを増やすべきかを決定します。
                            </para>
                    </callout>
                    <callout arearefs="component8">
                            <para>
                                <literal>unique</literal> (オプション - デフォルトは <literal>false</literal> ):
                                コンポーネントのすべてのマッピングするカラムに、ユニーク制約が存在するかを指定します。
                            </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                子の <literal>&lt;property&gt;</literal> タグで、
                子のクラスのプロパティをテーブルカラムにマッピングします。
            </para>

            <para>
                <literal>&lt;component&gt;</literal> 要素は、親エンティティへ戻る参照として、
                コンポーネントのクラスのプロパティをマッピングする <literal>&lt;parent&gt;</literal> サブ要素を許可します。
            </para>

            <para>
                <literal>&lt;dynamic-component&gt;</literal> 要素は、
                <literal>Map</literal> がコンポーネントとしてマッピングされることを可能にします。
                プロパティ名はmapのキーを参照します。<xref linkend="components-dynamic"/> を参照してください。
                
            </para>
            
        </sect2>

        <sect2 id="mapping-declaration-properties" revision="2">
            <title>properties</title>

            <para>
                <literal>&lt;properties&gt;</literal> 要素はクラスのプロパティの指定された、
                論理的なグルーピングを可能にします。
                この構造の最も重要な使用方法は、
                <literal>property-ref</literal> のターゲットになるプロパティの結合を許可することです。
                それはまた、複数カラムのユニーク制約を定義する簡単な方法でもあります。
            </para>

            <programlistingco>
                <areaspec>
                    <area id="properties1" coords="2 45"/>
                    <area id="properties2" coords="3 45"/>
                    <area id="properties3" coords="4 45"/>
                    <area id="properties4" coords="5 45"/>
                    <area id="properties5" coords="6 45"/>
                </areaspec>            
                <programlisting><![CDATA[<properties 
        name="logicalName" 
        insert="true|false"
        update="true|false"
        optimistic-lock="true|false"
        unique="true|false"
>
        
        <property ...../>
        <many-to-one .... />
        ........
</properties>]]></programlisting>
                <calloutlist>
                    <callout arearefs="properties1">
                        <para>
                            <literal>name</literal> : グルーピングの論理名。
                            実際のプロパティ名では <emphasis>ありません</emphasis> 。
                        </para>               
                    </callout>                   
                    <callout arearefs="properties2">
                        <para>
                            <literal>insert</literal>：マッピングされたカラムがSQLの 
                            <literal>INSERT</literal> に現れるようにするかどうかを指定します。
                        </para>               
                    </callout>                   
                    <callout arearefs="properties3">
                        <para>
                            <literal>update</literal>：マッピングされたカラムがSQLの 
                            <literal>UPDATE</literal> に現れるようにするかどうかを指定します。
                        </para>               
                    </callout>                   
                    <callout arearefs="properties4">
                            <para>
                                <literal>optimistic-lock</literal> (オプション - デフォルトは <literal>true</literal> ):
                            これらのプロパティの更新に楽観的ロックの取得を要求するかどうかを指定します。
                            言い換えれば、このプロパティがダーティであるときにバージョンを増やすべきかを決定します。
                            </para>
                    </callout>
                    <callout arearefs="properties5">
                            <para>
                                <literal>unique</literal> (オプション - デフォルトは <literal>false</literal> ):
                                コンポーネントのすべてのマッピングするカラムに、ユニーク制約が存在するかを指定します。
                            </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            
            <para>
                例えば、もし以下のような <literal>&lt;properties&gt;</literal> マッピングがあった場合：
            </para>
            
            <programlisting><![CDATA[<class name="Person">
    <id name="personNumber"/>
    ...
    <properties name="name" 
            unique="true" update="false">
        <property name="firstName"/>
        <property name="initial"/>
        <property name="lastName"/>
    </properties>
</class>]]></programlisting>

            <para>
                主キーの代わりに <literal>Person</literal> テーブルのユニークキーへの参照を持つ、
                レガシーデータの関連を持つかもしれません。：
            </para>

            <programlisting><![CDATA[<many-to-one name="person" 
         class="Person" property-ref="name">
    <column name="firstName"/>
    <column name="initial"/>
    <column name="lastName"/>
</many-to-one>]]></programlisting>
            
            <para>
                しかし、このようなレガシーデータマッピングのコンテキスト外への使用は推奨しません。
            </para>
            
        </sect2>

        <sect2 id="mapping-declaration-subclass" revision="4">
            <title>subclass</title>

            <para>
                最後にポリモーフィックな永続化には、ルートの永続クラスの各サブクラスの定義が必要です。
                table-per-class-hierarchyマッピング戦略では、
                <literal>&lt;subclass&gt;</literal> 定義が使われます。
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="subclass1" coords="2 55"/>
                    <area id="subclass2" coords="3 55"/>
                    <area id="subclass3" coords="4 55"/>
                    <area id="subclass4" coords="5 55"/>
                </areaspec>
                <programlisting><![CDATA[<subclass
        name="ClassName"
        discriminator-value="discriminator_value"
        proxy="ProxyInterface"
        lazy="true|false"
        dynamic-update="true|false"
        dynamic-insert="true|false"
        entity-name="EntityName"
        node="element-name"
        extends="SuperclassName">

        <property .... />
        .....
</subclass>]]></programlisting>
                <calloutlist>
                    <callout arearefs="subclass1">
                        <para>
                            <literal>name</literal>：サブクラスの完全修飾されたクラス名。
                        </para>              
                    </callout>                   
                    <callout arearefs="subclass2">
                        <para>
                            <literal>discriminator-value</literal>（オプション - デフォルトはクラス名）：
                            個々のサブクラスを区別するための値。
                        </para>               
                    </callout>
                    <callout arearefs="subclass3">
                        <para>
                            <literal>proxy</literal>（オプション）：
                            遅延初期化プロキシに使うクラスやインターフェイスを指定します。
                        </para>               
                    </callout>
                    <callout arearefs="subclass4">
                        <para>
                            <literal>lazy</literal>（オプション, デフォルトは <literal>true</literal> ）： 
                            <literal>lazy="false"</literal> と設定すると、遅延フェッチが使用できません。
                        </para>
                    </callout>    
                </calloutlist>
            </programlistingco>

            <para>
                各サブクラスでは、永続プロパティとサブクラスを定義します。  
                <literal>&lt;version&gt;</literal> と <literal>&lt;id&gt;</literal> プロパティは、
                ルートクラスから継承されると仮定されます。
                階層構造におけるサブクラスは、
                ユニークな <literal>discriminator-value</literal> を定義しなければなりません。
                noneが指定されると、完全修飾されたJavaクラス名が使われます。
            </para>
            
<!--
       <para>
            It is possible to define <literal>subclass</literal>, <literal>union-subclass</literal>,
            and <literal>joined-subclass</literal> mappings in separate mapping documents, directly beneath
            <literal>hibernate-mapping</literal>. This allows you to extend a class hierachy just by adding
            a new mapping file. You must specify an <literal>extends</literal> attribute in the subclass mapping,
            naming a previously mapped superclass. Note: Previously this feature made the ordering of the mapping
            documents important. Since Hibernate3, the ordering of mapping files does not matter when using the
            extends keyword. The ordering inside a single mapping file still needs to be defined as superclasses
            before subclasses.
            
            <literal>subclass</literal> 、<literal>union-subclass</literal> 、
            <literal>joined-subclass</literal> マッピングを 
            <literal>hibernate-mapping</literal> 直下の別のマッピングドキュメント内で宣言できます。
            これにより、新しいマッピングファイルを追加するだけでクラス階層を拡張することができます。
            あらかじめマッピングするスーパークラスを指定したサブクラスマッピング内で、
            <literal>extends</literal> 属性を指定しなければなりません。
            注意：この特性はマッピングドキュメントの順番付けが重要になります。
            Hibernate3では、拡張キーワードを使うときには、マッピングファイルの順序付けは問題になりません。
            一つのマッピングファイル内での順序付けは未だに、サブクラスの前にスーパークラスとして定義する必要があります。
        </para>
        
    
        <programlisting><![CDATA[
<hibernate-mapping>
    <subclass name="DomesticCat" extends="Cat" discriminator-value="D">
         <property name="name" type="string"/>
    </subclass>
</hibernate-mapping>]]></programlisting>
-->

            <para>
                継承のマッピングに関する情報は <xref linkend="inheritance"/> を見てください。
            </para>

        </sect2>
        

         <sect2 id="mapping-declaration-joinedsubclass" revision="3">
            <title>joined-subclass</title>

            <para>
                もう1つの方法として、各サブクラスを自身のテーブルへマッピングすることができます
                (table-per-subclass mapping strategy)。
                継承した状態はスーパークラスのテーブルを使った結合で検索します。
                <literal>&lt;joined-subclass&gt;</literal> 要素を使用します。
            </para>

            <programlistingco>
                <areaspec>
                    <area id="joinedsubclass1" coords="2 45"/>
                    <area id="joinedsubclass2" coords="3 45"/>
                    <area id="joinedsubclass3" coords="4 45"/>
                    <area id="joinedsubclass4" coords="5 45"/>
                </areaspec>
                <programlisting><![CDATA[<joined-subclass
        name="ClassName"
        table="tablename"
        proxy="ProxyInterface"
        lazy="true|false"
        dynamic-update="true|false"
        dynamic-insert="true|false"
        schema="schema"
        catalog="catalog"
        extends="SuperclassName"
        persister="ClassName"
        subselect="SQL expression"
        entity-name="EntityName"
        node="element-name">

        <key .... >

        <property .... />
        .....
</joined-subclass>]]></programlisting>
                <calloutlist>
                    <callout arearefs="joinedsubclass1">
                        <para>
                            <literal>name</literal>：サブクラスの完全修飾されたクラス名。
                        </para>            
                    </callout>                   
                    <callout arearefs="joinedsubclass2">
                        <para>
                            <literal>table</literal> :サブクラステーブルの名前。
                        </para>            
                    </callout>                   
                    <callout arearefs="joinedsubclass3">
                        <para>
                            <literal>proxy</literal> (オプション):
                            遅延初期化プロキシに使用するクラスやインターフェイスを指定します。
                        </para>              
                    </callout>
                    <callout arearefs="joinedsubclass4">
                        <para>
                            <literal>lazy</literal> (オプション, デフォルトは <literal>true</literal> ): 
                            <literal>lazy="false"</literal> とすると、遅延フェッチが使用できません。
                         </para>
                    </callout>    
                </calloutlist>
            </programlistingco>

            <para>
                このマッピング戦略には、識別カラムは必要ありません。
                しかし各サブクラスは <literal>&lt;key&gt;</literal> 要素を使い、
                オブジェクト識別子を保持するテーブルカラムを定義しなければなりません。
                この章の初めのマッピングは以下のように書き直せます：
            </para>
            
        <programlisting><![CDATA[<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">

<hibernate-mapping package="eg">

        <class name="Cat" table="CATS">
                <id name="id" column="uid" type="long">
                        <generator class="hilo"/>
                </id>
                <property name="birthdate" type="date"/>
                <property name="color" not-null="true"/>
                <property name="sex" not-null="true"/>
                <property name="weight"/>
                <many-to-one name="mate"/>
                <set name="kittens">
                        <key column="MOTHER"/>
                        <one-to-many class="Cat"/>
                </set>
                <joined-subclass name="DomesticCat" table="DOMESTIC_CATS">
                    <key column="CAT"/>
                    <property name="name" type="string"/>
                </joined-subclass>
        </class>

        <class name="eg.Dog">
                <!-- ここにDogのマッピングを書きます -->
        </class>

</hibernate-mapping>]]></programlisting>

             <para>
                 継承のマッピングに関する情報は <xref linkend="inheritance"/> を見てください。
             </para>

        </sect2>

        <sect2 id="mapping-declaration-unionsubclass" revision="2">
           <title>union-subclass</title>

           <para>
               3つ目の選択肢は、継承階層の具象クラスのみをテーブルにマッピングすることです
               (the table-per-concrete-class戦略)。
               それぞれのテーブルは継承の状態を含めすべてのクラスの永続状態を定義します。
               Hibernateではその様な継承階層が必ずしも必要ではありません。
               単純にそれぞれのクラスを、
               別々の <literal>&lt;class&gt;</literal> 宣言を使ってマッピングすることができます。
               しかしポリモーフィックな関連(例えば 階層のスーパークラスへの関連)を使いたいなら、
               <literal>&lt;union-subclass&gt;</literal> マッピングを使う必要があります。
               
           </para>

            <programlistingco>
                <areaspec>
                    <area id="unionsubclass1" coords="2 45"/>
                    <area id="unionsubclass2" coords="3 45"/>
                    <area id="unionsubclass3" coords="4 45"/>
                    <area id="unionsubclass4" coords="5 45"/>
                </areaspec>
                <programlisting><![CDATA[<union-subclass
        name="ClassName"
        table="tablename"
        proxy="ProxyInterface"
        lazy="true|false"
        dynamic-update="true|false"
        dynamic-insert="true|false"
        schema="schema"
        catalog="catalog"
        extends="SuperclassName"
        abstract="true|false"
        persister="ClassName"
        subselect="SQL expression"
        entity-name="EntityName"
        node="element-name">

        <property .... />
        .....
</union-subclass>]]></programlisting>
                <calloutlist>
                    <callout arearefs="unionsubclass1">
                        <para>
                            <literal>name</literal>：サブクラスの完全修飾されたクラス名。
                        </para>            
                    </callout>                   
                    <callout arearefs="unionsubclass2">
                        <para>
                            <literal>table</literal> :サブクラステーブルの名前。
                        </para>            
                    </callout>                   
                    <callout arearefs="unionsubclass3">
                        <para>
                            <literal>proxy</literal> (オプション):
                            遅延初期化プロキシに使用するクラスやインターフェイスを指定します。
                        </para>              
                    </callout>
                    <callout arearefs="unionsubclass4">
                        <para>
                            <literal>lazy</literal> (オプション, デフォルトは <literal>true</literal> ): 
                            <literal>lazy="false"</literal> とすると、遅延フェッチが使用できません。
                         </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                このマッピング戦略では識別カラムやキーカラムは必要ありません。
            </para>

            <para>
                継承のマッピングに関する情報は <xref linkend="inheritance"/> を見てください。
            </para>

        </sect2>

       <sect2 id="mapping-declaration-join" revision="3">
            <title>join</title>

            <para>
                <literal>&lt;join&gt;</literal> 要素を使うことで、
                １つのクラスのプロパティをいくつものテーブルにマッピングすることができます。
            </para>

            <programlistingco>
                <areaspec>
                    <area id="join1" coords="2 50"/>
                    <area id="join2" coords="3 50"/>
                    <area id="join3" coords="4 50"/>
                    <area id="join4" coords="5 50"/>
                    <area id="join5" coords="6 50"/>
                    <area id="join6" coords="7 50"/>
                </areaspec>
                <programlisting><![CDATA[<join
        table="tablename"
        schema="owner"
        catalog="catalog"
        fetch="join|select"
        inverse="true|false"
        optional="true|false">
        
        <key ... />
        
        <property ... />
        ...
</join>]]></programlisting>

                <calloutlist>
                    <callout arearefs="join1">
                        <para>
                            <literal>table</literal> :結合したテーブルの名前
                        </para>
                    </callout>
                    <callout arearefs="join2">
                        <para>
                           <literal>schema</literal> (オプション):
                           ルートの <literal>&lt;hibernate-mapping&gt;</literal> 要素で指定したスキーマ名を
                           オーバーライドします。
                        </para>
                    </callout>
                    <callout arearefs="join3">
                        <para>
                            <literal>catalog</literal> (オプション):
                            ルートの <literal>&lt;hibernate-mapping&gt;</literal> 要素で指定したカタログ名を
                            オーバーライドします。
                        </para>
                    </callout>
                    <callout arearefs="join4">
                        <para>
                            <literal>fetch</literal> (オプション - デフォルトは <literal>join</literal> ): 
                            <literal>join</literal> を設定した場合、
                            Hibernateはデフォルトで、クラスやスーパークラスで定義された <literal>&lt;join&gt;</literal> 
                            を検索するのに内部結合を使い、サブクラスで定義された <literal>&lt;join&gt;</literal> 
                            を検索するのに外部結合を使います。
                            <literal>select</literal> を設定した場合には、
                            Hibernateはサブクラスで定義された <literal>&lt;join&gt;</literal> 
                            の選択に順次選択を使います。この場合、
                            行がサブクラスのインスタンスを代表することがわかった場合にのみ発行されます。
                            内部結合はクラスやそのスーパークラスで定義された <literal>&lt;join&gt;</literal> を検索
                            するために使用します。                            
                        </para>
                    </callout>
                    <callout arearefs="join5">
                        <para>
                            <literal>inverse</literal> (オプション - デフォルトは <literal>false</literal> ):
                            もし可能であれば、Hibernateはこの結合で定義されているプロパティに対し
                            挿入や更新を行いません。
                        </para>
                    </callout>
                    <callout arearefs="join6">
                        <para>
                            <literal>optional</literal> (オプション - デフォルトは <literal>false</literal> ):
                            もし可能であれば、Hibernateはこの結合で定義されたプロパティがnullでない場合にのみ
                            行を挿入し、そのプロパティの検索には常に外部結合を使用します。
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                例えば人のアドレスの情報を分離したテーブルにマッピングすることが可能です
                (すべてのプロパティに対して値型のセマンティクスを保持します)。
            </para>

            <programlisting><![CDATA[<class name="Person"
    table="PERSON">

    <id name="id" column="PERSON_ID">...</id>

    <join table="ADDRESS">
        <key column="ADDRESS_ID"/>
        <property name="address"/>
        <property name="zip"/>
        <property name="country"/>
    </join>
    ...]]></programlisting>

            <para>
                この特徴はしばしばレガシーデータモデルに対してのみ有用ですが、
                クラスよりも少ないテーブルと、きめの細かいドメインモデルを推奨します。
                しかし後で説明するように、１つのクラス階層で継承のマッピング戦略を切り替える時には有用です。
            </para>

        </sect2>

        <sect2 id="mapping-declaration-key">
            <title>key</title>

            <para>
                今まで何度か <literal>&lt;key&gt;</literal> 要素が出てきました。
                この要素は新しいテーブルへの結合を定義したり、
                結合テーブルで外部キーを定義したりする親要素のどこにでも現れ、
                オリジナルテーブルの主キーを参照します。
            </para>

            <programlistingco>
                <areaspec>
                    <area id="key1" coords="2 50"/>
                    <area id="key2" coords="3 50"/>
                    <area id="key3" coords="4 50"/>
                    <area id="key4" coords="5 50"/>
                    <area id="key5" coords="6 50"/>
                    <area id="key6" coords="7 50"/>
                </areaspec>
                <programlisting><![CDATA[<key
        column="columnname"
        on-delete="noaction|cascade"
        property-ref="propertyName"
        not-null="true|false"
        update="true|false"
        unique="true|false"
/>]]></programlisting>

                <calloutlist>
                    <callout arearefs="key1">
                        <para>
                             <literal>column</literal> (オプション):外部キーカラムの名前。
                             ネストした <literal>&lt;column&gt;</literal> カラムによっても指定されます。
                        </para>
                    </callout>
                    <callout arearefs="key2">
                        <para>
                             <literal>on-delete</literal> (オプション, デフォルトは <literal>noaction</literal>):
                            外部キー制約がデータベースレベルでカスケード削除が可能かどうかを指定します。
                        </para>
                    </callout>
                    <callout arearefs="key3">
                        <para>
                             <literal>property-ref</literal> (オプション):
                             オリジナルテーブルの主キーではないカラムを参照する外部キーを指定します
                             (レガシーデータに対して提供されます)。
                        </para>
                    </callout>
                    <callout arearefs="key4">
                        <para>
                           <literal>not-null</literal> (オプション):
                           外部キーカラムがnull値を許容しないことを指定します
                           (このことは外部キーが主キーの一部であることを暗黙的に示します)。
                        </para>
                    </callout>
                    <callout arearefs="key5">
                        <para>
                            <literal>update</literal> (オプション):
                            外部キーを決して更新してはならないことを指定します
                            (このことは外部キーが主キーの一部であることを暗黙的に示します)。
                            
                        </para>
                    </callout>
                    <callout arearefs="key6">
                        <para>
                            <literal>unique</literal> (オプション):
                            外部キーがユニーク制約を持つべきであることを指定します
                            (このことは外部キーが主キーの一部であることを暗黙的に示します)。
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                削除のパフォーマンスが重要であるシステムには、
                すべてのキーを <literal>on-delete="cascade"</literal> と定義することを推奨します。
                そうすることでHibernateは、<literal>DELETE</literal> 文を毎回発行する代わりに、
                データベースレベルの <literal>ON CASCADE DELETE</literal> 制約を使用します。
                この特徴はバージョン付けられたデータに対するHibernateの通常の楽観的ロック戦略を
                無視するということに注意してください。
            </para>
            
            <para>
                <literal>not-null</literal> と <literal>update</literal> 属性は、単方向一対多関連の時には有用です。
                単方向一対多関連をnullを許容しない外部キーにマッピングするときは、
                <literal>&lt;key not-null="true"&gt;</literal> を使ってキーカラムを宣言
                 <emphasis> しなくてはなりません</emphasis> 。
            </para>

        </sect2>

        <sect2 id="mapping-column" revision="4">
           <title>column と formula 要素</title>
           <para>
               <literal>column</literal> 属性を記述できる任意のマッピング要素はまた、
               <literal>&lt;column&gt;</literal> サブ要素も記述できます。
               同様に <literal>&lt;formula&gt;</literal> も <literal>formula</literal> 属性の代替手段です。
           </para>

           <programlisting><![CDATA[<column
        name="column_name"
        length="N"
        precision="N"
        scale="N"
        not-null="true|false"
        unique="true|false"
        unique-key="multicolumn_unique_key_name"
        index="index_name"
        sql-type="sql_type_name"
        check="SQL expression"
        default="SQL expression"/>]]></programlisting>

            <programlisting><![CDATA[<formula>SQL expression</formula>]]></programlisting>
        
            <para>
                同じプロパティや関連のマッピングの中で、
                <literal>column</literal> と <literal>formula</literal> 属性を組み合わせることができます。
                例えば、特殊な結合条件などです。
            </para>

            <programlisting><![CDATA[<many-to-one name="homeAddress" class="Address"
        insert="false" update="false">
    <column name="person_id" not-null="true" length="10"/>
    <formula>'MAILING'</formula>
</many-to-one>]]></programlisting>

    </sect2>  
    
        <sect2 id="mapping-declaration-import">
            <title>import</title>

            <para>
                アプリケーションに同じ名前の2つの永続クラスがあり、
                Hibernateクエリで完全修飾された（パッケージの）名前を指定したくないと仮定します。
                そのような場合は <literal>auto-import="true"</literal> に頼らず、
                クラスが「インポート」されたものであると明示できます。
                明示的にマッピングされていないクラスやインターフェイスでさえもインポートできます。
            </para>
            
            <programlisting><![CDATA[<import class="java.lang.Object" rename="Universe"/>]]></programlisting>
            
            <programlistingco>
                <areaspec>
                    <area id="import1" coords="2 40"/>
                    <area id="import2" coords="3 40"/>
                </areaspec>
                <programlisting><![CDATA[<import
        class="ClassName"
        rename="ShortName"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="import1">
                        <para>
                            <literal>class</literal>：Javaクラスの完全修飾されたクラス名。
                        </para>              
                    </callout>                   
                    <callout arearefs="import2">
                        <para>
                            <literal>rename</literal>（オプション - デフォルトは修飾されていないクラス名）：
                            クエリ言語で使われる名前。
                        </para>               
                    </callout>
                </calloutlist>
            </programlistingco>
            
        </sect2>

        <sect2 id="mapping-types-anymapping" revision="2">
            <title>any</title>
            
            <para>
                プロパティマッピングにはさらにもう1つの型があります。
                <literal>&lt;any&gt;</literal> マッピング要素は、
                複数のテーブルからクラスへのポリモーフィックな関連を定義します。
                この型のマッピングには必ず複数のカラムが必要です。1番目のカラムは関連エンティティの型を保持します。
                残りのカラムは識別子を保持します。この種類の関連には外部キー制約を指定することはできません。
                そのためこれは最も使われることのない（ポリモーフィックな）関連のマッピング方法です。
                非常に特別な場合（例えば、検査ログやユーザセッションデータなど)に限って、これを使うべきです。
            </para>

            <para>
                 <literal>meta-type</literal> により、
                 アプリケーションはカスタム型を指定できます。このカスタム型は
                 データベースカラムの値を、<literal>id-type</literal> で指定した型の
                 識別子プロパティを持った永続クラスへマッピングします。
                 meta-typeの値からクラス名へのマッピングを指定しなければなりません。
            </para>

            <programlisting><![CDATA[<any name="being" id-type="long" meta-type="string">
    <meta-value value="TBL_ANIMAL" class="Animal"/>
    <meta-value value="TBL_HUMAN" class="Human"/>
    <meta-value value="TBL_ALIEN" class="Alien"/>
    <column name="table_name"/>
    <column name="id"/>
</any>]]></programlisting>

            <programlistingco>
                <areaspec>
                    <area id="any1" coords="2 50"/>
                    <area id="any2" coords="3 50"/>
                    <area id="any3" coords="4 50"/>
                    <area id="any4" coords="5 50"/>
                    <area id="any5" coords="6 50"/>
                    <area id="any6" coords="7 50"/>
                </areaspec>
                <programlisting><![CDATA[<any
        name="propertyName"
        id-type="idtypename"
        meta-type="metatypename"
        cascade="cascade_style"
        access="field|property|ClassName"
        optimistic-lock="true|false"
>
        <meta-value ... />
        <meta-value ... />
        .....
        <column .... />
        <column .... />
        .....
</any>]]></programlisting>
                <calloutlist>
                    <callout arearefs="any1">
                        <para>
                            <literal>name</literal>：プロパティ名。
                        </para>            
                    </callout>                   
                    <callout arearefs="any2">
                        <para>
                            <literal>id-type</literal>：識別子の型。
                        </para>            
                    </callout>                   
                    <callout arearefs="any3">
                        <para>
                            <literal>meta-type</literal>（オプション - デフォルトは <literal>string</literal> ）：
                            ディスクリミネータマッピングで許された型
                        </para>            
                    </callout>                   
                    <callout arearefs="any4">
                        <para>
                            <literal>cascade</literal>（オプション - デフォルトは <literal>none</literal> ）：
                            カスケードのスタイル。
                        </para>            
                    </callout>                   
                    <callout arearefs="any5">
                        <para>
                            <literal>access</literal>（オプション - デフォルトは <literal>property</literal> ）：
                            プロパティの値へのアクセスにHibernateが使う戦略。
                        </para>
                    </callout>
                    <callout arearefs="any6">
                        <para>
                            <literal>optimistic-lock</literal> (オプション - デフォルトは <literal>true</literal> ):
                            このプロパティの更新に楽観ロックの取得を要求するかどうかを指定します。
                            言い換えれば、このプロパティがダーティであるときにバージョンを増やすべきかを定義します。
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

      </sect2>

    </sect1>

    <sect1 id="mapping-types">
        <title>Hibernateの型</title>

        <sect2 id="mapping-types-entitiesvalues" revision="1">
            <title>エンティティと値</title>

            <para>
                永続サービスに関わる様々なJava言語レベルのオブジェクトの振る舞いを理解するためには、
                オブジェクトを2つのグループに分ける必要があります：
            </para>

            <para>
                 <emphasis> エンティティ</emphasis> はエンティティへの参照を保持する、
                他のすべてのオブジェクトから独立して存在します。
                参照されないオブジェクトがガベージコレクトされてしまう性質を持つ通常のJavaモデルと、
                これを比べてみてください。
                （親エンティティから子へ、セーブと削除が <emphasis>カスケード</emphasis> されうることを除いて）
                エンティティは明示的にセーブまたは削除されなければなりません。
                これは到達可能性によるオブジェクト永続化のODMGモデルとは異なっています。
                大規模なシステムでアプリケーションオブジェクトが普通どのように使われるかにより密接に対応します。
                エンティティは循環と参照の共有をサポートします。
                またそれらはバージョン付けすることもできます。
                
            </para>

            <para>
                エンティティの永続状態は他のエンティティや <emphasis>値</emphasis> 型の
                インスタンスへの参照から構成されます。
                値はプリミティブ、コレクション(コレクションの内部ではなく)、
                コンポーネント、不変オブジェクトです。
                エンティティとは違い、値は（特にコレクションとコンポーネントにおいて）、
                到達可能性による永続化や削除が <emphasis>行われます</emphasis> 。
                値オブジェクト（とプリミティブ）は、包含するエンティティと一緒に永続化や削除が行われるので、
                それらを独立にバージョン付けすることはできません。
                値には独立したアイデンティティがないので、
                複数のエンティティやコレクションがこれを共有することはできません。
            </para>

            <para>
                これまで「永続クラス」という言葉をエンティティの意味で使ってきました。
                これからもそうしていきます。
                厳密に言うと、永続状態を持つユーザ定義のクラスのすべてが
                エンティティというわけではありません。
                <emphasis>コンポーネント</emphasis> は値のセマンティクスを持つユーザ定義クラスです。
                <literal>java.lang.String</literal> 型のプロパティもまた値のセマンティクスを持ちます。
                定義するなら、JDKで提供されているすべてのJavaの型(クラス)が値のセマンティクスを持つといえます。
                一方ユーザ定義型は、エンティティや値型のセマンティクスとともにマッピングできます。
                この決定はアプリケーション開発者次第です。
                そのクラスの１つのインスタンスへの共有参照は、
                ドメインモデル内のエンティティクラスに対する良いヒントになります。
                一方合成集約や集約は、通常値型へ変換されます。
                
            </para>

            <para>
                本ドキュメントを通して、何度もこの概念を取り上げます。
            </para>

            <para>
                Java型のシステム(もしくは開発者が定義したエンティティと値型)を
                SQL/データベース型のシステムにマッピングすることは難しいです。
                Hibernateは２つのシステムの架け橋を提供します。
                エンティティに対しては 
                <literal>&lt;class&gt;</literal> や <literal>&lt;subclass&gt;</literal> などを使用します。
                値型に対しては <literal>&lt;property&gt;</literal> や 
                <literal>&lt;component&gt;</literal> などを、通常 <literal>type</literal> とともに使います。
                この属性の値はHibernateの <emphasis>マッピング型</emphasis> の名前です。
                Hibernateは(標準JDKの値型に対して)多くの自由なマッピングを提供します。
                後で見るように、自身のマッピング型を記述し、同様にカスタムの変換戦略を実装することができます。
            </para>

            <para>
                コレクションを除く組み込みのHibernateの型はすべて、nullセマンティクスをサポートします。
            </para>

        </sect2>

        <sect2 id="mapping-types-basictypes" revision="3">
            <title>基本的な型</title>

            <para>
                組み込みの <emphasis>基本的なマッピング型</emphasis> は大まかに以下のように分けられます。

                <variablelist>
                    <varlistentry>
                        <term><literal>integer, long, short, float, double, character, byte,
                            boolean, yes_no, true_false</literal></term>
                        <listitem>
                            <para>
                                Javaのプリミティブやラッパークラスから適切な（ベンダー固有の）
                                SQLカラム型への型マッピング。
                                <literal>boolean, yes_no</literal> と <literal>true_false</literal> は、
                                すべてJavaの <literal>boolean</literal> 
                                または <literal>java.lang.Boolean</literal> の代替エンコードです。
                                
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>string</literal></term>
                        <listitem>
                            <para>
                                <literal>java.lang.String</literal> から <literal>VARCHAR</literal> 
                                （またはOracleの <literal>VARCHAR2</literal> ）への型マッピング。
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>date, time, timestamp</literal></term>
                        <listitem>
                            <para>
                                 <literal>java.util.Date</literal> とそのサブクラスからSQL型の <literal>DATE</literal>, 
                                <literal>TIME</literal> , <literal>TIMESTAMP</literal> （またはそれらと等価なもの）
                                への型マッピング。
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>calendar, calendar_date</literal></term>
                        <listitem>
                            <para>
                                <literal>java.util.Calendar</literal> からSQL型 の「 <literal>TIMESTAMP</literal> , 
                                 <literal>DATE</literal> (またはそれらと等価なもの）への型マッピング。
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>big_decimal, big_integer</literal></term>
                        <listitem>
                            <para>
                                <literal>java.math.BigDecimal</literal> と <literal>java.math.BigInteger</literal> 
                                から <literal>NUMERIC</literal>（またはOracleの <literal>NUMBER</literal> ）への型マッピング。
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>locale, timezone, currency</literal></term>
                        <listitem>
                            <para>
                                <literal>java.util.Locale</literal> , <literal>java.util.TimeZone</literal> , 
                                <literal>java.util.Currency</literal> から <literal>VARCHAR</literal> 
                                （またはOracleの <literal>VARCHAR2</literal> ）への型マッピング。
                                <literal>Locale</literal> と <literal>Currency</literal> のインスタンスは、
                                それらのISOコードにマッピングされます。 
                                <literal>TimeZone</literal> のインスタンスは、
                                それらの <literal>ID</literal> にマッピングされます。
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>class</literal></term>
                        <listitem>
                            <para>
                                <literal>java.lang.Class</literal> から <literal>VARCHAR</literal> 
                                （またはOracleの <literal>VARCHAR2</literal> ）への型マッピング。
                                <literal>Class</literal> はその完全修飾された名前にマッピングされます。
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>binary</literal></term>
                        <listitem>
                            <para>
                                 バイト配列は、適切なSQLのバイナリ型にマッピングされます。
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>text</literal></term>
                        <listitem>
                            <para>
                                長いJava文字列は、SQLの <literal>CLOB</literal> または 
                                <literal>TEXT</literal> 型にマッピングされます。
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>serializable</literal></term>
                        <listitem>
                            <para>
                                シリアライズ可能なJava型は、適切なSQLのバイナリ型にマッピングされます。
                                デフォルトで基本型ではないシリアライズ可能なJavaクラスや
                                インターフェイスの名前を指定することで、
                                Hibernateの型を <literal>serializable</literal> とすることもできます。
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>clob, blob</literal></term>
                        <listitem>
                            <para>
                                JDBCクラス <literal>java.sql.Clob</literal> と <literal>java.sql.Blob</literal> 
                                に対する型マッピング。
                                blobやclobオブジェクトはトランザクションの外では再利用できないため、
                                アプリケーションによっては不便かもしれません。
                                （さらにはドライバサポートが一貫していません。）
                            </para>
                        </listitem>
                    </varlistentry>
                    
                    <varlistentry>
                        <term>
                            <literal>imm_date, imm_time, imm_timestamp, imm_calendar, imm_calendar_date,
                            imm_serializable, imm_binary</literal>
                        </term>
                        <listitem>
                            <para>
                                ほとんどの場合に可変であるJavaの型に対する型マッピング。
                                Hibernateは不変なJavaの型に対しては最適化を行い、
                                アプリケーションはそれを不変オブジェクトとして扱います。
                                例えば <literal>imm_timestamp</literal> としてマップしたインスタンスに対して、
                                <literal>Date.setTime()</literal> を呼び出してはなりません。
                                プロパティの値を変更しその変更を永続化するためには、
                                アプリケーションはプロパティに対して新しい(同一でない)オブジェクトを割り当てなければなりません。
                            </para>
                        </listitem>
                    </varlistentry>                    
                </variablelist>
            
            </para>

            <para>
                エンティティとコレクションのユニークな識別子は、<literal>binary</literal> , <literal>blob</literal> , 
                <literal>clob</literal> を除く、どんな基本型でも構いません。
                （複合識別子でも構いません。以下を見てください。）
            </para>
            
            <para>
                基本的な値型には、<literal>org.hibernate.Hibernate</literal> で定義された 
                <literal>Type</literal> 定数がそれぞれあります。
                例えば、<literal>Hibernate.STRING</literal> は <literal>string</literal> 型を表現しています。
            </para>

        </sect2>
        
        <sect2 id="mapping-types-custom" revision="2">
            <title>カスタム型</title>

            <para>
                  開発者が独自の値型を作成することは、比較的簡単です。
                例えば、<literal>java.lang.BigInteger</literal> 型のプロパティを 
                <literal>VARCHAR</literal> カラムに永続化したいかもしれません。
                Hibernateはこのための組み込み型を用意していません。
                しかしカスタム型は、プロパティ（またはコレクションの要素）を1つのテーブルカラムに
                マッピングするのに制限はありません。
                そのため例えば、<literal>java.lang.String</literal> 型の 
                <literal>getName()</literal> / <literal>setName()</literal> 
                Javaプロパティを <literal>FIRST_NAME</literal> , <literal>INITIAL</literal>, <literal>SURNAME</literal> 
                カラムに永続化できます。
            </para>
            
            <para>
                カスタム型を実装するには、<literal>org.hibernate.UserType</literal> または 
                <literal>org.hibernate.CompositeUserType</literal> を実装し、
                型の完全修飾された名前を使ってプロパティを定義します。
                どのような種類のものが可能かを調べるには、
                <literal>org.hibernate.test.DoubleStringType</literal> を確認してください。
            </para>

            <programlisting><![CDATA[<property name="twoStrings" type="org.hibernate.test.DoubleStringType">
    <column name="first_string"/>
    <column name="second_string"/>
</property>]]></programlisting>

            <para>
                <literal>&lt;column&gt;</literal> タグで、
                プロパティを複数のカラムへマッピングできることに注目してください。
            </para>
            
            <para>
                <literal>CompositeUserType</literal> , <literal>EnhancedUserType</literal> ,
                <literal>UserCollectionType</literal> , <literal>UserVersionType</literal> 
                インターフェイスは、より特殊な使用法に対してのサポートを提供します。
            </para>
            
            <para>
                マッピングファイル内で <literal>UserType</literal> へパラメータを提供できます。
                このためには、<literal>UserType</literal> は 
                <literal>org.hibernate.usertype.ParameterizedType</literal> を実装しなくてはなりません。
                カスタム型パラメータを提供するために、
                マッピングファイル内で <literal>&lt;type&gt;</literal> 要素を使用できます。
            </para>
            
            <programlisting><![CDATA[<property name="priority">
    <type name="com.mycompany.usertypes.DefaultValueIntegerType">
        <param name="default">0</param>
    </type>
</property>]]></programlisting>

            <para>
                <literal>UserType</literal> は、
                引数として渡された <literal>Properties</literal> オブジェクトから、
                <literal>default</literal> で指定したパラメータに対する値を検索することができます。
            </para>
            
            <para>
                特定の <literal>UserType</literal> を頻繁に使用するならば、短い名前を定義すると便利になるでしょう。
                <literal>&lt;typedef&gt;</literal> 要素を使ってこのようなことが行えます。
                Typedefsはカスタム型に名前を割り当てます。
                その型がパラメータを持つならば、
                パラメータのデフォルト値のリストを含むこともできます。
            </para>
            
            <programlisting><![CDATA[<typedef class="com.mycompany.usertypes.DefaultValueIntegerType" name="default_zero">
    <param name="default">0</param>
</typedef>]]></programlisting>

            <programlisting><![CDATA[<property name="priority" type="default_zero"/>]]></programlisting>

            <para>
                プロパティのマッピングで型パラメータを使うことで、
                typedefで提供されたパラメータをその都度オーバーライドすることが可能です。
                
            </para>
            
            <para>
                Hibernateの幅広い組み込み型とコンポーネントに対するサポートは、
                カスタム型をめったに <emphasis>使わない</emphasis> ということを意味します。
                それでもなお、アプリケーションで頻出する(エンティティではない)クラスに対するカスタム型の使用は、
                よいやり方であるとみなされます。
                例えば <literal>MonetaryAmount</literal> クラスはコンポーネントとして簡単にマッピングできますが、
                <literal>CompositeUserType</literal> の良い候補です。
                カスタム型を使用する動機の1つは抽象化です。
                カスタム型を使うことで、通貨をどのように表現しようとも
                マッピングドキュメントは起こりうる変化に対応できます。
            </para>

        </sect2>
        
    </sect1>
    
    
    <sect1 id="mapping-entityname">
        <title>１つのクラスに１つ以上のマッピング</title>
        <para>
            ある永続クラスに、一つ以上のマッピングを提供することが出来ます。
            この場合、マッピングする２つのエンティティのインスタンスを明確にするために、
            <emphasis>エンティティ名</emphasis> を指定しなければなりません
            (デフォルトではエンティティ名はクラス名と同じです。)。
            永続オブジェクトを扱うとき、クエリを書き込むとき、
            指定されたエンティティへの関連をマッピングするときには、
            Hibernateではエンティティ名を指定しなければなりません。
        </para>
        
        <programlisting><![CDATA[<class name="Contract" table="Contracts" 
        entity-name="CurrentContract">
    ...
    <set name="history" inverse="true" 
            order-by="effectiveEndDate desc">
        <key column="currentContractId"/>
        <one-to-many entity-name="HistoricalContract"/>
    </set>
</class>

<class name="Contract" table="ContractHistory" 
        entity-name="HistoricalContract">
    ...
    <many-to-one name="currentContract" 
            column="currentContractId" 
            entity-name="CurrentContract"/>
</class>]]></programlisting>

        <para>
            関連が<literal>class</literal> の代わりに <literal>entity-name</literal> を使って、
            どのように指定されるのかに注目してください。
        </para>

    </sect1>

    <sect1 id="mapping-quotedidentifiers">
            <title>バッククォートで囲んだ SQL 識別子</title>
            <para>
                マッピングドキュメントでテーブルやカラムの名前をバッククォートで囲むことで、
                Hibernateで生成されたSQL中の識別子を引用させることができます。
                HibernateはSQLの <literal>Dialect</literal> に対応する、正しい引用スタイルを使います
                （普通はダブルクォートですが、SQL Serverではかぎ括弧、MySQLではバッククォートです）。
            </para>

            <programlisting><![CDATA[<class name="LineItem" table="`Line Item`">
    <id name="id" column="`Item Id`"/><generator class="assigned"/></id>
    <property name="itemNumber" column="`Item #`"/>
    ...
</class>]]></programlisting>

    </sect1>

      
       <sect1 id="mapping-alternatives">
       <title>メタデータの代替手段</title>
       
       <para>
            XMLの記述以外に、
            HibernateではO/Rマッピングのメタデータを定義する代替方法があります。
       </para>

    <sect2 id="mapping-xdoclet">
        <title>XDoclet マークアップの使用</title>

        <para>
            多くのHibernateユーザはXDocletの <literal>@hibernate.tags</literal> を使って、
            ソースコード内に直接マッピング情報を埋め込むことを好みます。
            これは厳密に言えばXDocletの分野なので、本ドキュメントではこの方法を対象とはしません。
            しかしXDocletを使った以下の <literal>Cat</literal> マッピングの例を示します。
        </para>

        <programlisting><![CDATA[package eg;
import java.util.Set;
import java.util.Date;

/**
 * @hibernate.class
 *  table="CATS"
 */
public class Cat {
    private Long id; // identifier
    private Date birthdate;
    private Cat mother;
    private Set kittens
    private Color color;
    private char sex;
    private float weight;

    /*
     * @hibernate.id
     *  generator-class="native"
     *  column="CAT_ID"
     */
    public Long getId() {
        return id;
    }
    private void setId(Long id) {
        this.id=id;
    }

    /**
     * @hibernate.many-to-one
     *  column="PARENT_ID"
     */
    public Cat getMother() {
        return mother;
    }
    void setMother(Cat mother) {
        this.mother = mother;
    }

    /**
     * @hibernate.property
     *  column="BIRTH_DATE"
     */
    public Date getBirthdate() {
        return birthdate;
    }
    void setBirthdate(Date date) {
        birthdate = date;
    }
    /**
     * @hibernate.property
     *  column="WEIGHT"
     */
    public float getWeight() {
        return weight;
    }
    void setWeight(float weight) {
        this.weight = weight;
    }

    /**
     * @hibernate.property
     *  column="COLOR"
     *  not-null="true"
     */
    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }
    /**
     * @hibernate.set
     *  inverse="true"
     *  order-by="BIRTH_DATE"
     * @hibernate.collection-key
     *  column="PARENT_ID"
     * @hibernate.collection-one-to-many
     */
    public Set getKittens() {
        return kittens;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    // addKitten not needed by Hibernate
    public void addKitten(Cat kitten) {
        kittens.add(kitten);
    }

    /**
     * @hibernate.property
     *  column="SEX"
     *  not-null="true"
     *  update="false"
     */
    public char getSex() {
        return sex;
    }
    void setSex(char sex) {
        this.sex=sex;
    }
}]]></programlisting>

        <para>
            Hibernateのウェブサイトには、XDocletとHibernateに関するサンプルが多数あります。
        </para>

    </sect2>

    <sect2 id="mapping-annotations" revision="2">
        <title>JDK 5.0 アノテーションの使用</title>

        <para>
            JDK5.0ではタイプセーフかつコンパイル時にチェックできる、
            言語レベルのXDocletスタイルのアノテーションを導入しました。
            このメカニズムはXDocletのアノテーションよりも強力で、ツールやIDEも多くがサポートしています。
            例えばIntelliJ IDEAは、JDK5.0にアノテーションの自動補完と構文の強調表示をサポートしています。
            EJB仕様 (JSR-220)の新しいバージョンでは、エンティティビーンに対する主要なメタデータメカニズムとして
            JDK5.0のアノテーションを使用しています。
            Hibernate3ではJSR-220 (永続化API)の <literal>EntityManager</literal> を実装し、
            メタデータマッピングに対するサポートは、
            別ダウンロードの <emphasis>Hibernate Annotations</emphasis> パッケージにより利用可能です。
            これはEJB3(JSR-220)とHibernate3のメタデータをどちらもサポートしています。
            
        </para>

        <para>
            以下はEJBのエンティティビーンとして注釈されたPOJOクラスの例です。
        </para>

        <programlisting><![CDATA[@Entity(access = AccessType.FIELD)
public class Customer implements Serializable {

    @Id;
    Long id;

    String firstName;
    String lastName;
    Date birthday;

    @Transient
    Integer age;

    @Embedded
    private Address homeAddress;

    @OneToMany(cascade=CascadeType.ALL)
    @JoinColumn(name="CUSTOMER_ID")
    Set<Order> orders;

    // Getter/setter and business methods
}]]></programlisting>

        <para>
            JDK5.0のアノテーション(とJSR-220)のサポートは進行中の作業であり、完全ではないことに注意してください。
            さらに詳しい情報はHibernateのアノテーション・モジュールを参照してください。
        </para>
    
    </sect2>
    
    </sect1>


    <sect1 id="mapping-generated" revision="1">
        <title>生成プロパティ</title>
        <para>
            生成プロパティとは、データベースによって生成された値を持つプロパティです。
            通常、Hibernateアプリケーションは、データベースが値を生成したプロパティを含むオブジェクトを
            <literal>リフレッシュ</literal> する必要がありました。
            しかし、プロパティが生成されたということをマークすることで、
            アプリケーションはリフレッシュの責任をHibernateに委譲します。
            
            基本的に、生成プロパティを持つと定義したエンティティに対して
            HibernateがINSERTやUPDATEのSQLを発行した後すぐに、
            生成された値を読み込むための SELECT SQL が発行されます。
        </para>
        <para>
            生成プロパティは、挿入不可能かつ更新不可能でなければなりません。
            <xref linkend="mapping-declaration-version">versions</xref> 、
            <xref linkend="mapping-declaration-timestamp">timestamps</xref> 、
            <xref linkend="mapping-declaration-property">simple properties</xref> だけが生成されたとマークできます。
        </para>
        <para>
            <literal>never</literal> (デフォルト) - 与えられたプロパティの値は、
            データベースから生成されないことを意味します。
        </para>
        <para>
            <literal>insert</literal> - 与えられたプロパティの値は挿入時に生成されるが、
            続いて起こる更新時には生成されないこと示します。
            作成された日付などは、このカテゴリに分類されます。
            <xref linkend="mapping-declaration-version">version</xref> や
            <xref linkend="mapping-declaration-timestamp">timestamp</xref> の
            プロパティは生成されたとマークできますが、このオプションは利用できないことに注意してください。
        </para>
        <para>
            <literal>always</literal> - 挿入時も更新時もプロパティの値が生成されることを示します。
        </para>
    </sect1>

    <sect1 id="mapping-database-object" revision="0">
        <title>補助的なデータベース・オブジェクト</title>
        <para>
            Hibernateのスキーマ・エボリューションツールと連動することで、
            任意のデータベース・オブジェクト（トリガーやストアドプロシージャなど）のCREATEとDROPにより、
            Hibernateのマッピングファイル内のユーザ・スキーマをすべて定義することが出来ます。
            主にトリガやストアドプロシージャのようなデータベース・オブジェクトを生成や削除することを意図していますが、
            実際には <literal>java.sql.Statement.execute()</literal> メソッドによって実行できる
            任意のSQLコマンド（ALTER、INSERTなど）が実行できます。
            補助的なデータベース・オブジェクトを定義するための、2つの基本的な方法があります。
        </para>
        <para>
            1つ目の方法は、CREATEとDROPコマンドをマッピングファイルの外に、明示的に記載することです。
        </para>
        <programlisting><![CDATA[<hibernate-mapping>
    ...
    <database-object>
        <create>CREATE TRIGGER my_trigger ...</create>
        <drop>DROP TRIGGER my_trigger</drop>
    </database-object>
</hibernate-mapping>]]></programlisting>
        <para>
            2つ目の方法は、CREATEとDROPコマンドの組み立て方を知っているカスタムクラスを提供することです。
            このカスタムクラスは <literal>org.hibernate.mapping.AuxiliaryDatabaseObject</literal> インタフェースを
            実装しなければなりません。
        </para>
        <programlisting><![CDATA[<hibernate-mapping>
    ...
    <database-object>
        <definition class="MyTriggerDefinition"/>
    </database-object>
</hibernate-mapping>]]></programlisting>
        <para>
            さらに、あるデータベース方言が使用される時にだけ適用するといったように、
            データベース・オブジェクトが使われるケースを限定できます。
        </para>
        <programlisting><![CDATA[<hibernate-mapping>
    ...
    <database-object>
        <definition class="MyTriggerDefinition"/>
        <dialect-scope name="org.hibernate.dialect.Oracle9Dialect"/>
        <dialect-scope name="org.hibernate.dialect.OracleDialect"/>
    </database-object>
</hibernate-mapping>]]></programlisting>
    </sect1>

</chapter>
