<?xml version="1.0" encoding="Shift_JIS"?>
<chapter id="collections">
    <title>コレクションのマッピング</title>

    <sect1 id="collections-persistent" revision="3">
        <title>コレクションの永続化</title>
        
        <para>
            コレクション型のフィールドを永続化するには、
            そのコレクション型がインターフェイス型である必要があります。
            例えば、
        </para>
        
        <programlisting><![CDATA[public class Product {
    private String serialNumber;
    private Set parts = new HashSet();
    
    public Set getParts() { return parts; }
    void setParts(Set parts) { this.parts = parts; }
    public String getSerialNumber() { return serialNumber; }
    void setSerialNumber(String sn) { serialNumber = sn; }
}]]></programlisting>
        
        <para>
            実在するインターフェイスには <literal>java.util.Set</literal>、
            <literal>java.util.Collection</literal>、<literal>java.util.List</literal>、
            <literal>java.util.Map</literal>、<literal>java.util.SortedSet</literal>、
            <literal>java.util.SortedMap</literal> などがあります。
            または、任意のインターフェイスが使えます！
            （ただし、任意のインターフェイスを使用する場合は、
            <literal>org.hibernate.usertype.UserCollectionType</literal>
            の実装クラスを作成する必要があります。）
        </para>
        
        <para>
            <literal>HashSet</literal> のインスタンスを持つインスタンス変数が
            どのように初期化されるかに注目してみましょう。
            これは新たに生成された（永続化されていない）コレクション型のプロパティを
            初期化する最適な方法です。
            （例えば <literal>persist()</literal> により）インスタンスを永続化しようとしたとき、
            Hibernateは <literal>HashSet</literal> をHibernate独自の <literal>Set</literal>
            の実装クラスに置き換えます。
            このため、次のようなエラーには注意が必要です。
        </para>
        
        <programlisting><![CDATA[Cat cat = new DomesticCat();
Cat kitten = new DomesticCat();
....
Set kittens = new HashSet();
kittens.add(kitten);
cat.setKittens(kittens);
session.persist(cat);
kittens = cat.getKittens(); // Okay, kittens collection is a Set
(HashSet) cat.getKittens(); // Error!]]></programlisting>

        <para>
            Hibernateにより注入された永続性コレクションは、インターフェイス型に応じて、
            <literal>HashMap</literal> や <literal>HashSet</literal>、
            <literal>TreeMap</literal>、 <literal>TreeSet</literal>、
            <literal>ArrayList</literal> のように振舞います。
         </para>

        <para>
            コレクションインスタンスは、値型として普通に振舞います。
            永続化オブジェクトに参照されたときに自動的に永続化され、
            参照がなくなったときに自動的に削除されます。
            もしある永続化オブジェクトから別の永続化オブジェクトに渡されたら、
            その要素は現在のテーブルから別のテーブルに移動するかもしれません。
            ２つのエンティティが同じコレクションインスタンスを共有してはいけません。
            リレーショナルモデルをベースにしているため、コレクション型のプロパティに
            null値を代入しても意味がありません。
            つまりHibernateは参照先のないコレクションと空のコレクションを区別しません。
        </para>

        <para>
            しかしそれほど心配しなくても構いません。
            普段使っているJavaのコレクションと同じように、永続化コレクションを使ってください。
            双方向関連の意味を理解すればよいのです（これは後ほど説明します）。
        </para>

    </sect1>

    <sect1 id="collections-mapping" revision="4">
        <title>コレクションのマッピング</title>

        <para>
            コレクションをマッピングするためのマッピング要素は、インターフェイスの型に依存します。
            例えば、<literal>&lt;set&gt;</literal> 要素は <literal>Set</literal> 型を
            マッピングするために使います。
        </para>
        
        <programlisting><![CDATA[<class name="Product">
    <id name="serialNumber" column="productSerialNumber"/>
    <set name="parts">
        <key column="productSerialNumber" not-null="true"/>
        <one-to-many class="Part"/>
    </set>
</class>]]></programlisting>

        <para>
            マッピング要素には <literal>&lt;set&gt;</literal> の他に <literal>&lt;list&gt;</literal>、
            <literal>&lt;map&gt;</literal>、<literal>&lt;bag&gt;</literal>、
            <literal>&lt;array&gt;</literal>、<literal>&lt;primitive-array&gt;</literal> があります。
            代表として、<literal>&lt;map&gt;</literal> 要素を下記に示します。
        </para>

        <programlistingco>
            <areaspec>
                <area id="mappingcollection1" coords="2 65"/>
                <area id="mappingcollection2" coords="3 65"/>
                <area id="mappingcollection3" coords="4 65"/>
                <area id="mappingcollection4" coords="5 65"/>
                <area id="mappingcollection5" coords="6 65"/>
                <area id="mappingcollection6" coords="7 65"/>
                <area id="mappingcollection7" coords="8 65"/>
                <area id="mappingcollection8" coords="9 65"/>
                <area id="mappingcollection9" coords="10 65"/>
                <area id="mappingcollection10" coords="11 65"/>
                <area id="mappingcollection11" coords="12 65"/>
                <area id="mappingcollection12" coords="13 65"/>
                <area id="mappingcollection13" coords="14 65"/>
                <area id="mappingcollection14" coords="15 65"/>
            </areaspec>
            <programlisting><![CDATA[<map
    name="propertyName"
    table="table_name"
    schema="schema_name"
    lazy="true|extra|false"
    inverse="true|false"
    cascade="all|none|save-update|delete|all-delete-orphan|delete-orphan"
    sort="unsorted|natural|comparatorClass"
    order-by="column_name asc|desc"
    where="arbitrary sql where condition"
    fetch="join|select|subselect"
    batch-size="N"
    access="field|property|ClassName"
    optimistic-lock="true|false"
    mutable="true|false"
    node="element-name|."
    embed-xml="true|false"
>

    <key .... />
    <map-key .... />
    <element .... />
</map>]]></programlisting>
            <calloutlist>
                <callout arearefs="mappingcollection1">
                    <para>
                        <literal>name</literal> コレクション型であるプロパティの名前
                    </para>
                </callout>
                <callout arearefs="mappingcollection2">
                    <para>
                        <literal>table</literal> （オプション - デフォルトはプロパティ名）コレクションテーブルの名前
                       （一対多関連では使用しません）。
                    </para>
                </callout>
                <callout arearefs="mappingcollection3">
                    <para>
                        <literal>schema</literal> （オプション）テーブルスキーマの名前。
                        ルート要素で宣言されているスキーマより優先されます。
                    </para>
                </callout>
                <callout arearefs="mappingcollection4">
                    <para>
                        <literal>lazy</literal> （オプション - デフォルトは <literal>true</literal>）
                        遅延フェッチを無効にし、関連を常に即時にフェッチにするために使用します。
                        または、「extra-lazy」フェッチを有効にするために使用します。
                        「extra-lazy」フェッチは、ほとんどの操作ではコレクションを初期化しません
                        （非常に大きなコレクションに適しています）。
                    </para>
                </callout>
                <callout arearefs="mappingcollection5">
                    <para>
                        <literal>inverse</literal> （オプション - デフォルトは <literal>false</literal>）
                        このコレクションが双方向関連の「逆」側であるとマークします。
                    </para>
                </callout>
                <callout arearefs="mappingcollection6">
                    <para>
                        <literal>cascade</literal> （オプション - デフォルトは <literal>none</literal>）
                        子エンティティへのカスケード操作を有効にします。
                    </para>
                </callout>
                <callout arearefs="mappingcollection7">
                    <para>
                        <literal>sort</literal> （オプション）コレクションを自然な順序でソートする場合は
                        <literal>natural</literal> を指定します。
                        あるいはComparatorクラスを指定します。
                    </para>
                </callout>
                <callout arearefs="mappingcollection8">
                    <para>
                        <literal>order-by</literal> （オプション、JDK1.4のみ）
                        <literal>Map</literal>、<literal>Set</literal>、bagのイテレーション順序を定義する
                        テーブルカラムを指定すると共に、
                        オプションとして <literal>asc</literal>、<literal>desc</literal> を指定します。
                    </para>
                </callout>
                <callout arearefs="mappingcollection9">
                    <para>
                        <literal>where</literal> （オプション）コレクションの検索や削除の際に使う
                        任意のSQLの<literal>WHERE</literal> 条件を指定します
                        （利用可能なデータの一部分だけをコレクションが含むべきときに、これは有用です）。
                    </para>
                </callout>
                <callout arearefs="mappingcollection10">
                    <para>
                        <literal>fetch</literal>（オプション - デフォルトは <literal>select</literal>）
                        外部結合によるフェッチ、順次選択フェッチ（sequential select fetch）、
                        順次サブセレクトフェッチ（sequential subselect fetch）のどれかを選択してください。
                    </para>
                </callout>
                <callout arearefs="mappingcollection11">
                    <para>
                        <literal>batch-size</literal> （オプション - デフォルトは <literal>1</literal>）
                        コレクションのインスタンスの遅延フェッチのための「バッチサイズ」を指定します。
                    </para>
                </callout>
                <callout arearefs="mappingcollection12">
                    <para>
                        <literal>access</literal> （オプション - デフォルトは <literal>property</literal>）
                        コレクション型プロパティの値にアクセスするために使用する戦略です。
                    </para>
                </callout>
                <callout arearefs="mappingcollection13">
                    <para>
                        <literal>optimistic-lock</literal>（オプション - デフォルトは <literal>true</literal>）
                        コレクションの状態を変えることによって、
                        そのオーナーであるエンティティのバージョンがインクリメントされるかを指定します。
                        （一対多関連では、ほとんどの場合において無効に設定するのが妥当です。）
                    </para>
                </callout>
                <callout arearefs="mappingcollection14">
                    <para>
                        <literal>mutable</literal>（オプション - デフォルトは <literal>true</literal>）
                        <literal>false</literal> 値は、コレクションの要素が変更されないことを表します
                        （ある場合には、少しパフォーマンスを高めます）。
                    </para>
                </callout>
            </calloutlist>
        </programlistingco>

        <sect2 id="collections-foreignkeys" >
           <title>コレクションの外部キー</title>
    
            <para>
                コレクションのインスタンスは、データベース内では、
                そのコレクションを所有するエンティティの外部キーによって識別されます。
                この外部キーはコレクションテーブルの <emphasis>コレクションキーカラム</emphasis> と呼ばれます。
                コレクションキーカラムは <literal>&lt;key&gt;</literal> 要素によりマッピングします。
            </para>
    
            <para>
                外部キーカラムにはnull設定制約があるかもしれません。
                ほとんどのコレクションに当てはまるでしょう。
                単方向の一対多関連において、外部キーカラムはデフォルトでnullを許す設定になっています。
                よって、<literal>not-null="true"</literal> を指定する必要があるかもしれません。
            </para>
    
            <programlisting><![CDATA[<key column="productSerialNumber" not-null="true"/>]]></programlisting>
    
            <para>
                外部キーの制約が <literal>ON DELETE CASCADE</literal> を使うかもしれません。
            </para>
    
            <programlisting><![CDATA[<key column="productSerialNumber" on-delete="cascade"/>]]></programlisting>
            
            <para>
                <literal>&lt;key&gt;</literal> 要素のすべての定義については前の章を参照してください。
            </para>
            
        </sect2>
        
        <sect2 id="collections-elements" >
            <title>コレクションの要素</title>
    
            <para>
                コレクションは他のHibernateの型のほとんど（すべての基本型、カスタム型、コンポーネント、
                他のエンティティへの参照）を格納することができます。
                次の点は重要な違いになります。
                コレクションに格納されたオブジェクトが「値」セマンティクスとして扱われるのか
                （ライフサイクルはコレクションのオーナーに完全に依存します）、
                もしくはそれ自身のライフサイクルを持った別のエンティティへの参照であるかのかという違いです。
                後者は、2つのオブジェクト間の「リンク」をコレクションに保持していると見なしているだけです。
            </para>
                
            <para>
                格納される型は <emphasis>コレクション要素型</emphasis> と呼ばれます。
                コレクション要素は、<literal>&lt;element&gt;</literal> または <literal>&lt;composite-element&gt;</literal>
                によりマッピングされ、エンティティへの参照の場合には
                <literal>&lt;one-to-many&gt;</literal> または <literal>&lt;many-to-many&gt;</literal>
                によりマッピングされます。
                最初の二つは値として要素をマッピングし、次の二つはエンティティの関連をマッピングするのに使われます。
            </para>
            
        </sect2>
        
        <sect2 id="collections-indexed">
            <title>インデックス付きのコレクション</title>
    
            <para>
                setとbagを除く全てのコレクションマッピングには、
                コレクションテーブルの中に <emphasis>インデックス用のカラム</emphasis> が必要です。
                そのカラムに、配列や <literal>List</literal> のインデックス、
                もしくは <literal>Map</literal> のキーをマッピングします。
                <literal>Map</literal> のインデックスは、
                <literal>&lt;map-key&gt;</literal> によりマッピングされた基本型か、
                <literal>&lt;map-key-many-to-many&gt;</literal> によりマッピングされたエンティティの関連か、
                あるいは <literal>&lt;composite-map-key&gt;</literal> によりマッピングされたコンポジット型になります。
                配列かリストのインデックスは、常に <literal>integer</literal> 型で、
                <literal>&lt;list-index&gt;</literal> 要素によりマッピングします。
                マッピングされたカラムにはシーケンシャルな整数を格納します（デフォルトでは0から番号が付けられます）。
            </para>

        <programlistingco>
            <areaspec>
                <area id="index1" coords="2 45"/>
                <area id="index2" coords="3 45"/>
             </areaspec>
            <programlisting><![CDATA[<list-index 
        column="column_name"
        base="0|1|..."/>]]></programlisting>
            <calloutlist>
                <callout arearefs="index1">
                    <para>
                        <literal>column_name</literal>（必須）:コレクションインデックスの値を保持するカラムの名前。
                    </para>
                </callout>
                <callout arearefs="index2">
                    <para>
                        <literal>base</literal>（オプション、デフォルトは <literal>0</literal>）:
                        リストもしくは配列の最初の要素に該当するインデックスカラムの値。
                    </para>
                </callout>
            </calloutlist>
        </programlistingco>

        <programlistingco>
            <areaspec>
                <area id="mapkey1" coords="2 45"/>
                <area id="mapkey2" coords="3 45"/>
                <area id="mapkey3" coords="4 45"/>
             </areaspec>
            <programlisting><![CDATA[<map-key 
        column="column_name"
        formula="any SQL expression"
        type="type_name"
        node="@attribute-name"
        length="N"/>]]></programlisting>
            <calloutlist>
                <callout arearefs="mapkey1">
                    <para>
                        <literal>column</literal>（オプション）: コレクションインデックスの値を保持するカラムの名前。
                    </para>
                </callout>
                <callout arearefs="mapkey2">
                    <para>
                        <literal>formula</literal>（オプション）: Mapのキーを評価するのに使われるSQL式。
                    </para>
                </callout>
                <callout arearefs="mapkey3">
                    <para>
                        <literal>type</literal>（必須）: Mapのキーの型。
                    </para>
                </callout>
            </calloutlist>
        </programlistingco>

        <programlistingco>
            <areaspec>
                <area id="indexmanytomany1" coords="2 45"/>
                <area id="indexmanytomany2" coords="3 45"/>
                <area id="indexmanytomany3" coords="4 45"/>
             </areaspec>
            <programlisting><![CDATA[<map-key-many-to-many
        column="column_name"
        formula="any SQL expression"
        class="ClassName"
/>]]></programlisting>
            <calloutlist>
                <callout arearefs="indexmanytomany1">
                    <para>
                        <literal>column</literal> （オプション）:
                        コレクションインデックスの値のための外部キーカラムの名前。
                    </para>
                </callout>
                <callout arearefs="indexmanytomany2">
                    <para>
                        <literal>formula</literal> （オプション）:
                        Mapのキーのための外部キーを評価するために使うSQL式。
                    </para>
                </callout>
                <callout arearefs="indexmanytomany3">
                    <para>
                        <literal>class</literal> （必須）:
                        Mapのキーとして使われるエンティティクラス。
                    </para>
                </callout>
            </calloutlist>
        </programlistingco>


            <para>
                もしテーブルにインデックスカラムがなくても、プロパティ型として <literal>List</literal> を使いたければ、
                Hibernateの <emphasis>&lt;bag&gt;</emphasis> としてプロパティをマッピングします。
                bagはデータベースから復元される時、順序を保持しません。
                しかし、（メモリ上で）ソートしたり、（SQLで）順序付けしたり（order by）することもできます。
            </para>
            
        </sect2>

        <para>
            多くの一般的なリレーショナルモデルをカバーしたために、
            コレクションのために利用できるマッピングにはかなりの幅があります。
            様々なマッピング宣言がどのようにデータベーステーブルに変換されるかを知るために、
            スキーマ生成ツールを使ってみると良いでしょう。
        </para>

    <sect2 id="collections-ofvalues" revision="2">
        <title>値のコレクションと多対多関連</title>

        <para>
            値のコレクションや多対多関連は、専用の <emphasis>コレクションテーブル</emphasis> が必要です。
            このテーブルは、外部キーカラムと、
            <emphasis>コレクション要素のカラム</emphasis> と、
            場合によってはインデックスカラムを持ちます。
        </para>

        <para>
            値のコレクションのために、<literal>&lt;element&gt;</literal>タグを使用します。
        </para>

        <programlistingco>
            <areaspec>
                <area id="element1b" coords="2 50"/>
                <area id="element2b" coords="3 50"/>
                <area id="element3b" coords="4 50"/>
             </areaspec>
            <programlisting><![CDATA[<element
        column="column_name"
        formula="any SQL expression"
        type="typename"
        length="L"
        precision="P"
        scale="S"
        not-null="true|false"
        unique="true|false"
        node="element-name"
/>]]></programlisting>
            <calloutlist>
                <callout arearefs="element1b">
                    <para>
                        <literal>column</literal> （オプション）: コレクションの要素の値を保持するカラムの名前。
                    </para>
                </callout>
                <callout arearefs="element2b">
                    <para>
                        <literal>formula</literal> （オプション）: 要素を評価するために使うSQL式。
                    </para>
                </callout>
                <callout arearefs="element3b">
                    <para>
                        <literal>type</literal> （必須）コレクションの要素の型。
                    </para>
                </callout>
            </calloutlist>
        </programlistingco>

        <para>
            <emphasis>多対多関連</emphasis> は <literal>&lt;many-to-many&gt;</literal> 要素で指定します。
        </para>

        <programlistingco>
            <areaspec>
                <area id="manytomany1" coords="2 60"/>
                <area id="manytomany2" coords="3 60"/>
                <area id="manytomany3" coords="4 60"/>
                <area id="manytomany4" coords="5 60"/>
                <area id="manytomany5" coords="6 60"/>
                <area id="manytomany6" coords="7 60"/>
                <area id="manytomany7" coords="8 60"/>
                <area id="manytomany8" coords="9 60"/>
            </areaspec>
            <programlisting><![CDATA[<many-to-many
        column="column_name"
        formula="any SQL expression"
        class="ClassName"
        fetch="select|join"
        unique="true|false"
        not-found="ignore|exception"
        entity-name="EntityName"
        property-ref="propertyNameFromAssociatedClass"
        node="element-name"
        embed-xml="true|false"
    />]]></programlisting>
            <calloutlist>
                <callout arearefs="manytomany1">
                    <para>
                        <literal>column</literal> （オプション）: 外部キーカラムの要素の名前。
                    </para>
                </callout>
                <callout arearefs="manytomany2">
                    <para>
                        <literal>formula</literal> （オプション）: 外部キー値の要素を評価するために使うSQL式。
                    </para>
                </callout>
                <callout arearefs="manytomany3">
                    <para>
                        <literal>class</literal> （必須）: 関連クラスの名前。
                    </para>
                </callout>
                <callout arearefs="manytomany4">
                    <para>
                        <literal>fetch</literal> (オプション - デフォルトは <literal>join</literal>):
                        関連のために、外部結合か順次選択フェッチを有効にします。
                        これは特殊なケースですが、エンティティと他のエンティティとの多対多関係を
                        （１つの <literal>SELECT</literal> により）完全に即時にフェッチするためには、
                        そのコレクション自体だけでなく、
                        ネストした要素である <literal>&lt;many-to-many&gt;</literal> のこの属性についても
                        <literal>join</literal> フェッチを有効する必要があります。
                    </para>
                </callout>
                <callout arearefs="manytomany5">
                    <para>
                        <literal>unique</literal> （オプション）:
                        外部キーカラムのユニーク制約のDDL生成を有効にします。
                        これは、関連の多重度を事実上一対多にします。
                    </para>
                </callout>
                    <callout arearefs="manytomany6">
                        <para>
                            <literal>not-found</literal> （オプション - デフォルトは <literal>exception</literal>）
                            参照先の行がない外部キーをどのように扱うかを指定します。
                            <literal>ignore</literal> にすると、行がないことを関連が無いものとして扱います。
                        </para>
                    </callout>
                <callout arearefs="manytomany7">
                    <para>
                        <literal>entity-name</literal> （オプション）:
                        <literal>class</literal> の代替である関連クラスのエンティティ名。
                        <literal>class</literal> の代わりに指定する、関連クラスのエンティティ名。
                    </para>
                </callout>
                <callout arearefs="manytomany8">
                    <para>
                        <literal>property-ref</literal>: （オプション）
                        この外部キーに結合する関連クラスのプロパティ名。
                        指定しなかった場合は、関連クラスの主キーを使います。
                    </para>                
                </callout>                   
            </calloutlist>
        </programlistingco>

        <para>
            以下にいくつか例を示します。
            まずはStringのsetに関しての例です。
        </para>

        <programlisting><![CDATA[<set name="names" table="person_names">
    <key column="person_id"/>
    <element column="person_name" type="string"/>
</set>]]></programlisting>

        <para>
            整数値を含むbag（bagは <literal>order-by</literal> 属性によって反復順序が定義されています）
        </para>

        <programlisting><![CDATA[<bag name="sizes" 
        table="item_sizes" 
        order-by="size asc">
    <key column="item_id"/>
    <element column="size" type="integer"/>
</bag>]]></programlisting>

        <para>
            エンティティの配列 - この場合、多対多の関連です。
        </para>

        <programlisting><![CDATA[<array name="addresses" 
        table="PersonAddress" 
        cascade="persist">
    <key column="personId"/>
    <list-index column="sortOrder"/>
    <many-to-many column="addressId" class="Address"/>
</array>]]></programlisting>

        <para>
            文字列と日付のmap
        </para>

        <programlisting><![CDATA[<map name="holidays" 
        table="holidays" 
        schema="dbo" 
        order-by="hol_name asc">
    <key column="id"/>
    <map-key column="hol_name" type="string"/>
    <element column="hol_date" type="date"/>
</map>]]></programlisting>

        <para>
            コンポーネントのlist（次の章で詳しく説明します）
        </para>

        <programlisting><![CDATA[<list name="carComponents" 
        table="CarComponents">
    <key column="carId"/>
    <list-index column="sortOrder"/>
    <composite-element class="CarComponent">
        <property name="price"/>
        <property name="type"/>
        <property name="serialNumber" column="serialNum"/>
    </composite-element>
</list>]]></programlisting>

    </sect2>

    <sect2 id="collections-onetomany">
        <title>一対多関連</title>

        <para>
            <emphasis>一対多関連</emphasis> は、コレクション･テーブルを介さず、
            外部キーにより2つのクラスのテーブルを関連付けます。
            このマッピングは標準的なJavaのコレクションのセマンティクスをいくつか失います。
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    エンティティクラスのインスタンスは、
                    2つ以上のコレクションのインスタンスに属してはいけません。
                </para>
            </listitem>
            <listitem>
                <para>
                    コレクションに含まれるエンティティクラスのインスタンスは、
                    コレクションインデックスの値として2度以上現れてはいけません。
                </para>
            </listitem>
        </itemizedlist>

        <para>
            <literal>Product</literal> から <literal>Part</literal> への関連は、
            <literal>Part</literal> テーブルへの外部キーカラムと、場合によってはインデックスカラムが必要です。
            <literal>&lt;one-to-many&gt;</literal> タグは、これが一対多関連であることを表しています。
        </para>

        <programlistingco>
            <areaspec>
                <area id="onetomany1" coords="2 60"/>
                <area id="onetomany2" coords="3 60"/>
                <area id="onetomany3" coords="4 60"/>
            </areaspec>
            <programlisting><![CDATA[<one-to-many 
        class="ClassName"
        not-found="ignore|exception"
        entity-name="EntityName"
        node="element-name"
        embed-xml="true|false"
    />]]></programlisting>
            <calloutlist>
                <callout arearefs="onetomany1">
                    <para>
                        <literal>class</literal> （必須）: 関連クラスの名前。
                    </para>
                </callout>
                        <callout arearefs="onetomany2">
                            <para>
                                <literal>not-found</literal> （オプション - デフォルトは <literal>exception</literal>）:
                                参照先の行がないキャッシュされた識別子をどのように扱うかを指定します。
                                <literal>ignore</literal> を指定すると、行がないことを関連がないものとして扱います。
                            </para>
                        </callout>
                <callout arearefs="onetomany3">
                    <para>
                        <literal>entity-name</literal> （オプション）:
                        <literal>class</literal> の代替である関連クラスのエンティティ名。
                        <literal>class</literal> の代わりに指定する、関連クラスのエンティティ名。
                    </para>
                </callout>
            </calloutlist>
       </programlistingco>
  
        <para>
            <literal>&lt;one-to-many&gt;</literal> 要素はカラムを宣言する必要がないことに注意してください。
            同様に <literal>テーブル</literal> 名を指定する必要もありません。
        </para>

        <para>
            <emphasis>とても重要な注意:</emphasis> もし <literal>&lt;one-to-many&gt;</literal>
            関連の外部キーカラムが <literal>NOT NULL</literal>と宣言された場合、
            <literal>&lt;key&gt;</literal> マッピングに <literal>not-null="true"</literal> を宣言するか、
            コレクションマッピングに <literal>inverse="true"</literal> を付けた上で、
            <emphasis>双方向関連を使う</emphasis> 必要があります。
            双方向関連についてはこの章の後のほうで説明します。
        </para>
        
        <para>
            次の例は、名称（<literal>Part</literal> の永続的なプロパティである <literal>partName</literal>）
            による <literal>Part</literal> エンティティのmapを表しています。
            formulaによるインデックスを使っていることに注意してください。
        </para>

        <programlisting><![CDATA[<map name="parts"
        cascade="all">
    <key column="productId" not-null="true"/>
    <map-key formula="partName"/>
    <one-to-many class="Part"/>
</map>]]></programlisting>
    </sect2>
    
    </sect1>

    <sect1 id="collections-advancedmappings">
        <title>高度なコレクション･マッピング</title>

    <sect2 id="collections-sorted" revision="2">
        <title>ソートされたコレクション</title>

        <para>
            Hibernateは <literal>java.util.SortedMap</literal> と <literal>java.util.SortedSet</literal>
            を実装したコレクションをサポートしています。
            開発者はマッピング定義ファイルにコンパレータを指定しなければなりません。
        </para>

        <programlisting><![CDATA[<set name="aliases" 
            table="person_aliases" 
            sort="natural">
    <key column="person"/>
    <element column="name" type="string"/>
</set>

<map name="holidays" sort="my.custom.HolidayComparator">
    <key column="year_id"/>
    <map-key column="hol_name" type="string"/>
    <element column="hol_date" type="date"/>
</map>]]></programlisting>

        <para>
            <literal>sort</literal> 属性に設定できる値は <literal>unsorted</literal> と <literal>natural</literal>
            および、<literal>java.util.Comparator</literal> を実装したクラスの名前です。
        </para>

        <para>
            ソートされたコレクションは実質的には <literal>java.util.TreeSet</literal> や
            <literal>java.util.TreeMap</literal> のように振舞います。
        </para>

        <para>
            もしデータベース自身にコレクションの要素を並べさせたいなら、
            <literal>set</literal> や <literal>bag</literal>、<literal>map</literal> の
            <literal>order-by</literal> 属性を使います。
            この解決法はJDK1.4、もしくはそれ以上のバージョンで利用可能です
            （<literal>LinkedHashSet</literal> または <literal>LinkedHashMap</literal>を使って実装されています）。
            整列はメモリ上ではなく、SQLクエリ内で実行されます。
        </para>

        <programlisting><![CDATA[<set name="aliases" table="person_aliases" order-by="lower(name) asc">
    <key column="person"/>
    <element column="name" type="string"/>
</set>

<map name="holidays" order-by="hol_date, hol_name">
    <key column="year_id"/>
    <map-key column="hol_name" type="string"/>
    <element column="hol_date" type="date"/>
</map>]]></programlisting>

        <para>
            <literal>order-by</literal> 属性の値がSQL命令であって、HQL命令ではないことに注意してください！
        </para>

        <para>
            関連は、コレクションの <literal>filter()</literal> を使うことで、
            実行時に任意のcriteriaによってソートすることも可能です。
        </para>

        <programlisting><![CDATA[sortedUsers = s.createFilter( group.getUsers(), "order by this.name" ).list();]]></programlisting>

    </sect2>

     <sect2 id="collections-bidirectional" revision="1">
        <title>双方向関連</title>

        <para>
            <emphasis>双方向関連</emphasis> は関連のどちら「側」からでもナビゲーションできます。
            2種類の双方向関連がサポートされています。

            <variablelist>
                <varlistentry>
                    <term>one-to-many</term>
                    <listitem>
                        <para>
                            片側がsetかbag、もう片方が単一値です。
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>many-to-many</term>
                    <listitem>
                        <para>
                            両側がsetかbagです。
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>

        </para>

        <para>
            2つの多対多関連で同じデータベーステーブルをマッピングし、
            片方を <emphasis>inverse</emphasis> として宣言することで、
            双方向の多対多関連を指定することが出来ます
            （どちらをinverseに選んだとしても、そちら側にはインデックス付きのコレクションは使えません）。
        </para>

        <para>
            次に双方向の多対多関連の例を示します。
            各カテゴリは多数のアイテムを持つことができ、各アイテムは多くのカテゴリに属することが出来ます。
        </para>

        <programlisting><![CDATA[<class name="Category">
    <id name="id" column="CATEGORY_ID"/>
    ...
    <bag name="items" table="CATEGORY_ITEM">
        <key column="CATEGORY_ID"/>
        <many-to-many class="Item" column="ITEM_ID"/>
    </bag>
</class>

<class name="Item">
    <id name="id" column="CATEGORY_ID"/>
    ...

    <!-- inverse end -->
    <bag name="categories" table="CATEGORY_ITEM" inverse="true">
        <key column="ITEM_ID"/>
        <many-to-many class="Category" column="CATEGORY_ID"/>
    </bag>
</class>]]></programlisting>

        <para>
            関連のinverse側にのみ行われた変更は永続化 <emphasis>されません</emphasis>。
            これは、Hibernateは全ての双方向関連について、メモリ上に２つの表現を持っているという意味です。
            つまり一つはAからBへのリンクで、もう一つはBからAへのリンクということです。
            Javaのオブジェクトモデルについて考え、Javaで双方向関係をどうやって作るかを考えれば、
            これは理解しやすいです。下記に、Javaでの双方向関連を示します。
        </para>

        <programlisting><![CDATA[
category.getItems().add(item);          // The category now "knows" about the relationship
item.getCategories().add(category);     // The item now "knows" about the relationship

session.persist(item);                   // The relationship won't be saved!
session.persist(category);               // The relationship will be saved]]></programlisting>

        <para>
            関連のinverseではない側は、メモリ上の表現をデータベースに保存するのに使われます。
        </para>

        <para>
            双方向の一対多関連を定義するには、
            一対多関連を多対一関連と同じテーブルのカラムにマッピングし、
            多側に <literal>inverse="true"</literal> と宣言します。
        </para>

        <programlisting><![CDATA[<class name="Parent">
    <id name="id" column="parent_id"/>
    ....
    <set name="children" inverse="true">
        <key column="parent_id"/>
        <one-to-many class="Child"/>
    </set>
</class>

<class name="Child">
    <id name="id" column="child_id"/>
    ....
    <many-to-one name="parent" 
        class="Parent" 
        column="parent_id"
        not-null="true"/>
</class>]]></programlisting>

        <para>
            関連の片側に <literal>inverse="true"</literal> を設定しても、
            カスケード操作に影響を与えません。これらは直交した概念です！
        </para>

    </sect2>

    <sect2 id="collections-indexedbidirectional">
        <title>インデックス付きコレクションと双方向関連</title>
        <para>
            片側が <literal>&lt;list&gt;</literal> や <literal>&lt;map&gt;</literal> である
            双方向関連は、特によく考える必要があります。
            インデックスカラムにマップされる子クラスのプロパティがある場合は、問題ないです。
            コレクションのマッピングで <literal>inverse="true"</literal> を使い続けられます。
        </para>
        
        <programlisting><![CDATA[<class name="Parent">
    <id name="id" column="parent_id"/>
    ....
    <map name="children" inverse="true">
        <key column="parent_id"/>
        <map-key column="name" 
            type="string"/>
        <one-to-many class="Child"/>
    </map>
</class>

<class name="Child">
    <id name="id" column="child_id"/>
    ....
    <property name="name" 
        not-null="true"/>
    <many-to-one name="parent" 
        class="Parent" 
        column="parent_id"
        not-null="true"/>
</class>]]></programlisting>

        <para>
            しかし、子クラスにそのようなプロパティがない場合は、
            関連を真に双方向であると考えることができません
            （関連の片側に利用できる情報がありますが、もう一方にはありません）。
            この場合は、コレクションに <literal>inverse="true"</literal> をマッピングできません。
            代わりに、次のようなマッピングが使えます。
        </para>

        <programlisting><![CDATA[<class name="Parent">
    <id name="id" column="parent_id"/>
    ....
    <map name="children">
        <key column="parent_id"
            not-null="true"/>
        <map-key column="name" 
            type="string"/>
        <one-to-many class="Child"/>
    </map>
</class>

<class name="Child">
    <id name="id" column="child_id"/>
    ....
    <many-to-one name="parent" 
        class="Parent" 
        column="parent_id"
        insert="false"
        update="false"
        not-null="true"/>
</class>]]></programlisting>

       <para>
           注意： このマッピングでは、関連のコレクション値の側は、
           外部キーをアップデートする責任があります。
           <!-- TODO: Does this really result in some unnecessary update statements? -->
       </para>

    </sect2>

    <sect2 id="collections-ternary">
        <title>3項関連</title>

        <para>
            3項関連のマッピングには3つのアプローチがあります。
            1つ目は関連をインデックスとして <literal>Map</literal> を使用するアプローチです。
        </para>

        <programlisting><![CDATA[<map name="contracts">
    <key column="employer_id" not-null="true"/>
    <map-key-many-to-many column="employee_id" class="Employee"/>
    <one-to-many class="Contract"/>
</map>]]></programlisting>
            
            <programlisting><![CDATA[<map name="connections">
    <key column="incoming_node_id"/>
    <map-key-many-to-many column="outgoing_node_id" class="Node"/>
    <many-to-many column="connection_id" class="Connection"/>
</map>]]></programlisting>
            
        <para>
            2つ目は単純に関連をエンティティ･クラスとしてモデルを作り直すアプローチで、
            頻繁に使われます。
        </para>
        
        <para>
            最後はcomposite要素を使うアプローチです。これに関する議論は後ほど行います。
        </para>
        
    </sect2>
    
    <sect2 id="collections-idbag" revision="1">
        <title><literal>&lt;idbag&gt;</literal>の使用</title>

        <para>
            複合キーは悪いもので、エンティティは人工の識別子(代理キー)を持つべきであるという考え方からは、
            多対多関連と値のコレクションを複合キーを用いたテーブルへマッピングするのは少し奇妙に感じるかもしれません！
            確かにこの考え方には議論の余地があります。
            純粋な関連テーブルは代理キーを使っても利益を得られないように思えるからです
            （合成値のコレクションは利益がある <emphasis>かも</emphasis> しれませんが）。
            とはいえ、Hibernateは代理キーを持つテーブルへ多対多関連と値のコレクションを
            マッピングする機能も備えています。
        </para>

        <para>
            bagのセマンティックスを持った <literal>List</literal>（または <literal>Collection</literal>）を
            <literal>&lt;idbag&gt;</literal> 要素にマッピングできます。
        </para>

<programlisting><![CDATA[<idbag name="lovers" table="LOVERS">
    <collection-id column="ID" type="long">
        <generator class="sequence"/>
    </collection-id>
    <key column="PERSON1"/>
    <many-to-many column="PERSON2" class="Person" fetch="join"/>
</idbag>]]></programlisting>

        <para>
            ご存知のように <literal>&lt;idbag&gt;</literal> はエンティティ･クラスのように
            人工的なidジェネレータを持っています！
            異なる代理キーをそれぞれのコレクションの列に割り当てます。
            しかしながら、Hibernateはある行の代理キーの値を見つけ出す機構を持っていません。
        </para>

        <para>
            <literal>&lt;idbag&gt;</literal> を更新するパフォーマンスは
            通常の <literal>&lt;bag&gt;</literal> よりも良いことに注目してください！
            Hibernateは個々の行を効果的に見つけることができ、
            listやmap、setのように個別にその行を更新、削除できます。
        </para>

        <para>
            現在の実装では、<literal>native</literal> というid生成戦略を
            <literal>&lt;idbag&gt;</literal> コレクションの識別子に対して使えません。
        </para>

    </sect2>

    </sect1>
    
    <!--undocumenting this stuff -->
    
    <!--sect1 id="collections-heterogeneous">
        <title>Heterogeneous Associations</title>

        <para>
            The <literal>&lt;many-to-any&gt;</literal> and <literal>&lt;index-many-to-any&gt;</literal>
            elements provide for true heterogeneous associations. These mapping elements work in the
            same way as the <literal>&lt;any&gt;</literal> element - and should also be used
            rarely, if ever.
        </para>

    </sect1-->

    <sect1 id="collections-example" revision="1">
        <title>コレクションの例</title>

        <para>
            これまでの節の説明では理解しにくいので、以下の例を見てください。
        </para>

        <programlisting><![CDATA[package eg;
import java.util.Set;

public class Parent {
    private long id;
    private Set children;

    public long getId() { return id; }
    private void setId(long id) { this.id=id; }

    private Set getChildren() { return children; }
    private void setChildren(Set children) { this.children=children; }

    ....
    ....
}]]></programlisting>

        <para>
            このクラスは <literal>Child</literal> インスタンスのコレクションを持っています。
            もし各々のchildが最大でも一つのparentを持っているならば、最も自然なマッピングは一対多関連です。
        </para>

        <programlisting><![CDATA[<hibernate-mapping>

    <class name="Parent">
        <id name="id">
            <generator class="sequence"/>
        </id>
        <set name="children">
            <key column="parent_id"/>
            <one-to-many class="Child"/>
        </set>
    </class>

    <class name="Child">
        <id name="id">
            <generator class="sequence"/>
        </id>
        <property name="name"/>
    </class>

</hibernate-mapping>]]></programlisting>

        <para>
            これは以下のテーブル定義にマッピングします。
        </para>

        <programlisting><![CDATA[create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255), parent_id bigint )
alter table child add constraint childfk0 (parent_id) references parent]]></programlisting>

        <para>
            もしparentが <emphasis>要求</emphasis> されるなら、双方向の一対多関連を使用してください。
        </para>

        <programlisting><![CDATA[<hibernate-mapping>

    <class name="Parent">
        <id name="id">
            <generator class="sequence"/>
        </id>
        <set name="children" inverse="true">
            <key column="parent_id"/>
            <one-to-many class="Child"/>
        </set>
    </class>

    <class name="Child">
        <id name="id">
            <generator class="sequence"/>
        </id>
        <property name="name"/>
        <many-to-one name="parent" class="Parent" column="parent_id" not-null="true"/>
    </class>

</hibernate-mapping>]]></programlisting>

        <para>
            <literal>NOT NULL</literal> 制約に注意してください。
        </para>

        <programlisting><![CDATA[create table parent ( id bigint not null primary key )
create table child ( id bigint not null
                     primary key,
                     name varchar(255),
                     parent_id bigint not null )
alter table child add constraint childfk0 (parent_id) references parent]]></programlisting>

        <para>
            あるいは、もしこの関連は単方向であるべきと強く主張するのであれば、
            <literal>&lt;key&gt;</literal> に <literal>NOT NULL</literal> 制約を宣言できます。
        </para>

        <programlisting><![CDATA[<hibernate-mapping>

    <class name="Parent">
        <id name="id">
            <generator class="sequence"/>
        </id>
        <set name="children">
            <key column="parent_id" not-null="true"/>
            <one-to-many class="Child"/>
        </set>
    </class>

    <class name="Child">
        <id name="id">
            <generator class="sequence"/>
        </id>
        <property name="name"/>
    </class>

</hibernate-mapping>]]></programlisting>

        <para>
            一方で、もしchildが複数のparentを持てるならば、多対多関連が妥当です。
        </para>

        <programlisting><![CDATA[<hibernate-mapping>

    <class name="Parent">
        <id name="id">
            <generator class="sequence"/>
        </id>
        <set name="children" table="childset">
            <key column="parent_id"/>
            <many-to-many class="Child" column="child_id"/>
        </set>
    </class>

    <class name="Child">
        <id name="id">
            <generator class="sequence"/>
        </id>
        <property name="name"/>
    </class>

</hibernate-mapping>]]></programlisting>

        <para>
            テーブル定義は以下のようになります。
        </para>

        <programlisting><![CDATA[create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255) )
create table childset ( parent_id bigint not null,
                        child_id bigint not null,
                        primary key ( parent_id, child_id ) )
alter table childset add constraint childsetfk0 (parent_id) references parent
alter table childset add constraint childsetfk1 (child_id) references child]]></programlisting>

        <para>
            parent/child関係のマッピングについてのより多くの例や完全な手順が必要であれば、
            <xref linkend="example-parentchild"/> をご覧ください。
        </para>
        
        <para>
            また、さらに特殊な関連マッピングも可能です。次の章で詳しく述べます。
        </para>

    </sect1>

</chapter>
