<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="hibernate-gsg-tutorial-native">
    <title>Tutorial Using Native Hibernate APIs and <filename>hbm.xml</filename> Mappings</title>

    <note>
        <para>
            This tutorial uses the <phrase>standard layout</phrase> described in
            <ulink url="http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html"/>.
        </para>
    </note>

    <tip>
        <para>
            The tutorials in this guide use Maven, in order to leverage its
            transitive dependency management capabilities and its integration
            with many development environments (IDEs). <!--This sounds like
            marketing! -->You can use another build tool, adapting the examples
            to fit your needs.
        </para>
    </tip>

    <procedure>
        <title>Steps</title>

        <step id="hibernate-gsg-tutorial-native-pom">
            <title>Create the Maven POM file</title>
            <para>
                Create a file named <filename>pom.xml</filename> in the root of your project directory, containing
                the text in<xref linkend="hibernate-gsg-tutorial-native-pom-ex1"/>.
            </para>
            <example id="hibernate-gsg-tutorial-native-pom-ex1">
                <title>
                    <filename>pom.xml</filename>
                </title>
                <programlisting role="XML"><xi:include href="extras/examples/hbm/pom.xml" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text"/></programlisting>
            </example>
        </step>

        <step id="hibernate-gsg-tutorial-native-entity">
            <title>Create the entity Java class</title>

            <para>
                Create a file named
                <filename>src/main/java/org/hibernate/tutorial/hbm/Event.java</filename>,
                containing the text in<xref
                linkend="hibernate-gsg-tutorial-native-entity-ex1"/>.<!-- Can we
                just include these files in an example.zip? -->
            </para>

            <example id="hibernate-gsg-tutorial-native-entity-ex1">
                <title>
                    <filename>Entity.java</filename>
                </title>
                <programlisting role="JAVA"><xi:include href="extras/examples/hbm/org/hibernate/tutorial/hbm/Event.java" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text"/></programlisting>
            </example>
            <para>
                <!-- todo : what's the best way to refer to content in other books? -->
                <!--   like here it would be nice to say something like: -->
                <!--        "Entity class requirements are covered in detail in <x.y.z Some Developer Guide Chapter/Section>" -->
                <itemizedlist>
                    <title>Notes About the Entity</title>
                    <listitem>
                        <para>
                            This class uses standard JavaBean naming conventions
                            for property getter and setter methods, as well as
                            private visibility for the fields. Although this is
                            the recommended design, it is not required.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            The no-argument constructor, which is also a JavaBean
                            convention, is a requirement for all persistent
                            classes. Hibernate needs to create objects for you,
                            using Java Reflection. The constructor can be
                            private. However, package or public visibility is
                            required for runtime proxy generation and efficient
                            data retrieval without bytecode instrumentation.
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
        </step>

        <step id="hibernate-gsg-tutorial-native-mapping">
            <title>Create the entity mapping file</title>

            <para>
                Create a file named <filename>src/main/resources/org/hibernate/tutorial/native/Event.hbm.xml</filename>,
                with the contents in <xref linkend="hibernate-gsg-tutorial-native-hbm-xml-ex1"/>.
            </para>

            <example id="hibernate-gsg-tutorial-native-hbm-xml-ex1">
                <title>
                    <filename>Event.hbm.xml</filename>
                </title>
                <programlisting role="XML"><xi:include href="extras/examples/hbm/org/hibernate/tutorial/hbm/Event.hbm.xml" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text"/></programlisting>
            </example>

            <para>
                Hibernate uses the mapping metadata to find out how to load and
                store objects of the persistent class. The Hibernate mapping
                file is one choice for providing Hibernate with this metadata.
            </para>

            <orderedlist>
                <title>Functions of the <property>class</property> element</title>
                <listitem>
                    <para>
                        The <literal>class</literal> attribute, combined here
                        with the <literal>package</literal> attribute from the
                        containing <literal>hibernate-mapping</literal> element,
                        names the FQN of the class you want to define as an
                        entity.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The <literal>table</literal> attribute names the
                        database table which contains the data for this entity.
                    </para>
                </listitem>
            </orderedlist>

            <para>
                Instances of the <classname>Event</classname> class are now
                mapped to rows in the <database class="table">EVENTS</database>
                table. Hibernate uses the <literal>id</literal> element to
                uniquely identify rows in the table.
            </para>
            <important>
                <para>
                    It is not strictly necessary for the <literal>id</literal>
                    element to map to the table's actual primary key column(s),
                    but this type of mapping is conventional. Tables mapped in
                    Hibernate do not even need to define primary keys. However,
                    the Hibernate team <emphasis>strongly</emphasis> recommends
                    that all schemas define proper referential
                    integrity. Therefore <literal>id</literal> and
                    <phrase>primary key</phrase> are used interchangeably
                    throughout Hibernate documentation.
                </para>
            </important>
            <para>
                The <literal>id</literal> element here identifies the <database
                class="field">EVENT_ID</database> column as the primary key of
                the <database class="table">EVENTS</database> table. It also
                identifies the <literal>id</literal> property of the
                <classname>Event</classname> class as the property containing
                the identifier value.
            </para>
	    <para>
	      The <literal>generator</literal> element nested inside the
	      <literal>id</literal> element informs Hibernate about which
	      strategy is used to generated primary key values for this
	      entity. In this example, a sequence-like value generation is
	      used.
	    </para>
            <para>
                The two <literal>property</literal> elements declare the
                remaining two properties of the <classname>Event</classname>
                class: <literal>date</literal> and<literal>title</literal>. The
                <literal>date</literal> property mapping includes the
                <literal>column</literal> attribute, but the
                <literal>title</literal> does not. In the absence of a
                <literal>column</literal> attribute, Hibernate uses the property
                name as the column name. This is appropriate for
                <literal>title</literal>, but since <literal>date</literal> is a
                reserved keyword in most databases, you need to specify a
                different word for the column name.
            </para>
            <para>
                The <literal>title</literal> mapping also lacks a
                <literal>type</literal> attribute. The types declared and used
                in the mapping files are neither Java data types nor SQL
                database types. Instead, they are <firstterm><phrase>Hibernate
                mapping types</phrase></firstterm>. Hibernate mapping types are
                converters which translate between Java and SQL data
                types. Hibernate attempts to determine the correct conversion
                and mapping type autonomously if the <literal>type</literal>
                attribute is not present in the mapping, by using Java
                reflection to determine the Java type of the declared property
                and using a default mapping type for that Java type. <!-- We need to decide how we mark up XML tags (elements) and parameters (attributes). -->
            </para>
            <para>
                In some cases this automatic detection might not choose the
                default you expect or need, as seen with the
                <literal>date</literal> property. Hibernate cannot know if the
                property, which is of type
                <classname>java.util.Date</classname>, should map to a SQL
                <literal>DATE</literal>, <literal>TIME</literal>, or
                <literal>TIMESTAMP</literal> datatype. Full date and time
                information is preserved by mapping the property to a
                <literal>timestamp</literal> converter.
            </para>

            <info>
                <para>
                    Hibernate makes this mapping type determination using
                    reflection when the mapping files are processed. This can
                    take time and resources. If startup performance is
                    important, consider explicitly defining the type to use.
                </para>
            </info
        </step>

        <step id="hibernate-gsg-tutorial-native-config">
            <title>Create the Hibernate configuration file</title>

            <para>
                Create a file named <filename>src/main/resources/hibernate.cfg.xml</filename> with the following contents:
            </para>

            <example id="hibernate-gsg-tutorial-native-config-ex1">
                <title><filename>hibernate.cfg.xml</filename></title>
                <programlisting role="XML"><xi:include href="extras/examples/hbm/hibernate.cfg.xml" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text"/></programlisting>
            </example>

            <para>
                The first few <property>property</property> tags define
                information about the JDBC connection. The
                <option>connection.url</option> contains information directing
                Hibernate to use the <firstterm>H2 in-memory
                database</firstterm>. The rest of the properties are explained
                in <xref linkend="tutorial-native-config-options-explained" />.
	    </para>
	    
	    <!-- <mapping resource="org/hibernate/tutorial/hbm/Event.hbm.xml"/> -->

	    <table id="tutorial-native-config-options-explained">
	      <title>Configuration Options Used In the Native Configuration Example</title>
	      <tgroup cols="2">
		<thead>
		  <row>
		    <entry><p>Property Name</p></entry>
		    <entry><p>Description</p></entry>
		  </row>
		</thead>
		<tbody>
		  <row>
		    <entry><p><option>connection.pool_size</option></p></entry>
		    <entry>
		      <p>
			configures Hibernate's built-in connection pool to
			contain the specified number of connections.
		      </p>
		      <p>
			<warning> <!-- We try to limit note levels to 'note', 'info', 'warning' -->
			  <para>
			    The built-in Hibernate connection pool is inappropriate for
			    production use. It lacks several features found on any
			    decent connection pool.
			    <!-- What should be used instead? -->
			  </para>
			</warning>
		      </p>
		    </entry>
		  </row>
		  <row>
		    <entry><p><option>dialect</option></p></entry>
		    <entry>
		      <p>
			specifies the particular SQL variant Hibernate should
			generate.
		      </p>
		      <p> <!-- I hate doing this but Docbook has a silly rule about putting <note>s inside table entries -->
			<note>
			  <para>
			    In most cases, Hibernate can automatically determine which
			    dialect to use. This capability is valuable for applications
			    which target multiple databases.
			  </para>
			</note>
		      </p>		      
		    </entry>
		  </row>
		  <row>
		    <entry><p><option>cache.provider_class</option></p></entry>
		    <entry><p></p></entry><!-- Explain me -->
		  </row>
		  <row>
		    <entry><p>show_sql</p></entry>
		    <entry><p></p></entry><!-- Explain me -->
		  </row>
		  <row>
		    <entry><p>hbm2ddl.auto</p></entry>
		    <entry>
		      <p>
		      enables automatic generation of database schemas directly
		      into the database.
		      </p>
		    </entry>
		  </row>
		</tbody>
	      </tgroup>
	    </table>
		    
            <para>
	      Finally, the mapping files provide persistent classes to the
	      configuration.
            </para>
        </step>

        <step id="hibernate-gsg-tutorial-native-working">
            <title>Do stuff</title>
            <para>
                Create a file named <filename>src/main/java/org/hibernate/tutorial/hbm/EventManager.java</filename>
                with the following contents:
            </para>

            <example id="hibernate-gsg-tutorial-native-working-ex1">
                <title>
                    <filename>EventManager.java</filename>
                </title>
                <programlisting role="JAVA"><xi:include href="extras/examples/hbm/org/hibernate/tutorial/hbm/EventManager.java" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text"/></programlisting>
            </example>

            <para>
                The <classname>org.hibernate.cfg.Configuration</classname> class is the first thing to notice. In this
                tutorial we simply configure everything via the <filename>hibernate.cfg.xml</filename> file
                discussed in<xref linkend="hibernate-gsg-tutorial-native-config"/>.
            </para>

            <para>
                The <classname>org.hibernate.cfg.Configuration</classname> is then used to create the
                <interfacename>org.hibernate.SessionFactory</interfacename> which is a thread-safe object that is
                instantiated once to serve the entire application.
            </para>

            <para>
                The <interfacename>org.hibernate.SessionFactory</interfacename> acts as a factory for
                <interfacename>org.hibernate.Session</interfacename> instances as can be seen in the
                <methodname>createAndStoreEvent</methodname> and <methodname>listEvents</methodname> methods of the
                <classname>EventManager</classname> class. A <interfacename>org.hibernate.Session</interfacename>
                should be thought of as a corollary to a "unit of work". <!-- todo : reference to a discussion in dev guide -->
            </para>

            <para>
                <methodname>createAndStoreEvent</methodname> creates a new <classname>Event</classname> object
                and hands it over to Hibernate for "management". At that point, Hibernate takes responsibility to
                perform an <literal>INSERT</literal> on the database.
            </para>

            <para>
                <methodname>listEvents</methodname> illustrates use of the Hibernate Query Language (HQL) to load all
                existing <classname>Event</classname> objects from the database. Hibernate will generate the
                appropriate <literal>SELECT</literal> SQL, send it to the database and populate
                <classname>Event</classname> objects with the result set data.
            </para>
        </step>

        <step id="hibernate-gsg-tutorial-native-compile">
            <title>Compile the source</title>
            <screen><xi:include href="extras/examples/hbm/compile-output.txt" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text"/></screen>
        </step>

        <step id="hibernate-gsg-tutorial-native-running">
            <title>Running the code</title>
            <para>
                To perform a store (leveraging the maven exec plugin):
                <command>mvn exec:java -Dexec.mainClass="org.hibernate.tutorial.native.EventManager" -Dexec.args="store"</command>
                You should see Hibernate starting up and, depending on your configuration, lots of log output. Towards
                the end, the following line will be displayed:
                <screen>[java] Hibernate: insert into EVENTS (EVENT_DATE, title, EVENT_ID) values (?, ?, ?)</screen>
                This is the <literal>INSERT</literal>executed by Hibernate.
            </para>

            <para>
                To perform a list:
                <command>mvn exec:java -Dexec.mainClass="org.hibernate.tutorial.native.EventManager"-Dexec.args="list"</command>
            </para>

            <note>
                <para>
                    Currently nothing will ever be output when performing the list because the database is recreated
                    every time the <interfacename>org.hibernate.SessionFactory</interfacename> is created.
                </para>
            </note>
        </step>
    </procedure>

    <para>
        Take it further! Try the following:
        <itemizedlist>
            <listitem>
                <para>
                    Reconfigure the examples to connect to your own persistent relational database.
                </para>
            </listitem>
            <listitem>
                <para>
                    With help of the Developer Guide, add an association to the <classname>Event</classname>
                    entity to model a message thread.
                </para>
            </listitem>
        </itemizedlist>
    </para>

</chapter>