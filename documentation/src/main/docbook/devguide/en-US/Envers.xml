<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "Hibernate_Development_Guide.ent">
%BOOK_ENTITIES;
]>

<chapter>
    <title>Envers</title>

    <preface>
        <title>Preface</title>
        <para>
            The aim of Hibernate Envers is to provide historical versioning of your application's entity data.  Much
            like source control management tools such as Subversion or Git, Hibernate Envers manages a notion of revisions
            if your application data through the use of audit tables.  Each transaction relates to one global revision number
            which can be used to identify groups of changes (much like a change set in source control).  As the revisions
            are global, having a revision number, you can query for various entities at that revision, retrieving a
            (partial) view of the database at that revision. You can find a revision number having a date, and the other
            way round, you can get the date at which a revision was committed.
        </para>
    </preface>

    <section>
        <title>Configuration</title>
        <para>
            It is possible to configure various aspects of Hibernate Envers behavior, such as table names, etc.
        </para>

        <table frame="topbot">
            <title>Envers Configuration Properties</title>
            <tgroup cols="3">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>

                <thead>
                    <row>
                        <entry>Property name</entry>
                        <entry>Default value</entry>
                        <entry>Description</entry>
                    </row>
                </thead>

                <tbody>
                    <row>
                        <entry>
                            <property>org.hibernate.envers.audit_table_prefix</property>
                        </entry>
                        <entry>
                        </entry>
                        <entry>
                            String that will be prepended to the name of an audited entity to create the name of the
                            entity, that will hold audit information.
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <property>org.hibernate.envers.audit_table_suffix</property>
                        </entry>
                        <entry>
                            _AUD
                        </entry>
                        <entry>
                            String that will be appended to the name of an audited entity to create the name of the
                            entity, that will hold audit information. If you audit an entity with a table name Person,
                            in the default setting Envers will generate a <literal>Person_AUD</literal> table to store
                            historical data.
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <property>org.hibernate.envers.revision_field_name</property>
                        </entry>
                        <entry>
                            REV
                        </entry>
                        <entry>
                            Name of a field in the audit entity that will hold the revision number.
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <property>org.hibernate.envers.revision_type_field_name</property>
                        </entry>
                        <entry>
                            REVTYPE
                        </entry>
                        <entry>
                            Name of a field in the audit entity that will hold the type of the revision (currently,
                            this can be: add, mod, del).
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <property>org.hibernate.envers.revision_on_collection_change</property>
                        </entry>
                        <entry>
                            true
                        </entry>
                        <entry>
                            Should a revision be generated when a not-owned relation field changes (this can be either
                            a collection in a one-to-many relation, or the field using "mappedBy" attribute in a
                            one-to-one relation).
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <property>org.hibernate.envers.do_not_audit_optimistic_locking_field</property>
                        </entry>
                        <entry>
                            true
                        </entry>
                        <entry>
                            When true, properties to be used for optimistic locking, annotated with
                            <literal>@Version</literal>, will be automatically not audited (their history won't be
                            stored; it normally doesn't make sense to store it).
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <property>org.hibernate.envers.store_data_at_delete</property>
                        </entry>
                        <entry>
                            false
                        </entry>
                        <entry>
                            Should the entity data be stored in the revision when the entity is deleted (instead of only
                            storing the id and all other properties as null). This is not normally needed, as the data is
                            present in the last-but-one revision. Sometimes, however, it is easier and more efficient to
                            access it in the last revision (then the data that the entity contained before deletion is
                            stored twice).
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <property>org.hibernate.envers.default_schema</property>
                        </entry>
                        <entry>
                            null (same schema as table being audited)
                        </entry>
                        <entry>
                            The default schema name that should be used for audit tables. Can be overridden using the
                            <literal>@AuditTable(schema="...")</literal> annotation. If not present, the schema will
                            be the same as the schema of the table being audited.
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <property>org.hibernate.envers.default_catalog</property>
                        </entry>
                        <entry>
                            null (same catalog as table being audited)
                        </entry>
                        <entry>
                            The default catalog name that should be used for audit tables. Can be overridden using the
                            <literal>@AuditTable(catalog="...")</literal> annotation. If not present, the catalog will
                            be the same as the catalog of the normal tables.
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <property>org.hibernate.envers.audit_strategy</property>
                        </entry>
                        <entry>
                            org.hibernate.envers.strategy.DefaultAuditStrategy
                        </entry>
                        <entry>
                            The audit strategy that should be used when persisting audit data. The default stores only
                            the revision, at which an entity was modified. An alternative, the
                            <literal>org.hibernate.envers.strategy.ValidityAuditStrategy</literal> stores both the
                            start revision and the end revision. Together these define when an audit row was valid,
                            hence the name ValidityAuditStrategy.
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <property>org.hibernate.envers.audit_strategy_validity_end_rev_field_name</property>
                        </entry>
                        <entry>
                            REVEND
                        </entry>
                        <entry>
                            The column name that will hold the end revision number in audit entities. This property is
                            only valid if the validity audit strategy is used.
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <property>org.hibernate.envers.audit_strategy_validity_store_revend_timestamp</property>
                        </entry>
                        <entry>
                            false
                        </entry>
                        <entry>
                            Should the timestamp of the end revision be stored, until which the data was valid, in
                            addition to the end revision itself.  This is useful to be able to purge old Audit records
                            out of a relational database by using table partitioning.  Partitioning requires a column
                            that exists within the table.  This property is only evaluated if the ValidityAuditStrategy
                            is used.
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <property>org.hibernate.envers.audit_strategy_validity_revend_timestamp_field_name</property>
                        </entry>
                        <entry>
                            REVEND_TSTMP
                        </entry>
                        <entry>
                            Column name of the timestamp of the end revision until which the data was valid.  Only used
                            if the ValidityAuditStrategy is used, and
                            <property>org.hibernate.envers.audit_strategy_validity_store_revend_timestamp</property>
                            evaluates to true
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>
    </section>

    <section>
        <title>Choosing an audit strategy</title>
        <para>
            After the basic configuration it is important to choose the audit strategy that will be used to persist
            and retrieve audit information. There is a trade-off between the performance of persisting and the
            performance of querying the audit information. Currently there two audit strategies.
        </para>
        <orderedlist>
            <listitem>
                <para>
                    The default audit strategy persists the audit data together with a start revision. For each row
                    inserted, updated or deleted in an audited table, one or more rows are inserted in the audit
                    tables, together with the start revision of its validity. Rows in the audit tables are never
                    updated after insertion.  Queries of audit information use subqueries to select the applicable
                    rows in the audit tables.  These subqueries are notoriously slow and difficult to index.
                </para>
            </listitem>
            <listitem>
                <para>
                    The alternative is a validity audit strategy. This strategy stores the start-revision and the
                    end-revision of audit information. For each row inserted, updated or deleted in an audited table,
                    one or more rows are inserted in the audit tables, together with the start revision of its
                    validity. But at the same time the end-revision field of the previous audit rows (if available)
                    are set to this revision.  Queries on the audit information can then use 'between start and end
                    revision' instead of subqueries as used by the default audit strategy.
                </para>
                <para>
                    The consequence of this strategy is that persisting audit information will be a bit slower,
                    because of the extra updates involved, but retrieving audit information will be a lot faster.
                    This can be improved by adding extra indexes.
                </para>
            </listitem>
        </orderedlist>
    </section>

    <section id="envers-revisionlog">
        <title>Revision Log</title>
        <subtitle>Logging data for revisions</subtitle>

        <para>
            When Envers starts a new revision, it creates a new <firstterm>revision entity</firstterm> which stores
            information about the revision.  By default, that includes just
        </para>
        <orderedlist>
            <listitem>
                <para>
                    <term>revision number</term> - An integral value (<literal>int/Integer</literal> or
                    <literal>long/Long</literal>).  Essentially the primary key of the revision
                </para>
                <para>
                    <term>revision timestamp</term> - either a <literal>long/Long</literal> or
                    <classname>java.util.Date</classname> value representing the instant at which the revision was made.
                    When using a <classname>java.util.Date</classname>, instead of a <literal>long/Long</literal> for
                    the revision timestamp, take care not to store it to a column data type which will loose precision.
                </para>
            </listitem>
        </orderedlist>

        <para>
            Envers handles this information as an entity.  By default it uses its own internal class to act as the
            entity.  You can, however, supply your own approach to collecting this information which might be useful to
            capture additional details such as who made a change or the ip address from which the request came.  There
            are 2 things you need to make this work.
        </para>
        <orderedlist>
            <listitem>
                <para>
                    First, you will need to tell Envers about the entity you wish to use.  Your entity must use the
                    <interfacename>@org.hibernate.envers.RevisionEntity</interfacename> annotation.  It must
                    define the 2 attributes described above annotated with
                    <interfacename>@org.hibernate.envers.RevisionNumber</interfacename> and
                    <interfacename>@org.hibernate.envers.RevisionTimestamp</interfacename>, respectively.  You can extend
                    from <classname>org.hibernate.envers.DefaultRevisionEntity</classname>, if you wish, to inherit all
                    these required behaviors.
                </para>
                <para>
                    Simply add the custom revision entity as you do your normal entities.  Envers will "find it".  Note
                    that it is an error for there to be multiple entities marked as
                    <interfacename>@org.hibernate.envers.RevisionEntity</interfacename>
                </para>
            </listitem>
            <listitem>
                <para>
                    Second, you need to tell Envers how to create instances of your revision entity which is handled
                    by the <methodname>newRevision</methodname> method of the
                    <interfacename>org.jboss.envers.RevisionListener</interfacename> interface.
                </para>
                <para>
                    You tell Envers your custom <interfacename>org.hibernate.envers.RevisionListener</interfacename>
                    implementation to use by specifying it on the
                    <interfacename>@org.hibernate.envers.RevisionEntity</interfacename> annotation, using the
                    <methodname>value</methodname> attribute.
                </para>
            </listitem>
        </orderedlist>
        <programlisting><![CDATA[@Entity
@RevisionEntity( MyCustomRevisionListener.class )
public class MyCustomRevisionEntity {
    ...
}

public class MyCustomRevisionListener implements RevisionListener {
    public void newRevision(Object revisionEntity) {
        ( (MyCustomRevisionEntity) revisionEntity )...;
    }
}
]]></programlisting>

        <para>
            An alternative method to using the <interfacename>org.hibernate.envers.RevisionListener</interfacename>
            is to instead call the <methodname>getCurrentRevision</methodname> method of the
            <interfacename>org.hibernate.envers.AuditReader</interfacename> interface to obtain the current revision,
            and fill it with desired information.  The method accepts a <literal>persist</literal> parameter indicating
            whether the revision entity should be persisted prior to returning from this method.  <literal>true</literal>
            which will ensure the returned entity has access to its identifier value (revision number), but the revision
            entity will be persisted regardless of whether there are any audited entities changed.  <literal>false</literal>
            means that the revision number will be <literal>null</literal>, but the revision entity will be persisted
            only if some audited entities have changed.
        </para>


        <example>
            <title>Example of storing username with revision</title>

            <programlisting>
                <filename>ExampleRevEntity.java</filename><![CDATA[package org.hibernate.envers.example;

import org.hibernate.envers.RevisionEntity;
import org.hibernate.envers.DefaultRevisionEntity;

import javax.persistence.Entity;

@Entity
@RevisionEntity(ExampleListener.class)
public class ExampleRevEntity extends DefaultRevisionEntity {
    private String username;

    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
}]]></programlisting>

            <programlisting>
                <filename>ExampleListener.java</filename><![CDATA[package org.hibernate.envers.example;

import org.hibernate.envers.RevisionListener;
import org.jboss.seam.security.Identity;
import org.jboss.seam.Component;

public class ExampleListener implements RevisionListener {
    public void newRevision(Object revisionEntity) {
        ExampleRevEntity exampleRevEntity = (ExampleRevEntity) revisionEntity;
        Identity identity = (Identity) Component.getInstance("org.jboss.seam.security.identity");

        exampleRevEntity.setUsername(identity.getUsername());
    }
}]]></programlisting>

        </example>

    </section>

    <section>
        <title>Envers Schema</title>

        <para>
            For each audited entity (that is, for each entity containing at least one audited field), an audit table is
            created.  By default, the audit table's name is created by adding a "_AUD" suffix to the original table name,
            but this can be overridden by specifying a different suffix/prefix in the configuration or per-entity using
            the <interfacename>@org.hibernate.envers.AuditTable</interfacename> annotation.
        </para>

        <orderedlist>
            <title>Audit table columns</title>
            <listitem>
                <para>
                    id of the original entity (this can be more then one column in the case of composite primary keys)
                </para>
            </listitem>
            <listitem>
                <para>
                    revision number - an integer.  Matches to the revision number in the revision entity table.
                </para>
            </listitem>
            <listitem>
                <para>
                    revision type - a small integer
                </para>
            </listitem>
            <listitem>
                <para>
                    audited fields from the original entity
                </para>
            </listitem>
        </orderedlist>

        <para>
            The primary key of the audit table is the combination of the original id of the entity and the revision
            number - there can be at most one historic entry for a given entity instance at a given revision.
        </para>

        <para>
            The current entity data is stored in the original table and in the audit table.  This is a duplication of
            data, however as this solution makes the query system much more powerful, and as memory is cheap, hopefully
            this won't be a major drawback for the users.  A row in the audit table with entity id ID, revision N and
            data D means: entity with id ID has data D from revision N upwards.  Hence, if we want to find an entity at
            revision M, we have to search for a row in the audit table, which has the revision number smaller or equal
            to M, but as large as possible. If no such row is found, or a row with a "deleted" marker is found, it means
            that the entity didn't exist at that revision.
        </para>

        <para>
            The "revision type" field can currently have three values: 0, 1, 2, which means ADD, MOD and DEL,
            respectively. A row with a revision of type DEL will only contain the id of the entity and no data (all
            fields NULL), as it only serves as a marker saying "this entity was deleted at that revision".
        </para>

        <para>
            Additionally, there is a <term>revision entity</term> table which contains the information about the
            global revision.  By default the generated table is named <database class="table">REVINFO</database> and
            contains just 2 columns: <database class="field">ID</database> and <database class="field">TIMESTAMP</database>.
            A row is inserted into this table on each new revision, that is, on each commit of a transaction, which
            changes audited data.  The name of this table can be configured, the name of its columns as well as adding
            additional columns can be achieved as discussed in <xref linkend="envers-revisionlog"/>.
        </para>

        <para>
            While global revisions are a good way to provide correct auditing of relations, some people have pointed out
            that this may be a bottleneck in systems, where data is very often modified.  One viable solution is to
            introduce an option to have an entity "locally revisioned", that is revisions would be created for it
            independently.  This wouldn't enable correct versioning of relations, but wouldn't also require the
            <database class="table">REVINFO</database> table.  Another possibility is to introduce a notion of
            "revisioning groups": groups of entities which share revision numbering.  Each such group would have to
            consist of one or more strongly connected component of the graph induced by relations between entities.
            Your opinions on the subject are very welcome on the forum! :)
        </para>

    </section>

</chapter>