<?xml version="1.0" encoding="UTF-8"?>

<!--
  ~ Hibernate, Relational Persistence for Idiomatic Java
  ~
  ~ Copyright (c) 2007, Red Hat Middleware LLC or third-party contributors as
  ~ indicated by the @author tags or express copyright attribution
  ~ statements applied by the authors.  All third-party contributions are
  ~ distributed under license by Red Hat Middleware LLC.
  ~
  ~ This copyrighted material is made available to anyone wishing to use, modify,
  ~ copy, or redistribute it subject to the terms and conditions of the GNU
  ~ Lesser General Public License, as published by the Free Software Foundation.
  ~
  ~ This program is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  ~ for more details.
  ~
  ~ You should have received a copy of the GNU Lesser General Public License
  ~ along with this distribution; if not, write to:
  ~ Free Software Foundation, Inc.
  ~ 51 Franklin Street, Fifth Floor
  ~ Boston, MA  02110-1301  USA
  -->
<cache-configs>

    <!-- 
     Various JBoss Cache configurations, suitable for different caching
     uses (e.g. entities vs. queries).
     
     In all cases, TransactionManager configuration not required.
     Hibernate will plug in its own transaction manager integration. 
    -->
    
    
    <!-- A config appropriate for entity/collection caching. -->
    <cache-config name="optimistic-entity">

        <!-- Node locking scheme -->
        <attribute name="NodeLockingScheme">OPTIMISTIC</attribute>

        <!-- Valid modes are LOCAL
                             REPL_ASYNC
                             REPL_SYNC
                             INVALIDATION_ASYNC
                             INVALIDATION_SYNC

             INVALIDATION_SYNC is highly recommended as the mode for use
             with entity and collection caches.
        -->
        <attribute name="CacheMode">INVALIDATION_SYNC</attribute>

        <!-- Name of cluster. Needs to be the same for all members, in order
             to find each other -->
        <attribute name="ClusterName">optimistic-entity</attribute>
        
        <!-- Use a UDP (multicast) based stack. A udp-sync stack might be
             slightly better (no JGroups FC) but we stick with udp to
             help ensure this cache and others like timestamps-cache
             that require FC can use the same underlying JGroups resources. -->
        <attribute name="MultiplexerStack">udp</attribute>

        <!-- Whether or not to fetch state on joining a cluster. -->
        <attribute name="FetchInMemoryState">false</attribute>

        <!--
          The max amount of time (in milliseconds) we wait until the
          state (ie. the contents of the cache) are retrieved from
          existing members at startup. Ignored if FetchInMemoryState=false.
        -->
        <attribute name="StateRetrievalTimeout">20000</attribute>

        <!--
            Number of milliseconds to wait until all responses for a
            synchronous call have been received.
        -->
        <attribute name="SyncReplTimeout">20000</attribute>

        <!-- Max number of milliseconds to wait for a lock acquisition -->
        <attribute name="LockAcquisitionTimeout">15000</attribute>

       <!--
          Indicate whether to use marshalling or not. Set this to true if you are running under a scoped
          class loader, e.g., inside an application server. Default is "false".
       -->
       <attribute name="UseRegionBasedMarshalling">true</attribute>
       <!-- Must match the value of "useRegionBasedMarshalling" -->
       <attribute name="InactiveOnStartup">true</attribute>

      <!--  Specific eviction policy configurations. This is LRU -->
      <attribute name="EvictionPolicyConfig">
        <config>
          <attribute name="wakeUpIntervalSeconds">5</attribute>
          <!-- Name of the DEFAULT eviction policy class. -->
          <attribute name="policyClass">org.jboss.cache.eviction.LRUPolicy</attribute>
          <!--  Cache wide default -->
          <region name="/_default_">
            <!-- Evict LRU node once we have more than this number of nodes -->
            <attribute name="maxNodes">10000</attribute>
            <!-- And, evict any node that hasn't been accessed in this many seconds -->
            <attribute name="timeToLiveSeconds">1000</attribute>
            <!-- Don't evict a node that's been accessed within this many seconds. 
                 Set this to a value greater than your max expected transaction length. -->
            <attribute name="minTimeToLiveSeconds">120</attribute>
          </region>
          <!--  Don't ever evict modification timestamps -->
          <region name="/TS" policyClass="org.jboss.cache.eviction.NullEvictionPolicy"/>
        </config>
     </attribute>

    </cache-config>   
    
    

    <!-- A config appropriate for entity/collection caching that
         uses pessimistic locking -->
    <cache-config name="pessimistic-entity">

        <!-- Node locking scheme -->
        <attribute name="NodeLockingScheme">PESSIMISTIC</attribute>

        <!--
            Isolation level : SERIALIZABLE
                              REPEATABLE_READ (default)
                              READ_COMMITTED
                              READ_UNCOMMITTED
                              NONE
        -->
        <attribute name="IsolationLevel">REPEATABLE_READ</attribute>

        <!-- Valid modes are LOCAL
                             REPL_ASYNC
                             REPL_SYNC
                             INVALIDATION_ASYNC
                             INVALIDATION_SYNC

             INVALIDATION_SYNC is highly recommended as the mode for use
             with entity and collection caches.
        -->
        <attribute name="CacheMode">INVALIDATION_SYNC</attribute>

        <!-- Name of cluster. Needs to be the same for all members, in order
             to find each other -->
        <attribute name="ClusterName">pessimistic-entity</attribute>
        
        <!-- Use a UDP (multicast) based stack. A udp-sync stack might be
             slightly better (no JGroups FC) but we stick with udp to
             help ensure this cache and others like timestamps-cache
             that require FC can use the same underlying JGroups resources. -->
        <attribute name="MultiplexerStack">udp</attribute>

        <!-- Whether or not to fetch state on joining a cluster. -->
        <attribute name="FetchInMemoryState">false</attribute>

        <!--
          The max amount of time (in milliseconds) we wait until the
          state (ie. the contents of the cache) are retrieved from
          existing members at startup. Ignored if FetchInMemoryState=false.
        -->
        <attribute name="StateRetrievalTimeout">20000</attribute>

        <!--
            Number of milliseconds to wait until all responses for a
            synchronous call have been received.
        -->
        <attribute name="SyncReplTimeout">20000</attribute>

        <!-- Max number of milliseconds to wait for a lock acquisition -->
        <attribute name="LockAcquisitionTimeout">15000</attribute>

       <!--
          Indicate whether to use marshalling or not. Set this to true if you 
          are running under a scoped class loader, e.g., inside an application 
          server. Default is "false".
       -->
       <attribute name="UseRegionBasedMarshalling">true</attribute>
       <!-- Must match the value of "useRegionBasedMarshalling" -->
       <attribute name="InactiveOnStartup">true</attribute>

      <!--  Specific eviction policy configurations. This is LRU -->
      <attribute name="EvictionPolicyConfig">
        <config>
          <attribute name="wakeUpIntervalSeconds">5</attribute>
          <!-- Name of the DEFAULT eviction policy class. -->
          <attribute name="policyClass">org.jboss.cache.eviction.LRUPolicy</attribute>
          <!--  Cache wide default -->
          <region name="/_default_">
            <!-- Evict LRU node once we have more than this number of nodes -->
            <attribute name="maxNodes">10000</attribute>
            <!-- And, evict any node that hasn't been accessed in this many seconds -->
            <attribute name="timeToLiveSeconds">1000</attribute>
            <!-- Don't evict a node that's been accessed within this many seconds. 
                 Set this to a value greater than your max expected transaction length. -->
            <attribute name="minTimeToLiveSeconds">120</attribute>
          </region>
          <!--  Don't ever evict modification timestamps -->
          <region name="/TS" policyClass="org.jboss.cache.eviction.NullEvictionPolicy"/>
        </config>
     </attribute>

    </cache-config>    



    <!-- A config appropriate for query caching. Does not replicate
         queries. DO NOT STORE TIMESTAMPS IN THIS CACHE.
    -->
    <cache-config name="local-query">

        <!-- Node locking scheme -->
        <attribute name="NodeLockingScheme">OPTIMISTIC</attribute>

        <attribute name="CacheMode">LOCAL</attribute>

        <!-- Max number of milliseconds to wait for a lock acquisition -->
        <attribute name="LockAcquisitionTimeout">15000</attribute>

        <!--  Specific eviction policy configurations. This is LRU -->
        <attribute name="EvictionPolicyConfig">
          <config>
            <attribute name="wakeUpIntervalSeconds">5</attribute>
            <!-- Name of the DEFAULT eviction policy class. -->
            <attribute name="policyClass">org.jboss.cache.eviction.LRUPolicy</attribute>
            <!--  Cache wide default -->
            <region name="/_default_">
               <!-- Evict LRU node once we have more than this number of nodes -->
               <attribute name="maxNodes">10000</attribute>
               <!-- And, evict any node that hasn't been accessed in this many seconds -->
               <attribute name="timeToLiveSeconds">1000</attribute>
               <!-- Don't evict a node that's been accessed within this many seconds. 
                    Set this to a value greater than your max expected transaction length. -->
               <attribute name="minTimeToLiveSeconds">120</attribute>
            </region>
            <!--  Don't ever evict modification timestamps -->
            <region name="/TS" policyClass="org.jboss.cache.eviction.NullEvictionPolicy"/>
          </config>
       </attribute>

    </cache-config>   
    
    

    <!-- A query cache that replicates queries. Replication is asynchronous.
          DO NOT STORE TIMESTAMPS IN THIS CACHE.
    -->
    <cache-config name="replicated-query">

        <!-- Node locking scheme -->
        <attribute name="NodeLockingScheme">OPTIMISTIC</attribute>

        <!--
            Isolation level : SERIALIZABLE
                              REPEATABLE_READ (default)
                              READ_COMMITTED
                              READ_UNCOMMITTED
                              NONE
        -->
        <attribute name="IsolationLevel">REPEATABLE_READ</attribute>

        <!-- Valid modes are LOCAL
                             REPL_ASYNC
                             REPL_SYNC
                             INVALIDATION_ASYNC
                             INVALIDATION_SYNC

             INVALIDATION_SYNC is highly recommended as the mode for use
             with entity and collection caches.
        -->
        <attribute name="CacheMode">REPL_ASYNC</attribute>

        <!-- Name of cluster. Needs to be the same for all members, in order
             to find each other -->
        <attribute name="ClusterName">replicated-query</attribute>
        
        <!-- Use a UDP (multicast) based stack -->
        <attribute name="MultiplexerStack">udp</attribute>

        <!-- Whether or not to fetch state on joining a cluster. -->
        <attribute name="FetchInMemoryState">false</attribute>

        <!--
          The max amount of time (in milliseconds) we wait until the
          state (ie. the contents of the cache) are retrieved from
          existing members at startup. Ignored if FetchInMemoryState=false.
        -->
        <attribute name="StateRetrievalTimeout">20000</attribute>

        <!--
            Number of milliseconds to wait until all responses for a
            synchronous call have been received.
        -->
        <attribute name="SyncReplTimeout">20000</attribute>

        <!-- Max number of milliseconds to wait for a lock acquisition -->
        <attribute name="LockAcquisitionTimeout">15000</attribute>

       <!--
          Indicate whether to use marshalling or not. Set this to true if you 
          are running under a scoped class loader, e.g., inside an application 
          server. Default is "false".
       -->
       <attribute name="UseRegionBasedMarshalling">true</attribute>
       <!-- Must match the value of "useRegionBasedMarshalling" -->
       <attribute name="InactiveOnStartup">true</attribute>

      <!--  Specific eviction policy configurations. This is LRU -->
      <attribute name="EvictionPolicyConfig">
        <config>
          <attribute name="wakeUpIntervalSeconds">5</attribute>
          <!-- Name of the DEFAULT eviction policy class. -->
          <attribute name="policyClass">org.jboss.cache.eviction.LRUPolicy</attribute>
          <!--  Cache wide default -->
          <region name="/_default_">
            <!-- Evict LRU node once we have more than this number of nodes -->
            <attribute name="maxNodes">10000</attribute>
            <!-- And, evict any node that hasn't been accessed in this many seconds -->
            <attribute name="timeToLiveSeconds">1000</attribute>
            <!-- Don't evict a node that's been accessed within this many seconds. 
                 Set this to a value greater than your max expected transaction length. -->
            <attribute name="minTimeToLiveSeconds">120</attribute>
          </region>
          <!--  Don't ever evict modification timestamps -->
          <region name="/TS" policyClass="org.jboss.cache.eviction.NullEvictionPolicy"/>
        </config>
     </attribute>

    </cache-config>     
    
    

    <!-- Optimized for timestamp caching. A clustered timestamp cache
         is required if query caching is used, even if the query cache
         itself is configured with CacheMode=LOCAL.
    -->
    <cache-config name="timestamps-cache">

        <!-- Node locking scheme -->
        <attribute name="NodeLockingScheme">PESSIMISTIC</attribute>

        <!--
            Isolation level : SERIALIZABLE
                              REPEATABLE_READ (default)
                              READ_COMMITTED
                              READ_UNCOMMITTED
                              NONE
        -->
        <attribute name="IsolationLevel">REPEATABLE_READ</attribute>

        <!-- Cannot be INVALIDATION. ASYNC for improved performance. -->
        <attribute name="CacheMode">REPL_ASYNC</attribute>

        <!-- Name of cluster. Needs to be the same for all members, in order
             to find each other -->
        <attribute name="ClusterName">timestamp-cache</attribute>
        
        <!-- Use a UDP (multicast) based stack -->
        <attribute name="MultiplexerStack">udp</attribute>

        <!-- Used for timestamps, so must fetch state. -->
        <attribute name="FetchInMemoryState">true</attribute>

        <!--
          The max amount of time (in milliseconds) we wait until the
          state (ie. the contents of the cache) are retrieved from
          existing members at startup. Ignored if FetchInMemoryState=false.
        -->
        <attribute name="StateRetrievalTimeout">20000</attribute>

        <!--
            Number of milliseconds to wait until all responses for a
            synchronous call have been received.
        -->
        <attribute name="SyncReplTimeout">20000</attribute>

        <!-- Max number of milliseconds to wait for a lock acquisition -->
        <attribute name="LockAcquisitionTimeout">15000</attribute>

       <!--
          Indicate whether to use marshalling or not. Set this to true if you 
          are running under a scoped class loader, e.g., inside an application 
          server. Default is "false".
       -->
       <attribute name="UseRegionBasedMarshalling">true</attribute>
       <!-- Must match the value of "useRegionBasedMarshalling" -->
       <attribute name="InactiveOnStartup">true</attribute>

      <!--  Specific eviction policy configurations. This is LRU -->
      <attribute name="EvictionPolicyConfig">
        <config>
          <attribute name="wakeUpIntervalSeconds">5</attribute>
          <!-- Name of the DEFAULT eviction policy class. -->
          <attribute name="policyClass">org.jboss.cache.eviction.LRUPolicy</attribute>
          <!--  Cache wide default -->
          <region name="/_default_">
            <!-- Evict LRU node once we have more than this number of nodes -->
            <attribute name="maxNodes">10000</attribute>
            <!-- And, evict any node that hasn't been accessed in this many seconds -->
            <attribute name="timeToLiveSeconds">1000</attribute>
            <!-- Don't evict a node that's been accessed within this many seconds. 
                 Set this to a value greater than your max expected transaction length. -->
            <attribute name="minTimeToLiveSeconds">120</attribute>
          </region>
          <!--  Don't ever evict modification timestamps -->
          <region name="/TS" policyClass="org.jboss.cache.eviction.NullEvictionPolicy"/>
        </config>
     </attribute>

    </cache-config>  
    
    

    <!-- A config appropriate for a cache that's shared for
         entity, collection, query and timestamp caching. Not an advised
         configuration, since it requires cache mode REPL_SYNC, which is the 
         least efficient mode. Also requires a full state transfer at startup,
         which can be expensive. Uses optimistic locking -->
    <cache-config name="optimistic-shared">

        <!-- Node locking scheme:
                OPTIMISTIC
                PESSIMISTIC (default)
        -->
        <attribute name="NodeLockingScheme">OPTIMISTIC</attribute>

        <!-- Must use REPL since used for timestamp caching. -->
        <attribute name="CacheMode">REPL_SYNC</attribute>
        
        <!-- With OPTIMISTIC  with replication we need to use synchronous commits. -->
        <attribute name="SyncCommitPhase">true</attribute>
        <attribute name="SyncRollbackPhase">true</attribute>
        
        <!-- Name of cluster. Needs to be the same for all members, in order
             to find each other -->
        <attribute name="ClusterName">optimistic-shared</attribute>
        
        <!-- Use a UDP (multicast) based stack. Need JGroups flow control (FC)
             because timestamp communication will not require a synchronous response.
        -->
        <attribute name="MultiplexerStack">udp</attribute>

        <!-- Used for timestamps, so must fetch state. -->
        <attribute name="FetchInMemoryState">true</attribute>

        <!--
          The max amount of time (in milliseconds) we wait until the
          state (ie. the contents of the cache) are retrieved from
          existing members at startup. Ignored if FetchInMemoryState=false.
        -->
        <attribute name="StateRetrievalTimeout">20000</attribute>

        <!--
            Number of milliseconds to wait until all responses for a
            synchronous call have been received.
        -->
        <attribute name="SyncReplTimeout">20000</attribute>

        <!-- Max number of milliseconds to wait for a lock acquisition -->
        <attribute name="LockAcquisitionTimeout">15000</attribute>

       <!--
          Indicate whether to use marshalling or not. Set this to true if you are running under a scoped
          class loader, e.g., inside an application server. Default is "false".
       -->
       <attribute name="UseRegionBasedMarshalling">true</attribute>
       <!-- Must match the value of "useRegionBasedMarshalling" -->
       <attribute name="InactiveOnStartup">true</attribute>

      <!--  Specific eviction policy configurations. This is LRU -->
      <attribute name="EvictionPolicyConfig">
        <config>
          <attribute name="wakeUpIntervalSeconds">5</attribute>
          <!-- Name of the DEFAULT eviction policy class. -->
          <attribute name="policyClass">org.jboss.cache.eviction.LRUPolicy</attribute>
          <!--  Cache wide default -->
          <region name="/_default_">
            <!-- Evict LRU node once we have more than this number of nodes -->
            <attribute name="maxNodes">10000</attribute>
            <!-- And, evict any node that hasn't been accessed in this many seconds -->
            <attribute name="timeToLiveSeconds">1000</attribute>
            <!-- Don't evict a node that's been accessed within this many seconds. 
                 Set this to a value greater than your max expected transaction length. -->
            <attribute name="minTimeToLiveSeconds">120</attribute>
          </region>
          <!--  Don't ever evict modification timestamps -->
          <region name="/TS" policyClass="org.jboss.cache.eviction.NullEvictionPolicy"/>
        </config>
     </attribute>

    </cache-config>   
    
    

    <!-- A config appropriate for a cache that's shared for
         entity, collection, query and timestamp caching. Not an advised
         configuration, since it requires cache mode REPL_SYNC, which is the 
         least efficient mode. Also requires a full state transfer at startup,
         which can be expensive. Uses pessmistic locking.
    -->
    <cache-config name="pessimistic-shared">

        <!-- TransactionManager configuration not required for Hibernate!
             Hibernate will plug in its own transaction manager integration. 
        -->

        <!-- Node locking scheme:
                OPTIMISTIC
                PESSIMISTIC (default)
        -->
        <attribute name="NodeLockingScheme">PESSIMISTIC</attribute>

        <!--
            Isolation level : SERIALIZABLE
                              REPEATABLE_READ (default)
                              READ_COMMITTED
                              READ_UNCOMMITTED
                              NONE
        -->
        <attribute name="IsolationLevel">REPEATABLE_READ</attribute>

        <!-- Valid modes are LOCAL
                             REPL_ASYNC
                             REPL_SYNC
                             INVALIDATION_ASYNC
                             INVALIDATION_SYNC

             INVALIDATION_SYNC is highly recommended as the mode for use
             with entity and collection caches.
        -->
        <attribute name="CacheMode">REPL_SYNC</attribute>

        <!-- Name of cluster. Needs to be the same for all members, in order
             to find each other -->
        <attribute name="ClusterName">pessimistic-shared</attribute>
        
        <!-- Use a UDP (multicast) based stack. Need JGroups flow control (FC)
             because timestamp communication will not require a synchronous response.
        -->
        <attribute name="MultiplexerStack">udp</attribute>

        <!-- Used for timestamps, so must fetch state. -->
        <attribute name="FetchInMemoryState">true</attribute>

        <!--
          The max amount of time (in milliseconds) we wait until the
          state (ie. the contents of the cache) are retrieved from
          existing members at startup.
        -->
        <attribute name="StateRetrievalTimeout">20000</attribute>

        <!--
            Number of milliseconds to wait until all responses for a
            synchronous call have been received.
        -->
        <attribute name="SyncReplTimeout">20000</attribute>

        <!-- Max number of milliseconds to wait for a lock acquisition -->
        <attribute name="LockAcquisitionTimeout">15000</attribute>

       <!--
          Indicate whether to use marshalling or not. Set this to true if you 
          are running under a scoped class loader, e.g., inside an application 
          server. Default is "false".
       -->
       <attribute name="UseRegionBasedMarshalling">true</attribute>
       <!-- Must match the value of "useRegionBasedMarshalling" -->
       <attribute name="InactiveOnStartup">true</attribute>

      <!--  Specific eviction policy configurations. This is LRU -->
      <attribute name="EvictionPolicyConfig">
        <config>
          <attribute name="wakeUpIntervalSeconds">5</attribute>
          <!-- Name of the DEFAULT eviction policy class. -->
          <attribute name="policyClass">org.jboss.cache.eviction.LRUPolicy</attribute>
          <!--  Cache wide default -->
          <region name="/_default_">
            <!-- Evict LRU node once we have more than this number of nodes -->
            <attribute name="maxNodes">10000</attribute>
            <!-- And, evict any node that hasn't been accessed in this many seconds -->
            <attribute name="timeToLiveSeconds">1000</attribute>
            <!-- Don't evict a node that's been accessed within this many seconds. 
                 Set this to a value greater than your max expected transaction length. -->
            <attribute name="minTimeToLiveSeconds">120</attribute>
          </region>
          <!--  Don't ever evict modification timestamps -->
          <region name="/TS" policyClass="org.jboss.cache.eviction.NullEvictionPolicy"/>
        </config>
     </attribute>

    </cache-config>
    
</cache-configs>
