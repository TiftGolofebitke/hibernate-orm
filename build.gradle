import org.gradle.internal.jvm.Jvm

apply plugin: 'eclipse'
apply plugin: 'idea'
apply from: "./libraries.gradle"

allprojects {
    repositories {
        mavenCentral()
        mavenLocal()

        maven {
            name 'jboss-nexus'
            url "http://repository.jboss.org/nexus/content/groups/public/"
        }
        maven {
            name "jboss-snapshots"
            url "http://snapshots.jboss.org/maven2/"
        }
    }
}

buildscript {
    repositories {
        mavenCentral()
        mavenLocal()
		jcenter()

        maven {
            name 'jboss-nexus'
            url "http://repository.jboss.org/nexus/content/groups/public/"
        }
        maven {
            name "jboss-snapshots"
            url "http://snapshots.jboss.org/maven2/"
        }
    }
    dependencies {
        classpath 'org.hibernate.build.gradle:gradle-maven-publish-auth:2.0.1'
        classpath 'org.hibernate.build.gradle:hibernate-matrix-testing:1.0.0-SNAPSHOT'
        classpath 'org.hibernate.build.gradle:version-injection-plugin:1.0.0'
    }
}

ext {
    expectedGradleVersion = '2.2'
    hibernateTargetVersion = '5.0.0-SNAPSHOT'
    javaLanguageLevel = '1.6'

    osgiExportVersion = hibernateTargetVersion.replaceAll( "-SNAPSHOT", ".SNAPSHOT" )
}

if ( !JavaVersion.current().java8Compatible ) {
	throw new GradleException( "Gradle must be run with Java 8" )
}

final Jvm java6Home;

String java6HomeDirSetting = null;
if ( rootProject.hasProperty( "JDK6_HOME" ) ) {
	java6HomeDirSetting = rootProject.property( "JDK6_HOME" ) as String;
}
if ( java6HomeDirSetting == null ) {
	java6HomeDirSetting = System.getProperty( "JDK6_HOME" );
}

if ( java6HomeDirSetting != null ) {
	logger.info( "Using JDK6_HOME setting [${java6HomeDirSetting}]" )
	final File java6HomeDir = new File( java6HomeDirSetting );
	java6Home = Jvm.forHome( java6HomeDir ) as Jvm;

	if ( java6Home == null ) {
		throw new GradleException( "Could not resolve JDK6_HOME [${java6HomeDirSetting}] to proper JAVA_HOME" );
	}
}
else {
	logger.warn( "JDK6_HOME setting not specified, some build features will be disabled" )
	java6Home = null;
}

idea {
    project {
		jdkName = '1.6'
		languageLevel = '1.6'

		vcs = 'Git'
    }
    module {
        name = "hibernate-orm"
    }
}

// Used in POM customization.  Each sub-project overrides ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def pomName() {
    return "A Hibernate O/RM module"
}
def pomDescription() {
    return "A module of the Hibernate O/RM project"
}
// Used in MANIFEST.MF for OSGi Bundles
def osgiDescription() {
	// by default just reuse the pomDescription
	return pomDescription()
}


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

subprojects { subProject ->
    apply plugin: 'idea'
    apply plugin: 'eclipse'

    defaultTasks 'build'

    group = 'org.hibernate'
    version = rootProject.hibernateTargetVersion
    ext.exportPackageVersion = rootProject.osgiExportVersion

    // minimize changes, at least for now (gradle uses 'build' by default)..
    buildDir = "target"

	if ( subProject.name.startsWith( 'release' ) || subProject.name.startsWith( 'documentation' ) ) {
		return;
	}

	// everything below here in the closure applies to java projects
	apply plugin: 'java'
	apply plugin: 'maven-publish'
	apply plugin: 'maven-publish-auth'
	apply plugin: 'osgi'

	apply from: "${rootProject.projectDir}/source-generation.gradle"

	apply plugin: 'findbugs'
	apply plugin: 'checkstyle'
	apply plugin: 'build-dashboard'
	apply plugin: 'project-report'

	configurations {
		provided {
			// todo : need to make sure these are non-exported
			description = 'Non-exported compile-time dependencies.'
		}
		jaxb {
			description = 'Dependencies for running ant xjc (jaxb class generation)'
		}
		configurations {
			all*.exclude group: 'xml-apis', module: 'xml-apis'
		}
		animalSnifferSignature
		javaApiSignature
	}

	// appropriately inject the common dependencies into each sub-project
	dependencies {
		compile( libraries.logging )
		compile( libraries.logging_annotations )
		compile( libraries.logging_processor )

		testCompile( libraries.junit )
		testCompile( libraries.byteman )
		testCompile( libraries.byteman_install )
		testCompile( libraries.byteman_bmunit )

		testRuntime( libraries.log4j )
		testRuntime( libraries.javassist )
		testRuntime( libraries.h2 )
		testRuntime( libraries.woodstox )

		jaxb( libraries.jaxb ){
			exclude group: "javax.xml.stream"
		}
		jaxb( libraries.jaxb2_basics )
		jaxb( libraries.jaxb2_ant )
		jaxb( libraries.jaxb2_jaxb )
		jaxb( libraries.jaxb2_jaxb_xjc )

		animalSnifferSignature( libraries.java16_signature )
		javaApiSignature ( libraries.java16_signature )
	}

	// mac-specific stuff ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	ext.toolsJar = file("${System.getProperty('java.home')}/../lib/tools.jar")
	if ( ext.toolsJar.exists() ) {
		dependencies{
			testCompile files( toolsJar )
		}
	}
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	targetCompatibility = rootProject.javaLanguageLevel
	sourceCompatibility = rootProject.javaLanguageLevel

	task compile
	compile.dependsOn compileJava, processResources, compileTestJava, processTestResources

	sourceSets.main {
		compileClasspath += configurations.provided
	}

	tasks.withType( JavaCompile.class ).all { task->
		// basic compile options
		task.options.compilerArgs += [
				"-nowarn",
				"-encoding", "UTF-8"
		]

		if ( subProject.name.equals( 'hibernate-java8' ) ) {
			// For hibernate-java8 module, simply compile using Java 8 JDK which is required to
			// launch Gradle (for now).  This is verified in settings.gradle
			task.options.compilerArgs += [
				"-source", '1.8',
				"-target", '1.8'
			]
		}
		else {
			// For all other modules, use the 1.6 JDK (if available) as bootstrapclasspath
			task.options.compilerArgs += [
					"-source", '1.6',
					"-target", '1.6'
			]

			if ( java6Home != null ) {
				task.options.bootClasspath = java6Home.runtimeJar.absolutePath
			}
		}
	}

	tasks.withType( Test.class ).all { task->
		task.jvmArgs += ['-XX:+HeapDumpOnOutOfMemoryError', "-XX:HeapDumpPath=${subProject.file('target/OOM-dump.hprof').absolutePath}"]

		if ( subProject.name.equals( 'hibernate-osgi' ) ) {
			// hibernate-osgi *must* be run using Java 6 or 7.  So disable its tests if
			// java6Home is not available
			if ( java6Home == null ) {
				task.enabled = false;
			}
			else {
				task.executable = java6Home.javaExecutable
				task.maxHeapSize = '2G'
				task.jvmArgs += ['-XX:MaxPermGen=512M']
			}
		}
		else {
			// for all other modules, just use the Java 8 used to launch Gradle (for now)
			task.maxHeapSize = '2G'
			task.jvmArgs += ['-XX:MetaspaceSize=512M']
		}

//		task.beforeTest { descriptor ->
//			println "Starting test: " + descriptor
//		}
//		task.afterTest { descriptor ->
//			println "Completed test: " + descriptor
//		}
	}

	jar {
		manifest = osgiManifest {
			// GRADLE-1411: Even if we override Imports and Exports
			// auto-generation with instructions, classesDir and classpath
			// need to be here (temporarily).
			classesDir = sourceSets.main.output.classesDir
			classpath = configurations.runtime

			instruction 'Import-Package',
				// Temporarily support JTA 1.1 -- Karaf and other frameworks still
				// use it.  Without this, the plugin generates [1.2,2).
				'javax.transaction;version="[1.1,2)"',
				// Tell Gradle OSGi to still dynamically import the other packages.
				// IMPORTANT: Do not include the * in the modules' .gradle files.
				// If it exists more than once, the manifest will physically contain a *.
				'*'

			instruction 'Bundle-Vendor', 'Hibernate.org'
			instruction 'Bundle-Description', subProject.osgiDescription()
			instruction 'Implementation-Url', 'http://hibernate.org'
			instruction 'Implementation-Version', version
			instruction 'Implementation-Vendor', 'Hibernate.org'
			instruction 'Implementation-Vendor-Id', 'org.hibernate'
		}
	}

	test {
		systemProperties['hibernate.test.validatefailureexpected'] = true
		systemProperties += System.properties.findAll { it.key.startsWith( "hibernate.") }
		maxHeapSize = "1024m"
	}

	processTestResources.doLast( {
		copy {
			from( sourceSets.test.java.srcDirs ) {
				include '**/*.properties'
				include '**/*.xml'
			}
			into sourceSets.test.output.classesDir
		}
	} )

	idea {
		module {
			if ( subProject.name.equals( 'hibernate-java8' ) ) {
				jdkName = '1.8'
			}

			excludeDirs = [file( ".gradle" )]
			excludeDirs += file( "$buildDir/classes" )
			excludeDirs += file( "$buildDir/bundles" )
			excludeDirs += file( "$buildDir/packages" )
			excludeDirs += file( "$buildDir/dependency-cache" )
			excludeDirs += file( "$buildDir/libs" )
			excludeDirs += file( "$buildDir/reports" )
			excludeDirs += file( "$buildDir/test-results" )
			excludeDirs += file( "$buildDir/tmp" )
			excludeDirs += file( "$buildDir/matrix" )
			excludeDirs += file( "$buildDir/resources" )

			downloadSources = true
			scopes.PROVIDED.plus += [configurations.provided]
		}
	}

	eclipse {
		if ( subProject.name != 'hibernate-java8' && java6Home != null ) {
			jdt {
				sourceCompatibility = '1.6'
				targetCompatibility = '1.6'
			}
		}
		classpath {
			plusConfigurations.add( configurations.provided )
		}
	}

	// eclipseClasspath will not add sources to classpath unless the dirs actually exist.
	// TODO: Eclipse's annotation processor handling is also fairly stupid (and completely lacks in the
	// Gradle plugin).  For now, just compile first in order to get the logging classes.
	eclipseClasspath.dependsOn generateSources

	if ( subProject.name != 'hibernate-java8' ) {
		apply plugin: org.hibernate.build.animalsniffer.AnimalSnifferPlugin

		animalSniffer {
			skip = true;
		}
	}

	// specialized API/SPI checkstyle tasks ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	task checkstylePublicSources(type: Checkstyle) {
		checkstyleClasspath = checkstyleMain.checkstyleClasspath
		classpath = checkstyleMain.classpath
		configFile = rootProject.file( 'shared/config/checkstyle/checkstyle.xml' )
		source subProject.sourceSets.main.java.srcDirs
		// exclude generated sources
		exclude '**/generated-src/**'
		// because cfg package is a mess mainly from annotation stuff
		exclude '**/org/hibernate/cfg/**'
		exclude '**/org/hibernate/cfg/*'
		// because this should only report on api/spi
		exclude '**/internal/**'
		exclude '**/internal/*'
		ignoreFailures = false
		showViolations = true
		reports {
			xml {
				destination "$buildDir/reports/checkstyle/public.xml"
			}
		}
	}
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	// Report configs ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	checkstyle {
		sourceSets = [ subProject.sourceSets.main ]
		configFile = rootProject.file( 'shared/config/checkstyle/checkstyle.xml' )
		showViolations = false
		ignoreFailures = true
	}
	// exclude generated sources
	// unfortunately this nice easy approach does not seem to work : http://forums.gradle.org/gradle/topics/specify_excludes_to_checkstyle_task
	//checkstyleMain.exclude '**/generated-src/**'
	checkstyleMain.exclude '**/org/hibernate/hql/internal/antlr/**'
	checkstyleMain.exclude '**/org/hibernate/hql/internal/antlr/*'
	checkstyleMain.exclude '**/org/hibernate/sql/ordering/antlr/*'
	checkstyleMain.exclude '**/*_$logger*'
	checkstyleMain.exclude '**/org/hibernate/internal/jaxb/**'
	// because cfg package is a mess mainly from annotation stuff
	checkstyleMain.exclude '**/org/hibernate/cfg/**'
	checkstyleMain.exclude '**/org/hibernate/cfg/*'

	findbugs {
		sourceSets = [ subProject.sourceSets.main, subProject.sourceSets.test ]
		ignoreFailures = true
	}
	// exclude generated sources
	// unfortunately this nice easy approach does not seem to work : http://forums.gradle.org/gradle/topics/specify_excludes_to_checkstyle_task
	//findbugsMain.exclude '**/generated-src/**'
	findbugsMain.exclude '**/org/hibernate/hql/internal/antlr/**'
	findbugsMain.exclude '**/org/hibernate/hql/internal/antlr/*'
	findbugsMain.exclude '**/org/hibernate/sql/ordering/antlr/*'
	findbugsMain.exclude '**/*_$logger*'
	findbugsMain.exclude '**/org/hibernate/internal/jaxb/**'

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


	publishing {
		publications {
			mavenJava(MavenPublication) {
				from components.java

				artifact sourcesJar {
					classifier "sources"
				}

				pom.withXml {
					// append additional metadata
					asNode().children().last() + {
						resolveStrategy = Closure.DELEGATE_FIRST

						name subProject.pomName()
						description subProject.pomDescription()
						url 'http://hibernate.org'
						organization {
							name 'Hibernate.org'
							url 'http://hibernate.org'
						}
						issueManagement {
							system 'jira'
							url 'https://hibernate.atlassian.net/browse/HHH'
						}
						scm {
							url 'http://github.com/hibernate/hibernate-orm'
							connection 'scm:git:http://github.com/hibernate/hibernate-orm.git'
							developerConnection 'scm:git:git@github.com:hibernate/hibernate-orm.git'
						}
						licenses {
							license {
								name 'GNU Lesser General Public License'
								url 'http://www.gnu.org/licenses/lgpl-2.1.html'
								comments 'See discussion at http://hibernate.org/license for more details.'
								distribution 'repo'
							}
						}
						developers {
							developer {
								id 'hibernate-team'
								name 'The Hibernate Development Team'
								organization 'Hibernate.org'
								organizationUrl 'http://hibernate.org'
							}
						}
					}

					// TEMPORARY : currently Gradle Publishing feature is exporting dependencies as 'runtime' scope,
					//      rather than 'compile'; fix that.
					asNode().dependencies[0].dependency.each {
						it.scope[0].value = 'compile'
					}
				}
			}
		}

		repositories {
			maven {
				if ( subProject.version.endsWith( 'SNAPSHOT' ) ) {
					name 'jboss-snapshots-repository'
					url 'https://repository.jboss.org/nexus/content/repositories/snapshots'
				}
				else {
					name 'jboss-releases-repository'
					url 'https://repository.jboss.org/nexus/service/local/staging/deploy/maven2/'
				}
			}
		}
	}

	model {
		tasks.generatePomFileForMavenJavaPublication {
			destination = file( "$project.buildDir/generated-pom.xml" )
		}
	}

	task sourcesJar(type: Jar, dependsOn: compileJava) {
		from sourceSets.main.allSource
		classifier = 'sources'
	}
}

task release(type: Task, dependsOn: 'release:release')

task wrapper(type: Wrapper) {
    gradleVersion = expectedGradleVersion
}
